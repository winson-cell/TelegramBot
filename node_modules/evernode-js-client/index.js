/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 5224:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
exports.number = number;
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`Expected boolean, not ${b}`);
}
exports.bool = bool;
// copied from utils
function isBytes(a) {
    return (a instanceof Uint8Array ||
        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
}
function bytes(b, ...lengths) {
    if (!isBytes(b))
        throw new Error('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
exports.bytes = bytes;
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
exports.hash = hash;
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
exports.exists = exists;
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
exports.output = output;
const assert = { number, bool, bytes, hash, exists, output };
exports["default"] = assert;
//# sourceMappingURL=_assert.js.map

/***/ }),

/***/ 4687:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SHA2 = void 0;
const _assert_js_1 = __nccwpck_require__(5224);
const utils_js_1 = __nccwpck_require__(4984);
// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
// Base SHA2 class (RFC 6234)
class SHA2 extends utils_js_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
    }
    update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_js_1.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
}
exports.SHA2 = SHA2;
//# sourceMappingURL=_sha2.js.map

/***/ }),

/***/ 9663:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
exports.fromBig = fromBig;
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
exports.split = split;
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, _l, s) => h >>> s;
exports.shrSH = shrSH;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
exports.rotrSH = rotrSH;
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
exports.rotrBH = rotrBH;
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l) => l;
exports.rotr32H = rotr32H;
const rotr32L = (h, _l) => h;
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
exports.rotlSH = rotlSH;
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
exports.rotlBH = rotlBH;
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
exports.add = add;
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
exports.add3L = add3L;
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
exports.add3H = add3H;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
exports.add4L = add4L;
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
exports.add4H = add4H;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
exports.add5L = add5L;
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
exports.add5H = add5H;
// prettier-ignore
const u64 = {
    fromBig, split, toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
exports["default"] = u64;
//# sourceMappingURL=_u64.js.map

/***/ }),

/***/ 9806:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.crypto = void 0;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// See utils.ts for details.
// The file will throw on node.js 14 and earlier.
// @ts-ignore
const nc = __nccwpck_require__(6005);
exports.crypto = nc && typeof nc === 'object' && 'webcrypto' in nc ? nc.webcrypto : undefined;
//# sourceMappingURL=cryptoNode.js.map

/***/ }),

/***/ 3817:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hmac = exports.HMAC = void 0;
const _assert_js_1 = __nccwpck_require__(5224);
const utils_js_1 = __nccwpck_require__(4984);
// HMAC (RFC 2104)
class HMAC extends utils_js_1.Hash {
    constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.hash)(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== 'function')
            throw new Error('Expected instance of class which extends utils.Hash');
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        pad.fill(0);
    }
    update(buf) {
        (0, _assert_js_1.exists)(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
exports.HMAC = HMAC;
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 */
const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
exports.hmac = hmac;
exports.hmac.create = (hash, key) => new HMAC(hash, key);
//# sourceMappingURL=hmac.js.map

/***/ }),

/***/ 3945:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pbkdf2Async = exports.pbkdf2 = void 0;
const _assert_js_1 = __nccwpck_require__(5224);
const hmac_js_1 = __nccwpck_require__(3817);
const utils_js_1 = __nccwpck_require__(4984);
// Common prologue and epilogue for sync/async functions
function pbkdf2Init(hash, _password, _salt, _opts) {
    (0, _assert_js_1.hash)(hash);
    const opts = (0, utils_js_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
    const { c, dkLen, asyncTick } = opts;
    (0, _assert_js_1.number)(c);
    (0, _assert_js_1.number)(dkLen);
    (0, _assert_js_1.number)(asyncTick);
    if (c < 1)
        throw new Error('PBKDF2: iterations (c) should be >= 1');
    const password = (0, utils_js_1.toBytes)(_password);
    const salt = (0, utils_js_1.toBytes)(_salt);
    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);
    const DK = new Uint8Array(dkLen);
    // U1 = PRF(Password, Salt + INT_32_BE(i))
    const PRF = hmac_js_1.hmac.create(hash, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW)
        prfW.destroy();
    u.fill(0);
    return DK;
}
/**
 * PBKDF2-HMAC: RFC 2898 key derivation function
 * @param hash - hash function that would be used e.g. sha256
 * @param password - password from which a derived key is generated
 * @param salt - cryptographic salt
 * @param opts - {c, dkLen} where c is work factor and dkLen is output message size
 */
function pbkdf2(hash, password, salt, opts) {
    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, utils_js_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 + ⋯ + Tdklen/hlen
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for (let ui = 1; ui < c; ui++) {
            // Uc = PRF(Password, Uc−1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for (let i = 0; i < Ti.length; i++)
                Ti[i] ^= u[i];
        }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
exports.pbkdf2 = pbkdf2;
async function pbkdf2Async(hash, password, salt, opts) {
    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, utils_js_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 + ⋯ + Tdklen/hlen
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0, utils_js_1.asyncLoop)(c - 1, asyncTick, () => {
            // Uc = PRF(Password, Uc−1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for (let i = 0; i < Ti.length; i++)
                Ti[i] ^= u[i];
        });
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
exports.pbkdf2Async = pbkdf2Async;
//# sourceMappingURL=pbkdf2.js.map

/***/ }),

/***/ 1186:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sha224 = exports.sha256 = void 0;
const _sha2_js_1 = __nccwpck_require__(4687);
const utils_js_1 = __nccwpck_require__(4984);
// SHA2-256 need to try 2^128 hashes to execute birthday attack.
// BTC network is doing 2^67 hashes/sec as per early 2023.
// Choice: a ? b : c
const Chi = (a, b, c) => (a & b) ^ (~a & c);
// Majority function, true if any two inpust is true
const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = /* @__PURE__ */ new Uint32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
// prettier-ignore
const IV = /* @__PURE__ */ new Uint32Array([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _sha2_js_1.SHA2 {
    constructor() {
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = (sigma0 + Maj(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
class SHA224 extends SHA256 {
    constructor() {
        super();
        this.A = 0xc1059ed8 | 0;
        this.B = 0x367cd507 | 0;
        this.C = 0x3070dd17 | 0;
        this.D = 0xf70e5939 | 0;
        this.E = 0xffc00b31 | 0;
        this.F = 0x68581511 | 0;
        this.G = 0x64f98fa7 | 0;
        this.H = 0xbefa4fa4 | 0;
        this.outputLen = 28;
    }
}
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
//# sourceMappingURL=sha256.js.map

/***/ }),

/***/ 3054:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA512 = void 0;
const _sha2_js_1 = __nccwpck_require__(4687);
const _u64_js_1 = __nccwpck_require__(9663);
const utils_js_1 = __nccwpck_require__(4984);
// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):
// prettier-ignore
const [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js_1.default.split([
    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',
    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',
    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',
    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',
    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',
    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',
    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',
    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',
    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',
    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',
    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',
    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',
    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',
    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',
    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',
    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',
    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',
    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',
    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',
    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'
].map(n => BigInt(n))))();
// Temporary buffer, not used to store anything between runs
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends _sha2_js_1.SHA2 {
    constructor() {
        super(128, 64, 16, false);
        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.
        // Also looks cleaner and easier to verify with spec.
        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x6a09e667 | 0;
        this.Al = 0xf3bcc908 | 0;
        this.Bh = 0xbb67ae85 | 0;
        this.Bl = 0x84caa73b | 0;
        this.Ch = 0x3c6ef372 | 0;
        this.Cl = 0xfe94f82b | 0;
        this.Dh = 0xa54ff53a | 0;
        this.Dl = 0x5f1d36f1 | 0;
        this.Eh = 0x510e527f | 0;
        this.El = 0xade682d1 | 0;
        this.Fh = 0x9b05688c | 0;
        this.Fl = 0x2b3e6c1f | 0;
        this.Gh = 0x1f83d9ab | 0;
        this.Gl = 0xfb41bd6b | 0;
        this.Hh = 0x5be0cd19 | 0;
        this.Hl = 0x137e2179 | 0;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32((offset += 4));
        }
        for (let i = 16; i < 80; i++) {
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
            const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
            const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for (let i = 0; i < 80; i++) {
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
            const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = (Eh & Fh) ^ (~Eh & Gh);
            const CHIl = (El & Fl) ^ (~El & Gl);
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
            const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
            Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
    }
    destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
exports.SHA512 = SHA512;
class SHA512_224 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x8c3d37c8 | 0;
        this.Al = 0x19544da2 | 0;
        this.Bh = 0x73e19966 | 0;
        this.Bl = 0x89dcd4d6 | 0;
        this.Ch = 0x1dfab7ae | 0;
        this.Cl = 0x32ff9c82 | 0;
        this.Dh = 0x679dd514 | 0;
        this.Dl = 0x582f9fcf | 0;
        this.Eh = 0x0f6d2b69 | 0;
        this.El = 0x7bd44da8 | 0;
        this.Fh = 0x77e36f73 | 0;
        this.Fl = 0x04c48942 | 0;
        this.Gh = 0x3f9d85a8 | 0;
        this.Gl = 0x6a1d36c8 | 0;
        this.Hh = 0x1112e6ad | 0;
        this.Hl = 0x91d692a1 | 0;
        this.outputLen = 28;
    }
}
class SHA512_256 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x22312194 | 0;
        this.Al = 0xfc2bf72c | 0;
        this.Bh = 0x9f555fa3 | 0;
        this.Bl = 0xc84c64c2 | 0;
        this.Ch = 0x2393b86b | 0;
        this.Cl = 0x6f53b151 | 0;
        this.Dh = 0x96387719 | 0;
        this.Dl = 0x5940eabd | 0;
        this.Eh = 0x96283ee2 | 0;
        this.El = 0xa88effe3 | 0;
        this.Fh = 0xbe5e1e25 | 0;
        this.Fl = 0x53863992 | 0;
        this.Gh = 0x2b0199fc | 0;
        this.Gl = 0x2c85b8aa | 0;
        this.Hh = 0x0eb72ddc | 0;
        this.Hl = 0x81c52ca2 | 0;
        this.outputLen = 32;
    }
}
class SHA384 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0xcbbb9d5d | 0;
        this.Al = 0xc1059ed8 | 0;
        this.Bh = 0x629a292a | 0;
        this.Bl = 0x367cd507 | 0;
        this.Ch = 0x9159015a | 0;
        this.Cl = 0x3070dd17 | 0;
        this.Dh = 0x152fecd8 | 0;
        this.Dl = 0xf70e5939 | 0;
        this.Eh = 0x67332667 | 0;
        this.El = 0xffc00b31 | 0;
        this.Fh = 0x8eb44a87 | 0;
        this.Fl = 0x68581511 | 0;
        this.Gh = 0xdb0c2e0d | 0;
        this.Gl = 0x64f98fa7 | 0;
        this.Hh = 0x47b5481d | 0;
        this.Hl = 0xbefa4fa4 | 0;
        this.outputLen = 48;
    }
}
exports.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
exports.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
exports.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
exports.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
//# sourceMappingURL=sha512.js.map

/***/ }),

/***/ 4984:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
const crypto_1 = __nccwpck_require__(9806);
// Cast array to different type
const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
exports.u8 = u8;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
exports.u32 = u32;
function isBytes(a) {
    return (a instanceof Uint8Array ||
        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
}
// Cast array to view
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
exports.rotr = rotr;
// big-endian hardware is rare. Just in case someone still decides to run hashes:
// early-throw an error because we don't support BE yet.
// Other libraries would silently corrupt the data instead of throwing an error,
// when they don't support it.
exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
if (!exports.isLE)
    throw new Error('Non little-endian hardware is not supported');
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    if (!isBytes(bytes))
        throw new Error('Uint8Array expected');
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
// We use optimized technique to convert hex string to byte array
const asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
    if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
    return;
}
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// There is no setImmediate in browser and setTimeout is slow.
// call of async fn will return Promise, which will be fullfiled only on
// next scheduler queue processing step and this is exactly what we need.
const nextTick = async () => { };
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
exports.asyncLoop = asyncLoop;
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
exports.utf8ToBytes = utf8ToBytes;
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    if (!isBytes(data))
        throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
}
exports.toBytes = toBytes;
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        if (!isBytes(a))
            throw new Error('Uint8Array expected');
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
exports.concatBytes = concatBytes;
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
exports.Hash = Hash;
const toStr = {}.toString;
function checkOpts(defaults, opts) {
    if (opts !== undefined && toStr.call(opts) !== '[object Object]')
        throw new Error('Options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
exports.checkOpts = checkOpts;
function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}
exports.wrapConstructor = wrapConstructor;
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
/**
 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
 */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
}
exports.randomBytes = randomBytes;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 3358:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
// @ts-ignore
var _Buffer = (__nccwpck_require__(6621).Buffer)
function base (ALPHABET) {
  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
  var BASE_MAP = new Uint8Array(256)
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i)
    var xc = x.charCodeAt(0)
    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
    BASE_MAP[xc] = i
  }
  var BASE = ALPHABET.length
  var LEADER = ALPHABET.charAt(0)
  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up
  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up
  function encode (source) {
    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }
    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }
    if (source.length === 0) { return '' }
        // Skip & count leading zeroes.
    var zeroes = 0
    var length = 0
    var pbegin = 0
    var pend = source.length
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++
      zeroes++
    }
        // Allocate enough space in big-endian base58 representation.
    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0
    var b58 = new Uint8Array(size)
        // Process the bytes.
    while (pbegin !== pend) {
      var carry = source[pbegin]
            // Apply "b58 = b58 * 256 + ch".
      var i = 0
      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
        carry += (256 * b58[it1]) >>> 0
        b58[it1] = (carry % BASE) >>> 0
        carry = (carry / BASE) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      pbegin++
    }
        // Skip leading zeroes in base58 result.
    var it2 = size - length
    while (it2 !== size && b58[it2] === 0) {
      it2++
    }
        // Translate the result into a string.
    var str = LEADER.repeat(zeroes)
    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }
    return str
  }
  function decodeUnsafe (source) {
    if (typeof source !== 'string') { throw new TypeError('Expected String') }
    if (source.length === 0) { return _Buffer.alloc(0) }
    var psz = 0
        // Skip and count leading '1's.
    var zeroes = 0
    var length = 0
    while (source[psz] === LEADER) {
      zeroes++
      psz++
    }
        // Allocate enough space in big-endian base256 representation.
    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.
    var b256 = new Uint8Array(size)
        // Process the characters.
    while (source[psz]) {
            // Decode character
      var carry = BASE_MAP[source.charCodeAt(psz)]
            // Invalid character
      if (carry === 255) { return }
      var i = 0
      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
        carry += (BASE * b256[it3]) >>> 0
        b256[it3] = (carry % 256) >>> 0
        carry = (carry / 256) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      psz++
    }
        // Skip leading zeroes in b256.
    var it4 = size - length
    while (it4 !== size && b256[it4] === 0) {
      it4++
    }
    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))
    vch.fill(0x00, 0, zeroes)
    var j = zeroes
    while (it4 !== size) {
      vch[j++] = b256[it4++]
    }
    return vch
  }
  function decode (string) {
    var buffer = decodeUnsafe(string)
    if (buffer) { return buffer }
    throw new Error('Non-base' + BASE + ' character')
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  }
}
module.exports = base


/***/ }),

/***/ 3325:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ 4922:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/* module decorator */ module = __nccwpck_require__.nmd(module);
var bigInt = (function (undefined) {
    "use strict";

    var BASE = 1e7,
        LOG_BASE = 7,
        MAX_INT = 9007199254740992,
        MAX_INT_ARR = smallToArray(MAX_INT),
        DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";

    var supportsNativeBigInt = typeof BigInt === "function";

    function Integer(v, radix, alphabet, caseSensitive) {
        if (typeof v === "undefined") return Integer[0];
        if (typeof radix !== "undefined") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);
        return parseValue(v);
    }

    function BigInteger(value, sign) {
        this.value = value;
        this.sign = sign;
        this.isSmall = false;
    }
    BigInteger.prototype = Object.create(Integer.prototype);

    function SmallInteger(value) {
        this.value = value;
        this.sign = value < 0;
        this.isSmall = true;
    }
    SmallInteger.prototype = Object.create(Integer.prototype);

    function NativeBigInt(value) {
        this.value = value;
    }
    NativeBigInt.prototype = Object.create(Integer.prototype);

    function isPrecise(n) {
        return -MAX_INT < n && n < MAX_INT;
    }

    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes
        if (n < 1e7)
            return [n];
        if (n < 1e14)
            return [n % 1e7, Math.floor(n / 1e7)];
        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
    }

    function arrayToSmall(arr) { // If BASE changes this function may need to change
        trim(arr);
        var length = arr.length;
        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
            switch (length) {
                case 0: return 0;
                case 1: return arr[0];
                case 2: return arr[0] + arr[1] * BASE;
                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
            }
        }
        return arr;
    }

    function trim(v) {
        var i = v.length;
        while (v[--i] === 0);
        v.length = i + 1;
    }

    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger
        var x = new Array(length);
        var i = -1;
        while (++i < length) {
            x[i] = 0;
        }
        return x;
    }

    function truncate(n) {
        if (n > 0) return Math.floor(n);
        return Math.ceil(n);
    }

    function add(a, b) { // assumes a and b are arrays with a.length >= b.length
        var l_a = a.length,
            l_b = b.length,
            r = new Array(l_a),
            carry = 0,
            base = BASE,
            sum, i;
        for (i = 0; i < l_b; i++) {
            sum = a[i] + b[i] + carry;
            carry = sum >= base ? 1 : 0;
            r[i] = sum - carry * base;
        }
        while (i < l_a) {
            sum = a[i] + carry;
            carry = sum === base ? 1 : 0;
            r[i++] = sum - carry * base;
        }
        if (carry > 0) r.push(carry);
        return r;
    }

    function addAny(a, b) {
        if (a.length >= b.length) return add(a, b);
        return add(b, a);
    }

    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT
        var l = a.length,
            r = new Array(l),
            base = BASE,
            sum, i;
        for (i = 0; i < l; i++) {
            sum = a[i] - base + carry;
            carry = Math.floor(sum / base);
            r[i] = sum - carry * base;
            carry += 1;
        }
        while (carry > 0) {
            r[i++] = carry % base;
            carry = Math.floor(carry / base);
        }
        return r;
    }

    BigInteger.prototype.add = function (v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
            return this.subtract(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall) {
            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
        }
        return new BigInteger(addAny(a, b), this.sign);
    };
    BigInteger.prototype.plus = BigInteger.prototype.add;

    SmallInteger.prototype.add = function (v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
            return this.subtract(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
            if (isPrecise(a + b)) return new SmallInteger(a + b);
            b = smallToArray(Math.abs(b));
        }
        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
    };
    SmallInteger.prototype.plus = SmallInteger.prototype.add;

    NativeBigInt.prototype.add = function (v) {
        return new NativeBigInt(this.value + parseValue(v).value);
    }
    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;

    function subtract(a, b) { // assumes a and b are arrays with a >= b
        var a_l = a.length,
            b_l = b.length,
            r = new Array(a_l),
            borrow = 0,
            base = BASE,
            i, difference;
        for (i = 0; i < b_l; i++) {
            difference = a[i] - borrow - b[i];
            if (difference < 0) {
                difference += base;
                borrow = 1;
            } else borrow = 0;
            r[i] = difference;
        }
        for (i = b_l; i < a_l; i++) {
            difference = a[i] - borrow;
            if (difference < 0) difference += base;
            else {
                r[i++] = difference;
                break;
            }
            r[i] = difference;
        }
        for (; i < a_l; i++) {
            r[i] = a[i];
        }
        trim(r);
        return r;
    }

    function subtractAny(a, b, sign) {
        var value;
        if (compareAbs(a, b) >= 0) {
            value = subtract(a, b);
        } else {
            value = subtract(b, a);
            sign = !sign;
        }
        value = arrayToSmall(value);
        if (typeof value === "number") {
            if (sign) value = -value;
            return new SmallInteger(value);
        }
        return new BigInteger(value, sign);
    }

    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT
        var l = a.length,
            r = new Array(l),
            carry = -b,
            base = BASE,
            i, difference;
        for (i = 0; i < l; i++) {
            difference = a[i] + carry;
            carry = Math.floor(difference / base);
            difference %= base;
            r[i] = difference < 0 ? difference + base : difference;
        }
        r = arrayToSmall(r);
        if (typeof r === "number") {
            if (sign) r = -r;
            return new SmallInteger(r);
        } return new BigInteger(r, sign);
    }

    BigInteger.prototype.subtract = function (v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
            return this.add(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall)
            return subtractSmall(a, Math.abs(b), this.sign);
        return subtractAny(a, b, this.sign);
    };
    BigInteger.prototype.minus = BigInteger.prototype.subtract;

    SmallInteger.prototype.subtract = function (v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
            return this.add(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
            return new SmallInteger(a - b);
        }
        return subtractSmall(b, Math.abs(a), a >= 0);
    };
    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;

    NativeBigInt.prototype.subtract = function (v) {
        return new NativeBigInt(this.value - parseValue(v).value);
    }
    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;

    BigInteger.prototype.negate = function () {
        return new BigInteger(this.value, !this.sign);
    };
    SmallInteger.prototype.negate = function () {
        var sign = this.sign;
        var small = new SmallInteger(-this.value);
        small.sign = !sign;
        return small;
    };
    NativeBigInt.prototype.negate = function () {
        return new NativeBigInt(-this.value);
    }

    BigInteger.prototype.abs = function () {
        return new BigInteger(this.value, false);
    };
    SmallInteger.prototype.abs = function () {
        return new SmallInteger(Math.abs(this.value));
    };
    NativeBigInt.prototype.abs = function () {
        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
    }


    function multiplyLong(a, b) {
        var a_l = a.length,
            b_l = b.length,
            l = a_l + b_l,
            r = createArray(l),
            base = BASE,
            product, carry, i, a_i, b_j;
        for (i = 0; i < a_l; ++i) {
            a_i = a[i];
            for (var j = 0; j < b_l; ++j) {
                b_j = b[j];
                product = a_i * b_j + r[i + j];
                carry = Math.floor(product / base);
                r[i + j] = product - carry * base;
                r[i + j + 1] += carry;
            }
        }
        trim(r);
        return r;
    }

    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE
        var l = a.length,
            r = new Array(l),
            base = BASE,
            carry = 0,
            product, i;
        for (i = 0; i < l; i++) {
            product = a[i] * b + carry;
            carry = Math.floor(product / base);
            r[i] = product - carry * base;
        }
        while (carry > 0) {
            r[i++] = carry % base;
            carry = Math.floor(carry / base);
        }
        return r;
    }

    function shiftLeft(x, n) {
        var r = [];
        while (n-- > 0) r.push(0);
        return r.concat(x);
    }

    function multiplyKaratsuba(x, y) {
        var n = Math.max(x.length, y.length);

        if (n <= 30) return multiplyLong(x, y);
        n = Math.ceil(n / 2);

        var b = x.slice(n),
            a = x.slice(0, n),
            d = y.slice(n),
            c = y.slice(0, n);

        var ac = multiplyKaratsuba(a, c),
            bd = multiplyKaratsuba(b, d),
            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));

        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
        trim(product);
        return product;
    }

    // The following function is derived from a surface fit of a graph plotting the performance difference
    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.
    function useKaratsuba(l1, l2) {
        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;
    }

    BigInteger.prototype.multiply = function (v) {
        var n = parseValue(v),
            a = this.value, b = n.value,
            sign = this.sign !== n.sign,
            abs;
        if (n.isSmall) {
            if (b === 0) return Integer[0];
            if (b === 1) return this;
            if (b === -1) return this.negate();
            abs = Math.abs(b);
            if (abs < BASE) {
                return new BigInteger(multiplySmall(a, abs), sign);
            }
            b = smallToArray(abs);
        }
        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes
            return new BigInteger(multiplyKaratsuba(a, b), sign);
        return new BigInteger(multiplyLong(a, b), sign);
    };

    BigInteger.prototype.times = BigInteger.prototype.multiply;

    function multiplySmallAndArray(a, b, sign) { // a >= 0
        if (a < BASE) {
            return new BigInteger(multiplySmall(b, a), sign);
        }
        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
    }
    SmallInteger.prototype._multiplyBySmall = function (a) {
        if (isPrecise(a.value * this.value)) {
            return new SmallInteger(a.value * this.value);
        }
        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
    };
    BigInteger.prototype._multiplyBySmall = function (a) {
        if (a.value === 0) return Integer[0];
        if (a.value === 1) return this;
        if (a.value === -1) return this.negate();
        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
    };
    SmallInteger.prototype.multiply = function (v) {
        return parseValue(v)._multiplyBySmall(this);
    };
    SmallInteger.prototype.times = SmallInteger.prototype.multiply;

    NativeBigInt.prototype.multiply = function (v) {
        return new NativeBigInt(this.value * parseValue(v).value);
    }
    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;

    function square(a) {
        //console.assert(2 * BASE * BASE < MAX_INT);
        var l = a.length,
            r = createArray(l + l),
            base = BASE,
            product, carry, i, a_i, a_j;
        for (i = 0; i < l; i++) {
            a_i = a[i];
            carry = 0 - a_i * a_i;
            for (var j = i; j < l; j++) {
                a_j = a[j];
                product = 2 * (a_i * a_j) + r[i + j] + carry;
                carry = Math.floor(product / base);
                r[i + j] = product - carry * base;
            }
            r[i + l] = carry;
        }
        trim(r);
        return r;
    }

    BigInteger.prototype.square = function () {
        return new BigInteger(square(this.value), false);
    };

    SmallInteger.prototype.square = function () {
        var value = this.value * this.value;
        if (isPrecise(value)) return new SmallInteger(value);
        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
    };

    NativeBigInt.prototype.square = function (v) {
        return new NativeBigInt(this.value * this.value);
    }

    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.
        var a_l = a.length,
            b_l = b.length,
            base = BASE,
            result = createArray(b.length),
            divisorMostSignificantDigit = b[b_l - 1],
            // normalization
            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),
            remainder = multiplySmall(a, lambda),
            divisor = multiplySmall(b, lambda),
            quotientDigit, shift, carry, borrow, i, l, q;
        if (remainder.length <= a_l) remainder.push(0);
        divisor.push(0);
        divisorMostSignificantDigit = divisor[b_l - 1];
        for (shift = a_l - b_l; shift >= 0; shift--) {
            quotientDigit = base - 1;
            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
            }
            // quotientDigit <= base - 1
            carry = 0;
            borrow = 0;
            l = divisor.length;
            for (i = 0; i < l; i++) {
                carry += quotientDigit * divisor[i];
                q = Math.floor(carry / base);
                borrow += remainder[shift + i] - (carry - q * base);
                carry = q;
                if (borrow < 0) {
                    remainder[shift + i] = borrow + base;
                    borrow = -1;
                } else {
                    remainder[shift + i] = borrow;
                    borrow = 0;
                }
            }
            while (borrow !== 0) {
                quotientDigit -= 1;
                carry = 0;
                for (i = 0; i < l; i++) {
                    carry += remainder[shift + i] - base + divisor[i];
                    if (carry < 0) {
                        remainder[shift + i] = carry + base;
                        carry = 0;
                    } else {
                        remainder[shift + i] = carry;
                        carry = 1;
                    }
                }
                borrow += carry;
            }
            result[shift] = quotientDigit;
        }
        // denormalization
        remainder = divModSmall(remainder, lambda)[0];
        return [arrayToSmall(result), arrayToSmall(remainder)];
    }

    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/
        // Performs faster than divMod1 on larger input sizes.
        var a_l = a.length,
            b_l = b.length,
            result = [],
            part = [],
            base = BASE,
            guess, xlen, highx, highy, check;
        while (a_l) {
            part.unshift(a[--a_l]);
            trim(part);
            if (compareAbs(part, b) < 0) {
                result.push(0);
                continue;
            }
            xlen = part.length;
            highx = part[xlen - 1] * base + part[xlen - 2];
            highy = b[b_l - 1] * base + b[b_l - 2];
            if (xlen > b_l) {
                highx = (highx + 1) * base;
            }
            guess = Math.ceil(highx / highy);
            do {
                check = multiplySmall(b, guess);
                if (compareAbs(check, part) <= 0) break;
                guess--;
            } while (guess);
            result.push(guess);
            part = subtract(part, check);
        }
        result.reverse();
        return [arrayToSmall(result), arrayToSmall(part)];
    }

    function divModSmall(value, lambda) {
        var length = value.length,
            quotient = createArray(length),
            base = BASE,
            i, q, remainder, divisor;
        remainder = 0;
        for (i = length - 1; i >= 0; --i) {
            divisor = remainder * base + value[i];
            q = truncate(divisor / lambda);
            remainder = divisor - q * lambda;
            quotient[i] = q | 0;
        }
        return [quotient, remainder | 0];
    }

    function divModAny(self, v) {
        var value, n = parseValue(v);
        if (supportsNativeBigInt) {
            return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];
        }
        var a = self.value, b = n.value;
        var quotient;
        if (b === 0) throw new Error("Cannot divide by zero");
        if (self.isSmall) {
            if (n.isSmall) {
                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
            }
            return [Integer[0], self];
        }
        if (n.isSmall) {
            if (b === 1) return [self, Integer[0]];
            if (b == -1) return [self.negate(), Integer[0]];
            var abs = Math.abs(b);
            if (abs < BASE) {
                value = divModSmall(a, abs);
                quotient = arrayToSmall(value[0]);
                var remainder = value[1];
                if (self.sign) remainder = -remainder;
                if (typeof quotient === "number") {
                    if (self.sign !== n.sign) quotient = -quotient;
                    return [new SmallInteger(quotient), new SmallInteger(remainder)];
                }
                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];
            }
            b = smallToArray(abs);
        }
        var comparison = compareAbs(a, b);
        if (comparison === -1) return [Integer[0], self];
        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];

        // divMod1 is faster on smaller input sizes
        if (a.length + b.length <= 200)
            value = divMod1(a, b);
        else value = divMod2(a, b);

        quotient = value[0];
        var qSign = self.sign !== n.sign,
            mod = value[1],
            mSign = self.sign;
        if (typeof quotient === "number") {
            if (qSign) quotient = -quotient;
            quotient = new SmallInteger(quotient);
        } else quotient = new BigInteger(quotient, qSign);
        if (typeof mod === "number") {
            if (mSign) mod = -mod;
            mod = new SmallInteger(mod);
        } else mod = new BigInteger(mod, mSign);
        return [quotient, mod];
    }

    BigInteger.prototype.divmod = function (v) {
        var result = divModAny(this, v);
        return {
            quotient: result[0],
            remainder: result[1]
        };
    };
    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;


    BigInteger.prototype.divide = function (v) {
        return divModAny(this, v)[0];
    };
    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function (v) {
        return new NativeBigInt(this.value / parseValue(v).value);
    };
    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;

    BigInteger.prototype.mod = function (v) {
        return divModAny(this, v)[1];
    };
    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function (v) {
        return new NativeBigInt(this.value % parseValue(v).value);
    };
    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;

    BigInteger.prototype.pow = function (v) {
        var n = parseValue(v),
            a = this.value,
            b = n.value,
            value, x, y;
        if (b === 0) return Integer[1];
        if (a === 0) return Integer[0];
        if (a === 1) return Integer[1];
        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];
        if (n.sign) {
            return Integer[0];
        }
        if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
        if (this.isSmall) {
            if (isPrecise(value = Math.pow(a, b)))
                return new SmallInteger(truncate(value));
        }
        x = this;
        y = Integer[1];
        while (true) {
            if (b & 1 === 1) {
                y = y.times(x);
                --b;
            }
            if (b === 0) break;
            b /= 2;
            x = x.square();
        }
        return y;
    };
    SmallInteger.prototype.pow = BigInteger.prototype.pow;

    NativeBigInt.prototype.pow = function (v) {
        var n = parseValue(v);
        var a = this.value, b = n.value;
        var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);
        if (b === _0) return Integer[1];
        if (a === _0) return Integer[0];
        if (a === _1) return Integer[1];
        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];
        if (n.isNegative()) return new NativeBigInt(_0);
        var x = this;
        var y = Integer[1];
        while (true) {
            if ((b & _1) === _1) {
                y = y.times(x);
                --b;
            }
            if (b === _0) break;
            b /= _2;
            x = x.square();
        }
        return y;
    }

    BigInteger.prototype.modPow = function (exp, mod) {
        exp = parseValue(exp);
        mod = parseValue(mod);
        if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
        var r = Integer[1],
            base = this.mod(mod);
        if (exp.isNegative()) {
            exp = exp.multiply(Integer[-1]);
            base = base.modInv(mod);
        }
        while (exp.isPositive()) {
            if (base.isZero()) return Integer[0];
            if (exp.isOdd()) r = r.multiply(base).mod(mod);
            exp = exp.divide(2);
            base = base.square().mod(mod);
        }
        return r;
    };
    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;

    function compareAbs(a, b) {
        if (a.length !== b.length) {
            return a.length > b.length ? 1 : -1;
        }
        for (var i = a.length - 1; i >= 0; i--) {
            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
        }
        return 0;
    }

    BigInteger.prototype.compareAbs = function (v) {
        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (n.isSmall) return 1;
        return compareAbs(a, b);
    };
    SmallInteger.prototype.compareAbs = function (v) {
        var n = parseValue(v),
            a = Math.abs(this.value),
            b = n.value;
        if (n.isSmall) {
            b = Math.abs(b);
            return a === b ? 0 : a > b ? 1 : -1;
        }
        return -1;
    };
    NativeBigInt.prototype.compareAbs = function (v) {
        var a = this.value;
        var b = parseValue(v).value;
        a = a >= 0 ? a : -a;
        b = b >= 0 ? b : -b;
        return a === b ? 0 : a > b ? 1 : -1;
    }

    BigInteger.prototype.compare = function (v) {
        // See discussion about comparison with Infinity:
        // https://github.com/peterolson/BigInteger.js/issues/61
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }

        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (this.sign !== n.sign) {
            return n.sign ? 1 : -1;
        }
        if (n.isSmall) {
            return this.sign ? -1 : 1;
        }
        return compareAbs(a, b) * (this.sign ? -1 : 1);
    };
    BigInteger.prototype.compareTo = BigInteger.prototype.compare;

    SmallInteger.prototype.compare = function (v) {
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }

        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (n.isSmall) {
            return a == b ? 0 : a > b ? 1 : -1;
        }
        if (a < 0 !== n.sign) {
            return a < 0 ? -1 : 1;
        }
        return a < 0 ? 1 : -1;
    };
    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;

    NativeBigInt.prototype.compare = function (v) {
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }
        var a = this.value;
        var b = parseValue(v).value;
        return a === b ? 0 : a > b ? 1 : -1;
    }
    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;

    BigInteger.prototype.equals = function (v) {
        return this.compare(v) === 0;
    };
    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;

    BigInteger.prototype.notEquals = function (v) {
        return this.compare(v) !== 0;
    };
    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;

    BigInteger.prototype.greater = function (v) {
        return this.compare(v) > 0;
    };
    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;

    BigInteger.prototype.lesser = function (v) {
        return this.compare(v) < 0;
    };
    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;

    BigInteger.prototype.greaterOrEquals = function (v) {
        return this.compare(v) >= 0;
    };
    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;

    BigInteger.prototype.lesserOrEquals = function (v) {
        return this.compare(v) <= 0;
    };
    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;

    BigInteger.prototype.isEven = function () {
        return (this.value[0] & 1) === 0;
    };
    SmallInteger.prototype.isEven = function () {
        return (this.value & 1) === 0;
    };
    NativeBigInt.prototype.isEven = function () {
        return (this.value & BigInt(1)) === BigInt(0);
    }

    BigInteger.prototype.isOdd = function () {
        return (this.value[0] & 1) === 1;
    };
    SmallInteger.prototype.isOdd = function () {
        return (this.value & 1) === 1;
    };
    NativeBigInt.prototype.isOdd = function () {
        return (this.value & BigInt(1)) === BigInt(1);
    }

    BigInteger.prototype.isPositive = function () {
        return !this.sign;
    };
    SmallInteger.prototype.isPositive = function () {
        return this.value > 0;
    };
    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;

    BigInteger.prototype.isNegative = function () {
        return this.sign;
    };
    SmallInteger.prototype.isNegative = function () {
        return this.value < 0;
    };
    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;

    BigInteger.prototype.isUnit = function () {
        return false;
    };
    SmallInteger.prototype.isUnit = function () {
        return Math.abs(this.value) === 1;
    };
    NativeBigInt.prototype.isUnit = function () {
        return this.abs().value === BigInt(1);
    }

    BigInteger.prototype.isZero = function () {
        return false;
    };
    SmallInteger.prototype.isZero = function () {
        return this.value === 0;
    };
    NativeBigInt.prototype.isZero = function () {
        return this.value === BigInt(0);
    }

    BigInteger.prototype.isDivisibleBy = function (v) {
        var n = parseValue(v);
        if (n.isZero()) return false;
        if (n.isUnit()) return true;
        if (n.compareAbs(2) === 0) return this.isEven();
        return this.mod(n).isZero();
    };
    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;

    function isBasicPrime(v) {
        var n = v.abs();
        if (n.isUnit()) return false;
        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
        if (n.lesser(49)) return true;
        // we don't know if it's prime: let the other functions figure it out
    }

    function millerRabinTest(n, a) {
        var nPrev = n.prev(),
            b = nPrev,
            r = 0,
            d, t, i, x;
        while (b.isEven()) b = b.divide(2), r++;
        next: for (i = 0; i < a.length; i++) {
            if (n.lesser(a[i])) continue;
            x = bigInt(a[i]).modPow(b, n);
            if (x.isUnit() || x.equals(nPrev)) continue;
            for (d = r - 1; d != 0; d--) {
                x = x.square().mod(n);
                if (x.isUnit()) return false;
                if (x.equals(nPrev)) continue next;
            }
            return false;
        }
        return true;
    }

    // Set "strict" to true to force GRH-supported lower bound of 2*log(N)^2
    BigInteger.prototype.isPrime = function (strict) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined) return isPrime;
        var n = this.abs();
        var bits = n.bitLength();
        if (bits <= 64)
            return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
        var logN = Math.log(2) * bits.toJSNumber();
        var t = Math.ceil((strict === true) ? (2 * Math.pow(logN, 2)) : logN);
        for (var a = [], i = 0; i < t; i++) {
            a.push(bigInt(i + 2));
        }
        return millerRabinTest(n, a);
    };
    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;

    BigInteger.prototype.isProbablePrime = function (iterations, rng) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined) return isPrime;
        var n = this.abs();
        var t = iterations === undefined ? 5 : iterations;
        for (var a = [], i = 0; i < t; i++) {
            a.push(bigInt.randBetween(2, n.minus(2), rng));
        }
        return millerRabinTest(n, a);
    };
    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;

    BigInteger.prototype.modInv = function (n) {
        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;
        while (!newR.isZero()) {
            q = r.divide(newR);
            lastT = t;
            lastR = r;
            t = newT;
            r = newR;
            newT = lastT.subtract(q.multiply(newT));
            newR = lastR.subtract(q.multiply(newR));
        }
        if (!r.isUnit()) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
        if (t.compare(0) === -1) {
            t = t.add(n);
        }
        if (this.isNegative()) {
            return t.negate();
        }
        return t;
    };

    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;

    BigInteger.prototype.next = function () {
        var value = this.value;
        if (this.sign) {
            return subtractSmall(value, 1, this.sign);
        }
        return new BigInteger(addSmall(value, 1), this.sign);
    };
    SmallInteger.prototype.next = function () {
        var value = this.value;
        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
        return new BigInteger(MAX_INT_ARR, false);
    };
    NativeBigInt.prototype.next = function () {
        return new NativeBigInt(this.value + BigInt(1));
    }

    BigInteger.prototype.prev = function () {
        var value = this.value;
        if (this.sign) {
            return new BigInteger(addSmall(value, 1), true);
        }
        return subtractSmall(value, 1, this.sign);
    };
    SmallInteger.prototype.prev = function () {
        var value = this.value;
        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
        return new BigInteger(MAX_INT_ARR, true);
    };
    NativeBigInt.prototype.prev = function () {
        return new NativeBigInt(this.value - BigInt(1));
    }

    var powersOfTwo = [1];
    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];

    function shift_isSmall(n) {
        return Math.abs(n) <= BASE;
    }

    BigInteger.prototype.shiftLeft = function (v) {
        var n = parseValue(v).toJSNumber();
        if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
        }
        if (n < 0) return this.shiftRight(-n);
        var result = this;
        if (result.isZero()) return result;
        while (n >= powers2Length) {
            result = result.multiply(highestPower2);
            n -= powers2Length - 1;
        }
        return result.multiply(powersOfTwo[n]);
    };
    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;

    BigInteger.prototype.shiftRight = function (v) {
        var remQuo;
        var n = parseValue(v).toJSNumber();
        if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
        }
        if (n < 0) return this.shiftLeft(-n);
        var result = this;
        while (n >= powers2Length) {
            if (result.isZero() || (result.isNegative() && result.isUnit())) return result;
            remQuo = divModAny(result, highestPower2);
            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
            n -= powers2Length - 1;
        }
        remQuo = divModAny(result, powersOfTwo[n]);
        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
    };
    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;

    function bitwise(x, y, fn) {
        y = parseValue(y);
        var xSign = x.isNegative(), ySign = y.isNegative();
        var xRem = xSign ? x.not() : x,
            yRem = ySign ? y.not() : y;
        var xDigit = 0, yDigit = 0;
        var xDivMod = null, yDivMod = null;
        var result = [];
        while (!xRem.isZero() || !yRem.isZero()) {
            xDivMod = divModAny(xRem, highestPower2);
            xDigit = xDivMod[1].toJSNumber();
            if (xSign) {
                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers
            }

            yDivMod = divModAny(yRem, highestPower2);
            yDigit = yDivMod[1].toJSNumber();
            if (ySign) {
                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers
            }

            xRem = xDivMod[0];
            yRem = yDivMod[0];
            result.push(fn(xDigit, yDigit));
        }
        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
        for (var i = result.length - 1; i >= 0; i -= 1) {
            sum = sum.multiply(highestPower2).add(bigInt(result[i]));
        }
        return sum;
    }

    BigInteger.prototype.not = function () {
        return this.negate().prev();
    };
    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;

    BigInteger.prototype.and = function (n) {
        return bitwise(this, n, function (a, b) { return a & b; });
    };
    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;

    BigInteger.prototype.or = function (n) {
        return bitwise(this, n, function (a, b) { return a | b; });
    };
    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;

    BigInteger.prototype.xor = function (n) {
        return bitwise(this, n, function (a, b) { return a ^ b; });
    };
    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;

    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
    function roughLOB(n) { // get lowestOneBit (rough)
        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)
        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]
        var v = n.value,
            x = typeof v === "number" ? v | LOBMASK_I :
                typeof v === "bigint" ? v | BigInt(LOBMASK_I) :
                    v[0] + v[1] * BASE | LOBMASK_BI;
        return x & -x;
    }

    function integerLogarithm(value, base) {
        if (base.compareTo(value) <= 0) {
            var tmp = integerLogarithm(value, base.square(base));
            var p = tmp.p;
            var e = tmp.e;
            var t = p.multiply(base);
            return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p: p, e: e * 2 };
        }
        return { p: bigInt(1), e: 0 };
    }

    BigInteger.prototype.bitLength = function () {
        var n = this;
        if (n.compareTo(bigInt(0)) < 0) {
            n = n.negate().subtract(bigInt(1));
        }
        if (n.compareTo(bigInt(0)) === 0) {
            return bigInt(0);
        }
        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));
    }
    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;

    function max(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.greater(b) ? a : b;
    }
    function min(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.lesser(b) ? a : b;
    }
    function gcd(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        if (a.equals(b)) return a;
        if (a.isZero()) return b;
        if (b.isZero()) return a;
        var c = Integer[1], d, t;
        while (a.isEven() && b.isEven()) {
            d = min(roughLOB(a), roughLOB(b));
            a = a.divide(d);
            b = b.divide(d);
            c = c.multiply(d);
        }
        while (a.isEven()) {
            a = a.divide(roughLOB(a));
        }
        do {
            while (b.isEven()) {
                b = b.divide(roughLOB(b));
            }
            if (a.greater(b)) {
                t = b; b = a; a = t;
            }
            b = b.subtract(a);
        } while (!b.isZero());
        return c.isUnit() ? a : a.multiply(c);
    }
    function lcm(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        return a.divide(gcd(a, b)).multiply(b);
    }
    function randBetween(a, b, rng) {
        a = parseValue(a);
        b = parseValue(b);
        var usedRNG = rng || Math.random;
        var low = min(a, b), high = max(a, b);
        var range = high.subtract(low).add(1);
        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));
        var digits = toBase(range, BASE).value;
        var result = [], restricted = true;
        for (var i = 0; i < digits.length; i++) {
            var top = restricted ? digits[i] + (i + 1 < digits.length ? digits[i + 1] / BASE : 0) : BASE;
            var digit = truncate(usedRNG() * top);
            result.push(digit);
            if (digit < digits[i]) restricted = false;
        }
        return low.add(Integer.fromArray(result, BASE, false));
    }

    var parseBase = function (text, base, alphabet, caseSensitive) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        text = String(text);
        if (!caseSensitive) {
            text = text.toLowerCase();
            alphabet = alphabet.toLowerCase();
        }
        var length = text.length;
        var i;
        var absBase = Math.abs(base);
        var alphabetValues = {};
        for (i = 0; i < alphabet.length; i++) {
            alphabetValues[alphabet[i]] = i;
        }
        for (i = 0; i < length; i++) {
            var c = text[i];
            if (c === "-") continue;
            if (c in alphabetValues) {
                if (alphabetValues[c] >= absBase) {
                    if (c === "1" && absBase === 1) continue;
                    throw new Error(c + " is not a valid digit in base " + base + ".");
                }
            }
        }
        base = parseValue(base);
        var digits = [];
        var isNegative = text[0] === "-";
        for (i = isNegative ? 1 : 0; i < text.length; i++) {
            var c = text[i];
            if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));
            else if (c === "<") {
                var start = i;
                do { i++; } while (text[i] !== ">" && i < text.length);
                digits.push(parseValue(text.slice(start + 1, i)));
            }
            else throw new Error(c + " is not a valid character");
        }
        return parseBaseFromArray(digits, base, isNegative);
    };

    function parseBaseFromArray(digits, base, isNegative) {
        var val = Integer[0], pow = Integer[1], i;
        for (i = digits.length - 1; i >= 0; i--) {
            val = val.add(digits[i].times(pow));
            pow = pow.times(base);
        }
        return isNegative ? val.negate() : val;
    }

    function stringify(digit, alphabet) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        if (digit < alphabet.length) {
            return alphabet[digit];
        }
        return "<" + digit + ">";
    }

    function toBase(n, base) {
        base = bigInt(base);
        if (base.isZero()) {
            if (n.isZero()) return { value: [0], isNegative: false };
            throw new Error("Cannot convert nonzero numbers to base 0.");
        }
        if (base.equals(-1)) {
            if (n.isZero()) return { value: [0], isNegative: false };
            if (n.isNegative())
                return {
                    value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber()))
                        .map(Array.prototype.valueOf, [1, 0])
                    ),
                    isNegative: false
                };

            var arr = Array.apply(null, Array(n.toJSNumber() - 1))
                .map(Array.prototype.valueOf, [0, 1]);
            arr.unshift([1]);
            return {
                value: [].concat.apply([], arr),
                isNegative: false
            };
        }

        var neg = false;
        if (n.isNegative() && base.isPositive()) {
            neg = true;
            n = n.abs();
        }
        if (base.isUnit()) {
            if (n.isZero()) return { value: [0], isNegative: false };

            return {
                value: Array.apply(null, Array(n.toJSNumber()))
                    .map(Number.prototype.valueOf, 1),
                isNegative: neg
            };
        }
        var out = [];
        var left = n, divmod;
        while (left.isNegative() || left.compareAbs(base) >= 0) {
            divmod = left.divmod(base);
            left = divmod.quotient;
            var digit = divmod.remainder;
            if (digit.isNegative()) {
                digit = base.minus(digit).abs();
                left = left.next();
            }
            out.push(digit.toJSNumber());
        }
        out.push(left.toJSNumber());
        return { value: out.reverse(), isNegative: neg };
    }

    function toBaseString(n, base, alphabet) {
        var arr = toBase(n, base);
        return (arr.isNegative ? "-" : "") + arr.value.map(function (x) {
            return stringify(x, alphabet);
        }).join('');
    }

    BigInteger.prototype.toArray = function (radix) {
        return toBase(this, radix);
    };

    SmallInteger.prototype.toArray = function (radix) {
        return toBase(this, radix);
    };

    NativeBigInt.prototype.toArray = function (radix) {
        return toBase(this, radix);
    };

    BigInteger.prototype.toString = function (radix, alphabet) {
        if (radix === undefined) radix = 10;
        if (radix !== 10 || alphabet) return toBaseString(this, radix, alphabet);
        var v = this.value, l = v.length, str = String(v[--l]), zeros = "0000000", digit;
        while (--l >= 0) {
            digit = String(v[l]);
            str += zeros.slice(digit.length) + digit;
        }
        var sign = this.sign ? "-" : "";
        return sign + str;
    };

    SmallInteger.prototype.toString = function (radix, alphabet) {
        if (radix === undefined) radix = 10;
        if (radix != 10 || alphabet) return toBaseString(this, radix, alphabet);
        return String(this.value);
    };

    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;

    NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () { return this.toString(); }

    BigInteger.prototype.valueOf = function () {
        return parseInt(this.toString(), 10);
    };
    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;

    SmallInteger.prototype.valueOf = function () {
        return this.value;
    };
    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function () {
        return parseInt(this.toString(), 10);
    }

    function parseStringValue(v) {
        if (isPrecise(+v)) {
            var x = +v;
            if (x === truncate(x))
                return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);
            throw new Error("Invalid integer: " + v);
        }
        var sign = v[0] === "-";
        if (sign) v = v.slice(1);
        var split = v.split(/e/i);
        if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));
        if (split.length === 2) {
            var exp = split[1];
            if (exp[0] === "+") exp = exp.slice(1);
            exp = +exp;
            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
            var text = split[0];
            var decimalPlace = text.indexOf(".");
            if (decimalPlace >= 0) {
                exp -= text.length - decimalPlace - 1;
                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
            }
            if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
            text += (new Array(exp + 1)).join("0");
            v = text;
        }
        var isValid = /^([0-9][0-9]*)$/.test(v);
        if (!isValid) throw new Error("Invalid integer: " + v);
        if (supportsNativeBigInt) {
            return new NativeBigInt(BigInt(sign ? "-" + v : v));
        }
        var r = [], max = v.length, l = LOG_BASE, min = max - l;
        while (max > 0) {
            r.push(+v.slice(min, max));
            min -= l;
            if (min < 0) min = 0;
            max -= l;
        }
        trim(r);
        return new BigInteger(r, sign);
    }

    function parseNumberValue(v) {
        if (supportsNativeBigInt) {
            return new NativeBigInt(BigInt(v));
        }
        if (isPrecise(v)) {
            if (v !== truncate(v)) throw new Error(v + " is not an integer.");
            return new SmallInteger(v);
        }
        return parseStringValue(v.toString());
    }

    function parseValue(v) {
        if (typeof v === "number") {
            return parseNumberValue(v);
        }
        if (typeof v === "string") {
            return parseStringValue(v);
        }
        if (typeof v === "bigint") {
            return new NativeBigInt(v);
        }
        return v;
    }
    // Pre-define numbers in range [-999,999]
    for (var i = 0; i < 1000; i++) {
        Integer[i] = parseValue(i);
        if (i > 0) Integer[-i] = parseValue(-i);
    }
    // Backwards compatibility
    Integer.one = Integer[1];
    Integer.zero = Integer[0];
    Integer.minusOne = Integer[-1];
    Integer.max = max;
    Integer.min = min;
    Integer.gcd = gcd;
    Integer.lcm = lcm;
    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt; };
    Integer.randBetween = randBetween;

    Integer.fromArray = function (digits, base, isNegative) {
        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
    };

    return Integer;
})();

// Node.js check
if ( true && module.hasOwnProperty("exports")) {
    module.exports = bigInt;
}

//amd check
if (typeof define === "function" && define.amd) {
    define( function () {
        return bigInt;
    });
}


/***/ }),

/***/ 3783:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const crypto = __nccwpck_require__(4155);
const bs58check = __nccwpck_require__(1768);
const ecc = __nccwpck_require__(5303);
const typeforce = __nccwpck_require__(8158);
const wif = __nccwpck_require__(8445);
const UINT256_TYPE = typeforce.BufferN(32);
const NETWORK_TYPE = typeforce.compile({
    wif: typeforce.UInt8,
    bip32: {
        public: typeforce.UInt32,
        private: typeforce.UInt32,
    },
});
const BITCOIN = {
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'bc',
    bip32: {
        public: 0x0488b21e,
        private: 0x0488ade4,
    },
    pubKeyHash: 0x00,
    scriptHash: 0x05,
    wif: 0x80,
};
const HIGHEST_BIT = 0x80000000;
const UINT31_MAX = Math.pow(2, 31) - 1;
function BIP32Path(value) {
    return (typeforce.String(value) && value.match(/^(m\/)?(\d+'?\/)*\d+'?$/) !== null);
}
function UInt31(value) {
    return typeforce.UInt32(value) && value <= UINT31_MAX;
}
class BIP32 {
    constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0x00000000) {
        this.__D = __D;
        this.__Q = __Q;
        this.chainCode = chainCode;
        this.network = network;
        this.__DEPTH = __DEPTH;
        this.__INDEX = __INDEX;
        this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;
        typeforce(NETWORK_TYPE, network);
        this.lowR = false;
    }
    get depth() {
        return this.__DEPTH;
    }
    get index() {
        return this.__INDEX;
    }
    get parentFingerprint() {
        return this.__PARENT_FINGERPRINT;
    }
    get publicKey() {
        if (this.__Q === undefined)
            this.__Q = ecc.pointFromScalar(this.__D, true);
        return this.__Q;
    }
    get privateKey() {
        return this.__D;
    }
    get identifier() {
        return crypto.hash160(this.publicKey);
    }
    get fingerprint() {
        return this.identifier.slice(0, 4);
    }
    get compressed() {
        return true;
    }
    // Private === not neutered
    // Public === neutered
    isNeutered() {
        return this.__D === undefined;
    }
    neutered() {
        return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
    }
    toBase58() {
        const network = this.network;
        const version = !this.isNeutered()
            ? network.bip32.private
            : network.bip32.public;
        const buffer = Buffer.allocUnsafe(78);
        // 4 bytes: version bytes
        buffer.writeUInt32BE(version, 0);
        // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....
        buffer.writeUInt8(this.depth, 4);
        // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
        buffer.writeUInt32BE(this.parentFingerprint, 5);
        // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
        // This is encoded in big endian. (0x00000000 if master key)
        buffer.writeUInt32BE(this.index, 9);
        // 32 bytes: the chain code
        this.chainCode.copy(buffer, 13);
        // 33 bytes: the public key or private key data
        if (!this.isNeutered()) {
            // 0x00 + k for private keys
            buffer.writeUInt8(0, 45);
            this.privateKey.copy(buffer, 46);
            // 33 bytes: the public key
        }
        else {
            // X9.62 encoding for public keys
            this.publicKey.copy(buffer, 45);
        }
        return bs58check.encode(buffer);
    }
    toWIF() {
        if (!this.privateKey)
            throw new TypeError('Missing private key');
        return wif.encode(this.network.wif, this.privateKey, true);
    }
    // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
    derive(index) {
        typeforce(typeforce.UInt32, index);
        const isHardened = index >= HIGHEST_BIT;
        const data = Buffer.allocUnsafe(37);
        // Hardened child
        if (isHardened) {
            if (this.isNeutered())
                throw new TypeError('Missing private key for hardened child key');
            // data = 0x00 || ser256(kpar) || ser32(index)
            data[0] = 0x00;
            this.privateKey.copy(data, 1);
            data.writeUInt32BE(index, 33);
            // Normal child
        }
        else {
            // data = serP(point(kpar)) || ser32(index)
            //      = serP(Kpar) || ser32(index)
            this.publicKey.copy(data, 0);
            data.writeUInt32BE(index, 33);
        }
        const I = crypto.hmacSHA512(this.chainCode, data);
        const IL = I.slice(0, 32);
        const IR = I.slice(32);
        // if parse256(IL) >= n, proceed with the next value for i
        if (!ecc.isPrivate(IL))
            return this.derive(index + 1);
        // Private parent key -> private child key
        let hd;
        if (!this.isNeutered()) {
            // ki = parse256(IL) + kpar (mod n)
            const ki = ecc.privateAdd(this.privateKey, IL);
            // In case ki == 0, proceed with the next value for i
            if (ki == null)
                return this.derive(index + 1);
            hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));
            // Public parent key -> public child key
        }
        else {
            // Ki = point(parse256(IL)) + Kpar
            //    = G*IL + Kpar
            const Ki = ecc.pointAddScalar(this.publicKey, IL, true);
            // In case Ki is the point at infinity, proceed with the next value for i
            if (Ki === null)
                return this.derive(index + 1);
            hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));
        }
        return hd;
    }
    deriveHardened(index) {
        typeforce(UInt31, index);
        // Only derives hardened private keys by default
        return this.derive(index + HIGHEST_BIT);
    }
    derivePath(path) {
        typeforce(BIP32Path, path);
        let splitPath = path.split('/');
        if (splitPath[0] === 'm') {
            if (this.parentFingerprint)
                throw new TypeError('Expected master, got child');
            splitPath = splitPath.slice(1);
        }
        return splitPath.reduce((prevHd, indexStr) => {
            let index;
            if (indexStr.slice(-1) === `'`) {
                index = parseInt(indexStr.slice(0, -1), 10);
                return prevHd.deriveHardened(index);
            }
            else {
                index = parseInt(indexStr, 10);
                return prevHd.derive(index);
            }
        }, this);
    }
    sign(hash, lowR) {
        if (!this.privateKey)
            throw new Error('Missing private key');
        if (lowR === undefined)
            lowR = this.lowR;
        if (lowR === false) {
            return ecc.sign(hash, this.privateKey);
        }
        else {
            let sig = ecc.sign(hash, this.privateKey);
            const extraData = Buffer.alloc(32, 0);
            let counter = 0;
            // if first try is lowR, skip the loop
            // for second try and on, add extra entropy counting up
            while (sig[0] > 0x7f) {
                counter++;
                extraData.writeUIntLE(counter, 0, 6);
                sig = ecc.signWithEntropy(hash, this.privateKey, extraData);
            }
            return sig;
        }
    }
    verify(hash, signature) {
        return ecc.verify(hash, this.publicKey, signature);
    }
}
function fromBase58(inString, network) {
    const buffer = bs58check.decode(inString);
    if (buffer.length !== 78)
        throw new TypeError('Invalid buffer length');
    network = network || BITCOIN;
    // 4 bytes: version bytes
    const version = buffer.readUInt32BE(0);
    if (version !== network.bip32.private && version !== network.bip32.public)
        throw new TypeError('Invalid network version');
    // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...
    const depth = buffer[4];
    // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
    const parentFingerprint = buffer.readUInt32BE(5);
    if (depth === 0) {
        if (parentFingerprint !== 0x00000000)
            throw new TypeError('Invalid parent fingerprint');
    }
    // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
    // This is encoded in MSB order. (0x00000000 if master key)
    const index = buffer.readUInt32BE(9);
    if (depth === 0 && index !== 0)
        throw new TypeError('Invalid index');
    // 32 bytes: the chain code
    const chainCode = buffer.slice(13, 45);
    let hd;
    // 33 bytes: private key data (0x00 + k)
    if (version === network.bip32.private) {
        if (buffer.readUInt8(45) !== 0x00)
            throw new TypeError('Invalid private key');
        const k = buffer.slice(46, 78);
        hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);
        // 33 bytes: public key data (0x02 + X or 0x03 + X)
    }
    else {
        const X = buffer.slice(45, 78);
        hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);
    }
    return hd;
}
exports.fromBase58 = fromBase58;
function fromPrivateKey(privateKey, chainCode, network) {
    return fromPrivateKeyLocal(privateKey, chainCode, network);
}
exports.fromPrivateKey = fromPrivateKey;
function fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {
    typeforce({
        privateKey: UINT256_TYPE,
        chainCode: UINT256_TYPE,
    }, { privateKey, chainCode });
    network = network || BITCOIN;
    if (!ecc.isPrivate(privateKey))
        throw new TypeError('Private key not in range [1, n)');
    return new BIP32(privateKey, undefined, chainCode, network, depth, index, parentFingerprint);
}
function fromPublicKey(publicKey, chainCode, network) {
    return fromPublicKeyLocal(publicKey, chainCode, network);
}
exports.fromPublicKey = fromPublicKey;
function fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {
    typeforce({
        publicKey: typeforce.BufferN(33),
        chainCode: UINT256_TYPE,
    }, { publicKey, chainCode });
    network = network || BITCOIN;
    // verify the X coordinate is a point on the curve
    if (!ecc.isPoint(publicKey))
        throw new TypeError('Point is not on the curve');
    return new BIP32(undefined, publicKey, chainCode, network, depth, index, parentFingerprint);
}
function fromSeed(seed, network) {
    typeforce(typeforce.Buffer, seed);
    if (seed.length < 16)
        throw new TypeError('Seed should be at least 128 bits');
    if (seed.length > 64)
        throw new TypeError('Seed should be at most 512 bits');
    network = network || BITCOIN;
    const I = crypto.hmacSHA512(Buffer.from('Bitcoin seed', 'utf8'), seed);
    const IL = I.slice(0, 32);
    const IR = I.slice(32);
    return fromPrivateKey(IL, IR, network);
}
exports.fromSeed = fromSeed;


/***/ }),

/***/ 4155:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const createHash = __nccwpck_require__(3614);
const createHmac = __nccwpck_require__(9922);
function hash160(buffer) {
    const sha256Hash = createHash('sha256')
        .update(buffer)
        .digest();
    try {
        return createHash('rmd160')
            .update(sha256Hash)
            .digest();
    }
    catch (err) {
        return createHash('ripemd160')
            .update(sha256Hash)
            .digest();
    }
}
exports.hash160 = hash160;
function hmacSHA512(key, data) {
    return createHmac('sha512', key)
        .update(data)
        .digest();
}
exports.hmacSHA512 = hmacSHA512;


/***/ }),

/***/ 821:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var bip32_1 = __nccwpck_require__(3783);
exports.fromSeed = bip32_1.fromSeed;
exports.fromBase58 = bip32_1.fromBase58;
exports.fromPublicKey = bip32_1.fromPublicKey;
exports.fromPrivateKey = bip32_1.fromPrivateKey;


/***/ }),

/***/ 8112:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// browserify by default only pulls in files that are hard coded in requires
// In order of last to first in this file, the default wordlist will be chosen
// based on what is present. (Bundles may remove wordlists they don't need)
const wordlists = {};
exports.wordlists = wordlists;
let _default;
exports._default = _default;
try {
    exports._default = _default = __nccwpck_require__(32);
    wordlists.czech = _default;
}
catch (err) { }
try {
    exports._default = _default = __nccwpck_require__(6996);
    wordlists.chinese_simplified = _default;
}
catch (err) { }
try {
    exports._default = _default = __nccwpck_require__(4262);
    wordlists.chinese_traditional = _default;
}
catch (err) { }
try {
    exports._default = _default = __nccwpck_require__(8013);
    wordlists.korean = _default;
}
catch (err) { }
try {
    exports._default = _default = __nccwpck_require__(1848);
    wordlists.french = _default;
}
catch (err) { }
try {
    exports._default = _default = __nccwpck_require__(2841);
    wordlists.italian = _default;
}
catch (err) { }
try {
    exports._default = _default = __nccwpck_require__(659);
    wordlists.spanish = _default;
}
catch (err) { }
try {
    exports._default = _default = __nccwpck_require__(4472);
    wordlists.japanese = _default;
    wordlists.JA = _default;
}
catch (err) { }
try {
    exports._default = _default = __nccwpck_require__(1945);
    wordlists.portuguese = _default;
}
catch (err) { }
try {
    exports._default = _default = __nccwpck_require__(4573);
    wordlists.english = _default;
    wordlists.EN = _default;
}
catch (err) { }


/***/ }),

/***/ 781:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const sha256_1 = __nccwpck_require__(1186);
const sha512_1 = __nccwpck_require__(3054);
const pbkdf2_1 = __nccwpck_require__(3945);
const utils_1 = __nccwpck_require__(4984);
const _wordlists_1 = __nccwpck_require__(8112);
let DEFAULT_WORDLIST = _wordlists_1._default;
const INVALID_MNEMONIC = 'Invalid mnemonic';
const INVALID_ENTROPY = 'Invalid entropy';
const INVALID_CHECKSUM = 'Invalid mnemonic checksum';
const WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\n' +
    'Please pass a 2048 word array explicitly.';
function normalize(str) {
    return (str || '').normalize('NFKD');
}
function lpad(str, padString, length) {
    while (str.length < length) {
        str = padString + str;
    }
    return str;
}
function binaryToByte(bin) {
    return parseInt(bin, 2);
}
function bytesToBinary(bytes) {
    return bytes.map((x) => lpad(x.toString(2), '0', 8)).join('');
}
function deriveChecksumBits(entropyBuffer) {
    const ENT = entropyBuffer.length * 8;
    const CS = ENT / 32;
    const hash = sha256_1.sha256(Uint8Array.from(entropyBuffer));
    return bytesToBinary(Array.from(hash)).slice(0, CS);
}
function salt(password) {
    return 'mnemonic' + (password || '');
}
function mnemonicToSeedSync(mnemonic, password) {
    const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), 'utf8'));
    const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), 'utf8'));
    const res = pbkdf2_1.pbkdf2(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
        c: 2048,
        dkLen: 64,
    });
    return Buffer.from(res);
}
exports.mnemonicToSeedSync = mnemonicToSeedSync;
function mnemonicToSeed(mnemonic, password) {
    const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), 'utf8'));
    const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), 'utf8'));
    return pbkdf2_1.pbkdf2Async(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
        c: 2048,
        dkLen: 64,
    }).then((res) => Buffer.from(res));
}
exports.mnemonicToSeed = mnemonicToSeed;
function mnemonicToEntropy(mnemonic, wordlist) {
    wordlist = wordlist || DEFAULT_WORDLIST;
    if (!wordlist) {
        throw new Error(WORDLIST_REQUIRED);
    }
    const words = normalize(mnemonic).split(' ');
    if (words.length % 3 !== 0) {
        throw new Error(INVALID_MNEMONIC);
    }
    // convert word indices to 11 bit binary strings
    const bits = words
        .map((word) => {
        const index = wordlist.indexOf(word);
        if (index === -1) {
            throw new Error(INVALID_MNEMONIC);
        }
        return lpad(index.toString(2), '0', 11);
    })
        .join('');
    // split the binary string into ENT/CS
    const dividerIndex = Math.floor(bits.length / 33) * 32;
    const entropyBits = bits.slice(0, dividerIndex);
    const checksumBits = bits.slice(dividerIndex);
    // calculate the checksum and compare
    const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
    if (entropyBytes.length < 16) {
        throw new Error(INVALID_ENTROPY);
    }
    if (entropyBytes.length > 32) {
        throw new Error(INVALID_ENTROPY);
    }
    if (entropyBytes.length % 4 !== 0) {
        throw new Error(INVALID_ENTROPY);
    }
    const entropy = Buffer.from(entropyBytes);
    const newChecksum = deriveChecksumBits(entropy);
    if (newChecksum !== checksumBits) {
        throw new Error(INVALID_CHECKSUM);
    }
    return entropy.toString('hex');
}
exports.mnemonicToEntropy = mnemonicToEntropy;
function entropyToMnemonic(entropy, wordlist) {
    if (!Buffer.isBuffer(entropy)) {
        entropy = Buffer.from(entropy, 'hex');
    }
    wordlist = wordlist || DEFAULT_WORDLIST;
    if (!wordlist) {
        throw new Error(WORDLIST_REQUIRED);
    }
    // 128 <= ENT <= 256
    if (entropy.length < 16) {
        throw new TypeError(INVALID_ENTROPY);
    }
    if (entropy.length > 32) {
        throw new TypeError(INVALID_ENTROPY);
    }
    if (entropy.length % 4 !== 0) {
        throw new TypeError(INVALID_ENTROPY);
    }
    const entropyBits = bytesToBinary(Array.from(entropy));
    const checksumBits = deriveChecksumBits(entropy);
    const bits = entropyBits + checksumBits;
    const chunks = bits.match(/(.{1,11})/g);
    const words = chunks.map((binary) => {
        const index = binaryToByte(binary);
        return wordlist[index];
    });
    return wordlist[0] === '\u3042\u3044\u3053\u304f\u3057\u3093' // Japanese wordlist
        ? words.join('\u3000')
        : words.join(' ');
}
exports.entropyToMnemonic = entropyToMnemonic;
function generateMnemonic(strength, rng, wordlist) {
    strength = strength || 128;
    if (strength % 32 !== 0) {
        throw new TypeError(INVALID_ENTROPY);
    }
    rng = rng || ((size) => Buffer.from(utils_1.randomBytes(size)));
    return entropyToMnemonic(rng(strength / 8), wordlist);
}
exports.generateMnemonic = generateMnemonic;
function validateMnemonic(mnemonic, wordlist) {
    try {
        mnemonicToEntropy(mnemonic, wordlist);
    }
    catch (e) {
        return false;
    }
    return true;
}
exports.validateMnemonic = validateMnemonic;
function setDefaultWordlist(language) {
    const result = _wordlists_1.wordlists[language];
    if (result) {
        DEFAULT_WORDLIST = result;
    }
    else {
        throw new Error('Could not find wordlist for language "' + language + '"');
    }
}
exports.setDefaultWordlist = setDefaultWordlist;
function getDefaultWordlist() {
    if (!DEFAULT_WORDLIST) {
        throw new Error('No Default Wordlist set');
    }
    return Object.keys(_wordlists_1.wordlists).filter((lang) => {
        if (lang === 'JA' || lang === 'EN') {
            return false;
        }
        return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);
    })[0];
}
exports.getDefaultWordlist = getDefaultWordlist;
var _wordlists_2 = __nccwpck_require__(8112);
exports.wordlists = _wordlists_2.wordlists;


/***/ }),

/***/ 3693:
/***/ (function(module, __unused_webpack_exports, __nccwpck_require__) {

/* module decorator */ module = __nccwpck_require__.nmd(module);
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = (__nccwpck_require__(4300).Buffer);
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})( false || module, this);


/***/ }),

/***/ 3803:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = __nccwpck_require__(6113);
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}


/***/ }),

/***/ 1983:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var basex = __nccwpck_require__(3358)
var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'

module.exports = basex(ALPHABET)


/***/ }),

/***/ 778:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var base58 = __nccwpck_require__(1983)
var Buffer = (__nccwpck_require__(6621).Buffer)

module.exports = function (checksumFn) {
  // Encode a buffer as a base58-check encoded string
  function encode (payload) {
    var checksum = checksumFn(payload)

    return base58.encode(Buffer.concat([
      payload,
      checksum
    ], payload.length + 4))
  }

  function decodeRaw (buffer) {
    var payload = buffer.slice(0, -4)
    var checksum = buffer.slice(-4)
    var newChecksum = checksumFn(payload)

    if (checksum[0] ^ newChecksum[0] |
        checksum[1] ^ newChecksum[1] |
        checksum[2] ^ newChecksum[2] |
        checksum[3] ^ newChecksum[3]) return

    return payload
  }

  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong
  function decodeUnsafe (string) {
    var buffer = base58.decodeUnsafe(string)
    if (!buffer) return

    return decodeRaw(buffer)
  }

  function decode (string) {
    var buffer = base58.decode(string)
    var payload = decodeRaw(buffer, checksumFn)
    if (!payload) throw new Error('Invalid checksum')
    return payload
  }

  return {
    encode: encode,
    decode: decode,
    decodeUnsafe: decodeUnsafe
  }
}


/***/ }),

/***/ 1768:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var createHash = __nccwpck_require__(3614)
var bs58checkBase = __nccwpck_require__(778)

// SHA256(SHA256(buffer))
function sha256x2 (buffer) {
  var tmp = createHash('sha256').update(buffer).digest()
  return createHash('sha256').update(tmp).digest()
}

module.exports = bs58checkBase(sha256x2)


/***/ }),

/***/ 3365:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



const base64 = __nccwpck_require__(3325)
const ieee754 = __nccwpck_require__(2458)
const customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

const K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1)
    const proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0
  let buf = createBuffer(length)

  const actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0
  const buf = createBuffer(length)
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0
    const buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length
  let y = b.length

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  const buffer = Buffer.allocUnsafe(length)
  let pos = 0
  for (i = 0; i < list.length; ++i) {
    let buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
        buf.copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length
  const mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  let loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  const i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  const length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  let str = ''
  const max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  let x = thisEnd - thisStart
  let y = end - start
  const len = Math.min(x, y)

  const thisCopy = this.slice(thisStart, thisEnd)
  const targetCopy = target.slice(start, end)

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1
  let arrLength = arr.length
  let valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i
  if (dir) {
    let foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      let found = true
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  const remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  const strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  let i
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  const res = []

  let i = start
  while (i < end) {
    const firstByte = buf[i]
    let codePoint = null
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = ''
  let i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  let out = ''
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end)
  let res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  const newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  let val = this[offset + --byteLength]
  let mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
})

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
})

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let i = byteLength
  let mul = 1
  let val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
})

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
})

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let mul = 1
  let i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let i = byteLength - 1
  let mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = 0
  let mul = 1
  let sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = byteLength - 1
  let mul = 1
  let sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  const len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  let i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    const len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {}
function E (sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor () {
      super()

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      })

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      })
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError)
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError)
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`
    let received = input
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    }
    msg += ` It must be ${range}. Received ${received}`
    return msg
  }, RangeError)

function addNumericalSeparator (val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset')
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1))
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : ''
    let range
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength)
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type)
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  let codePoint
  const length = string.length
  let leadSurrogate = null
  const bytes = []

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef'
  const table = new Array(256)
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}


/***/ }),

/***/ 2567:
/***/ ((module) => {

"use strict";


/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
const mask = (source, mask, output, offset, length) => {
  for (var i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
};

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
const unmask = (buffer, mask) => {
  // Required until https://github.com/nodejs/node/issues/9006 is resolved.
  const length = buffer.length;
  for (var i = 0; i < length; i++) {
    buffer[i] ^= mask[i & 3];
  }
};

module.exports = { mask, unmask };


/***/ }),

/***/ 264:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


try {
  module.exports = require(__nccwpck_require__.ab + "prebuilds/linux-x64/node.napi.node");
} catch (e) {
  module.exports = __nccwpck_require__(2567);
}


/***/ }),

/***/ 3614:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(6113).createHash


/***/ }),

/***/ 9922:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(6113).createHmac


/***/ }),

/***/ 3079:
/***/ ((module, exports, __nccwpck_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __nccwpck_require__(1289)(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ 1289:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __nccwpck_require__(5150);
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ 4085:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __nccwpck_require__(3079);
} else {
	module.exports = __nccwpck_require__(2723);
}


/***/ }),

/***/ 2723:
/***/ ((module, exports, __nccwpck_require__) => {

/**
 * Module dependencies.
 */

const tty = __nccwpck_require__(6224);
const util = __nccwpck_require__(3837);

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	() => {},
	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
);

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __nccwpck_require__(8400);

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __nccwpck_require__(1289)(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.split('\n')
		.map(str => str.trim())
		.join(' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),

/***/ 7569:
/***/ (function(module) {

;(function (globalScope) {
  'use strict';


  /*!
   *  decimal.js v10.4.3
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   */


  // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //


    // The maximum exponent magnitude.
    // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.
  var EXP_LIMIT = 9e15,                      // 0 to 9e15

    // The limit on the value of `precision`, and on the value of the first argument to
    // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.
    MAX_DIGITS = 1e9,                        // 0 to 1e9

    // Base conversion alphabet.
    NUMERALS = '0123456789abcdef',

    // The natural logarithm of 10 (1025 digits).
    LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',

    // Pi (1025 digits).
    PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',


    // The initial configuration properties of the Decimal constructor.
    DEFAULTS = {

      // These values must be integers within the stated ranges (inclusive).
      // Most of these values can be changed at run-time using the `Decimal.config` method.

      // The maximum number of significant digits of the result of a calculation or base conversion.
      // E.g. `Decimal.config({ precision: 20 });`
      precision: 20,                         // 1 to MAX_DIGITS

      // The rounding mode used when rounding to `precision`.
      //
      // ROUND_UP         0 Away from zero.
      // ROUND_DOWN       1 Towards zero.
      // ROUND_CEIL       2 Towards +Infinity.
      // ROUND_FLOOR      3 Towards -Infinity.
      // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      //
      // E.g.
      // `Decimal.rounding = 4;`
      // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
      rounding: 4,                           // 0 to 8

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP         0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
      // FLOOR      3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN  6 The IEEE 754 remainder function.
      // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
      //
      // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
      // division (9) are commonly used for the modulus operation. The other rounding modes can also
      // be used, but they may not give useful results.
      modulo: 1,                             // 0 to 9

      // The exponent value at and beneath which `toString` returns exponential notation.
      // JavaScript numbers: -7
      toExpNeg: -7,                          // 0 to -EXP_LIMIT

      // The exponent value at and above which `toString` returns exponential notation.
      // JavaScript numbers: 21
      toExpPos:  21,                         // 0 to EXP_LIMIT

      // The minimum exponent value, beneath which underflow to zero occurs.
      // JavaScript numbers: -324  (5e-324)
      minE: -EXP_LIMIT,                      // -1 to -EXP_LIMIT

      // The maximum exponent value, above which overflow to Infinity occurs.
      // JavaScript numbers: 308  (1.7976931348623157e+308)
      maxE: EXP_LIMIT,                       // 1 to EXP_LIMIT

      // Whether to use cryptographically-secure random number generation, if available.
      crypto: false                          // true/false
    },


  // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //


    Decimal, inexact, noConflict, quadrant,
    external = true,

    decimalError = '[DecimalError] ',
    invalidArgument = decimalError + 'Invalid argument: ',
    precisionLimitExceeded = decimalError + 'Precision limit exceeded',
    cryptoUnavailable = decimalError + 'crypto unavailable',
    tag = '[object Decimal]',

    mathfloor = Math.floor,
    mathpow = Math.pow,

    isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,
    isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,
    isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,
    isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,

    BASE = 1e7,
    LOG_BASE = 7,
    MAX_SAFE_INTEGER = 9007199254740991,

    LN10_PRECISION = LN10.length - 1,
    PI_PRECISION = PI.length - 1,

    // Decimal.prototype object
    P = { toStringTag: tag };


  // Decimal prototype methods


  /*
   *  absoluteValue             abs
   *  ceil
   *  clampedTo                 clamp
   *  comparedTo                cmp
   *  cosine                    cos
   *  cubeRoot                  cbrt
   *  decimalPlaces             dp
   *  dividedBy                 div
   *  dividedToIntegerBy        divToInt
   *  equals                    eq
   *  floor
   *  greaterThan               gt
   *  greaterThanOrEqualTo      gte
   *  hyperbolicCosine          cosh
   *  hyperbolicSine            sinh
   *  hyperbolicTangent         tanh
   *  inverseCosine             acos
   *  inverseHyperbolicCosine   acosh
   *  inverseHyperbolicSine     asinh
   *  inverseHyperbolicTangent  atanh
   *  inverseSine               asin
   *  inverseTangent            atan
   *  isFinite
   *  isInteger                 isInt
   *  isNaN
   *  isNegative                isNeg
   *  isPositive                isPos
   *  isZero
   *  lessThan                  lt
   *  lessThanOrEqualTo         lte
   *  logarithm                 log
   *  [maximum]                 [max]
   *  [minimum]                 [min]
   *  minus                     sub
   *  modulo                    mod
   *  naturalExponential        exp
   *  naturalLogarithm          ln
   *  negated                   neg
   *  plus                      add
   *  precision                 sd
   *  round
   *  sine                      sin
   *  squareRoot                sqrt
   *  tangent                   tan
   *  times                     mul
   *  toBinary
   *  toDecimalPlaces           toDP
   *  toExponential
   *  toFixed
   *  toFraction
   *  toHexadecimal             toHex
   *  toNearest
   *  toNumber
   *  toOctal
   *  toPower                   pow
   *  toPrecision
   *  toSignificantDigits       toSD
   *  toString
   *  truncated                 trunc
   *  valueOf                   toJSON
   */


  /*
   * Return a new Decimal whose value is the absolute value of this Decimal.
   *
   */
  P.absoluteValue = P.abs = function () {
    var x = new this.constructor(this);
    if (x.s < 0) x.s = 1;
    return finalise(x);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
   * direction of positive Infinity.
   *
   */
  P.ceil = function () {
    return finalise(new this.constructor(this), this.e + 1, 2);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal clamped to the range
   * delineated by `min` and `max`.
   *
   * min {number|string|Decimal}
   * max {number|string|Decimal}
   *
   */
  P.clampedTo = P.clamp = function (min, max) {
    var k,
      x = this,
      Ctor = x.constructor;
    min = new Ctor(min);
    max = new Ctor(max);
    if (!min.s || !max.s) return new Ctor(NaN);
    if (min.gt(max)) throw Error(invalidArgument + max);
    k = x.cmp(min);
    return k < 0 ? min : x.cmp(max) > 0 ? max : new Ctor(x);
  };


  /*
   * Return
   *   1    if the value of this Decimal is greater than the value of `y`,
   *  -1    if the value of this Decimal is less than the value of `y`,
   *   0    if they have the same value,
   *   NaN  if the value of either Decimal is NaN.
   *
   */
  P.comparedTo = P.cmp = function (y) {
    var i, j, xdL, ydL,
      x = this,
      xd = x.d,
      yd = (y = new x.constructor(y)).d,
      xs = x.s,
      ys = y.s;

    // Either NaN or ±Infinity?
    if (!xd || !yd) {
      return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
    }

    // Either zero?
    if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;

    // Signs differ?
    if (xs !== ys) return xs;

    // Compare exponents.
    if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;

    xdL = xd.length;
    ydL = yd.length;

    // Compare digit by digit.
    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
      if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
    }

    // Compare lengths.
    return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
  };


  /*
   * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-1, 1]
   *
   * cos(0)         = 1
   * cos(-0)        = 1
   * cos(Infinity)  = NaN
   * cos(-Infinity) = NaN
   * cos(NaN)       = NaN
   *
   */
  P.cosine = P.cos = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (!x.d) return new Ctor(NaN);

    // cos(0) = cos(-0) = 1
    if (!x.d[0]) return new Ctor(1);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
    Ctor.rounding = 1;

    x = cosine(Ctor, toLessThanHalfPi(Ctor, x));

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
  };


  /*
   *
   * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   *  cbrt(0)  =  0
   *  cbrt(-0) = -0
   *  cbrt(1)  =  1
   *  cbrt(-1) = -1
   *  cbrt(N)  =  N
   *  cbrt(-I) = -I
   *  cbrt(I)  =  I
   *
   * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))
   *
   */
  P.cubeRoot = P.cbrt = function () {
    var e, m, n, r, rep, s, sd, t, t3, t3plusx,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite() || x.isZero()) return new Ctor(x);
    external = false;

    // Initial estimate.
    s = x.s * mathpow(x.s * x, 1 / 3);

     // Math.cbrt underflow/overflow?
     // Pass x to Math.pow as integer, then adjust the exponent of the result.
    if (!s || Math.abs(s) == 1 / 0) {
      n = digitsToString(x.d);
      e = x.e;

      // Adjust n exponent so it is a multiple of 3 away from x exponent.
      if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');
      s = mathpow(n, 1 / 3);

      // Rarely, e may be one less than the result exponent value.
      e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));

      if (s == 1 / 0) {
        n = '5e' + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf('e') + 1) + e;
      }

      r = new Ctor(n);
      r.s = x.s;
    } else {
      r = new Ctor(s.toString());
    }

    sd = (e = Ctor.precision) + 3;

    // Halley's method.
    // TODO? Compare Newton's method.
    for (;;) {
      t = r;
      t3 = t.times(t).times(t);
      t3plusx = t3.plus(x);
      r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);

      // TODO? Replace with for-loop and checkRoundingDigits.
      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
        n = n.slice(sd - 3, sd + 1);

        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999
        // , i.e. approaching a rounding boundary, continue the iteration.
        if (n == '9999' || !rep && n == '4999') {

          // On the first iteration only, check to see if rounding up gives the exact result as the
          // nines may infinitely repeat.
          if (!rep) {
            finalise(t, e + 1, 0);

            if (t.times(t).times(t).eq(x)) {
              r = t;
              break;
            }
          }

          sd += 4;
          rep = 1;
        } else {

          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
          // If not, then there are further digits and m will be truthy.
          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

            // Truncate to the first rounding digit.
            finalise(r, e + 1, 1);
            m = !r.times(r).times(r).eq(x);
          }

          break;
        }
      }
    }

    external = true;

    return finalise(r, e, Ctor.rounding, m);
  };


  /*
   * Return the number of decimal places of the value of this Decimal.
   *
   */
  P.decimalPlaces = P.dp = function () {
    var w,
      d = this.d,
      n = NaN;

    if (d) {
      w = d.length - 1;
      n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last word.
      w = d[w];
      if (w) for (; w % 10 == 0; w /= 10) n--;
      if (n < 0) n = 0;
    }

    return n;
  };


  /*
   *  n / 0 = I
   *  n / N = N
   *  n / I = 0
   *  0 / n = 0
   *  0 / 0 = N
   *  0 / N = N
   *  0 / I = 0
   *  N / n = N
   *  N / 0 = N
   *  N / N = N
   *  N / I = N
   *  I / n = I
   *  I / 0 = I
   *  I / N = N
   *  I / I = N
   *
   * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   */
  P.dividedBy = P.div = function (y) {
    return divide(this, new this.constructor(y));
  };


  /*
   * Return a new Decimal whose value is the integer part of dividing the value of this Decimal
   * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.
   *
   */
  P.dividedToIntegerBy = P.divToInt = function (y) {
    var x = this,
      Ctor = x.constructor;
    return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
  };


  /*
   * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.
   *
   */
  P.equals = P.eq = function (y) {
    return this.cmp(y) === 0;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
   * direction of negative Infinity.
   *
   */
  P.floor = function () {
    return finalise(new this.constructor(this), this.e + 1, 3);
  };


  /*
   * Return true if the value of this Decimal is greater than the value of `y`, otherwise return
   * false.
   *
   */
  P.greaterThan = P.gt = function (y) {
    return this.cmp(y) > 0;
  };


  /*
   * Return true if the value of this Decimal is greater than or equal to the value of `y`,
   * otherwise return false.
   *
   */
  P.greaterThanOrEqualTo = P.gte = function (y) {
    var k = this.cmp(y);
    return k == 1 || k === 0;
  };


  /*
   * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [1, Infinity]
   *
   * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...
   *
   * cosh(0)         = 1
   * cosh(-0)        = 1
   * cosh(Infinity)  = Infinity
   * cosh(-Infinity) = Infinity
   * cosh(NaN)       = NaN
   *
   *  x        time taken (ms)   result
   * 1000      9                 9.8503555700852349694e+433
   * 10000     25                4.4034091128314607936e+4342
   * 100000    171               1.4033316802130615897e+43429
   * 1000000   3817              1.5166076984010437725e+434294
   * 10000000  abandoned after 2 minute wait
   *
   * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))
   *
   */
  P.hyperbolicCosine = P.cosh = function () {
    var k, n, pr, rm, len,
      x = this,
      Ctor = x.constructor,
      one = new Ctor(1);

    if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
    if (x.isZero()) return one;

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
    Ctor.rounding = 1;
    len = x.d.length;

    // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1
    // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))

    // Estimate the optimum number of times to use the argument reduction.
    // TODO? Estimation reused from cosine() and may not be optimal here.
    if (len < 32) {
      k = Math.ceil(len / 3);
      n = (1 / tinyPow(4, k)).toString();
    } else {
      k = 16;
      n = '2.3283064365386962890625e-10';
    }

    x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);

    // Reverse argument reduction
    var cosh2_x,
      i = k,
      d8 = new Ctor(8);
    for (; i--;) {
      cosh2_x = x.times(x);
      x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
    }

    return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
  };


  /*
   * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-Infinity, Infinity]
   *
   * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...
   *
   * sinh(0)         = 0
   * sinh(-0)        = -0
   * sinh(Infinity)  = Infinity
   * sinh(-Infinity) = -Infinity
   * sinh(NaN)       = NaN
   *
   * x        time taken (ms)
   * 10       2 ms
   * 100      5 ms
   * 1000     14 ms
   * 10000    82 ms
   * 100000   886 ms            1.4033316802130615897e+43429
   * 200000   2613 ms
   * 300000   5407 ms
   * 400000   8824 ms
   * 500000   13026 ms          8.7080643612718084129e+217146
   * 1000000  48543 ms
   *
   * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))
   *
   */
  P.hyperbolicSine = P.sinh = function () {
    var k, pr, rm, len,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite() || x.isZero()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
    Ctor.rounding = 1;
    len = x.d.length;

    if (len < 3) {
      x = taylorSeries(Ctor, 2, x, x, true);
    } else {

      // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))
      // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))
      // 3 multiplications and 1 addition

      // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))
      // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))
      // 4 multiplications and 2 additions

      // Estimate the optimum number of times to use the argument reduction.
      k = 1.4 * Math.sqrt(len);
      k = k > 16 ? 16 : k | 0;

      x = x.times(1 / tinyPow(5, k));
      x = taylorSeries(Ctor, 2, x, x, true);

      // Reverse argument reduction
      var sinh2_x,
        d5 = new Ctor(5),
        d16 = new Ctor(16),
        d20 = new Ctor(20);
      for (; k--;) {
        sinh2_x = x.times(x);
        x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
      }
    }

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return finalise(x, pr, rm, true);
  };


  /*
   * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-1, 1]
   *
   * tanh(x) = sinh(x) / cosh(x)
   *
   * tanh(0)         = 0
   * tanh(-0)        = -0
   * tanh(Infinity)  = 1
   * tanh(-Infinity) = -1
   * tanh(NaN)       = NaN
   *
   */
  P.hyperbolicTangent = P.tanh = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite()) return new Ctor(x.s);
    if (x.isZero()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 7;
    Ctor.rounding = 1;

    return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
  };


  /*
   * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of
   * this Decimal.
   *
   * Domain: [-1, 1]
   * Range: [0, pi]
   *
   * acos(x) = pi/2 - asin(x)
   *
   * acos(0)       = pi/2
   * acos(-0)      = pi/2
   * acos(1)       = 0
   * acos(-1)      = pi
   * acos(1/2)     = pi/3
   * acos(-1/2)    = 2*pi/3
   * acos(|x| > 1) = NaN
   * acos(NaN)     = NaN
   *
   */
  P.inverseCosine = P.acos = function () {
    var halfPi,
      x = this,
      Ctor = x.constructor,
      k = x.abs().cmp(1),
      pr = Ctor.precision,
      rm = Ctor.rounding;

    if (k !== -1) {
      return k === 0
        // |x| is 1
        ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)
        // |x| > 1 or x is NaN
        : new Ctor(NaN);
    }

    if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);

    // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3

    Ctor.precision = pr + 6;
    Ctor.rounding = 1;

    x = x.asin();
    halfPi = getPi(Ctor, pr + 4, rm).times(0.5);

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return halfPi.minus(x);
  };


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the
   * value of this Decimal.
   *
   * Domain: [1, Infinity]
   * Range: [0, Infinity]
   *
   * acosh(x) = ln(x + sqrt(x^2 - 1))
   *
   * acosh(x < 1)     = NaN
   * acosh(NaN)       = NaN
   * acosh(Infinity)  = Infinity
   * acosh(-Infinity) = NaN
   * acosh(0)         = NaN
   * acosh(-0)        = NaN
   * acosh(1)         = 0
   * acosh(-1)        = NaN
   *
   */
  P.inverseHyperbolicCosine = P.acosh = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
    if (!x.isFinite()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
    Ctor.rounding = 1;
    external = false;

    x = x.times(x).minus(1).sqrt().plus(x);

    external = true;
    Ctor.precision = pr;
    Ctor.rounding = rm;

    return x.ln();
  };


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value
   * of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-Infinity, Infinity]
   *
   * asinh(x) = ln(x + sqrt(x^2 + 1))
   *
   * asinh(NaN)       = NaN
   * asinh(Infinity)  = Infinity
   * asinh(-Infinity) = -Infinity
   * asinh(0)         = 0
   * asinh(-0)        = -0
   *
   */
  P.inverseHyperbolicSine = P.asinh = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite() || x.isZero()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
    Ctor.rounding = 1;
    external = false;

    x = x.times(x).plus(1).sqrt().plus(x);

    external = true;
    Ctor.precision = pr;
    Ctor.rounding = rm;

    return x.ln();
  };


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the
   * value of this Decimal.
   *
   * Domain: [-1, 1]
   * Range: [-Infinity, Infinity]
   *
   * atanh(x) = 0.5 * ln((1 + x) / (1 - x))
   *
   * atanh(|x| > 1)   = NaN
   * atanh(NaN)       = NaN
   * atanh(Infinity)  = NaN
   * atanh(-Infinity) = NaN
   * atanh(0)         = 0
   * atanh(-0)        = -0
   * atanh(1)         = Infinity
   * atanh(-1)        = -Infinity
   *
   */
  P.inverseHyperbolicTangent = P.atanh = function () {
    var pr, rm, wpr, xsd,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite()) return new Ctor(NaN);
    if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    xsd = x.sd();

    if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);

    Ctor.precision = wpr = xsd - x.e;

    x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);

    Ctor.precision = pr + 4;
    Ctor.rounding = 1;

    x = x.ln();

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return x.times(0.5);
  };


  /*
   * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-pi/2, pi/2]
   *
   * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))
   *
   * asin(0)       = 0
   * asin(-0)      = -0
   * asin(1/2)     = pi/6
   * asin(-1/2)    = -pi/6
   * asin(1)       = pi/2
   * asin(-1)      = -pi/2
   * asin(|x| > 1) = NaN
   * asin(NaN)     = NaN
   *
   * TODO? Compare performance of Taylor series.
   *
   */
  P.inverseSine = P.asin = function () {
    var halfPi, k,
      pr, rm,
      x = this,
      Ctor = x.constructor;

    if (x.isZero()) return new Ctor(x);

    k = x.abs().cmp(1);
    pr = Ctor.precision;
    rm = Ctor.rounding;

    if (k !== -1) {

      // |x| is 1
      if (k === 0) {
        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
        halfPi.s = x.s;
        return halfPi;
      }

      // |x| > 1 or x is NaN
      return new Ctor(NaN);
    }

    // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6

    Ctor.precision = pr + 6;
    Ctor.rounding = 1;

    x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return x.times(2);
  };


  /*
   * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value
   * of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-pi/2, pi/2]
   *
   * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
   *
   * atan(0)         = 0
   * atan(-0)        = -0
   * atan(1)         = pi/4
   * atan(-1)        = -pi/4
   * atan(Infinity)  = pi/2
   * atan(-Infinity) = -pi/2
   * atan(NaN)       = NaN
   *
   */
  P.inverseTangent = P.atan = function () {
    var i, j, k, n, px, t, r, wpr, x2,
      x = this,
      Ctor = x.constructor,
      pr = Ctor.precision,
      rm = Ctor.rounding;

    if (!x.isFinite()) {
      if (!x.s) return new Ctor(NaN);
      if (pr + 4 <= PI_PRECISION) {
        r = getPi(Ctor, pr + 4, rm).times(0.5);
        r.s = x.s;
        return r;
      }
    } else if (x.isZero()) {
      return new Ctor(x);
    } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.25);
      r.s = x.s;
      return r;
    }

    Ctor.precision = wpr = pr + 10;
    Ctor.rounding = 1;

    // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);

    // Argument reduction
    // Ensure |x| < 0.42
    // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))

    k = Math.min(28, wpr / LOG_BASE + 2 | 0);

    for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));

    external = false;

    j = Math.ceil(wpr / LOG_BASE);
    n = 1;
    x2 = x.times(x);
    r = new Ctor(x);
    px = x;

    // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
    for (; i !== -1;) {
      px = px.times(x2);
      t = r.minus(px.div(n += 2));

      px = px.times(x2);
      r = t.plus(px.div(n += 2));

      if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);
    }

    if (k) r = r.times(2 << (k - 1));

    external = true;

    return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
  };


  /*
   * Return true if the value of this Decimal is a finite number, otherwise return false.
   *
   */
  P.isFinite = function () {
    return !!this.d;
  };


  /*
   * Return true if the value of this Decimal is an integer, otherwise return false.
   *
   */
  P.isInteger = P.isInt = function () {
    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
  };


  /*
   * Return true if the value of this Decimal is NaN, otherwise return false.
   *
   */
  P.isNaN = function () {
    return !this.s;
  };


  /*
   * Return true if the value of this Decimal is negative, otherwise return false.
   *
   */
  P.isNegative = P.isNeg = function () {
    return this.s < 0;
  };


  /*
   * Return true if the value of this Decimal is positive, otherwise return false.
   *
   */
  P.isPositive = P.isPos = function () {
    return this.s > 0;
  };


  /*
   * Return true if the value of this Decimal is 0 or -0, otherwise return false.
   *
   */
  P.isZero = function () {
    return !!this.d && this.d[0] === 0;
  };


  /*
   * Return true if the value of this Decimal is less than `y`, otherwise return false.
   *
   */
  P.lessThan = P.lt = function (y) {
    return this.cmp(y) < 0;
  };


  /*
   * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.
   *
   */
  P.lessThanOrEqualTo = P.lte = function (y) {
    return this.cmp(y) < 1;
  };


  /*
   * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * If no base is specified, return log[10](arg).
   *
   * log[base](arg) = ln(arg) / ln(base)
   *
   * The result will always be correctly rounded if the base of the log is 10, and 'almost always'
   * otherwise:
   *
   * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen
   * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error
   * between the result and the correctly rounded result will be one ulp (unit in the last place).
   *
   * log[-b](a)       = NaN
   * log[0](a)        = NaN
   * log[1](a)        = NaN
   * log[NaN](a)      = NaN
   * log[Infinity](a) = NaN
   * log[b](0)        = -Infinity
   * log[b](-0)       = -Infinity
   * log[b](-a)       = NaN
   * log[b](1)        = 0
   * log[b](Infinity) = Infinity
   * log[b](NaN)      = NaN
   *
   * [base] {number|string|Decimal} The base of the logarithm.
   *
   */
  P.logarithm = P.log = function (base) {
    var isBase10, d, denominator, k, inf, num, sd, r,
      arg = this,
      Ctor = arg.constructor,
      pr = Ctor.precision,
      rm = Ctor.rounding,
      guard = 5;

    // Default base is 10.
    if (base == null) {
      base = new Ctor(10);
      isBase10 = true;
    } else {
      base = new Ctor(base);
      d = base.d;

      // Return NaN if base is negative, or non-finite, or is 0 or 1.
      if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);

      isBase10 = base.eq(10);
    }

    d = arg.d;

    // Is arg negative, non-finite, 0 or 1?
    if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
      return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
    }

    // The result will have a non-terminating decimal expansion if base is 10 and arg is not an
    // integer power of 10.
    if (isBase10) {
      if (d.length > 1) {
        inf = true;
      } else {
        for (k = d[0]; k % 10 === 0;) k /= 10;
        inf = k !== 1;
      }
    }

    external = false;
    sd = pr + guard;
    num = naturalLogarithm(arg, sd);
    denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);

    // The result will have 5 rounding digits.
    r = divide(num, denominator, sd, 1);

    // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,
    // calculate 10 further digits.
    //
    // If the result is known to have an infinite decimal expansion, repeat this until it is clear
    // that the result is above or below the boundary. Otherwise, if after calculating the 10
    // further digits, the last 14 are nines, round up and assume the result is exact.
    // Also assume the result is exact if the last 14 are zero.
    //
    // Example of a result that will be incorrectly rounded:
    // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...
    // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it
    // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so
    // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal
    // place is still 2.6.
    if (checkRoundingDigits(r.d, k = pr, rm)) {

      do {
        sd += 10;
        num = naturalLogarithm(arg, sd);
        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
        r = divide(num, denominator, sd, 1);

        if (!inf) {

          // Check for 14 nines from the 2nd rounding digit, as the first may be 4.
          if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
            r = finalise(r, pr + 1, 0);
          }

          break;
        }
      } while (checkRoundingDigits(r.d, k += 10, rm));
    }

    external = true;

    return finalise(r, pr, rm);
  };


  /*
   * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.
   *
   * arguments {number|string|Decimal}
   *
  P.max = function () {
    Array.prototype.push.call(arguments, this);
    return maxOrMin(this.constructor, arguments, 'lt');
  };
   */


  /*
   * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.
   *
   * arguments {number|string|Decimal}
   *
  P.min = function () {
    Array.prototype.push.call(arguments, this);
    return maxOrMin(this.constructor, arguments, 'gt');
  };
   */


  /*
   *  n - 0 = n
   *  n - N = N
   *  n - I = -I
   *  0 - n = -n
   *  0 - 0 = 0
   *  0 - N = N
   *  0 - I = -I
   *  N - n = N
   *  N - 0 = N
   *  N - N = N
   *  N - I = N
   *  I - n = I
   *  I - 0 = I
   *  I - N = N
   *  I - I = N
   *
   * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   */
  P.minus = P.sub = function (y) {
    var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,
      x = this,
      Ctor = x.constructor;

    y = new Ctor(y);

    // If either is not finite...
    if (!x.d || !y.d) {

      // Return NaN if either is NaN.
      if (!x.s || !y.s) y = new Ctor(NaN);

      // Return y negated if x is finite and y is ±Infinity.
      else if (x.d) y.s = -y.s;

      // Return x if y is finite and x is ±Infinity.
      // Return x if both are ±Infinity with different signs.
      // Return NaN if both are ±Infinity with the same sign.
      else y = new Ctor(y.d || x.s !== y.s ? x : NaN);

      return y;
    }

    // If signs differ...
    if (x.s != y.s) {
      y.s = -y.s;
      return x.plus(y);
    }

    xd = x.d;
    yd = y.d;
    pr = Ctor.precision;
    rm = Ctor.rounding;

    // If either is zero...
    if (!xd[0] || !yd[0]) {

      // Return y negated if x is zero and y is non-zero.
      if (yd[0]) y.s = -y.s;

      // Return x if y is zero and x is non-zero.
      else if (xd[0]) y = new Ctor(x);

      // Return zero if both are zero.
      // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.
      else return new Ctor(rm === 3 ? -0 : 0);

      return external ? finalise(y, pr, rm) : y;
    }

    // x and y are finite, non-zero numbers with the same sign.

    // Calculate base 1e7 exponents.
    e = mathfloor(y.e / LOG_BASE);
    xe = mathfloor(x.e / LOG_BASE);

    xd = xd.slice();
    k = xe - e;

    // If base 1e7 exponents differ...
    if (k) {
      xLTy = k < 0;

      if (xLTy) {
        d = xd;
        k = -k;
        len = yd.length;
      } else {
        d = yd;
        e = xe;
        len = xd.length;
      }

      // Numbers with massively different exponents would result in a very high number of
      // zeros needing to be prepended, but this can be avoided while still ensuring correct
      // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.
      i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;

      if (k > i) {
        k = i;
        d.length = 1;
      }

      // Prepend zeros to equalise exponents.
      d.reverse();
      for (i = k; i--;) d.push(0);
      d.reverse();

    // Base 1e7 exponents equal.
    } else {

      // Check digits to determine which is the bigger number.

      i = xd.length;
      len = yd.length;
      xLTy = i < len;
      if (xLTy) len = i;

      for (i = 0; i < len; i++) {
        if (xd[i] != yd[i]) {
          xLTy = xd[i] < yd[i];
          break;
        }
      }

      k = 0;
    }

    if (xLTy) {
      d = xd;
      xd = yd;
      yd = d;
      y.s = -y.s;
    }

    len = xd.length;

    // Append zeros to `xd` if shorter.
    // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.
    for (i = yd.length - len; i > 0; --i) xd[len++] = 0;

    // Subtract yd from xd.
    for (i = yd.length; i > k;) {

      if (xd[--i] < yd[i]) {
        for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;
        --xd[j];
        xd[i] += BASE;
      }

      xd[i] -= yd[i];
    }

    // Remove trailing zeros.
    for (; xd[--len] === 0;) xd.pop();

    // Remove leading zeros and adjust exponent accordingly.
    for (; xd[0] === 0; xd.shift()) --e;

    // Zero?
    if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);

    y.d = xd;
    y.e = getBase10Exponent(xd, e);

    return external ? finalise(y, pr, rm) : y;
  };


  /*
   *   n % 0 =  N
   *   n % N =  N
   *   n % I =  n
   *   0 % n =  0
   *  -0 % n = -0
   *   0 % 0 =  N
   *   0 % N =  N
   *   0 % I =  0
   *   N % n =  N
   *   N % 0 =  N
   *   N % N =  N
   *   N % I =  N
   *   I % n =  N
   *   I % 0 =  N
   *   I % N =  N
   *   I % I =  N
   *
   * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * The result depends on the modulo mode.
   *
   */
  P.modulo = P.mod = function (y) {
    var q,
      x = this,
      Ctor = x.constructor;

    y = new Ctor(y);

    // Return NaN if x is ±Infinity or NaN, or y is NaN or ±0.
    if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);

    // Return x if y is ±Infinity or x is ±0.
    if (!y.d || x.d && !x.d[0]) {
      return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
    }

    // Prevent rounding of intermediate calculations.
    external = false;

    if (Ctor.modulo == 9) {

      // Euclidian division: q = sign(y) * floor(x / abs(y))
      // result = x - q * y    where  0 <= result < abs(y)
      q = divide(x, y.abs(), 0, 3, 1);
      q.s *= y.s;
    } else {
      q = divide(x, y, 0, Ctor.modulo, 1);
    }

    q = q.times(y);

    external = true;

    return x.minus(q);
  };


  /*
   * Return a new Decimal whose value is the natural exponential of the value of this Decimal,
   * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   */
  P.naturalExponential = P.exp = function () {
    return naturalExponential(this);
  };


  /*
   * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,
   * rounded to `precision` significant digits using rounding mode `rounding`.
   *
   */
  P.naturalLogarithm = P.ln = function () {
    return naturalLogarithm(this);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by
   * -1.
   *
   */
  P.negated = P.neg = function () {
    var x = new this.constructor(this);
    x.s = -x.s;
    return finalise(x);
  };


  /*
   *  n + 0 = n
   *  n + N = N
   *  n + I = I
   *  0 + n = n
   *  0 + 0 = 0
   *  0 + N = N
   *  0 + I = I
   *  N + n = N
   *  N + 0 = N
   *  N + N = N
   *  N + I = N
   *  I + n = I
   *  I + 0 = I
   *  I + N = N
   *  I + I = I
   *
   * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   */
  P.plus = P.add = function (y) {
    var carry, d, e, i, k, len, pr, rm, xd, yd,
      x = this,
      Ctor = x.constructor;

    y = new Ctor(y);

    // If either is not finite...
    if (!x.d || !y.d) {

      // Return NaN if either is NaN.
      if (!x.s || !y.s) y = new Ctor(NaN);

      // Return x if y is finite and x is ±Infinity.
      // Return x if both are ±Infinity with the same sign.
      // Return NaN if both are ±Infinity with different signs.
      // Return y if x is finite and y is ±Infinity.
      else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);

      return y;
    }

     // If signs differ...
    if (x.s != y.s) {
      y.s = -y.s;
      return x.minus(y);
    }

    xd = x.d;
    yd = y.d;
    pr = Ctor.precision;
    rm = Ctor.rounding;

    // If either is zero...
    if (!xd[0] || !yd[0]) {

      // Return x if y is zero.
      // Return y if y is non-zero.
      if (!yd[0]) y = new Ctor(x);

      return external ? finalise(y, pr, rm) : y;
    }

    // x and y are finite, non-zero numbers with the same sign.

    // Calculate base 1e7 exponents.
    k = mathfloor(x.e / LOG_BASE);
    e = mathfloor(y.e / LOG_BASE);

    xd = xd.slice();
    i = k - e;

    // If base 1e7 exponents differ...
    if (i) {

      if (i < 0) {
        d = xd;
        i = -i;
        len = yd.length;
      } else {
        d = yd;
        e = k;
        len = xd.length;
      }

      // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.
      k = Math.ceil(pr / LOG_BASE);
      len = k > len ? k + 1 : len + 1;

      if (i > len) {
        i = len;
        d.length = 1;
      }

      // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.
      d.reverse();
      for (; i--;) d.push(0);
      d.reverse();
    }

    len = xd.length;
    i = yd.length;

    // If yd is longer than xd, swap xd and yd so xd points to the longer array.
    if (len - i < 0) {
      i = len;
      d = yd;
      yd = xd;
      xd = d;
    }

    // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.
    for (carry = 0; i;) {
      carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
      xd[i] %= BASE;
    }

    if (carry) {
      xd.unshift(carry);
      ++e;
    }

    // Remove trailing zeros.
    // No need to check for zero, as +x + +y != 0 && -x + -y != 0
    for (len = xd.length; xd[--len] == 0;) xd.pop();

    y.d = xd;
    y.e = getBase10Exponent(xd, e);

    return external ? finalise(y, pr, rm) : y;
  };


  /*
   * Return the number of significant digits of the value of this Decimal.
   *
   * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
   *
   */
  P.precision = P.sd = function (z) {
    var k,
      x = this;

    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);

    if (x.d) {
      k = getPrecision(x.d);
      if (z && x.e + 1 > k) k = x.e + 1;
    } else {
      k = NaN;
    }

    return k;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using
   * rounding mode `rounding`.
   *
   */
  P.round = function () {
    var x = this,
      Ctor = x.constructor;

    return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
  };


  /*
   * Return a new Decimal whose value is the sine of the value in radians of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-1, 1]
   *
   * sin(x) = x - x^3/3! + x^5/5! - ...
   *
   * sin(0)         = 0
   * sin(-0)        = -0
   * sin(Infinity)  = NaN
   * sin(-Infinity) = NaN
   * sin(NaN)       = NaN
   *
   */
  P.sine = P.sin = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite()) return new Ctor(NaN);
    if (x.isZero()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
    Ctor.rounding = 1;

    x = sine(Ctor, toLessThanHalfPi(Ctor, x));

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
  };


  /*
   * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   *  sqrt(-n) =  N
   *  sqrt(N)  =  N
   *  sqrt(-I) =  N
   *  sqrt(I)  =  I
   *  sqrt(0)  =  0
   *  sqrt(-0) = -0
   *
   */
  P.squareRoot = P.sqrt = function () {
    var m, n, sd, r, rep, t,
      x = this,
      d = x.d,
      e = x.e,
      s = x.s,
      Ctor = x.constructor;

    // Negative/NaN/Infinity/zero?
    if (s !== 1 || !d || !d[0]) {
      return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
    }

    external = false;

    // Initial estimate.
    s = Math.sqrt(+x);

    // Math.sqrt underflow/overflow?
    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
    if (s == 0 || s == 1 / 0) {
      n = digitsToString(d);

      if ((n.length + e) % 2 == 0) n += '0';
      s = Math.sqrt(n);
      e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);

      if (s == 1 / 0) {
        n = '5e' + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf('e') + 1) + e;
      }

      r = new Ctor(n);
    } else {
      r = new Ctor(s.toString());
    }

    sd = (e = Ctor.precision) + 3;

    // Newton-Raphson iteration.
    for (;;) {
      t = r;
      r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);

      // TODO? Replace with for-loop and checkRoundingDigits.
      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
        n = n.slice(sd - 3, sd + 1);

        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
        // 4999, i.e. approaching a rounding boundary, continue the iteration.
        if (n == '9999' || !rep && n == '4999') {

          // On the first iteration only, check to see if rounding up gives the exact result as the
          // nines may infinitely repeat.
          if (!rep) {
            finalise(t, e + 1, 0);

            if (t.times(t).eq(x)) {
              r = t;
              break;
            }
          }

          sd += 4;
          rep = 1;
        } else {

          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
          // If not, then there are further digits and m will be truthy.
          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

            // Truncate to the first rounding digit.
            finalise(r, e + 1, 1);
            m = !r.times(r).eq(x);
          }

          break;
        }
      }
    }

    external = true;

    return finalise(r, e, Ctor.rounding, m);
  };


  /*
   * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-Infinity, Infinity]
   *
   * tan(0)         = 0
   * tan(-0)        = -0
   * tan(Infinity)  = NaN
   * tan(-Infinity) = NaN
   * tan(NaN)       = NaN
   *
   */
  P.tangent = P.tan = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite()) return new Ctor(NaN);
    if (x.isZero()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 10;
    Ctor.rounding = 1;

    x = x.sin();
    x.s = 1;
    x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
  };


  /*
   *  n * 0 = 0
   *  n * N = N
   *  n * I = I
   *  0 * n = 0
   *  0 * 0 = 0
   *  0 * N = N
   *  0 * I = N
   *  N * n = N
   *  N * 0 = N
   *  N * N = N
   *  N * I = N
   *  I * n = I
   *  I * 0 = N
   *  I * N = N
   *  I * I = I
   *
   * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   */
  P.times = P.mul = function (y) {
    var carry, e, i, k, r, rL, t, xdL, ydL,
      x = this,
      Ctor = x.constructor,
      xd = x.d,
      yd = (y = new Ctor(y)).d;

    y.s *= x.s;

     // If either is NaN, ±Infinity or ±0...
    if (!xd || !xd[0] || !yd || !yd[0]) {

      return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd

        // Return NaN if either is NaN.
        // Return NaN if x is ±0 and y is ±Infinity, or y is ±0 and x is ±Infinity.
        ? NaN

        // Return ±Infinity if either is ±Infinity.
        // Return ±0 if either is ±0.
        : !xd || !yd ? y.s / 0 : y.s * 0);
    }

    e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
    xdL = xd.length;
    ydL = yd.length;

    // Ensure xd points to the longer array.
    if (xdL < ydL) {
      r = xd;
      xd = yd;
      yd = r;
      rL = xdL;
      xdL = ydL;
      ydL = rL;
    }

    // Initialise the result array with zeros.
    r = [];
    rL = xdL + ydL;
    for (i = rL; i--;) r.push(0);

    // Multiply!
    for (i = ydL; --i >= 0;) {
      carry = 0;
      for (k = xdL + i; k > i;) {
        t = r[k] + yd[i] * xd[k - i - 1] + carry;
        r[k--] = t % BASE | 0;
        carry = t / BASE | 0;
      }

      r[k] = (r[k] + carry) % BASE | 0;
    }

    // Remove trailing zeros.
    for (; !r[--rL];) r.pop();

    if (carry) ++e;
    else r.shift();

    y.d = r;
    y.e = getBase10Exponent(r, e);

    return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
  };


  /*
   * Return a string representing the value of this Decimal in base 2, round to `sd` significant
   * digits using rounding mode `rm`.
   *
   * If the optional `sd` argument is present then return binary exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toBinary = function (sd, rm) {
    return toStringBinary(this, 2, sd, rm);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`
   * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.
   *
   * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toDecimalPlaces = P.toDP = function (dp, rm) {
    var x = this,
      Ctor = x.constructor;

    x = new Ctor(x);
    if (dp === void 0) return x;

    checkInt32(dp, 0, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);

    return finalise(x, dp + x.e + 1, rm);
  };


  /*
   * Return a string representing the value of this Decimal in exponential notation rounded to
   * `dp` fixed decimal places using rounding mode `rounding`.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toExponential = function (dp, rm) {
    var str,
      x = this,
      Ctor = x.constructor;

    if (dp === void 0) {
      str = finiteToString(x, true);
    } else {
      checkInt32(dp, 0, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);

      x = finalise(new Ctor(x), dp + 1, rm);
      str = finiteToString(x, true, dp + 1);
    }

    return x.isNeg() && !x.isZero() ? '-' + str : str;
  };


  /*
   * Return a string representing the value of this Decimal in normal (fixed-point) notation to
   * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is
   * omitted.
   *
   * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
   * (-0).toFixed(3) is '0.000'.
   * (-0.5).toFixed(0) is '-0'.
   *
   */
  P.toFixed = function (dp, rm) {
    var str, y,
      x = this,
      Ctor = x.constructor;

    if (dp === void 0) {
      str = finiteToString(x);
    } else {
      checkInt32(dp, 0, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);

      y = finalise(new Ctor(x), dp + x.e + 1, rm);
      str = finiteToString(y, false, dp + y.e + 1);
    }

    // To determine whether to add the minus sign look at the value before it was rounded,
    // i.e. look at `x` rather than `y`.
    return x.isNeg() && !x.isZero() ? '-' + str : str;
  };


  /*
   * Return an array representing the value of this Decimal as a simple fraction with an integer
   * numerator and an integer denominator.
   *
   * The denominator will be a positive non-zero value less than or equal to the specified maximum
   * denominator. If a maximum denominator is not specified, the denominator will be the lowest
   * value necessary to represent the number exactly.
   *
   * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.
   *
   */
  P.toFraction = function (maxD) {
    var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,
      x = this,
      xd = x.d,
      Ctor = x.constructor;

    if (!xd) return new Ctor(x);

    n1 = d0 = new Ctor(1);
    d1 = n0 = new Ctor(0);

    d = new Ctor(d1);
    e = d.e = getPrecision(xd) - x.e - 1;
    k = e % LOG_BASE;
    d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);

    if (maxD == null) {

      // d is 10**e, the minimum max-denominator needed.
      maxD = e > 0 ? d : n1;
    } else {
      n = new Ctor(maxD);
      if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
      maxD = n.gt(d) ? (e > 0 ? d : n1) : n;
    }

    external = false;
    n = new Ctor(digitsToString(xd));
    pr = Ctor.precision;
    Ctor.precision = e = xd.length * LOG_BASE * 2;

    for (;;)  {
      q = divide(n, d, 0, 1, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.cmp(maxD) == 1) break;
      d0 = d1;
      d1 = d2;
      d2 = n1;
      n1 = n0.plus(q.times(d2));
      n0 = d2;
      d2 = d;
      d = n.minus(q.times(d2));
      n = d2;
    }

    d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s;

    // Determine which fraction is closer to x, n0/d0 or n1/d1?
    r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1
        ? [n1, d1] : [n0, d0];

    Ctor.precision = pr;
    external = true;

    return r;
  };


  /*
   * Return a string representing the value of this Decimal in base 16, round to `sd` significant
   * digits using rounding mode `rm`.
   *
   * If the optional `sd` argument is present then return binary exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toHexadecimal = P.toHex = function (sd, rm) {
    return toStringBinary(this, 16, sd, rm);
  };


  /*
   * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding
   * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.
   *
   * The return value will always have the same sign as this Decimal, unless either this Decimal
   * or `y` is NaN, in which case the return value will be also be NaN.
   *
   * The return value is not affected by the value of `precision`.
   *
   * y {number|string|Decimal} The magnitude to round to a multiple of.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * 'toNearest() rounding mode not an integer: {rm}'
   * 'toNearest() rounding mode out of range: {rm}'
   *
   */
  P.toNearest = function (y, rm) {
    var x = this,
      Ctor = x.constructor;

    x = new Ctor(x);

    if (y == null) {

      // If x is not finite, return x.
      if (!x.d) return x;

      y = new Ctor(1);
      rm = Ctor.rounding;
    } else {
      y = new Ctor(y);
      if (rm === void 0) {
        rm = Ctor.rounding;
      } else {
        checkInt32(rm, 0, 8);
      }

      // If x is not finite, return x if y is not NaN, else NaN.
      if (!x.d) return y.s ? x : y;

      // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.
      if (!y.d) {
        if (y.s) y.s = x.s;
        return y;
      }
    }

    // If y is not zero, calculate the nearest multiple of y to x.
    if (y.d[0]) {
      external = false;
      x = divide(x, y, 0, rm, 1).times(y);
      external = true;
      finalise(x);

    // If y is zero, return zero with the sign of x.
    } else {
      y.s = x.s;
      x = y;
    }

    return x;
  };


  /*
   * Return the value of this Decimal converted to a number primitive.
   * Zero keeps its sign.
   *
   */
  P.toNumber = function () {
    return +this;
  };


  /*
   * Return a string representing the value of this Decimal in base 8, round to `sd` significant
   * digits using rounding mode `rm`.
   *
   * If the optional `sd` argument is present then return binary exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toOctal = function (sd, rm) {
    return toStringBinary(this, 8, sd, rm);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded
   * to `precision` significant digits using rounding mode `rounding`.
   *
   * ECMAScript compliant.
   *
   *   pow(x, NaN)                           = NaN
   *   pow(x, ±0)                            = 1

   *   pow(NaN, non-zero)                    = NaN
   *   pow(abs(x) > 1, +Infinity)            = +Infinity
   *   pow(abs(x) > 1, -Infinity)            = +0
   *   pow(abs(x) == 1, ±Infinity)           = NaN
   *   pow(abs(x) < 1, +Infinity)            = +0
   *   pow(abs(x) < 1, -Infinity)            = +Infinity
   *   pow(+Infinity, y > 0)                 = +Infinity
   *   pow(+Infinity, y < 0)                 = +0
   *   pow(-Infinity, odd integer > 0)       = -Infinity
   *   pow(-Infinity, even integer > 0)      = +Infinity
   *   pow(-Infinity, odd integer < 0)       = -0
   *   pow(-Infinity, even integer < 0)      = +0
   *   pow(+0, y > 0)                        = +0
   *   pow(+0, y < 0)                        = +Infinity
   *   pow(-0, odd integer > 0)              = -0
   *   pow(-0, even integer > 0)             = +0
   *   pow(-0, odd integer < 0)              = -Infinity
   *   pow(-0, even integer < 0)             = +Infinity
   *   pow(finite x < 0, finite non-integer) = NaN
   *
   * For non-integer or very large exponents pow(x, y) is calculated using
   *
   *   x^y = exp(y*ln(x))
   *
   * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the
   * probability of an incorrectly rounded result
   * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14
   * i.e. 1 in 250,000,000,000,000
   *
   * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).
   *
   * y {number|string|Decimal} The power to which to raise this Decimal.
   *
   */
  P.toPower = P.pow = function (y) {
    var e, k, pr, r, rm, s,
      x = this,
      Ctor = x.constructor,
      yn = +(y = new Ctor(y));

    // Either ±Infinity, NaN or ±0?
    if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));

    x = new Ctor(x);

    if (x.eq(1)) return x;

    pr = Ctor.precision;
    rm = Ctor.rounding;

    if (y.eq(1)) return finalise(x, pr, rm);

    // y exponent
    e = mathfloor(y.e / LOG_BASE);

    // If y is a small integer use the 'exponentiation by squaring' algorithm.
    if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
      r = intPow(Ctor, x, k, pr);
      return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
    }

    s = x.s;

    // if x is negative
    if (s < 0) {

      // if y is not an integer
      if (e < y.d.length - 1) return new Ctor(NaN);

      // Result is positive if x is negative and the last digit of integer y is even.
      if ((y.d[e] & 1) == 0) s = 1;

      // if x.eq(-1)
      if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
        x.s = s;
        return x;
      }
    }

    // Estimate result exponent.
    // x^y = 10^e,  where e = y * log10(x)
    // log10(x) = log10(x_significand) + x_exponent
    // log10(x_significand) = ln(x_significand) / ln(10)
    k = mathpow(+x, yn);
    e = k == 0 || !isFinite(k)
      ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))
      : new Ctor(k + '').e;

    // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.

    // Overflow/underflow?
    if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);

    external = false;
    Ctor.rounding = x.s = 1;

    // Estimate the extra guard digits needed to ensure five correct rounding digits from
    // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):
    // new Decimal(2.32456).pow('2087987436534566.46411')
    // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815
    k = Math.min(12, (e + '').length);

    // r = x^y = exp(y*ln(x))
    r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);

    // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)
    if (r.d) {

      // Truncate to the required precision plus five rounding digits.
      r = finalise(r, pr + 5, 1);

      // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate
      // the result.
      if (checkRoundingDigits(r.d, pr, rm)) {
        e = pr + 10;

        // Truncate to the increased precision plus five rounding digits.
        r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);

        // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).
        if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }
      }
    }

    r.s = s;
    external = true;
    Ctor.rounding = rm;

    return finalise(r, pr, rm);
  };


  /*
   * Return a string representing the value of this Decimal rounded to `sd` significant digits
   * using rounding mode `rounding`.
   *
   * Return exponential notation if `sd` is less than the number of digits necessary to represent
   * the integer part of the value in normal notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toPrecision = function (sd, rm) {
    var str,
      x = this,
      Ctor = x.constructor;

    if (sd === void 0) {
      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
    } else {
      checkInt32(sd, 1, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);

      x = finalise(new Ctor(x), sd, rm);
      str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
    }

    return x.isNeg() && !x.isZero() ? '-' + str : str;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`
   * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if
   * omitted.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * 'toSD() digits out of range: {sd}'
   * 'toSD() digits not an integer: {sd}'
   * 'toSD() rounding mode not an integer: {rm}'
   * 'toSD() rounding mode out of range: {rm}'
   *
   */
  P.toSignificantDigits = P.toSD = function (sd, rm) {
    var x = this,
      Ctor = x.constructor;

    if (sd === void 0) {
      sd = Ctor.precision;
      rm = Ctor.rounding;
    } else {
      checkInt32(sd, 1, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);
    }

    return finalise(new Ctor(x), sd, rm);
  };


  /*
   * Return a string representing the value of this Decimal.
   *
   * Return exponential notation if this Decimal has a positive exponent equal to or greater than
   * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.
   *
   */
  P.toString = function () {
    var x = this,
      Ctor = x.constructor,
      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);

    return x.isNeg() && !x.isZero() ? '-' + str : str;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.
   *
   */
  P.truncated = P.trunc = function () {
    return finalise(new this.constructor(this), this.e + 1, 1);
  };


  /*
   * Return a string representing the value of this Decimal.
   * Unlike `toString`, negative zero will include the minus sign.
   *
   */
  P.valueOf = P.toJSON = function () {
    var x = this,
      Ctor = x.constructor,
      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);

    return x.isNeg() ? '-' + str : str;
  };


  // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.


  /*
   *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,
   *                           finiteToString, naturalExponential, naturalLogarithm
   *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,
   *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random
   *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm
   *  convertBase              toStringBinary, parseOther
   *  cos                      P.cos
   *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,
   *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,
   *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,
   *                           taylorSeries, atan2, parseOther
   *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,
   *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,
   *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,
   *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,
   *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,
   *                           P.truncated, divide, getLn10, getPi, naturalExponential,
   *                           naturalLogarithm, ceil, floor, round, trunc
   *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,
   *                           toStringBinary
   *  getBase10Exponent        P.minus, P.plus, P.times, parseOther
   *  getLn10                  P.logarithm, naturalLogarithm
   *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2
   *  getPrecision             P.precision, P.toFraction
   *  getZeroString            digitsToString, finiteToString
   *  intPow                   P.toPower, parseOther
   *  isOdd                    toLessThanHalfPi
   *  maxOrMin                 max, min
   *  naturalExponential       P.naturalExponential, P.toPower
   *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,
   *                           P.toPower, naturalExponential
   *  nonFiniteToString        finiteToString, toStringBinary
   *  parseDecimal             Decimal
   *  parseOther               Decimal
   *  sin                      P.sin
   *  taylorSeries             P.cosh, P.sinh, cos, sin
   *  toLessThanHalfPi         P.cos, P.sin
   *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal
   *  truncate                 intPow
   *
   *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,
   *                           naturalLogarithm, config, parseOther, random, Decimal
   */


  function digitsToString(d) {
    var i, k, ws,
      indexOfLastWord = d.length - 1,
      str = '',
      w = d[0];

    if (indexOfLastWord > 0) {
      str += w;
      for (i = 1; i < indexOfLastWord; i++) {
        ws = d[i] + '';
        k = LOG_BASE - ws.length;
        if (k) str += getZeroString(k);
        str += ws;
      }

      w = d[i];
      ws = w + '';
      k = LOG_BASE - ws.length;
      if (k) str += getZeroString(k);
    } else if (w === 0) {
      return '0';
    }

    // Remove trailing zeros of last w.
    for (; w % 10 === 0;) w /= 10;

    return str + w;
  }


  function checkInt32(i, min, max) {
    if (i !== ~~i || i < min || i > max) {
      throw Error(invalidArgument + i);
    }
  }


  /*
   * Check 5 rounding digits if `repeating` is null, 4 otherwise.
   * `repeating == null` if caller is `log` or `pow`,
   * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.
   */
  function checkRoundingDigits(d, i, rm, repeating) {
    var di, k, r, rd;

    // Get the length of the first word of the array d.
    for (k = d[0]; k >= 10; k /= 10) --i;

    // Is the rounding digit in the first word of d?
    if (--i < 0) {
      i += LOG_BASE;
      di = 0;
    } else {
      di = Math.ceil((i + 1) / LOG_BASE);
      i %= LOG_BASE;
    }

    // i is the index (0 - 6) of the rounding digit.
    // E.g. if within the word 3487563 the first rounding digit is 5,
    // then i = 4, k = 1000, rd = 3487563 % 1000 = 563
    k = mathpow(10, LOG_BASE - i);
    rd = d[di] % k | 0;

    if (repeating == null) {
      if (i < 3) {
        if (i == 0) rd = rd / 100 | 0;
        else if (i == 1) rd = rd / 10 | 0;
        r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;
      } else {
        r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) &&
          (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 ||
            (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
      }
    } else {
      if (i < 4) {
        if (i == 0) rd = rd / 1000 | 0;
        else if (i == 1) rd = rd / 100 | 0;
        else if (i == 2) rd = rd / 10 | 0;
        r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
      } else {
        r = ((repeating || rm < 4) && rd + 1 == k ||
        (!repeating && rm > 3) && rd + 1 == k / 2) &&
          (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;
      }
    }

    return r;
  }


  // Convert string of `baseIn` to an array of numbers of `baseOut`.
  // Eg. convertBase('255', 10, 16) returns [15, 15].
  // Eg. convertBase('ff', 16, 10) returns [2, 5, 5].
  function convertBase(str, baseIn, baseOut) {
    var j,
      arr = [0],
      arrL,
      i = 0,
      strL = str.length;

    for (; i < strL;) {
      for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;
      arr[0] += NUMERALS.indexOf(str.charAt(i++));
      for (j = 0; j < arr.length; j++) {
        if (arr[j] > baseOut - 1) {
          if (arr[j + 1] === void 0) arr[j + 1] = 0;
          arr[j + 1] += arr[j] / baseOut | 0;
          arr[j] %= baseOut;
        }
      }
    }

    return arr.reverse();
  }


  /*
   * cos(x) = 1 - x^2/2! + x^4/4! - ...
   * |x| < pi/2
   *
   */
  function cosine(Ctor, x) {
    var k, len, y;

    if (x.isZero()) return x;

    // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1
    // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1

    // Estimate the optimum number of times to use the argument reduction.
    len = x.d.length;
    if (len < 32) {
      k = Math.ceil(len / 3);
      y = (1 / tinyPow(4, k)).toString();
    } else {
      k = 16;
      y = '2.3283064365386962890625e-10';
    }

    Ctor.precision += k;

    x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));

    // Reverse argument reduction
    for (var i = k; i--;) {
      var cos2x = x.times(x);
      x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
    }

    Ctor.precision -= k;

    return x;
  }


  /*
   * Perform division in the specified base.
   */
  var divide = (function () {

    // Assumes non-zero x and k, and hence non-zero result.
    function multiplyInteger(x, k, base) {
      var temp,
        carry = 0,
        i = x.length;

      for (x = x.slice(); i--;) {
        temp = x[i] * k + carry;
        x[i] = temp % base | 0;
        carry = temp / base | 0;
      }

      if (carry) x.unshift(carry);

      return x;
    }

    function compare(a, b, aL, bL) {
      var i, r;

      if (aL != bL) {
        r = aL > bL ? 1 : -1;
      } else {
        for (i = r = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            r = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }

      return r;
    }

    function subtract(a, b, aL, base) {
      var i = 0;

      // Subtract b from a.
      for (; aL--;) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      }

      // Remove leading zeros.
      for (; !a[0] && a.length > 1;) a.shift();
    }

    return function (x, y, pr, rm, dp, base) {
      var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0,
        yL, yz,
        Ctor = x.constructor,
        sign = x.s == y.s ? 1 : -1,
        xd = x.d,
        yd = y.d;

      // Either NaN, Infinity or 0?
      if (!xd || !xd[0] || !yd || !yd[0]) {

        return new Ctor(// Return NaN if either NaN, or both Infinity or 0.
          !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN :

          // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.
          xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);
      }

      if (base) {
        logBase = 1;
        e = x.e - y.e;
      } else {
        base = BASE;
        logBase = LOG_BASE;
        e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
      }

      yL = yd.length;
      xL = xd.length;
      q = new Ctor(sign);
      qd = q.d = [];

      // Result exponent may be one less than e.
      // The digit array of a Decimal from toStringBinary may have trailing zeros.
      for (i = 0; yd[i] == (xd[i] || 0); i++);

      if (yd[i] > (xd[i] || 0)) e--;

      if (pr == null) {
        sd = pr = Ctor.precision;
        rm = Ctor.rounding;
      } else if (dp) {
        sd = pr + (x.e - y.e) + 1;
      } else {
        sd = pr;
      }

      if (sd < 0) {
        qd.push(1);
        more = true;
      } else {

        // Convert precision in number of base 10 digits to base 1e7 digits.
        sd = sd / logBase + 2 | 0;
        i = 0;

        // divisor < 1e7
        if (yL == 1) {
          k = 0;
          yd = yd[0];
          sd++;

          // k is the carry.
          for (; (i < xL || k) && sd--; i++) {
            t = k * base + (xd[i] || 0);
            qd[i] = t / yd | 0;
            k = t % yd | 0;
          }

          more = k || i < xL;

        // divisor >= 1e7
        } else {

          // Normalise xd and yd so highest order digit of yd is >= base/2
          k = base / (yd[0] + 1) | 0;

          if (k > 1) {
            yd = multiplyInteger(yd, k, base);
            xd = multiplyInteger(xd, k, base);
            yL = yd.length;
            xL = xd.length;
          }

          xi = yL;
          rem = xd.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL;) rem[remL++] = 0;

          yz = yd.slice();
          yz.unshift(0);
          yd0 = yd[0];

          if (yd[1] >= base / 2) ++yd0;

          do {
            k = 0;

            // Compare divisor and remainder.
            cmp = compare(yd, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, k.
              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // k will be how many times the divisor goes into the current remainder.
              k = rem0 / yd0 | 0;

              //  Algorithm:
              //  1. product = divisor * trial digit (k)
              //  2. if product > remainder: product -= divisor, k--
              //  3. remainder -= product
              //  4. if product was < remainder at 2:
              //    5. compare new remainder and divisor
              //    6. If remainder > divisor: remainder -= divisor, k++

              if (k > 1) {
                if (k >= base) k = base - 1;

                // product = divisor * trial digit.
                prod = multiplyInteger(yd, k, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                cmp = compare(prod, rem, prodL, remL);

                // product > remainder.
                if (cmp == 1) {
                  k--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yd, prodL, base);
                }
              } else {

                // cmp is -1.
                // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1
                // to avoid it. If k is 1 there is a need to compare yd and rem again below.
                if (k == 0) cmp = k = 1;
                prod = yd.slice();
              }

              prodL = prod.length;
              if (prodL < remL) prod.unshift(0);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);

              // If product was < previous remainder.
              if (cmp == -1) {
                remL = rem.length;

                // Compare divisor and new remainder.
                cmp = compare(yd, rem, yL, remL);

                // If divisor < new remainder, subtract divisor from remainder.
                if (cmp < 1) {
                  k++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yd, remL, base);
                }
              }

              remL = rem.length;
            } else if (cmp === 0) {
              k++;
              rem = [0];
            }    // if cmp === 1, k will be 0

            // Add the next digit, k, to the result array.
            qd[i++] = k;

            // Update the remainder.
            if (cmp && rem[0]) {
              rem[remL++] = xd[xi] || 0;
            } else {
              rem = [xd[xi]];
              remL = 1;
            }

          } while ((xi++ < xL || rem[0] !== void 0) && sd--);

          more = rem[0] !== void 0;
        }

        // Leading zero?
        if (!qd[0]) qd.shift();
      }

      // logBase is 1 when divide is being used for base conversion.
      if (logBase == 1) {
        q.e = e;
        inexact = more;
      } else {

        // To calculate q.e, first get the number of digits of qd[0].
        for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;
        q.e = i + e * logBase - 1;

        finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
      }

      return q;
    };
  })();


  /*
   * Round `x` to `sd` significant digits using rounding mode `rm`.
   * Check for over/under-flow.
   */
   function finalise(x, sd, rm, isTruncated) {
    var digits, i, j, k, rd, roundUp, w, xd, xdi,
      Ctor = x.constructor;

    // Don't round if sd is null or undefined.
    out: if (sd != null) {
      xd = x.d;

      // Infinity/NaN.
      if (!xd) return x;

      // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.
      // w: the word of xd containing rd, a base 1e7 number.
      // xdi: the index of w within xd.
      // digits: the number of digits of w.
      // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if
      // they had leading zeros)
      // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).

      // Get the length of the first word of the digits array xd.
      for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;
      i = sd - digits;

      // Is the rounding digit in the first word of xd?
      if (i < 0) {
        i += LOG_BASE;
        j = sd;
        w = xd[xdi = 0];

        // Get the rounding digit at index j of w.
        rd = w / mathpow(10, digits - j - 1) % 10 | 0;
      } else {
        xdi = Math.ceil((i + 1) / LOG_BASE);
        k = xd.length;
        if (xdi >= k) {
          if (isTruncated) {

            // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.
            for (; k++ <= xdi;) xd.push(0);
            w = rd = 0;
            digits = 1;
            i %= LOG_BASE;
            j = i - LOG_BASE + 1;
          } else {
            break out;
          }
        } else {
          w = k = xd[xdi];

          // Get the number of digits of w.
          for (digits = 1; k >= 10; k /= 10) digits++;

          // Get the index of rd within w.
          i %= LOG_BASE;

          // Get the index of rd within w, adjusted for leading zeros.
          // The number of leading zeros of w is given by LOG_BASE - digits.
          j = i - LOG_BASE + digits;

          // Get the rounding digit at index j of w.
          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
        }
      }

      // Are there any non-zero digits after the rounding digit?
      isTruncated = isTruncated || sd < 0 ||
        xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));

      // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right
      // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression
      // will give 714.

      roundUp = rm < 4
        ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
        : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 &&

          // Check whether the digit to the left of the rounding digit is odd.
          ((i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10) & 1 ||
            rm == (x.s < 0 ? 8 : 7));

      if (sd < 1 || !xd[0]) {
        xd.length = 0;
        if (roundUp) {

          // Convert sd to decimal places.
          sd -= x.e + 1;

          // 1, 0.1, 0.01, 0.001, 0.0001 etc.
          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
          x.e = -sd || 0;
        } else {

          // Zero.
          xd[0] = x.e = 0;
        }

        return x;
      }

      // Remove excess digits.
      if (i == 0) {
        xd.length = xdi;
        k = 1;
        xdi--;
      } else {
        xd.length = xdi + 1;
        k = mathpow(10, LOG_BASE - i);

        // E.g. 56700 becomes 56000 if 7 is the rounding digit.
        // j > 0 means i > number of leading zeros of w.
        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
      }

      if (roundUp) {
        for (;;) {

          // Is the digit to be rounded up in the first word of xd?
          if (xdi == 0) {

            // i will be the length of xd[0] before k is added.
            for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;
            j = xd[0] += k;
            for (k = 1; j >= 10; j /= 10) k++;

            // if i != k the length has increased.
            if (i != k) {
              x.e++;
              if (xd[0] == BASE) xd[0] = 1;
            }

            break;
          } else {
            xd[xdi] += k;
            if (xd[xdi] != BASE) break;
            xd[xdi--] = 0;
            k = 1;
          }
        }
      }

      // Remove trailing zeros.
      for (i = xd.length; xd[--i] === 0;) xd.pop();
    }

    if (external) {

      // Overflow?
      if (x.e > Ctor.maxE) {

        // Infinity.
        x.d = null;
        x.e = NaN;

      // Underflow?
      } else if (x.e < Ctor.minE) {

        // Zero.
        x.e = 0;
        x.d = [0];
        // Ctor.underflow = true;
      } // else Ctor.underflow = false;
    }

    return x;
  }


  function finiteToString(x, isExp, sd) {
    if (!x.isFinite()) return nonFiniteToString(x);
    var k,
      e = x.e,
      str = digitsToString(x.d),
      len = str.length;

    if (isExp) {
      if (sd && (k = sd - len) > 0) {
        str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);
      } else if (len > 1) {
        str = str.charAt(0) + '.' + str.slice(1);
      }

      str = str + (x.e < 0 ? 'e' : 'e+') + x.e;
    } else if (e < 0) {
      str = '0.' + getZeroString(-e - 1) + str;
      if (sd && (k = sd - len) > 0) str += getZeroString(k);
    } else if (e >= len) {
      str += getZeroString(e + 1 - len);
      if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);
    } else {
      if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);
      if (sd && (k = sd - len) > 0) {
        if (e + 1 === len) str += '.';
        str += getZeroString(k);
      }
    }

    return str;
  }


  // Calculate the base 10 exponent from the base 1e7 exponent.
  function getBase10Exponent(digits, e) {
    var w = digits[0];

    // Add the number of digits of the first word of the digits array.
    for ( e *= LOG_BASE; w >= 10; w /= 10) e++;
    return e;
  }


  function getLn10(Ctor, sd, pr) {
    if (sd > LN10_PRECISION) {

      // Reset global state in case the exception is caught.
      external = true;
      if (pr) Ctor.precision = pr;
      throw Error(precisionLimitExceeded);
    }
    return finalise(new Ctor(LN10), sd, 1, true);
  }


  function getPi(Ctor, sd, rm) {
    if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
    return finalise(new Ctor(PI), sd, rm, true);
  }


  function getPrecision(digits) {
    var w = digits.length - 1,
      len = w * LOG_BASE + 1;

    w = digits[w];

    // If non-zero...
    if (w) {

      // Subtract the number of trailing zeros of the last word.
      for (; w % 10 == 0; w /= 10) len--;

      // Add the number of digits of the first word.
      for (w = digits[0]; w >= 10; w /= 10) len++;
    }

    return len;
  }


  function getZeroString(k) {
    var zs = '';
    for (; k--;) zs += '0';
    return zs;
  }


  /*
   * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an
   * integer of type number.
   *
   * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.
   *
   */
  function intPow(Ctor, x, n, pr) {
    var isTruncated,
      r = new Ctor(1),

      // Max n of 9007199254740991 takes 53 loop iterations.
      // Maximum digits array length; leaves [28, 34] guard digits.
      k = Math.ceil(pr / LOG_BASE + 4);

    external = false;

    for (;;) {
      if (n % 2) {
        r = r.times(x);
        if (truncate(r.d, k)) isTruncated = true;
      }

      n = mathfloor(n / 2);
      if (n === 0) {

        // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.
        n = r.d.length - 1;
        if (isTruncated && r.d[n] === 0) ++r.d[n];
        break;
      }

      x = x.times(x);
      truncate(x.d, k);
    }

    external = true;

    return r;
  }


  function isOdd(n) {
    return n.d[n.d.length - 1] & 1;
  }


  /*
   * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.
   */
  function maxOrMin(Ctor, args, ltgt) {
    var y,
      x = new Ctor(args[0]),
      i = 0;

    for (; ++i < args.length;) {
      y = new Ctor(args[i]);
      if (!y.s) {
        x = y;
        break;
      } else if (x[ltgt](y)) {
        x = y;
      }
    }

    return x;
  }


  /*
   * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant
   * digits.
   *
   * Taylor/Maclaurin series.
   *
   * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...
   *
   * Argument reduction:
   *   Repeat x = x / 32, k += 5, until |x| < 0.1
   *   exp(x) = exp(x / 2^k)^(2^k)
   *
   * Previously, the argument was initially reduced by
   * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)
   * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was
   * found to be slower than just dividing repeatedly by 32 as above.
   *
   * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000
   * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000
   * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)
   *
   *  exp(Infinity)  = Infinity
   *  exp(-Infinity) = 0
   *  exp(NaN)       = NaN
   *  exp(±0)        = 1
   *
   *  exp(x) is non-terminating for any finite, non-zero x.
   *
   *  The result will always be correctly rounded.
   *
   */
  function naturalExponential(x, sd) {
    var denominator, guard, j, pow, sum, t, wpr,
      rep = 0,
      i = 0,
      k = 0,
      Ctor = x.constructor,
      rm = Ctor.rounding,
      pr = Ctor.precision;

    // 0/NaN/Infinity?
    if (!x.d || !x.d[0] || x.e > 17) {

      return new Ctor(x.d
        ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0
        : x.s ? x.s < 0 ? 0 : x : 0 / 0);
    }

    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }

    t = new Ctor(0.03125);

    // while abs(x) >= 0.1
    while (x.e > -2) {

      // x = x / 2^5
      x = x.times(t);
      k += 5;
    }

    // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision
    // necessary to ensure the first 4 rounding digits are correct.
    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
    wpr += guard;
    denominator = pow = sum = new Ctor(1);
    Ctor.precision = wpr;

    for (;;) {
      pow = finalise(pow.times(x), wpr, 1);
      denominator = denominator.times(++i);
      t = sum.plus(divide(pow, denominator, wpr, 1));

      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
        j = k;
        while (j--) sum = finalise(sum.times(sum), wpr, 1);

        // Check to see if the first 4 rounding digits are [49]999.
        // If so, repeat the summation with a higher precision, otherwise
        // e.g. with precision: 18, rounding: 1
        // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)
        // `wpr - guard` is the index of first rounding digit.
        if (sd == null) {

          if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
            Ctor.precision = wpr += 10;
            denominator = pow = t = new Ctor(1);
            i = 0;
            rep++;
          } else {
            return finalise(sum, Ctor.precision = pr, rm, external = true);
          }
        } else {
          Ctor.precision = pr;
          return sum;
        }
      }

      sum = t;
    }
  }


  /*
   * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant
   * digits.
   *
   *  ln(-n)        = NaN
   *  ln(0)         = -Infinity
   *  ln(-0)        = -Infinity
   *  ln(1)         = 0
   *  ln(Infinity)  = Infinity
   *  ln(-Infinity) = NaN
   *  ln(NaN)       = NaN
   *
   *  ln(n) (n != 1) is non-terminating.
   *
   */
  function naturalLogarithm(y, sd) {
    var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2,
      n = 1,
      guard = 10,
      x = y,
      xd = x.d,
      Ctor = x.constructor,
      rm = Ctor.rounding,
      pr = Ctor.precision;

    // Is x negative or Infinity, NaN, 0 or 1?
    if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
      return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
    }

    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }

    Ctor.precision = wpr += guard;
    c = digitsToString(xd);
    c0 = c.charAt(0);

    if (Math.abs(e = x.e) < 1.5e15) {

      // Argument reduction.
      // The series converges faster the closer the argument is to 1, so using
      // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b
      // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,
      // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can
      // later be divided by this number, then separate out the power of 10 using
      // ln(a*10^b) = ln(a) + b*ln(10).

      // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).
      //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {
      // max n is 6 (gives 0.7 - 1.3)
      while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
        x = x.times(y);
        c = digitsToString(x.d);
        c0 = c.charAt(0);
        n++;
      }

      e = x.e;

      if (c0 > 1) {
        x = new Ctor('0.' + c);
        e++;
      } else {
        x = new Ctor(c0 + '.' + c.slice(1));
      }
    } else {

      // The argument reduction method above may result in overflow if the argument y is a massive
      // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this
      // function using ln(x*10^e) = ln(x) + e*ln(10).
      t = getLn10(Ctor, wpr + 2, pr).times(e + '');
      x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);
      Ctor.precision = pr;

      return sd == null ? finalise(x, pr, rm, external = true) : x;
    }

    // x1 is x reduced to a value near 1.
    x1 = x;

    // Taylor series.
    // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)
    // where x = (y - 1)/(y + 1)    (|x| < 1)
    sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
    x2 = finalise(x.times(x), wpr, 1);
    denominator = 3;

    for (;;) {
      numerator = finalise(numerator.times(x2), wpr, 1);
      t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));

      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
        sum = sum.times(2);

        // Reverse the argument reduction. Check that e is not 0 because, besides preventing an
        // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.
        if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));
        sum = divide(sum, new Ctor(n), wpr, 1);

        // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has
        // been repeated previously) and the first 4 rounding digits 9999?
        // If so, restart the summation with a higher precision, otherwise
        // e.g. with precision: 12, rounding: 1
        // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.
        // `wpr - guard` is the index of first rounding digit.
        if (sd == null) {
          if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
            Ctor.precision = wpr += guard;
            t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
            x2 = finalise(x.times(x), wpr, 1);
            denominator = rep = 1;
          } else {
            return finalise(sum, Ctor.precision = pr, rm, external = true);
          }
        } else {
          Ctor.precision = pr;
          return sum;
        }
      }

      sum = t;
      denominator += 2;
    }
  }


  // ±Infinity, NaN.
  function nonFiniteToString(x) {
    // Unsigned.
    return String(x.s * x.s / 0);
  }


  /*
   * Parse the value of a new Decimal `x` from string `str`.
   */
  function parseDecimal(x, str) {
    var e, i, len;

    // Decimal point?
    if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

    // Exponential form?
    if ((i = str.search(/e/i)) > 0) {

      // Determine exponent.
      if (e < 0) e = i;
      e += +str.slice(i + 1);
      str = str.substring(0, i);
    } else if (e < 0) {

      // Integer.
      e = str.length;
    }

    // Determine leading zeros.
    for (i = 0; str.charCodeAt(i) === 48; i++);

    // Determine trailing zeros.
    for (len = str.length; str.charCodeAt(len - 1) === 48; --len);
    str = str.slice(i, len);

    if (str) {
      len -= i;
      x.e = e = e - i - 1;
      x.d = [];

      // Transform base

      // e is the base 10 exponent.
      // i is where to slice str to get the first word of the digits array.
      i = (e + 1) % LOG_BASE;
      if (e < 0) i += LOG_BASE;

      if (i < len) {
        if (i) x.d.push(+str.slice(0, i));
        for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));
        str = str.slice(i);
        i = LOG_BASE - str.length;
      } else {
        i -= len;
      }

      for (; i--;) str += '0';
      x.d.push(+str);

      if (external) {

        // Overflow?
        if (x.e > x.constructor.maxE) {

          // Infinity.
          x.d = null;
          x.e = NaN;

        // Underflow?
        } else if (x.e < x.constructor.minE) {

          // Zero.
          x.e = 0;
          x.d = [0];
          // x.constructor.underflow = true;
        } // else x.constructor.underflow = false;
      }
    } else {

      // Zero.
      x.e = 0;
      x.d = [0];
    }

    return x;
  }


  /*
   * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.
   */
  function parseOther(x, str) {
    var base, Ctor, divisor, i, isFloat, len, p, xd, xe;

    if (str.indexOf('_') > -1) {
      str = str.replace(/(\d)_(?=\d)/g, '$1');
      if (isDecimal.test(str)) return parseDecimal(x, str);
    } else if (str === 'Infinity' || str === 'NaN') {
      if (!+str) x.s = NaN;
      x.e = NaN;
      x.d = null;
      return x;
    }

    if (isHex.test(str))  {
      base = 16;
      str = str.toLowerCase();
    } else if (isBinary.test(str))  {
      base = 2;
    } else if (isOctal.test(str))  {
      base = 8;
    } else {
      throw Error(invalidArgument + str);
    }

    // Is there a binary exponent part?
    i = str.search(/p/i);

    if (i > 0) {
      p = +str.slice(i + 1);
      str = str.substring(2, i);
    } else {
      str = str.slice(2);
    }

    // Convert `str` as an integer then divide the result by `base` raised to a power such that the
    // fraction part will be restored.
    i = str.indexOf('.');
    isFloat = i >= 0;
    Ctor = x.constructor;

    if (isFloat) {
      str = str.replace('.', '');
      len = str.length;
      i = len - i;

      // log[10](16) = 1.2041... , log[10](88) = 1.9444....
      divisor = intPow(Ctor, new Ctor(base), i, i * 2);
    }

    xd = convertBase(str, base, BASE);
    xe = xd.length - 1;

    // Remove trailing zeros.
    for (i = xe; xd[i] === 0; --i) xd.pop();
    if (i < 0) return new Ctor(x.s * 0);
    x.e = getBase10Exponent(xd, xe);
    x.d = xd;
    external = false;

    // At what precision to perform the division to ensure exact conversion?
    // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)
    // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412
    // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.
    // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount
    // Therefore using 4 * the number of digits of str will always be enough.
    if (isFloat) x = divide(x, divisor, len * 4);

    // Multiply by the binary exponent part if present.
    if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
    external = true;

    return x;
  }


  /*
   * sin(x) = x - x^3/3! + x^5/5! - ...
   * |x| < pi/2
   *
   */
  function sine(Ctor, x) {
    var k,
      len = x.d.length;

    if (len < 3) {
      return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
    }

    // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)
    // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)
    // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))

    // Estimate the optimum number of times to use the argument reduction.
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;

    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x);

    // Reverse argument reduction
    var sin2_x,
      d5 = new Ctor(5),
      d16 = new Ctor(16),
      d20 = new Ctor(20);
    for (; k--;) {
      sin2_x = x.times(x);
      x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
    }

    return x;
  }


  // Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.
  function taylorSeries(Ctor, n, x, y, isHyperbolic) {
    var j, t, u, x2,
      i = 1,
      pr = Ctor.precision,
      k = Math.ceil(pr / LOG_BASE);

    external = false;
    x2 = x.times(x);
    u = new Ctor(y);

    for (;;) {
      t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
      u = isHyperbolic ? y.plus(t) : y.minus(t);
      y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
      t = u.plus(y);

      if (t.d[k] !== void 0) {
        for (j = k; t.d[j] === u.d[j] && j--;);
        if (j == -1) break;
      }

      j = u;
      u = y;
      y = t;
      t = j;
      i++;
    }

    external = true;
    t.d.length = k + 1;

    return t;
  }


  // Exponent e must be positive and non-zero.
  function tinyPow(b, e) {
    var n = b;
    while (--e) n *= b;
    return n;
  }


  // Return the absolute value of `x` reduced to less than or equal to half pi.
  function toLessThanHalfPi(Ctor, x) {
    var t,
      isNeg = x.s < 0,
      pi = getPi(Ctor, Ctor.precision, 1),
      halfPi = pi.times(0.5);

    x = x.abs();

    if (x.lte(halfPi)) {
      quadrant = isNeg ? 4 : 1;
      return x;
    }

    t = x.divToInt(pi);

    if (t.isZero()) {
      quadrant = isNeg ? 3 : 2;
    } else {
      x = x.minus(t.times(pi));

      // 0 <= x < pi
      if (x.lte(halfPi)) {
        quadrant = isOdd(t) ? (isNeg ? 2 : 3) : (isNeg ? 4 : 1);
        return x;
      }

      quadrant = isOdd(t) ? (isNeg ? 1 : 4) : (isNeg ? 3 : 2);
    }

    return x.minus(pi).abs();
  }


  /*
   * Return the value of Decimal `x` as a string in base `baseOut`.
   *
   * If the optional `sd` argument is present include a binary exponent suffix.
   */
  function toStringBinary(x, baseOut, sd, rm) {
    var base, e, i, k, len, roundUp, str, xd, y,
      Ctor = x.constructor,
      isExp = sd !== void 0;

    if (isExp) {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);
    } else {
      sd = Ctor.precision;
      rm = Ctor.rounding;
    }

    if (!x.isFinite()) {
      str = nonFiniteToString(x);
    } else {
      str = finiteToString(x);
      i = str.indexOf('.');

      // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:
      // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))
      // minBinaryExponent = floor(decimalExponent * log[2](10))
      // log[2](10) = 3.321928094887362347870319429489390175864

      if (isExp) {
        base = 2;
        if (baseOut == 16) {
          sd = sd * 4 - 3;
        } else if (baseOut == 8) {
          sd = sd * 3 - 2;
        }
      } else {
        base = baseOut;
      }

      // Convert the number as an integer then divide the result by its base raised to a power such
      // that the fraction part will be restored.

      // Non-integer.
      if (i >= 0) {
        str = str.replace('.', '');
        y = new Ctor(1);
        y.e = str.length - i;
        y.d = convertBase(finiteToString(y), 10, base);
        y.e = y.d.length;
      }

      xd = convertBase(str, 10, base);
      e = len = xd.length;

      // Remove trailing zeros.
      for (; xd[--len] == 0;) xd.pop();

      if (!xd[0]) {
        str = isExp ? '0p+0' : '0';
      } else {
        if (i < 0) {
          e--;
        } else {
          x = new Ctor(x);
          x.d = xd;
          x.e = e;
          x = divide(x, y, sd, rm, 0, base);
          xd = x.d;
          e = x.e;
          roundUp = inexact;
        }

        // The rounding digit, i.e. the digit after the digit that may be rounded up.
        i = xd[sd];
        k = base / 2;
        roundUp = roundUp || xd[sd + 1] !== void 0;

        roundUp = rm < 4
          ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2))
          : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 ||
            rm === (x.s < 0 ? 8 : 7));

        xd.length = sd;

        if (roundUp) {

          // Rounding up may mean the previous digit has to be rounded up and so on.
          for (; ++xd[--sd] > base - 1;) {
            xd[sd] = 0;
            if (!sd) {
              ++e;
              xd.unshift(1);
            }
          }
        }

        // Determine trailing zeros.
        for (len = xd.length; !xd[len - 1]; --len);

        // E.g. [4, 11, 15] becomes 4bf.
        for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i]);

        // Add binary exponent suffix?
        if (isExp) {
          if (len > 1) {
            if (baseOut == 16 || baseOut == 8) {
              i = baseOut == 16 ? 4 : 3;
              for (--len; len % i; len++) str += '0';
              xd = convertBase(str, base, baseOut);
              for (len = xd.length; !xd[len - 1]; --len);

              // xd[0] will always be be 1
              for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i]);
            } else {
              str = str.charAt(0) + '.' + str.slice(1);
            }
          }

          str =  str + (e < 0 ? 'p' : 'p+') + e;
        } else if (e < 0) {
          for (; ++e;) str = '0' + str;
          str = '0.' + str;
        } else {
          if (++e > len) for (e -= len; e-- ;) str += '0';
          else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);
        }
      }

      str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;
    }

    return x.s < 0 ? '-' + str : str;
  }


  // Does not strip trailing zeros.
  function truncate(arr, len) {
    if (arr.length > len) {
      arr.length = len;
      return true;
    }
  }


  // Decimal methods


  /*
   *  abs
   *  acos
   *  acosh
   *  add
   *  asin
   *  asinh
   *  atan
   *  atanh
   *  atan2
   *  cbrt
   *  ceil
   *  clamp
   *  clone
   *  config
   *  cos
   *  cosh
   *  div
   *  exp
   *  floor
   *  hypot
   *  ln
   *  log
   *  log2
   *  log10
   *  max
   *  min
   *  mod
   *  mul
   *  pow
   *  random
   *  round
   *  set
   *  sign
   *  sin
   *  sinh
   *  sqrt
   *  sub
   *  sum
   *  tan
   *  tanh
   *  trunc
   */


  /*
   * Return a new Decimal whose value is the absolute value of `x`.
   *
   * x {number|string|Decimal}
   *
   */
  function abs(x) {
    return new this(x).abs();
  }


  /*
   * Return a new Decimal whose value is the arccosine in radians of `x`.
   *
   * x {number|string|Decimal}
   *
   */
  function acos(x) {
    return new this(x).acos();
  }


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function acosh(x) {
    return new this(x).acosh();
  }


  /*
   * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */
  function add(x, y) {
    return new this(x).plus(y);
  }


  /*
   * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function asin(x) {
    return new this(x).asin();
  }


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function asinh(x) {
    return new this(x).asinh();
  }


  /*
   * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function atan(x) {
    return new this(x).atan();
  }


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function atanh(x) {
    return new this(x).atanh();
  }


  /*
   * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi
   * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-pi, pi]
   *
   * y {number|string|Decimal} The y-coordinate.
   * x {number|string|Decimal} The x-coordinate.
   *
   * atan2(±0, -0)               = ±pi
   * atan2(±0, +0)               = ±0
   * atan2(±0, -x)               = ±pi for x > 0
   * atan2(±0, x)                = ±0 for x > 0
   * atan2(-y, ±0)               = -pi/2 for y > 0
   * atan2(y, ±0)                = pi/2 for y > 0
   * atan2(±y, -Infinity)        = ±pi for finite y > 0
   * atan2(±y, +Infinity)        = ±0 for finite y > 0
   * atan2(±Infinity, x)         = ±pi/2 for finite x
   * atan2(±Infinity, -Infinity) = ±3*pi/4
   * atan2(±Infinity, +Infinity) = ±pi/4
   * atan2(NaN, x) = NaN
   * atan2(y, NaN) = NaN
   *
   */
  function atan2(y, x) {
    y = new this(y);
    x = new this(x);
    var r,
      pr = this.precision,
      rm = this.rounding,
      wpr = pr + 4;

    // Either NaN
    if (!y.s || !x.s) {
      r = new this(NaN);

    // Both ±Infinity
    } else if (!y.d && !x.d) {
      r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
      r.s = y.s;

    // x is ±Infinity or y is ±0
    } else if (!x.d || y.isZero()) {
      r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
      r.s = y.s;

    // y is ±Infinity or x is ±0
    } else if (!y.d || x.isZero()) {
      r = getPi(this, wpr, 1).times(0.5);
      r.s = y.s;

    // Both non-zero and finite
    } else if (x.s < 0) {
      this.precision = wpr;
      this.rounding = 1;
      r = this.atan(divide(y, x, wpr, 1));
      x = getPi(this, wpr, 1);
      this.precision = pr;
      this.rounding = rm;
      r = y.s < 0 ? r.minus(x) : r.plus(x);
    } else {
      r = this.atan(divide(y, x, wpr, 1));
    }

    return r;
  }


  /*
   * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function cbrt(x) {
    return new this(x).cbrt();
  }


  /*
   * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.
   *
   * x {number|string|Decimal}
   *
   */
  function ceil(x) {
    return finalise(x = new this(x), x.e + 1, 2);
  }


  /*
   * Return a new Decimal whose value is `x` clamped to the range delineated by `min` and `max`.
   *
   * x {number|string|Decimal}
   * min {number|string|Decimal}
   * max {number|string|Decimal}
   *
   */
  function clamp(x, min, max) {
    return new this(x).clamp(min, max);
  }


  /*
   * Configure global settings for a Decimal constructor.
   *
   * `obj` is an object with one or more of the following properties,
   *
   *   precision  {number}
   *   rounding   {number}
   *   toExpNeg   {number}
   *   toExpPos   {number}
   *   maxE       {number}
   *   minE       {number}
   *   modulo     {number}
   *   crypto     {boolean|number}
   *   defaults   {true}
   *
   * E.g. Decimal.config({ precision: 20, rounding: 4 })
   *
   */
  function config(obj) {
    if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');
    var i, p, v,
      useDefaults = obj.defaults === true,
      ps = [
        'precision', 1, MAX_DIGITS,
        'rounding', 0, 8,
        'toExpNeg', -EXP_LIMIT, 0,
        'toExpPos', 0, EXP_LIMIT,
        'maxE', 0, EXP_LIMIT,
        'minE', -EXP_LIMIT, 0,
        'modulo', 0, 9
      ];

    for (i = 0; i < ps.length; i += 3) {
      if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];
      if ((v = obj[p]) !== void 0) {
        if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
        else throw Error(invalidArgument + p + ': ' + v);
      }
    }

    if (p = 'crypto', useDefaults) this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== void 0) {
      if (v === true || v === false || v === 0 || v === 1) {
        if (v) {
          if (typeof crypto != 'undefined' && crypto &&
            (crypto.getRandomValues || crypto.randomBytes)) {
            this[p] = true;
          } else {
            throw Error(cryptoUnavailable);
          }
        } else {
          this[p] = false;
        }
      } else {
        throw Error(invalidArgument + p + ': ' + v);
      }
    }

    return this;
  }


  /*
   * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function cos(x) {
    return new this(x).cos();
  }


  /*
   * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function cosh(x) {
    return new this(x).cosh();
  }


  /*
   * Create and return a Decimal constructor with the same configuration properties as this Decimal
   * constructor.
   *
   */
  function clone(obj) {
    var i, p, ps;

    /*
     * The Decimal constructor and exported function.
     * Return a new Decimal instance.
     *
     * v {number|string|Decimal} A numeric value.
     *
     */
    function Decimal(v) {
      var e, i, t,
        x = this;

      // Decimal called without new.
      if (!(x instanceof Decimal)) return new Decimal(v);

      // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
      // which points to Object.
      x.constructor = Decimal;

      // Duplicate.
      if (isDecimalInstance(v)) {
        x.s = v.s;

        if (external) {
          if (!v.d || v.e > Decimal.maxE) {

            // Infinity.
            x.e = NaN;
            x.d = null;
          } else if (v.e < Decimal.minE) {

            // Zero.
            x.e = 0;
            x.d = [0];
          } else {
            x.e = v.e;
            x.d = v.d.slice();
          }
        } else {
          x.e = v.e;
          x.d = v.d ? v.d.slice() : v.d;
        }

        return;
      }

      t = typeof v;

      if (t === 'number') {
        if (v === 0) {
          x.s = 1 / v < 0 ? -1 : 1;
          x.e = 0;
          x.d = [0];
          return;
        }

        if (v < 0) {
          v = -v;
          x.s = -1;
        } else {
          x.s = 1;
        }

        // Fast path for small integers.
        if (v === ~~v && v < 1e7) {
          for (e = 0, i = v; i >= 10; i /= 10) e++;

          if (external) {
            if (e > Decimal.maxE) {
              x.e = NaN;
              x.d = null;
            } else if (e < Decimal.minE) {
              x.e = 0;
              x.d = [0];
            } else {
              x.e = e;
              x.d = [v];
            }
          } else {
            x.e = e;
            x.d = [v];
          }

          return;

        // Infinity, NaN.
        } else if (v * 0 !== 0) {
          if (!v) x.s = NaN;
          x.e = NaN;
          x.d = null;
          return;
        }

        return parseDecimal(x, v.toString());

      } else if (t !== 'string') {
        throw Error(invalidArgument + v);
      }

      // Minus sign?
      if ((i = v.charCodeAt(0)) === 45) {
        v = v.slice(1);
        x.s = -1;
      } else {
        // Plus sign?
        if (i === 43) v = v.slice(1);
        x.s = 1;
      }

      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
    }

    Decimal.prototype = P;

    Decimal.ROUND_UP = 0;
    Decimal.ROUND_DOWN = 1;
    Decimal.ROUND_CEIL = 2;
    Decimal.ROUND_FLOOR = 3;
    Decimal.ROUND_HALF_UP = 4;
    Decimal.ROUND_HALF_DOWN = 5;
    Decimal.ROUND_HALF_EVEN = 6;
    Decimal.ROUND_HALF_CEIL = 7;
    Decimal.ROUND_HALF_FLOOR = 8;
    Decimal.EUCLID = 9;

    Decimal.config = Decimal.set = config;
    Decimal.clone = clone;
    Decimal.isDecimal = isDecimalInstance;

    Decimal.abs = abs;
    Decimal.acos = acos;
    Decimal.acosh = acosh;        // ES6
    Decimal.add = add;
    Decimal.asin = asin;
    Decimal.asinh = asinh;        // ES6
    Decimal.atan = atan;
    Decimal.atanh = atanh;        // ES6
    Decimal.atan2 = atan2;
    Decimal.cbrt = cbrt;          // ES6
    Decimal.ceil = ceil;
    Decimal.clamp = clamp;
    Decimal.cos = cos;
    Decimal.cosh = cosh;          // ES6
    Decimal.div = div;
    Decimal.exp = exp;
    Decimal.floor = floor;
    Decimal.hypot = hypot;        // ES6
    Decimal.ln = ln;
    Decimal.log = log;
    Decimal.log10 = log10;        // ES6
    Decimal.log2 = log2;          // ES6
    Decimal.max = max;
    Decimal.min = min;
    Decimal.mod = mod;
    Decimal.mul = mul;
    Decimal.pow = pow;
    Decimal.random = random;
    Decimal.round = round;
    Decimal.sign = sign;          // ES6
    Decimal.sin = sin;
    Decimal.sinh = sinh;          // ES6
    Decimal.sqrt = sqrt;
    Decimal.sub = sub;
    Decimal.sum = sum;
    Decimal.tan = tan;
    Decimal.tanh = tanh;          // ES6
    Decimal.trunc = trunc;        // ES6

    if (obj === void 0) obj = {};
    if (obj) {
      if (obj.defaults !== true) {
        ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];
        for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
      }
    }

    Decimal.config(obj);

    return Decimal;
  }


  /*
   * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */
  function div(x, y) {
    return new this(x).div(y);
  }


  /*
   * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} The power to which to raise the base of the natural log.
   *
   */
  function exp(x) {
    return new this(x).exp();
  }


  /*
   * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.
   *
   * x {number|string|Decimal}
   *
   */
  function floor(x) {
    return finalise(x = new this(x), x.e + 1, 3);
  }


  /*
   * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,
   * rounded to `precision` significant digits using rounding mode `rounding`.
   *
   * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)
   *
   * arguments {number|string|Decimal}
   *
   */
  function hypot() {
    var i, n,
      t = new this(0);

    external = false;

    for (i = 0; i < arguments.length;) {
      n = new this(arguments[i++]);
      if (!n.d) {
        if (n.s) {
          external = true;
          return new this(1 / 0);
        }
        t = n;
      } else if (t.d) {
        t = t.plus(n.times(n));
      }
    }

    external = true;

    return t.sqrt();
  }


  /*
   * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),
   * otherwise return false.
   *
   */
  function isDecimalInstance(obj) {
    return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
  }


  /*
   * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function ln(x) {
    return new this(x).ln();
  }


  /*
   * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base
   * is specified, rounded to `precision` significant digits using rounding mode `rounding`.
   *
   * log[y](x)
   *
   * x {number|string|Decimal} The argument of the logarithm.
   * y {number|string|Decimal} The base of the logarithm.
   *
   */
  function log(x, y) {
    return new this(x).log(y);
  }


  /*
   * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function log2(x) {
    return new this(x).log(2);
  }


  /*
   * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function log10(x) {
    return new this(x).log(10);
  }


  /*
   * Return a new Decimal whose value is the maximum of the arguments.
   *
   * arguments {number|string|Decimal}
   *
   */
  function max() {
    return maxOrMin(this, arguments, 'lt');
  }


  /*
   * Return a new Decimal whose value is the minimum of the arguments.
   *
   * arguments {number|string|Decimal}
   *
   */
  function min() {
    return maxOrMin(this, arguments, 'gt');
  }


  /*
   * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits
   * using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */
  function mod(x, y) {
    return new this(x).mod(y);
  }


  /*
   * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */
  function mul(x, y) {
    return new this(x).mul(y);
  }


  /*
   * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} The base.
   * y {number|string|Decimal} The exponent.
   *
   */
  function pow(x, y) {
    return new this(x).pow(y);
  }


  /*
   * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with
   * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros
   * are produced).
   *
   * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.
   *
   */
  function random(sd) {
    var d, e, k, n,
      i = 0,
      r = new this(1),
      rd = [];

    if (sd === void 0) sd = this.precision;
    else checkInt32(sd, 1, MAX_DIGITS);

    k = Math.ceil(sd / LOG_BASE);

    if (!this.crypto) {
      for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;

    // Browsers supporting crypto.getRandomValues.
    } else if (crypto.getRandomValues) {
      d = crypto.getRandomValues(new Uint32Array(k));

      for (; i < k;) {
        n = d[i];

        // 0 <= n < 4294967296
        // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).
        if (n >= 4.29e9) {
          d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
        } else {

          // 0 <= n <= 4289999999
          // 0 <= (n % 1e7) <= 9999999
          rd[i++] = n % 1e7;
        }
      }

    // Node.js supporting crypto.randomBytes.
    } else if (crypto.randomBytes) {

      // buffer
      d = crypto.randomBytes(k *= 4);

      for (; i < k;) {

        // 0 <= n < 2147483648
        n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);

        // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).
        if (n >= 2.14e9) {
          crypto.randomBytes(4).copy(d, i);
        } else {

          // 0 <= n <= 2139999999
          // 0 <= (n % 1e7) <= 9999999
          rd.push(n % 1e7);
          i += 4;
        }
      }

      i = k / 4;
    } else {
      throw Error(cryptoUnavailable);
    }

    k = rd[--i];
    sd %= LOG_BASE;

    // Convert trailing digits to zeros according to sd.
    if (k && sd) {
      n = mathpow(10, LOG_BASE - sd);
      rd[i] = (k / n | 0) * n;
    }

    // Remove trailing words which are zero.
    for (; rd[i] === 0; i--) rd.pop();

    // Zero?
    if (i < 0) {
      e = 0;
      rd = [0];
    } else {
      e = -1;

      // Remove leading words which are zero and adjust exponent accordingly.
      for (; rd[0] === 0; e -= LOG_BASE) rd.shift();

      // Count the digits of the first word of rd to determine leading zeros.
      for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;

      // Adjust the exponent for leading zeros of the first word of rd.
      if (k < LOG_BASE) e -= LOG_BASE - k;
    }

    r.e = e;
    r.d = rd;

    return r;
  }


  /*
   * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.
   *
   * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).
   *
   * x {number|string|Decimal}
   *
   */
  function round(x) {
    return finalise(x = new this(x), x.e + 1, this.rounding);
  }


  /*
   * Return
   *   1    if x > 0,
   *  -1    if x < 0,
   *   0    if x is 0,
   *  -0    if x is -0,
   *   NaN  otherwise
   *
   * x {number|string|Decimal}
   *
   */
  function sign(x) {
    x = new this(x);
    return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;
  }


  /*
   * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits
   * using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function sin(x) {
    return new this(x).sin();
  }


  /*
   * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function sinh(x) {
    return new this(x).sinh();
  }


  /*
   * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function sqrt(x) {
    return new this(x).sqrt();
  }


  /*
   * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits
   * using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */
  function sub(x, y) {
    return new this(x).sub(y);
  }


  /*
   * Return a new Decimal whose value is the sum of the arguments, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * Only the result is rounded, not the intermediate calculations.
   *
   * arguments {number|string|Decimal}
   *
   */
  function sum() {
    var i = 0,
      args = arguments,
      x = new this(args[i]);

    external = false;
    for (; x.s && ++i < args.length;) x = x.plus(args[i]);
    external = true;

    return finalise(x, this.precision, this.rounding);
  }


  /*
   * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function tan(x) {
    return new this(x).tan();
  }


  /*
   * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function tanh(x) {
    return new this(x).tanh();
  }


  /*
   * Return a new Decimal whose value is `x` truncated to an integer.
   *
   * x {number|string|Decimal}
   *
   */
  function trunc(x) {
    return finalise(x = new this(x), x.e + 1, 1);
  }


  // Create and configure initial Decimal constructor.
  Decimal = clone(DEFAULTS);
  Decimal.prototype.constructor = Decimal;
  Decimal['default'] = Decimal.Decimal = Decimal;

  // Create the internal constants from their string values.
  LN10 = new Decimal(LN10);
  PI = new Decimal(PI);


  // Export.


  // AMD.
  if (typeof define == 'function' && define.amd) {
    define(function () {
      return Decimal;
    });

  // Node and other environments that support module.exports.
  } else if ( true && module.exports) {
    if (typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol') {
      P[Symbol['for']('nodejs.util.inspect.custom')] = P.toString;
      P[Symbol.toStringTag] = 'Decimal';
    }

    module.exports = Decimal;

  // Browser.
  } else {
    if (!globalScope) {
      globalScope = typeof self != 'undefined' && self && self.self == self ? self : window;
    }

    noConflict = globalScope.Decimal;
    Decimal.noConflict = function () {
      globalScope.Decimal = noConflict;
      return Decimal;
    };

    globalScope.Decimal = Decimal;
  }
})(this);


/***/ }),

/***/ 256:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var BN = __nccwpck_require__(3693);

var utils = __nccwpck_require__(2727);
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;

  // Indefinite length or overflow
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }

  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }

  // Leading zeroes
  if (val <= 0x7f) {
    return false;
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};


/***/ }),

/***/ 2727:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var utils = exports;
var BN = __nccwpck_require__(3693);
var minAssert = __nccwpck_require__(4795);
var minUtils = __nccwpck_require__(3756);

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w, bits) {
  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
  naf.fill(0);

  var ws = 1 << (w + 1);
  var k = num.clone();

  for (var i = 0; i < naf.length; i++) {
    var z;
    var mod = k.andln(ws - 1);
    if (k.isOdd()) {
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }

    naf[i] = z;
    k.iushrn(1);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    [],
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  var m8;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
      this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
    bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;



/***/ }),

/***/ 6125:
/***/ ((module) => {

"use strict";


module.exports = (flag, argv = process.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};


/***/ }),

/***/ 609:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

var hash = exports;

hash.utils = __nccwpck_require__(2592);
hash.common = __nccwpck_require__(6304);
hash.sha = __nccwpck_require__(3460);
hash.ripemd = __nccwpck_require__(8385);
hash.hmac = __nccwpck_require__(4459);

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;


/***/ }),

/***/ 6304:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(2592);
var assert = __nccwpck_require__(4795);

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};


/***/ }),

/***/ 4459:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(2592);
var assert = __nccwpck_require__(4795);

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};


/***/ }),

/***/ 8385:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(2592);
var common = __nccwpck_require__(6304);

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];


/***/ }),

/***/ 3460:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


exports.sha1 = __nccwpck_require__(5616);
exports.sha224 = __nccwpck_require__(982);
exports.sha256 = __nccwpck_require__(2054);
exports.sha384 = __nccwpck_require__(5810);
exports.sha512 = __nccwpck_require__(4048);


/***/ }),

/***/ 5616:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(2592);
var common = __nccwpck_require__(6304);
var shaCommon = __nccwpck_require__(2745);

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),

/***/ 982:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(2592);
var SHA256 = __nccwpck_require__(2054);

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};



/***/ }),

/***/ 2054:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(2592);
var common = __nccwpck_require__(6304);
var shaCommon = __nccwpck_require__(2745);
var assert = __nccwpck_require__(4795);

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),

/***/ 5810:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(2592);

var SHA512 = __nccwpck_require__(4048);

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};


/***/ }),

/***/ 4048:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(2592);
var common = __nccwpck_require__(6304);
var assert = __nccwpck_require__(4795);

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}


/***/ }),

/***/ 2745:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(2592);
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;


/***/ }),

/***/ 2592:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var assert = __nccwpck_require__(4795);
var inherits = __nccwpck_require__(7263);

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;


/***/ }),

/***/ 2458:
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ 7263:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

try {
  var util = __nccwpck_require__(3837);
  /* istanbul ignore next */
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = __nccwpck_require__(9733);
}


/***/ }),

/***/ 9733:
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ 4980:
/***/ ((module) => {

module.exports      = isTypedArray
isTypedArray.strict = isStrictTypedArray
isTypedArray.loose  = isLooseTypedArray

var toString = Object.prototype.toString
var names = {
    '[object Int8Array]': true
  , '[object Int16Array]': true
  , '[object Int32Array]': true
  , '[object Uint8Array]': true
  , '[object Uint8ClampedArray]': true
  , '[object Uint16Array]': true
  , '[object Uint32Array]': true
  , '[object Float32Array]': true
  , '[object Float64Array]': true
}

function isTypedArray(arr) {
  return (
       isStrictTypedArray(arr)
    || isLooseTypedArray(arr)
  )
}

function isStrictTypedArray(arr) {
  return (
       arr instanceof Int8Array
    || arr instanceof Int16Array
    || arr instanceof Int32Array
    || arr instanceof Uint8Array
    || arr instanceof Uint8ClampedArray
    || arr instanceof Uint16Array
    || arr instanceof Uint32Array
    || arr instanceof Float32Array
    || arr instanceof Float64Array
  )
}

function isLooseTypedArray(arr) {
  return names[toString.call(arr)]
}


/***/ }),

/***/ 5315:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

!function(e){function r(e,r){"use strict";var t,a=r.ready.then((function(){function a(){if(0!==t._sodium_init())throw new Error("libsodium was not correctly initialized.");for(var r=["crypto_aead_chacha20poly1305_decrypt","crypto_aead_chacha20poly1305_decrypt_detached","crypto_aead_chacha20poly1305_encrypt","crypto_aead_chacha20poly1305_encrypt_detached","crypto_aead_chacha20poly1305_ietf_decrypt","crypto_aead_chacha20poly1305_ietf_decrypt_detached","crypto_aead_chacha20poly1305_ietf_encrypt","crypto_aead_chacha20poly1305_ietf_encrypt_detached","crypto_aead_chacha20poly1305_ietf_keygen","crypto_aead_chacha20poly1305_keygen","crypto_aead_xchacha20poly1305_ietf_decrypt","crypto_aead_xchacha20poly1305_ietf_decrypt_detached","crypto_aead_xchacha20poly1305_ietf_encrypt","crypto_aead_xchacha20poly1305_ietf_encrypt_detached","crypto_aead_xchacha20poly1305_ietf_keygen","crypto_auth","crypto_auth_hmacsha256","crypto_auth_hmacsha256_final","crypto_auth_hmacsha256_init","crypto_auth_hmacsha256_keygen","crypto_auth_hmacsha256_update","crypto_auth_hmacsha256_verify","crypto_auth_hmacsha512","crypto_auth_hmacsha512_final","crypto_auth_hmacsha512_init","crypto_auth_hmacsha512_keygen","crypto_auth_hmacsha512_update","crypto_auth_hmacsha512_verify","crypto_auth_keygen","crypto_auth_verify","crypto_box_beforenm","crypto_box_curve25519xchacha20poly1305_keypair","crypto_box_curve25519xchacha20poly1305_seal","crypto_box_curve25519xchacha20poly1305_seal_open","crypto_box_detached","crypto_box_easy","crypto_box_easy_afternm","crypto_box_keypair","crypto_box_open_detached","crypto_box_open_easy","crypto_box_open_easy_afternm","crypto_box_seal","crypto_box_seal_open","crypto_box_seed_keypair","crypto_core_ed25519_add","crypto_core_ed25519_from_hash","crypto_core_ed25519_from_uniform","crypto_core_ed25519_is_valid_point","crypto_core_ed25519_random","crypto_core_ed25519_scalar_add","crypto_core_ed25519_scalar_complement","crypto_core_ed25519_scalar_invert","crypto_core_ed25519_scalar_mul","crypto_core_ed25519_scalar_negate","crypto_core_ed25519_scalar_random","crypto_core_ed25519_scalar_reduce","crypto_core_ed25519_scalar_sub","crypto_core_ed25519_sub","crypto_core_hchacha20","crypto_core_hsalsa20","crypto_core_ristretto255_add","crypto_core_ristretto255_from_hash","crypto_core_ristretto255_is_valid_point","crypto_core_ristretto255_random","crypto_core_ristretto255_scalar_add","crypto_core_ristretto255_scalar_complement","crypto_core_ristretto255_scalar_invert","crypto_core_ristretto255_scalar_mul","crypto_core_ristretto255_scalar_negate","crypto_core_ristretto255_scalar_random","crypto_core_ristretto255_scalar_reduce","crypto_core_ristretto255_scalar_sub","crypto_core_ristretto255_sub","crypto_generichash","crypto_generichash_blake2b_salt_personal","crypto_generichash_final","crypto_generichash_init","crypto_generichash_keygen","crypto_generichash_update","crypto_hash","crypto_hash_sha256","crypto_hash_sha256_final","crypto_hash_sha256_init","crypto_hash_sha256_update","crypto_hash_sha512","crypto_hash_sha512_final","crypto_hash_sha512_init","crypto_hash_sha512_update","crypto_kdf_derive_from_key","crypto_kdf_keygen","crypto_kx_client_session_keys","crypto_kx_keypair","crypto_kx_seed_keypair","crypto_kx_server_session_keys","crypto_onetimeauth","crypto_onetimeauth_final","crypto_onetimeauth_init","crypto_onetimeauth_keygen","crypto_onetimeauth_update","crypto_onetimeauth_verify","crypto_pwhash","crypto_pwhash_scryptsalsa208sha256","crypto_pwhash_scryptsalsa208sha256_ll","crypto_pwhash_scryptsalsa208sha256_str","crypto_pwhash_scryptsalsa208sha256_str_verify","crypto_pwhash_str","crypto_pwhash_str_needs_rehash","crypto_pwhash_str_verify","crypto_scalarmult","crypto_scalarmult_base","crypto_scalarmult_ed25519","crypto_scalarmult_ed25519_base","crypto_scalarmult_ed25519_base_noclamp","crypto_scalarmult_ed25519_noclamp","crypto_scalarmult_ristretto255","crypto_scalarmult_ristretto255_base","crypto_secretbox_detached","crypto_secretbox_easy","crypto_secretbox_keygen","crypto_secretbox_open_detached","crypto_secretbox_open_easy","crypto_secretstream_xchacha20poly1305_init_pull","crypto_secretstream_xchacha20poly1305_init_push","crypto_secretstream_xchacha20poly1305_keygen","crypto_secretstream_xchacha20poly1305_pull","crypto_secretstream_xchacha20poly1305_push","crypto_secretstream_xchacha20poly1305_rekey","crypto_shorthash","crypto_shorthash_keygen","crypto_shorthash_siphashx24","crypto_sign","crypto_sign_detached","crypto_sign_ed25519_pk_to_curve25519","crypto_sign_ed25519_sk_to_curve25519","crypto_sign_ed25519_sk_to_pk","crypto_sign_ed25519_sk_to_seed","crypto_sign_final_create","crypto_sign_final_verify","crypto_sign_init","crypto_sign_keypair","crypto_sign_open","crypto_sign_seed_keypair","crypto_sign_update","crypto_sign_verify_detached","crypto_stream_chacha20","crypto_stream_chacha20_ietf_xor","crypto_stream_chacha20_ietf_xor_ic","crypto_stream_chacha20_keygen","crypto_stream_chacha20_xor","crypto_stream_chacha20_xor_ic","crypto_stream_keygen","crypto_stream_xchacha20_keygen","crypto_stream_xchacha20_xor","crypto_stream_xchacha20_xor_ic","randombytes_buf","randombytes_buf_deterministic","randombytes_close","randombytes_random","randombytes_set_implementation","randombytes_stir","randombytes_uniform","sodium_version_string"],a=[E,x,k,S,T,w,Y,B,A,K,M,I,N,L,U,O,C,R,P,G,X,D,F,V,H,q,j,z,W,J,Q,Z,$,ee,re,te,ae,_e,se,ne,ce,oe,he,pe,ye,ie,le,ue,de,ve,ge,be,fe,me,Ee,xe,ke,Se,Te,we,Ye,Be,Ae,Ke,Me,Ie,Ne,Le,Ue,Oe,Ce,Re,Pe,Ge,Xe,De,Fe,Ve,He,qe,je,ze,We,Je,Qe,Ze,$e,er,rr,tr,ar,_r,sr,nr,cr,or,hr,pr,yr,ir,lr,ur,dr,vr,gr,br,fr,mr,Er,xr,kr,Sr,Tr,wr,Yr,Br,Ar,Kr,Mr,Ir,Nr,Lr,Ur,Or,Cr,Rr,Pr,Gr,Xr,Dr,Fr,Vr,Hr,qr,jr,zr,Wr,Jr,Qr,Zr,$r,et,rt,tt,at,_t,st,nt,ct,ot,ht,pt,yt,it,lt,ut,dt,vt,gt,bt,ft,mt],_=0;_<a.length;_++)"function"==typeof t["_"+r[_]]&&(e[r[_]]=a[_]);var s=["SODIUM_LIBRARY_VERSION_MAJOR","SODIUM_LIBRARY_VERSION_MINOR","crypto_aead_chacha20poly1305_ABYTES","crypto_aead_chacha20poly1305_IETF_ABYTES","crypto_aead_chacha20poly1305_IETF_KEYBYTES","crypto_aead_chacha20poly1305_IETF_MESSAGEBYTES_MAX","crypto_aead_chacha20poly1305_IETF_NPUBBYTES","crypto_aead_chacha20poly1305_IETF_NSECBYTES","crypto_aead_chacha20poly1305_KEYBYTES","crypto_aead_chacha20poly1305_MESSAGEBYTES_MAX","crypto_aead_chacha20poly1305_NPUBBYTES","crypto_aead_chacha20poly1305_NSECBYTES","crypto_aead_chacha20poly1305_ietf_ABYTES","crypto_aead_chacha20poly1305_ietf_KEYBYTES","crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX","crypto_aead_chacha20poly1305_ietf_NPUBBYTES","crypto_aead_chacha20poly1305_ietf_NSECBYTES","crypto_aead_xchacha20poly1305_IETF_ABYTES","crypto_aead_xchacha20poly1305_IETF_KEYBYTES","crypto_aead_xchacha20poly1305_IETF_MESSAGEBYTES_MAX","crypto_aead_xchacha20poly1305_IETF_NPUBBYTES","crypto_aead_xchacha20poly1305_IETF_NSECBYTES","crypto_aead_xchacha20poly1305_ietf_ABYTES","crypto_aead_xchacha20poly1305_ietf_KEYBYTES","crypto_aead_xchacha20poly1305_ietf_MESSAGEBYTES_MAX","crypto_aead_xchacha20poly1305_ietf_NPUBBYTES","crypto_aead_xchacha20poly1305_ietf_NSECBYTES","crypto_auth_BYTES","crypto_auth_KEYBYTES","crypto_auth_hmacsha256_BYTES","crypto_auth_hmacsha256_KEYBYTES","crypto_auth_hmacsha512256_BYTES","crypto_auth_hmacsha512256_KEYBYTES","crypto_auth_hmacsha512_BYTES","crypto_auth_hmacsha512_KEYBYTES","crypto_box_BEFORENMBYTES","crypto_box_MACBYTES","crypto_box_MESSAGEBYTES_MAX","crypto_box_NONCEBYTES","crypto_box_PUBLICKEYBYTES","crypto_box_SEALBYTES","crypto_box_SECRETKEYBYTES","crypto_box_SEEDBYTES","crypto_box_curve25519xchacha20poly1305_BEFORENMBYTES","crypto_box_curve25519xchacha20poly1305_MACBYTES","crypto_box_curve25519xchacha20poly1305_MESSAGEBYTES_MAX","crypto_box_curve25519xchacha20poly1305_NONCEBYTES","crypto_box_curve25519xchacha20poly1305_PUBLICKEYBYTES","crypto_box_curve25519xchacha20poly1305_SEALBYTES","crypto_box_curve25519xchacha20poly1305_SECRETKEYBYTES","crypto_box_curve25519xchacha20poly1305_SEEDBYTES","crypto_box_curve25519xsalsa20poly1305_BEFORENMBYTES","crypto_box_curve25519xsalsa20poly1305_MACBYTES","crypto_box_curve25519xsalsa20poly1305_MESSAGEBYTES_MAX","crypto_box_curve25519xsalsa20poly1305_NONCEBYTES","crypto_box_curve25519xsalsa20poly1305_PUBLICKEYBYTES","crypto_box_curve25519xsalsa20poly1305_SECRETKEYBYTES","crypto_box_curve25519xsalsa20poly1305_SEEDBYTES","crypto_core_ed25519_BYTES","crypto_core_ed25519_HASHBYTES","crypto_core_ed25519_NONREDUCEDSCALARBYTES","crypto_core_ed25519_SCALARBYTES","crypto_core_ed25519_UNIFORMBYTES","crypto_core_hchacha20_CONSTBYTES","crypto_core_hchacha20_INPUTBYTES","crypto_core_hchacha20_KEYBYTES","crypto_core_hchacha20_OUTPUTBYTES","crypto_core_hsalsa20_CONSTBYTES","crypto_core_hsalsa20_INPUTBYTES","crypto_core_hsalsa20_KEYBYTES","crypto_core_hsalsa20_OUTPUTBYTES","crypto_core_ristretto255_BYTES","crypto_core_ristretto255_HASHBYTES","crypto_core_ristretto255_NONREDUCEDSCALARBYTES","crypto_core_ristretto255_SCALARBYTES","crypto_core_salsa2012_CONSTBYTES","crypto_core_salsa2012_INPUTBYTES","crypto_core_salsa2012_KEYBYTES","crypto_core_salsa2012_OUTPUTBYTES","crypto_core_salsa20_CONSTBYTES","crypto_core_salsa20_INPUTBYTES","crypto_core_salsa20_KEYBYTES","crypto_core_salsa20_OUTPUTBYTES","crypto_generichash_BYTES","crypto_generichash_BYTES_MAX","crypto_generichash_BYTES_MIN","crypto_generichash_KEYBYTES","crypto_generichash_KEYBYTES_MAX","crypto_generichash_KEYBYTES_MIN","crypto_generichash_blake2b_BYTES","crypto_generichash_blake2b_BYTES_MAX","crypto_generichash_blake2b_BYTES_MIN","crypto_generichash_blake2b_KEYBYTES","crypto_generichash_blake2b_KEYBYTES_MAX","crypto_generichash_blake2b_KEYBYTES_MIN","crypto_generichash_blake2b_PERSONALBYTES","crypto_generichash_blake2b_SALTBYTES","crypto_hash_BYTES","crypto_hash_sha256_BYTES","crypto_hash_sha512_BYTES","crypto_kdf_BYTES_MAX","crypto_kdf_BYTES_MIN","crypto_kdf_CONTEXTBYTES","crypto_kdf_KEYBYTES","crypto_kdf_blake2b_BYTES_MAX","crypto_kdf_blake2b_BYTES_MIN","crypto_kdf_blake2b_CONTEXTBYTES","crypto_kdf_blake2b_KEYBYTES","crypto_kx_PUBLICKEYBYTES","crypto_kx_SECRETKEYBYTES","crypto_kx_SEEDBYTES","crypto_kx_SESSIONKEYBYTES","crypto_onetimeauth_BYTES","crypto_onetimeauth_KEYBYTES","crypto_onetimeauth_poly1305_BYTES","crypto_onetimeauth_poly1305_KEYBYTES","crypto_pwhash_ALG_ARGON2I13","crypto_pwhash_ALG_ARGON2ID13","crypto_pwhash_ALG_DEFAULT","crypto_pwhash_BYTES_MAX","crypto_pwhash_BYTES_MIN","crypto_pwhash_MEMLIMIT_INTERACTIVE","crypto_pwhash_MEMLIMIT_MAX","crypto_pwhash_MEMLIMIT_MIN","crypto_pwhash_MEMLIMIT_MODERATE","crypto_pwhash_MEMLIMIT_SENSITIVE","crypto_pwhash_OPSLIMIT_INTERACTIVE","crypto_pwhash_OPSLIMIT_MAX","crypto_pwhash_OPSLIMIT_MIN","crypto_pwhash_OPSLIMIT_MODERATE","crypto_pwhash_OPSLIMIT_SENSITIVE","crypto_pwhash_PASSWD_MAX","crypto_pwhash_PASSWD_MIN","crypto_pwhash_SALTBYTES","crypto_pwhash_STRBYTES","crypto_pwhash_argon2i_BYTES_MAX","crypto_pwhash_argon2i_BYTES_MIN","crypto_pwhash_argon2i_SALTBYTES","crypto_pwhash_argon2i_STRBYTES","crypto_pwhash_argon2id_BYTES_MAX","crypto_pwhash_argon2id_BYTES_MIN","crypto_pwhash_argon2id_SALTBYTES","crypto_pwhash_argon2id_STRBYTES","crypto_pwhash_scryptsalsa208sha256_BYTES_MAX","crypto_pwhash_scryptsalsa208sha256_BYTES_MIN","crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE","crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MAX","crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MIN","crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE","crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE","crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MAX","crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MIN","crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE","crypto_pwhash_scryptsalsa208sha256_SALTBYTES","crypto_pwhash_scryptsalsa208sha256_STRBYTES","crypto_scalarmult_BYTES","crypto_scalarmult_SCALARBYTES","crypto_scalarmult_curve25519_BYTES","crypto_scalarmult_curve25519_SCALARBYTES","crypto_scalarmult_ed25519_BYTES","crypto_scalarmult_ed25519_SCALARBYTES","crypto_scalarmult_ristretto255_BYTES","crypto_scalarmult_ristretto255_SCALARBYTES","crypto_secretbox_KEYBYTES","crypto_secretbox_MACBYTES","crypto_secretbox_MESSAGEBYTES_MAX","crypto_secretbox_NONCEBYTES","crypto_secretbox_xchacha20poly1305_KEYBYTES","crypto_secretbox_xchacha20poly1305_MACBYTES","crypto_secretbox_xchacha20poly1305_MESSAGEBYTES_MAX","crypto_secretbox_xchacha20poly1305_NONCEBYTES","crypto_secretbox_xsalsa20poly1305_KEYBYTES","crypto_secretbox_xsalsa20poly1305_MACBYTES","crypto_secretbox_xsalsa20poly1305_MESSAGEBYTES_MAX","crypto_secretbox_xsalsa20poly1305_NONCEBYTES","crypto_secretstream_xchacha20poly1305_ABYTES","crypto_secretstream_xchacha20poly1305_HEADERBYTES","crypto_secretstream_xchacha20poly1305_KEYBYTES","crypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX","crypto_secretstream_xchacha20poly1305_TAG_FINAL","crypto_secretstream_xchacha20poly1305_TAG_MESSAGE","crypto_secretstream_xchacha20poly1305_TAG_PUSH","crypto_secretstream_xchacha20poly1305_TAG_REKEY","crypto_shorthash_BYTES","crypto_shorthash_KEYBYTES","crypto_shorthash_siphash24_BYTES","crypto_shorthash_siphash24_KEYBYTES","crypto_shorthash_siphashx24_BYTES","crypto_shorthash_siphashx24_KEYBYTES","crypto_sign_BYTES","crypto_sign_MESSAGEBYTES_MAX","crypto_sign_PUBLICKEYBYTES","crypto_sign_SECRETKEYBYTES","crypto_sign_SEEDBYTES","crypto_sign_ed25519_BYTES","crypto_sign_ed25519_MESSAGEBYTES_MAX","crypto_sign_ed25519_PUBLICKEYBYTES","crypto_sign_ed25519_SECRETKEYBYTES","crypto_sign_ed25519_SEEDBYTES","crypto_stream_KEYBYTES","crypto_stream_MESSAGEBYTES_MAX","crypto_stream_NONCEBYTES","crypto_stream_chacha20_IETF_KEYBYTES","crypto_stream_chacha20_IETF_MESSAGEBYTES_MAX","crypto_stream_chacha20_IETF_NONCEBYTES","crypto_stream_chacha20_KEYBYTES","crypto_stream_chacha20_MESSAGEBYTES_MAX","crypto_stream_chacha20_NONCEBYTES","crypto_stream_chacha20_ietf_KEYBYTES","crypto_stream_chacha20_ietf_MESSAGEBYTES_MAX","crypto_stream_chacha20_ietf_NONCEBYTES","crypto_stream_salsa2012_KEYBYTES","crypto_stream_salsa2012_MESSAGEBYTES_MAX","crypto_stream_salsa2012_NONCEBYTES","crypto_stream_salsa208_KEYBYTES","crypto_stream_salsa208_MESSAGEBYTES_MAX","crypto_stream_salsa208_NONCEBYTES","crypto_stream_salsa20_KEYBYTES","crypto_stream_salsa20_MESSAGEBYTES_MAX","crypto_stream_salsa20_NONCEBYTES","crypto_stream_xchacha20_KEYBYTES","crypto_stream_xchacha20_MESSAGEBYTES_MAX","crypto_stream_xchacha20_NONCEBYTES","crypto_stream_xsalsa20_KEYBYTES","crypto_stream_xsalsa20_MESSAGEBYTES_MAX","crypto_stream_xsalsa20_NONCEBYTES","crypto_verify_16_BYTES","crypto_verify_32_BYTES","crypto_verify_64_BYTES"];for(_=0;_<s.length;_++)"function"==typeof(c=t["_"+s[_].toLowerCase()])&&(e[s[_]]=c());var n=["SODIUM_VERSION_STRING","crypto_pwhash_STRPREFIX","crypto_pwhash_scryptsalsa208sha256_STRPREFIX"];for(_=0;_<n.length;_++){var c;"function"==typeof(c=t["_"+n[_].toLowerCase()])&&(e[n[_]]=t.UTF8ToString(c()))}}t=r;try{a();var _=new Uint8Array([98,97,108,108,115]),s=e.randombytes_buf(e.crypto_secretbox_NONCEBYTES),n=e.randombytes_buf(e.crypto_secretbox_KEYBYTES),c=e.crypto_secretbox_easy(_,s,n),o=e.crypto_secretbox_open_easy(c,s,n);if(e.memcmp(_,o))return}catch(e){if(null==t.useBackupModule)throw new Error("Both wasm and asm failed to load"+e)}t.useBackupModule(),a()}));function _(e){if("function"==typeof TextEncoder)return(new TextEncoder).encode(e);e=unescape(encodeURIComponent(e));for(var r=new Uint8Array(e.length),t=0,a=e.length;t<a;t++)r[t]=e.charCodeAt(t);return r}function s(e){if("function"==typeof TextDecoder)return new TextDecoder("utf-8",{fatal:!0}).decode(e);var r=8192,t=Math.ceil(e.length/r);if(t<=1)try{return decodeURIComponent(escape(String.fromCharCode.apply(null,e)))}catch(e){throw new TypeError("The encoded data was not valid.")}for(var a="",_=0,n=0;n<t;n++){var c=Array.prototype.slice.call(e,n*r+_,(n+1)*r+_);if(0!=c.length){var o,h=c.length,p=0;do{var y=c[--h];y>=240?(p=4,o=!0):y>=224?(p=3,o=!0):y>=192?(p=2,o=!0):y<128&&(p=1,o=!0)}while(!o);for(var i=p-(c.length-h),l=0;l<i;l++)_--,c.pop();a+=s(c)}}return a}function n(e){e=m(null,e,"input");for(var r,t,a,_="",s=0;s<e.length;s++)a=87+(t=15&e[s])+(t-10>>8&-39)<<8|87+(r=e[s]>>>4)+(r-10>>8&-39),_+=String.fromCharCode(255&a)+String.fromCharCode(a>>>8);return _}var c={ORIGINAL:1,ORIGINAL_NO_PADDING:3,URLSAFE:5,URLSAFE_NO_PADDING:7};function o(e){if(null==e)return c.URLSAFE_NO_PADDING;if(e!==c.ORIGINAL&&e!==c.ORIGINAL_NO_PADDING&&e!==c.URLSAFE&&e!=c.URLSAFE_NO_PADDING)throw new Error("unsupported base64 variant");return e}function h(e,r){r=o(r),e=m(_,e,"input");var a,_=[],n=0|Math.floor(e.length/3),c=e.length-3*n,h=4*n+(0!==c?0==(2&r)?4:2+(c>>>1):0),p=new l(h+1),y=u(e);return _.push(y),_.push(p.address),0===t._sodium_bin2base64(p.address,p.length,y,e.length,r)&&g(_,"conversion failed"),p.length=h,a=s(p.to_Uint8Array()),v(_),a}function p(e,r){var t=r||"uint8array";if(!y(t))throw new Error(t+" output format is not available");if(e instanceof l){if("uint8array"===t)return e.to_Uint8Array();if("text"===t)return s(e.to_Uint8Array());if("hex"===t)return n(e.to_Uint8Array());if("base64"===t)return h(e.to_Uint8Array(),c.URLSAFE_NO_PADDING);throw new Error('What is output format "'+t+'"?')}if("object"==typeof e){for(var a=Object.keys(e),_={},o=0;o<a.length;o++)_[a[o]]=p(e[a[o]],t);return _}if("string"==typeof e)return e;throw new TypeError("Cannot format output")}function y(e){for(var r=["uint8array","text","hex","base64"],t=0;t<r.length;t++)if(r[t]===e)return!0;return!1}function i(e){if(e){if("string"!=typeof e)throw new TypeError("When defined, the output format must be a string");if(!y(e))throw new Error(e+" is not a supported output format")}}function l(e){this.length=e,this.address=d(e)}function u(e){var r=d(e.length);return t.HEAPU8.set(e,r),r}function d(e){var r=t._malloc(e);if(0===r)throw{message:"_malloc() failed",length:e};return r}function v(e){if(e)for(var r=0;r<e.length;r++)a=e[r],t._free(a);var a}function g(e,r){throw v(e),new Error(r)}function b(e,r){throw v(e),new TypeError(r)}function f(e,r,t){null==r&&b(e,t+" cannot be null or undefined")}function m(e,r,t){return f(e,r,t),r instanceof Uint8Array?r:"string"==typeof r?_(r):void b(e,"unsupported input type for "+t)}function E(e,r,a,_,s,n){var c=[];i(n);var o=null;null!=e&&(o=u(e=m(c,e,"secret_nonce")),e.length,c.push(o)),r=m(c,r,"ciphertext");var h,y=t._crypto_aead_chacha20poly1305_abytes(),d=r.length;d<y&&b(c,"ciphertext is too short"),h=u(r),c.push(h);var f=null,E=0;null!=a&&(f=u(a=m(c,a,"additional_data")),E=a.length,c.push(f)),_=m(c,_,"public_nonce");var x,k=0|t._crypto_aead_chacha20poly1305_npubbytes();_.length!==k&&b(c,"invalid public_nonce length"),x=u(_),c.push(x),s=m(c,s,"key");var S,T=0|t._crypto_aead_chacha20poly1305_keybytes();s.length!==T&&b(c,"invalid key length"),S=u(s),c.push(S);var w=new l(d-t._crypto_aead_chacha20poly1305_abytes()|0),Y=w.address;if(c.push(Y),0===t._crypto_aead_chacha20poly1305_decrypt(Y,null,o,h,d,0,f,E,0,x,S)){var B=p(w,n);return v(c),B}g(c,"ciphertext cannot be decrypted using that key")}function x(e,r,a,_,s,n,c){var o=[];i(c);var h=null;null!=e&&(h=u(e=m(o,e,"secret_nonce")),e.length,o.push(h));var y=u(r=m(o,r,"ciphertext")),d=r.length;o.push(y),a=m(o,a,"mac");var f,E=0|t._crypto_box_macbytes();a.length!==E&&b(o,"invalid mac length"),f=u(a),o.push(f);var x=null,k=0;null!=_&&(x=u(_=m(o,_,"additional_data")),k=_.length,o.push(x)),s=m(o,s,"public_nonce");var S,T=0|t._crypto_aead_chacha20poly1305_npubbytes();s.length!==T&&b(o,"invalid public_nonce length"),S=u(s),o.push(S),n=m(o,n,"key");var w,Y=0|t._crypto_aead_chacha20poly1305_keybytes();n.length!==Y&&b(o,"invalid key length"),w=u(n),o.push(w);var B=new l(0|d),A=B.address;if(o.push(A),0===t._crypto_aead_chacha20poly1305_decrypt_detached(A,h,y,d,0,f,x,k,0,S,w)){var K=p(B,c);return v(o),K}g(o,"ciphertext cannot be decrypted using that key")}function k(e,r,a,_,s,n){var c=[];i(n);var o=u(e=m(c,e,"message")),h=e.length;c.push(o);var y=null,d=0;null!=r&&(y=u(r=m(c,r,"additional_data")),d=r.length,c.push(y));var f=null;null!=a&&(f=u(a=m(c,a,"secret_nonce")),a.length,c.push(f)),_=m(c,_,"public_nonce");var E,x=0|t._crypto_aead_chacha20poly1305_npubbytes();_.length!==x&&b(c,"invalid public_nonce length"),E=u(_),c.push(E),s=m(c,s,"key");var k,S=0|t._crypto_aead_chacha20poly1305_keybytes();s.length!==S&&b(c,"invalid key length"),k=u(s),c.push(k);var T=new l(h+t._crypto_aead_chacha20poly1305_abytes()|0),w=T.address;if(c.push(w),0===t._crypto_aead_chacha20poly1305_encrypt(w,null,o,h,0,y,d,0,f,E,k)){var Y=p(T,n);return v(c),Y}g(c,"invalid usage")}function S(e,r,a,_,s,n){var c=[];i(n);var o=u(e=m(c,e,"message")),h=e.length;c.push(o);var y=null,d=0;null!=r&&(y=u(r=m(c,r,"additional_data")),d=r.length,c.push(y));var f=null;null!=a&&(f=u(a=m(c,a,"secret_nonce")),a.length,c.push(f)),_=m(c,_,"public_nonce");var E,x=0|t._crypto_aead_chacha20poly1305_npubbytes();_.length!==x&&b(c,"invalid public_nonce length"),E=u(_),c.push(E),s=m(c,s,"key");var k,S=0|t._crypto_aead_chacha20poly1305_keybytes();s.length!==S&&b(c,"invalid key length"),k=u(s),c.push(k);var T=new l(0|h),w=T.address;c.push(w);var Y=new l(0|t._crypto_aead_chacha20poly1305_abytes()),B=Y.address;if(c.push(B),0===t._crypto_aead_chacha20poly1305_encrypt_detached(w,B,null,o,h,0,y,d,0,f,E,k)){var A=p({ciphertext:T,mac:Y},n);return v(c),A}g(c,"invalid usage")}function T(e,r,a,_,s,n){var c=[];i(n);var o=null;null!=e&&(o=u(e=m(c,e,"secret_nonce")),e.length,c.push(o)),r=m(c,r,"ciphertext");var h,y=t._crypto_aead_chacha20poly1305_ietf_abytes(),d=r.length;d<y&&b(c,"ciphertext is too short"),h=u(r),c.push(h);var f=null,E=0;null!=a&&(f=u(a=m(c,a,"additional_data")),E=a.length,c.push(f)),_=m(c,_,"public_nonce");var x,k=0|t._crypto_aead_chacha20poly1305_ietf_npubbytes();_.length!==k&&b(c,"invalid public_nonce length"),x=u(_),c.push(x),s=m(c,s,"key");var S,T=0|t._crypto_aead_chacha20poly1305_ietf_keybytes();s.length!==T&&b(c,"invalid key length"),S=u(s),c.push(S);var w=new l(d-t._crypto_aead_chacha20poly1305_ietf_abytes()|0),Y=w.address;if(c.push(Y),0===t._crypto_aead_chacha20poly1305_ietf_decrypt(Y,null,o,h,d,0,f,E,0,x,S)){var B=p(w,n);return v(c),B}g(c,"ciphertext cannot be decrypted using that key")}function w(e,r,a,_,s,n,c){var o=[];i(c);var h=null;null!=e&&(h=u(e=m(o,e,"secret_nonce")),e.length,o.push(h));var y=u(r=m(o,r,"ciphertext")),d=r.length;o.push(y),a=m(o,a,"mac");var f,E=0|t._crypto_box_macbytes();a.length!==E&&b(o,"invalid mac length"),f=u(a),o.push(f);var x=null,k=0;null!=_&&(x=u(_=m(o,_,"additional_data")),k=_.length,o.push(x)),s=m(o,s,"public_nonce");var S,T=0|t._crypto_aead_chacha20poly1305_ietf_npubbytes();s.length!==T&&b(o,"invalid public_nonce length"),S=u(s),o.push(S),n=m(o,n,"key");var w,Y=0|t._crypto_aead_chacha20poly1305_ietf_keybytes();n.length!==Y&&b(o,"invalid key length"),w=u(n),o.push(w);var B=new l(0|d),A=B.address;if(o.push(A),0===t._crypto_aead_chacha20poly1305_ietf_decrypt_detached(A,h,y,d,0,f,x,k,0,S,w)){var K=p(B,c);return v(o),K}g(o,"ciphertext cannot be decrypted using that key")}function Y(e,r,a,_,s,n){var c=[];i(n);var o=u(e=m(c,e,"message")),h=e.length;c.push(o);var y=null,d=0;null!=r&&(y=u(r=m(c,r,"additional_data")),d=r.length,c.push(y));var f=null;null!=a&&(f=u(a=m(c,a,"secret_nonce")),a.length,c.push(f)),_=m(c,_,"public_nonce");var E,x=0|t._crypto_aead_chacha20poly1305_ietf_npubbytes();_.length!==x&&b(c,"invalid public_nonce length"),E=u(_),c.push(E),s=m(c,s,"key");var k,S=0|t._crypto_aead_chacha20poly1305_ietf_keybytes();s.length!==S&&b(c,"invalid key length"),k=u(s),c.push(k);var T=new l(h+t._crypto_aead_chacha20poly1305_ietf_abytes()|0),w=T.address;if(c.push(w),0===t._crypto_aead_chacha20poly1305_ietf_encrypt(w,null,o,h,0,y,d,0,f,E,k)){var Y=p(T,n);return v(c),Y}g(c,"invalid usage")}function B(e,r,a,_,s,n){var c=[];i(n);var o=u(e=m(c,e,"message")),h=e.length;c.push(o);var y=null,d=0;null!=r&&(y=u(r=m(c,r,"additional_data")),d=r.length,c.push(y));var f=null;null!=a&&(f=u(a=m(c,a,"secret_nonce")),a.length,c.push(f)),_=m(c,_,"public_nonce");var E,x=0|t._crypto_aead_chacha20poly1305_ietf_npubbytes();_.length!==x&&b(c,"invalid public_nonce length"),E=u(_),c.push(E),s=m(c,s,"key");var k,S=0|t._crypto_aead_chacha20poly1305_ietf_keybytes();s.length!==S&&b(c,"invalid key length"),k=u(s),c.push(k);var T=new l(0|h),w=T.address;c.push(w);var Y=new l(0|t._crypto_aead_chacha20poly1305_ietf_abytes()),B=Y.address;if(c.push(B),0===t._crypto_aead_chacha20poly1305_ietf_encrypt_detached(w,B,null,o,h,0,y,d,0,f,E,k)){var A=p({ciphertext:T,mac:Y},n);return v(c),A}g(c,"invalid usage")}function A(e){var r=[];i(e);var a=new l(0|t._crypto_aead_chacha20poly1305_ietf_keybytes()),_=a.address;r.push(_),t._crypto_aead_chacha20poly1305_ietf_keygen(_);var s=p(a,e);return v(r),s}function K(e){var r=[];i(e);var a=new l(0|t._crypto_aead_chacha20poly1305_keybytes()),_=a.address;r.push(_),t._crypto_aead_chacha20poly1305_keygen(_);var s=p(a,e);return v(r),s}function M(e,r,a,_,s,n){var c=[];i(n);var o=null;null!=e&&(o=u(e=m(c,e,"secret_nonce")),e.length,c.push(o)),r=m(c,r,"ciphertext");var h,y=t._crypto_aead_xchacha20poly1305_ietf_abytes(),d=r.length;d<y&&b(c,"ciphertext is too short"),h=u(r),c.push(h);var f=null,E=0;null!=a&&(f=u(a=m(c,a,"additional_data")),E=a.length,c.push(f)),_=m(c,_,"public_nonce");var x,k=0|t._crypto_aead_xchacha20poly1305_ietf_npubbytes();_.length!==k&&b(c,"invalid public_nonce length"),x=u(_),c.push(x),s=m(c,s,"key");var S,T=0|t._crypto_aead_xchacha20poly1305_ietf_keybytes();s.length!==T&&b(c,"invalid key length"),S=u(s),c.push(S);var w=new l(d-t._crypto_aead_xchacha20poly1305_ietf_abytes()|0),Y=w.address;if(c.push(Y),0===t._crypto_aead_xchacha20poly1305_ietf_decrypt(Y,null,o,h,d,0,f,E,0,x,S)){var B=p(w,n);return v(c),B}g(c,"ciphertext cannot be decrypted using that key")}function I(e,r,a,_,s,n,c){var o=[];i(c);var h=null;null!=e&&(h=u(e=m(o,e,"secret_nonce")),e.length,o.push(h));var y=u(r=m(o,r,"ciphertext")),d=r.length;o.push(y),a=m(o,a,"mac");var f,E=0|t._crypto_box_macbytes();a.length!==E&&b(o,"invalid mac length"),f=u(a),o.push(f);var x=null,k=0;null!=_&&(x=u(_=m(o,_,"additional_data")),k=_.length,o.push(x)),s=m(o,s,"public_nonce");var S,T=0|t._crypto_aead_xchacha20poly1305_ietf_npubbytes();s.length!==T&&b(o,"invalid public_nonce length"),S=u(s),o.push(S),n=m(o,n,"key");var w,Y=0|t._crypto_aead_xchacha20poly1305_ietf_keybytes();n.length!==Y&&b(o,"invalid key length"),w=u(n),o.push(w);var B=new l(0|d),A=B.address;if(o.push(A),0===t._crypto_aead_xchacha20poly1305_ietf_decrypt_detached(A,h,y,d,0,f,x,k,0,S,w)){var K=p(B,c);return v(o),K}g(o,"ciphertext cannot be decrypted using that key")}function N(e,r,a,_,s,n){var c=[];i(n);var o=u(e=m(c,e,"message")),h=e.length;c.push(o);var y=null,d=0;null!=r&&(y=u(r=m(c,r,"additional_data")),d=r.length,c.push(y));var f=null;null!=a&&(f=u(a=m(c,a,"secret_nonce")),a.length,c.push(f)),_=m(c,_,"public_nonce");var E,x=0|t._crypto_aead_xchacha20poly1305_ietf_npubbytes();_.length!==x&&b(c,"invalid public_nonce length"),E=u(_),c.push(E),s=m(c,s,"key");var k,S=0|t._crypto_aead_xchacha20poly1305_ietf_keybytes();s.length!==S&&b(c,"invalid key length"),k=u(s),c.push(k);var T=new l(h+t._crypto_aead_xchacha20poly1305_ietf_abytes()|0),w=T.address;if(c.push(w),0===t._crypto_aead_xchacha20poly1305_ietf_encrypt(w,null,o,h,0,y,d,0,f,E,k)){var Y=p(T,n);return v(c),Y}g(c,"invalid usage")}function L(e,r,a,_,s,n){var c=[];i(n);var o=u(e=m(c,e,"message")),h=e.length;c.push(o);var y=null,d=0;null!=r&&(y=u(r=m(c,r,"additional_data")),d=r.length,c.push(y));var f=null;null!=a&&(f=u(a=m(c,a,"secret_nonce")),a.length,c.push(f)),_=m(c,_,"public_nonce");var E,x=0|t._crypto_aead_xchacha20poly1305_ietf_npubbytes();_.length!==x&&b(c,"invalid public_nonce length"),E=u(_),c.push(E),s=m(c,s,"key");var k,S=0|t._crypto_aead_xchacha20poly1305_ietf_keybytes();s.length!==S&&b(c,"invalid key length"),k=u(s),c.push(k);var T=new l(0|h),w=T.address;c.push(w);var Y=new l(0|t._crypto_aead_xchacha20poly1305_ietf_abytes()),B=Y.address;if(c.push(B),0===t._crypto_aead_xchacha20poly1305_ietf_encrypt_detached(w,B,null,o,h,0,y,d,0,f,E,k)){var A=p({ciphertext:T,mac:Y},n);return v(c),A}g(c,"invalid usage")}function U(e){var r=[];i(e);var a=new l(0|t._crypto_aead_xchacha20poly1305_ietf_keybytes()),_=a.address;r.push(_),t._crypto_aead_xchacha20poly1305_ietf_keygen(_);var s=p(a,e);return v(r),s}function O(e,r,a){var _=[];i(a);var s=u(e=m(_,e,"message")),n=e.length;_.push(s),r=m(_,r,"key");var c,o=0|t._crypto_auth_keybytes();r.length!==o&&b(_,"invalid key length"),c=u(r),_.push(c);var h=new l(0|t._crypto_auth_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_auth(y,s,n,0,c))){var d=p(h,a);return v(_),d}g(_,"invalid usage")}function C(e,r,a){var _=[];i(a);var s=u(e=m(_,e,"message")),n=e.length;_.push(s),r=m(_,r,"key");var c,o=0|t._crypto_auth_hmacsha256_keybytes();r.length!==o&&b(_,"invalid key length"),c=u(r),_.push(c);var h=new l(0|t._crypto_auth_hmacsha256_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_auth_hmacsha256(y,s,n,0,c))){var d=p(h,a);return v(_),d}g(_,"invalid usage")}function R(e,r){var a=[];i(r),f(a,e,"state_address");var _=new l(0|t._crypto_auth_hmacsha256_bytes()),s=_.address;if(a.push(s),0==(0|t._crypto_auth_hmacsha256_final(e,s))){var n=(t._free(e),p(_,r));return v(a),n}g(a,"invalid usage")}function P(e,r){var a=[];i(r);var _=null,s=0;null!=e&&(_=u(e=m(a,e,"key")),s=e.length,a.push(_));var n=new l(208).address;if(0==(0|t._crypto_auth_hmacsha256_init(n,_,s))){var c=n;return v(a),c}g(a,"invalid usage")}function G(e){var r=[];i(e);var a=new l(0|t._crypto_auth_hmacsha256_keybytes()),_=a.address;r.push(_),t._crypto_auth_hmacsha256_keygen(_);var s=p(a,e);return v(r),s}function X(e,r,a){var _=[];i(a),f(_,e,"state_address");var s=u(r=m(_,r,"message_chunk")),n=r.length;_.push(s),0!=(0|t._crypto_auth_hmacsha256_update(e,s,n))&&g(_,"invalid usage"),v(_)}function D(e,r,a){var _=[];e=m(_,e,"tag");var s,n=0|t._crypto_auth_hmacsha256_bytes();e.length!==n&&b(_,"invalid tag length"),s=u(e),_.push(s);var c=u(r=m(_,r,"message")),o=r.length;_.push(c),a=m(_,a,"key");var h,p=0|t._crypto_auth_hmacsha256_keybytes();a.length!==p&&b(_,"invalid key length"),h=u(a),_.push(h);var y=0==(0|t._crypto_auth_hmacsha256_verify(s,c,o,0,h));return v(_),y}function F(e,r,a){var _=[];i(a);var s=u(e=m(_,e,"message")),n=e.length;_.push(s),r=m(_,r,"key");var c,o=0|t._crypto_auth_hmacsha512_keybytes();r.length!==o&&b(_,"invalid key length"),c=u(r),_.push(c);var h=new l(0|t._crypto_auth_hmacsha512_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_auth_hmacsha512(y,s,n,0,c))){var d=p(h,a);return v(_),d}g(_,"invalid usage")}function V(e,r){var a=[];i(r),f(a,e,"state_address");var _=new l(0|t._crypto_auth_hmacsha512_bytes()),s=_.address;if(a.push(s),0==(0|t._crypto_auth_hmacsha512_final(e,s))){var n=(t._free(e),p(_,r));return v(a),n}g(a,"invalid usage")}function H(e,r){var a=[];i(r);var _=null,s=0;null!=e&&(_=u(e=m(a,e,"key")),s=e.length,a.push(_));var n=new l(416).address;if(0==(0|t._crypto_auth_hmacsha512_init(n,_,s))){var c=n;return v(a),c}g(a,"invalid usage")}function q(e){var r=[];i(e);var a=new l(0|t._crypto_auth_hmacsha512_keybytes()),_=a.address;r.push(_),t._crypto_auth_hmacsha512_keygen(_);var s=p(a,e);return v(r),s}function j(e,r,a){var _=[];i(a),f(_,e,"state_address");var s=u(r=m(_,r,"message_chunk")),n=r.length;_.push(s),0!=(0|t._crypto_auth_hmacsha512_update(e,s,n))&&g(_,"invalid usage"),v(_)}function z(e,r,a){var _=[];e=m(_,e,"tag");var s,n=0|t._crypto_auth_hmacsha512_bytes();e.length!==n&&b(_,"invalid tag length"),s=u(e),_.push(s);var c=u(r=m(_,r,"message")),o=r.length;_.push(c),a=m(_,a,"key");var h,p=0|t._crypto_auth_hmacsha512_keybytes();a.length!==p&&b(_,"invalid key length"),h=u(a),_.push(h);var y=0==(0|t._crypto_auth_hmacsha512_verify(s,c,o,0,h));return v(_),y}function W(e){var r=[];i(e);var a=new l(0|t._crypto_auth_keybytes()),_=a.address;r.push(_),t._crypto_auth_keygen(_);var s=p(a,e);return v(r),s}function J(e,r,a){var _=[];e=m(_,e,"tag");var s,n=0|t._crypto_auth_bytes();e.length!==n&&b(_,"invalid tag length"),s=u(e),_.push(s);var c=u(r=m(_,r,"message")),o=r.length;_.push(c),a=m(_,a,"key");var h,p=0|t._crypto_auth_keybytes();a.length!==p&&b(_,"invalid key length"),h=u(a),_.push(h);var y=0==(0|t._crypto_auth_verify(s,c,o,0,h));return v(_),y}function Q(e,r,a){var _=[];i(a),e=m(_,e,"publicKey");var s,n=0|t._crypto_box_publickeybytes();e.length!==n&&b(_,"invalid publicKey length"),s=u(e),_.push(s),r=m(_,r,"privateKey");var c,o=0|t._crypto_box_secretkeybytes();r.length!==o&&b(_,"invalid privateKey length"),c=u(r),_.push(c);var h=new l(0|t._crypto_box_beforenmbytes()),y=h.address;if(_.push(y),0==(0|t._crypto_box_beforenm(y,s,c))){var d=p(h,a);return v(_),d}g(_,"invalid usage")}function Z(e){var r=[];i(e);var a=new l(0|t._crypto_box_curve25519xchacha20poly1305_publickeybytes()),_=a.address;r.push(_);var s=new l(0|t._crypto_box_curve25519xchacha20poly1305_secretkeybytes()),n=s.address;r.push(n),t._crypto_box_curve25519xchacha20poly1305_keypair(_,n);var c=p({publicKey:a,privateKey:s,keyType:"curve25519"},e);return v(r),c}function $(e,r,a){var _=[];i(a);var s=u(e=m(_,e,"message")),n=e.length;_.push(s),r=m(_,r,"publicKey");var c,o=0|t._crypto_box_curve25519xchacha20poly1305_publickeybytes();r.length!==o&&b(_,"invalid publicKey length"),c=u(r),_.push(c);var h=new l(n+t._crypto_box_curve25519xchacha20poly1305_sealbytes()|0),y=h.address;_.push(y),t._crypto_box_curve25519xchacha20poly1305_seal(y,s,n,0,c);var d=p(h,a);return v(_),d}function ee(e,r,a,_){var s=[];i(_),e=m(s,e,"ciphertext");var n,c=t._crypto_box_curve25519xchacha20poly1305_sealbytes(),o=e.length;o<c&&b(s,"ciphertext is too short"),n=u(e),s.push(n),r=m(s,r,"publicKey");var h,y=0|t._crypto_box_curve25519xchacha20poly1305_publickeybytes();r.length!==y&&b(s,"invalid publicKey length"),h=u(r),s.push(h),a=m(s,a,"secretKey");var d,g=0|t._crypto_box_curve25519xchacha20poly1305_secretkeybytes();a.length!==g&&b(s,"invalid secretKey length"),d=u(a),s.push(d);var f=new l(o-t._crypto_box_curve25519xchacha20poly1305_sealbytes()|0),E=f.address;s.push(E),t._crypto_box_curve25519xchacha20poly1305_seal_open(E,n,o,0,h,d);var x=p(f,_);return v(s),x}function re(e,r,a,_,s){var n=[];i(s);var c=u(e=m(n,e,"message")),o=e.length;n.push(c),r=m(n,r,"nonce");var h,y=0|t._crypto_box_noncebytes();r.length!==y&&b(n,"invalid nonce length"),h=u(r),n.push(h),a=m(n,a,"publicKey");var d,f=0|t._crypto_box_publickeybytes();a.length!==f&&b(n,"invalid publicKey length"),d=u(a),n.push(d),_=m(n,_,"privateKey");var E,x=0|t._crypto_box_secretkeybytes();_.length!==x&&b(n,"invalid privateKey length"),E=u(_),n.push(E);var k=new l(0|o),S=k.address;n.push(S);var T=new l(0|t._crypto_box_macbytes()),w=T.address;if(n.push(w),0==(0|t._crypto_box_detached(S,w,c,o,0,h,d,E))){var Y=p({ciphertext:k,mac:T},s);return v(n),Y}g(n,"invalid usage")}function te(e,r,a,_,s){var n=[];i(s);var c=u(e=m(n,e,"message")),o=e.length;n.push(c),r=m(n,r,"nonce");var h,y=0|t._crypto_box_noncebytes();r.length!==y&&b(n,"invalid nonce length"),h=u(r),n.push(h),a=m(n,a,"publicKey");var d,f=0|t._crypto_box_publickeybytes();a.length!==f&&b(n,"invalid publicKey length"),d=u(a),n.push(d),_=m(n,_,"privateKey");var E,x=0|t._crypto_box_secretkeybytes();_.length!==x&&b(n,"invalid privateKey length"),E=u(_),n.push(E);var k=new l(o+t._crypto_box_macbytes()|0),S=k.address;if(n.push(S),0==(0|t._crypto_box_easy(S,c,o,0,h,d,E))){var T=p(k,s);return v(n),T}g(n,"invalid usage")}function ae(e,r,a,_){var s=[];i(_);var n=u(e=m(s,e,"message")),c=e.length;s.push(n),r=m(s,r,"nonce");var o,h=0|t._crypto_box_noncebytes();r.length!==h&&b(s,"invalid nonce length"),o=u(r),s.push(o),a=m(s,a,"sharedKey");var y,d=0|t._crypto_box_beforenmbytes();a.length!==d&&b(s,"invalid sharedKey length"),y=u(a),s.push(y);var f=new l(c+t._crypto_box_macbytes()|0),E=f.address;if(s.push(E),0==(0|t._crypto_box_easy_afternm(E,n,c,0,o,y))){var x=p(f,_);return v(s),x}g(s,"invalid usage")}function _e(e){var r=[];i(e);var a=new l(0|t._crypto_box_publickeybytes()),_=a.address;r.push(_);var s=new l(0|t._crypto_box_secretkeybytes()),n=s.address;if(r.push(n),0==(0|t._crypto_box_keypair(_,n))){var c={publicKey:p(a,e),privateKey:p(s,e),keyType:"x25519"};return v(r),c}g(r,"internal error")}function se(e,r,a,_,s,n){var c=[];i(n);var o=u(e=m(c,e,"ciphertext")),h=e.length;c.push(o),r=m(c,r,"mac");var y,d=0|t._crypto_box_macbytes();r.length!==d&&b(c,"invalid mac length"),y=u(r),c.push(y),a=m(c,a,"nonce");var f,E=0|t._crypto_box_noncebytes();a.length!==E&&b(c,"invalid nonce length"),f=u(a),c.push(f),_=m(c,_,"publicKey");var x,k=0|t._crypto_box_publickeybytes();_.length!==k&&b(c,"invalid publicKey length"),x=u(_),c.push(x),s=m(c,s,"privateKey");var S,T=0|t._crypto_box_secretkeybytes();s.length!==T&&b(c,"invalid privateKey length"),S=u(s),c.push(S);var w=new l(0|h),Y=w.address;if(c.push(Y),0==(0|t._crypto_box_open_detached(Y,o,y,h,0,f,x,S))){var B=p(w,n);return v(c),B}g(c,"incorrect key pair for the given ciphertext")}function ne(e,r,a,_,s){var n=[];i(s),e=m(n,e,"ciphertext");var c,o=t._crypto_box_macbytes(),h=e.length;h<o&&b(n,"ciphertext is too short"),c=u(e),n.push(c),r=m(n,r,"nonce");var y,d=0|t._crypto_box_noncebytes();r.length!==d&&b(n,"invalid nonce length"),y=u(r),n.push(y),a=m(n,a,"publicKey");var f,E=0|t._crypto_box_publickeybytes();a.length!==E&&b(n,"invalid publicKey length"),f=u(a),n.push(f),_=m(n,_,"privateKey");var x,k=0|t._crypto_box_secretkeybytes();_.length!==k&&b(n,"invalid privateKey length"),x=u(_),n.push(x);var S=new l(h-t._crypto_box_macbytes()|0),T=S.address;if(n.push(T),0==(0|t._crypto_box_open_easy(T,c,h,0,y,f,x))){var w=p(S,s);return v(n),w}g(n,"incorrect key pair for the given ciphertext")}function ce(e,r,a,_){var s=[];i(_);var n=u(e=m(s,e,"ciphertext")),c=e.length;s.push(n),r=m(s,r,"nonce");var o,h=0|t._crypto_box_noncebytes();r.length!==h&&b(s,"invalid nonce length"),o=u(r),s.push(o),a=m(s,a,"sharedKey");var y,d=0|t._crypto_box_beforenmbytes();a.length!==d&&b(s,"invalid sharedKey length"),y=u(a),s.push(y);var f=new l(c-t._crypto_box_macbytes()|0),E=f.address;if(s.push(E),0==(0|t._crypto_box_open_easy_afternm(E,n,c,0,o,y))){var x=p(f,_);return v(s),x}g(s,"incorrect secret key for the given ciphertext")}function oe(e,r,a){var _=[];i(a);var s=u(e=m(_,e,"message")),n=e.length;_.push(s),r=m(_,r,"publicKey");var c,o=0|t._crypto_box_publickeybytes();r.length!==o&&b(_,"invalid publicKey length"),c=u(r),_.push(c);var h=new l(n+t._crypto_box_sealbytes()|0),y=h.address;if(_.push(y),0==(0|t._crypto_box_seal(y,s,n,0,c))){var d=p(h,a);return v(_),d}g(_,"invalid usage")}function he(e,r,a,_){var s=[];i(_),e=m(s,e,"ciphertext");var n,c=t._crypto_box_sealbytes(),o=e.length;o<c&&b(s,"ciphertext is too short"),n=u(e),s.push(n),r=m(s,r,"publicKey");var h,y=0|t._crypto_box_publickeybytes();r.length!==y&&b(s,"invalid publicKey length"),h=u(r),s.push(h),a=m(s,a,"privateKey");var d,f=0|t._crypto_box_secretkeybytes();a.length!==f&&b(s,"invalid privateKey length"),d=u(a),s.push(d);var E=new l(o-t._crypto_box_sealbytes()|0),x=E.address;if(s.push(x),0==(0|t._crypto_box_seal_open(x,n,o,0,h,d))){var k=p(E,_);return v(s),k}g(s,"incorrect key pair for the given ciphertext")}function pe(e,r){var a=[];i(r),e=m(a,e,"seed");var _,s=0|t._crypto_box_seedbytes();e.length!==s&&b(a,"invalid seed length"),_=u(e),a.push(_);var n=new l(0|t._crypto_box_publickeybytes()),c=n.address;a.push(c);var o=new l(0|t._crypto_box_secretkeybytes()),h=o.address;if(a.push(h),0==(0|t._crypto_box_seed_keypair(c,h,_))){var y={publicKey:p(n,r),privateKey:p(o,r),keyType:"x25519"};return v(a),y}g(a,"invalid usage")}function ye(e,r,a){var _=[];i(a),e=m(_,e,"p");var s,n=0|t._crypto_core_ed25519_bytes();e.length!==n&&b(_,"invalid p length"),s=u(e),_.push(s),r=m(_,r,"q");var c,o=0|t._crypto_core_ed25519_bytes();r.length!==o&&b(_,"invalid q length"),c=u(r),_.push(c);var h=new l(0|t._crypto_core_ed25519_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_core_ed25519_add(y,s,c))){var d=p(h,a);return v(_),d}g(_,"input is an invalid element")}function ie(e,r){var a=[];i(r);var _=u(e=m(a,e,"r"));e.length,a.push(_);var s=new l(0|t._crypto_core_ed25519_bytes()),n=s.address;if(a.push(n),0==(0|t._crypto_core_ed25519_from_hash(n,_))){var c=p(s,r);return v(a),c}g(a,"invalid usage")}function le(e,r){var a=[];i(r);var _=u(e=m(a,e,"r"));e.length,a.push(_);var s=new l(0|t._crypto_core_ed25519_bytes()),n=s.address;if(a.push(n),0==(0|t._crypto_core_ed25519_from_uniform(n,_))){var c=p(s,r);return v(a),c}g(a,"invalid usage")}function ue(e,r){var a=[];i(r),e=m(a,e,"repr");var _,s=0|t._crypto_core_ed25519_bytes();e.length!==s&&b(a,"invalid repr length"),_=u(e),a.push(_);var n=1==(0|t._crypto_core_ed25519_is_valid_point(_));return v(a),n}function de(e){var r=[];i(e);var a=new l(0|t._crypto_core_ed25519_bytes()),_=a.address;r.push(_),t._crypto_core_ed25519_random(_);var s=p(a,e);return v(r),s}function ve(e,r,a){var _=[];i(a),e=m(_,e,"x");var s,n=0|t._crypto_core_ed25519_scalarbytes();e.length!==n&&b(_,"invalid x length"),s=u(e),_.push(s),r=m(_,r,"y");var c,o=0|t._crypto_core_ed25519_scalarbytes();r.length!==o&&b(_,"invalid y length"),c=u(r),_.push(c);var h=new l(0|t._crypto_core_ed25519_scalarbytes()),y=h.address;_.push(y),t._crypto_core_ed25519_scalar_add(y,s,c);var d=p(h,a);return v(_),d}function ge(e,r){var a=[];i(r),e=m(a,e,"s");var _,s=0|t._crypto_core_ed25519_scalarbytes();e.length!==s&&b(a,"invalid s length"),_=u(e),a.push(_);var n=new l(0|t._crypto_core_ed25519_scalarbytes()),c=n.address;a.push(c),t._crypto_core_ed25519_scalar_complement(c,_);var o=p(n,r);return v(a),o}function be(e,r){var a=[];i(r),e=m(a,e,"s");var _,s=0|t._crypto_core_ed25519_scalarbytes();e.length!==s&&b(a,"invalid s length"),_=u(e),a.push(_);var n=new l(0|t._crypto_core_ed25519_scalarbytes()),c=n.address;if(a.push(c),0==(0|t._crypto_core_ed25519_scalar_invert(c,_))){var o=p(n,r);return v(a),o}g(a,"invalid reciprocate")}function fe(e,r,a){var _=[];i(a),e=m(_,e,"x");var s,n=0|t._crypto_core_ed25519_scalarbytes();e.length!==n&&b(_,"invalid x length"),s=u(e),_.push(s),r=m(_,r,"y");var c,o=0|t._crypto_core_ed25519_scalarbytes();r.length!==o&&b(_,"invalid y length"),c=u(r),_.push(c);var h=new l(0|t._crypto_core_ed25519_scalarbytes()),y=h.address;_.push(y),t._crypto_core_ed25519_scalar_mul(y,s,c);var d=p(h,a);return v(_),d}function me(e,r){var a=[];i(r),e=m(a,e,"s");var _,s=0|t._crypto_core_ed25519_scalarbytes();e.length!==s&&b(a,"invalid s length"),_=u(e),a.push(_);var n=new l(0|t._crypto_core_ed25519_scalarbytes()),c=n.address;a.push(c),t._crypto_core_ed25519_scalar_negate(c,_);var o=p(n,r);return v(a),o}function Ee(e){var r=[];i(e);var a=new l(0|t._crypto_core_ed25519_scalarbytes()),_=a.address;r.push(_),t._crypto_core_ed25519_scalar_random(_);var s=p(a,e);return v(r),s}function xe(e,r){var a=[];i(r),e=m(a,e,"sample");var _,s=0|t._crypto_core_ed25519_nonreducedscalarbytes();e.length!==s&&b(a,"invalid sample length"),_=u(e),a.push(_);var n=new l(0|t._crypto_core_ed25519_scalarbytes()),c=n.address;a.push(c),t._crypto_core_ed25519_scalar_reduce(c,_);var o=p(n,r);return v(a),o}function ke(e,r,a){var _=[];i(a),e=m(_,e,"x");var s,n=0|t._crypto_core_ed25519_scalarbytes();e.length!==n&&b(_,"invalid x length"),s=u(e),_.push(s),r=m(_,r,"y");var c,o=0|t._crypto_core_ed25519_scalarbytes();r.length!==o&&b(_,"invalid y length"),c=u(r),_.push(c);var h=new l(0|t._crypto_core_ed25519_scalarbytes()),y=h.address;_.push(y),t._crypto_core_ed25519_scalar_sub(y,s,c);var d=p(h,a);return v(_),d}function Se(e,r,a){var _=[];i(a),e=m(_,e,"p");var s,n=0|t._crypto_core_ed25519_bytes();e.length!==n&&b(_,"invalid p length"),s=u(e),_.push(s),r=m(_,r,"q");var c,o=0|t._crypto_core_ed25519_bytes();r.length!==o&&b(_,"invalid q length"),c=u(r),_.push(c);var h=new l(0|t._crypto_core_ed25519_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_core_ed25519_sub(y,s,c))){var d=p(h,a);return v(_),d}g(_,"input is an invalid element")}function Te(e,r,a,_){var s=[];i(_),e=m(s,e,"input");var n,c=0|t._crypto_core_hchacha20_inputbytes();e.length!==c&&b(s,"invalid input length"),n=u(e),s.push(n),r=m(s,r,"privateKey");var o,h=0|t._crypto_core_hchacha20_keybytes();r.length!==h&&b(s,"invalid privateKey length"),o=u(r),s.push(o);var y=null;null!=a&&(y=u(a=m(s,a,"constant")),a.length,s.push(y));var d=new l(0|t._crypto_core_hchacha20_outputbytes()),f=d.address;if(s.push(f),0==(0|t._crypto_core_hchacha20(f,n,o,y))){var E=p(d,_);return v(s),E}g(s,"invalid usage")}function we(e,r,a,_){var s=[];i(_),e=m(s,e,"input");var n,c=0|t._crypto_core_hsalsa20_inputbytes();e.length!==c&&b(s,"invalid input length"),n=u(e),s.push(n),r=m(s,r,"privateKey");var o,h=0|t._crypto_core_hsalsa20_keybytes();r.length!==h&&b(s,"invalid privateKey length"),o=u(r),s.push(o);var y=null;null!=a&&(y=u(a=m(s,a,"constant")),a.length,s.push(y));var d=new l(0|t._crypto_core_hsalsa20_outputbytes()),f=d.address;if(s.push(f),0==(0|t._crypto_core_hsalsa20(f,n,o,y))){var E=p(d,_);return v(s),E}g(s,"invalid usage")}function Ye(e,r,a){var _=[];i(a),e=m(_,e,"p");var s,n=0|t._crypto_core_ristretto255_bytes();e.length!==n&&b(_,"invalid p length"),s=u(e),_.push(s),r=m(_,r,"q");var c,o=0|t._crypto_core_ristretto255_bytes();r.length!==o&&b(_,"invalid q length"),c=u(r),_.push(c);var h=new l(0|t._crypto_core_ristretto255_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_core_ristretto255_add(y,s,c))){var d=p(h,a);return v(_),d}g(_,"input is an invalid element")}function Be(e,r){var a=[];i(r);var _=u(e=m(a,e,"r"));e.length,a.push(_);var s=new l(0|t._crypto_core_ristretto255_bytes()),n=s.address;if(a.push(n),0==(0|t._crypto_core_ristretto255_from_hash(n,_))){var c=p(s,r);return v(a),c}g(a,"invalid usage")}function Ae(e,r){var a=[];i(r),e=m(a,e,"repr");var _,s=0|t._crypto_core_ristretto255_bytes();e.length!==s&&b(a,"invalid repr length"),_=u(e),a.push(_);var n=1==(0|t._crypto_core_ristretto255_is_valid_point(_));return v(a),n}function Ke(e){var r=[];i(e);var a=new l(0|t._crypto_core_ristretto255_bytes()),_=a.address;r.push(_),t._crypto_core_ristretto255_random(_);var s=p(a,e);return v(r),s}function Me(e,r,a){var _=[];i(a),e=m(_,e,"x");var s,n=0|t._crypto_core_ristretto255_scalarbytes();e.length!==n&&b(_,"invalid x length"),s=u(e),_.push(s),r=m(_,r,"y");var c,o=0|t._crypto_core_ristretto255_scalarbytes();r.length!==o&&b(_,"invalid y length"),c=u(r),_.push(c);var h=new l(0|t._crypto_core_ristretto255_scalarbytes()),y=h.address;_.push(y),t._crypto_core_ristretto255_scalar_add(y,s,c);var d=p(h,a);return v(_),d}function Ie(e,r){var a=[];i(r),e=m(a,e,"s");var _,s=0|t._crypto_core_ristretto255_scalarbytes();e.length!==s&&b(a,"invalid s length"),_=u(e),a.push(_);var n=new l(0|t._crypto_core_ristretto255_scalarbytes()),c=n.address;a.push(c),t._crypto_core_ristretto255_scalar_complement(c,_);var o=p(n,r);return v(a),o}function Ne(e,r){var a=[];i(r),e=m(a,e,"s");var _,s=0|t._crypto_core_ristretto255_scalarbytes();e.length!==s&&b(a,"invalid s length"),_=u(e),a.push(_);var n=new l(0|t._crypto_core_ristretto255_scalarbytes()),c=n.address;if(a.push(c),0==(0|t._crypto_core_ristretto255_scalar_invert(c,_))){var o=p(n,r);return v(a),o}g(a,"invalid reciprocate")}function Le(e,r,a){var _=[];i(a),e=m(_,e,"x");var s,n=0|t._crypto_core_ristretto255_scalarbytes();e.length!==n&&b(_,"invalid x length"),s=u(e),_.push(s),r=m(_,r,"y");var c,o=0|t._crypto_core_ristretto255_scalarbytes();r.length!==o&&b(_,"invalid y length"),c=u(r),_.push(c);var h=new l(0|t._crypto_core_ristretto255_scalarbytes()),y=h.address;_.push(y),t._crypto_core_ristretto255_scalar_mul(y,s,c);var d=p(h,a);return v(_),d}function Ue(e,r){var a=[];i(r),e=m(a,e,"s");var _,s=0|t._crypto_core_ristretto255_scalarbytes();e.length!==s&&b(a,"invalid s length"),_=u(e),a.push(_);var n=new l(0|t._crypto_core_ristretto255_scalarbytes()),c=n.address;a.push(c),t._crypto_core_ristretto255_scalar_negate(c,_);var o=p(n,r);return v(a),o}function Oe(e){var r=[];i(e);var a=new l(0|t._crypto_core_ristretto255_scalarbytes()),_=a.address;r.push(_),t._crypto_core_ristretto255_scalar_random(_);var s=p(a,e);return v(r),s}function Ce(e,r){var a=[];i(r),e=m(a,e,"sample");var _,s=0|t._crypto_core_ristretto255_nonreducedscalarbytes();e.length!==s&&b(a,"invalid sample length"),_=u(e),a.push(_);var n=new l(0|t._crypto_core_ristretto255_scalarbytes()),c=n.address;a.push(c),t._crypto_core_ristretto255_scalar_reduce(c,_);var o=p(n,r);return v(a),o}function Re(e,r,a){var _=[];i(a),e=m(_,e,"x");var s,n=0|t._crypto_core_ristretto255_scalarbytes();e.length!==n&&b(_,"invalid x length"),s=u(e),_.push(s),r=m(_,r,"y");var c,o=0|t._crypto_core_ristretto255_scalarbytes();r.length!==o&&b(_,"invalid y length"),c=u(r),_.push(c);var h=new l(0|t._crypto_core_ristretto255_scalarbytes()),y=h.address;_.push(y),t._crypto_core_ristretto255_scalar_sub(y,s,c);var d=p(h,a);return v(_),d}function Pe(e,r,a){var _=[];i(a),e=m(_,e,"p");var s,n=0|t._crypto_core_ristretto255_bytes();e.length!==n&&b(_,"invalid p length"),s=u(e),_.push(s),r=m(_,r,"q");var c,o=0|t._crypto_core_ristretto255_bytes();r.length!==o&&b(_,"invalid q length"),c=u(r),_.push(c);var h=new l(0|t._crypto_core_ristretto255_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_core_ristretto255_sub(y,s,c))){var d=p(h,a);return v(_),d}g(_,"input is an invalid element")}function Ge(e,r,a,_){var s=[];i(_),f(s,e,"hash_length"),("number"!=typeof e||(0|e)!==e||e<0)&&b(s,"hash_length must be an unsigned integer");var n=u(r=m(s,r,"message")),c=r.length;s.push(n);var o=null,h=0;null!=a&&(o=u(a=m(s,a,"key")),h=a.length,s.push(o));var y=new l(e|=0),d=y.address;if(s.push(d),0==(0|t._crypto_generichash(d,e,n,c,0,o,h))){var E=p(y,_);return v(s),E}g(s,"invalid usage")}function Xe(e,r,a,_,s){var n=[];i(s),f(n,e,"subkey_len"),("number"!=typeof e||(0|e)!==e||e<0)&&b(n,"subkey_len must be an unsigned integer");var c=null,o=0;null!=r&&(c=u(r=m(n,r,"key")),o=r.length,n.push(c)),a=m(n,a,"id");var h,y=0|t._crypto_generichash_blake2b_saltbytes();a.length!==y&&b(n,"invalid id length"),h=u(a),n.push(h),_=m(n,_,"ctx");var d,E=0|t._crypto_generichash_blake2b_personalbytes();_.length!==E&&b(n,"invalid ctx length"),d=u(_),n.push(d);var x=new l(0|e),k=x.address;if(n.push(k),0==(0|t._crypto_generichash_blake2b_salt_personal(k,e,null,0,0,c,o,h,d))){var S=p(x,s);return v(n),S}g(n,"invalid usage")}function De(e,r,a){var _=[];i(a),f(_,e,"state_address"),f(_,r,"hash_length"),("number"!=typeof r||(0|r)!==r||r<0)&&b(_,"hash_length must be an unsigned integer");var s=new l(r|=0),n=s.address;if(_.push(n),0==(0|t._crypto_generichash_final(e,n,r))){var c=(t._free(e),p(s,a));return v(_),c}g(_,"invalid usage")}function Fe(e,r,a){var _=[];i(a);var s=null,n=0;null!=e&&(s=u(e=m(_,e,"key")),n=e.length,_.push(s)),f(_,r,"hash_length"),("number"!=typeof r||(0|r)!==r||r<0)&&b(_,"hash_length must be an unsigned integer");var c=new l(357).address;if(0==(0|t._crypto_generichash_init(c,s,n,r))){var o=c;return v(_),o}g(_,"invalid usage")}function Ve(e){var r=[];i(e);var a=new l(0|t._crypto_generichash_keybytes()),_=a.address;r.push(_),t._crypto_generichash_keygen(_);var s=p(a,e);return v(r),s}function He(e,r,a){var _=[];i(a),f(_,e,"state_address");var s=u(r=m(_,r,"message_chunk")),n=r.length;_.push(s),0!=(0|t._crypto_generichash_update(e,s,n))&&g(_,"invalid usage"),v(_)}function qe(e,r){var a=[];i(r);var _=u(e=m(a,e,"message")),s=e.length;a.push(_);var n=new l(0|t._crypto_hash_bytes()),c=n.address;if(a.push(c),0==(0|t._crypto_hash(c,_,s,0))){var o=p(n,r);return v(a),o}g(a,"invalid usage")}function je(e,r){var a=[];i(r);var _=u(e=m(a,e,"message")),s=e.length;a.push(_);var n=new l(0|t._crypto_hash_sha256_bytes()),c=n.address;if(a.push(c),0==(0|t._crypto_hash_sha256(c,_,s,0))){var o=p(n,r);return v(a),o}g(a,"invalid usage")}function ze(e,r){var a=[];i(r),f(a,e,"state_address");var _=new l(0|t._crypto_hash_sha256_bytes()),s=_.address;if(a.push(s),0==(0|t._crypto_hash_sha256_final(e,s))){var n=(t._free(e),p(_,r));return v(a),n}g(a,"invalid usage")}function We(e){var r=[];i(e);var a=new l(104).address;if(0==(0|t._crypto_hash_sha256_init(a))){var _=a;return v(r),_}g(r,"invalid usage")}function Je(e,r,a){var _=[];i(a),f(_,e,"state_address");var s=u(r=m(_,r,"message_chunk")),n=r.length;_.push(s),0!=(0|t._crypto_hash_sha256_update(e,s,n))&&g(_,"invalid usage"),v(_)}function Qe(e,r){var a=[];i(r);var _=u(e=m(a,e,"message")),s=e.length;a.push(_);var n=new l(0|t._crypto_hash_sha512_bytes()),c=n.address;if(a.push(c),0==(0|t._crypto_hash_sha512(c,_,s,0))){var o=p(n,r);return v(a),o}g(a,"invalid usage")}function Ze(e,r){var a=[];i(r),f(a,e,"state_address");var _=new l(0|t._crypto_hash_sha512_bytes()),s=_.address;if(a.push(s),0==(0|t._crypto_hash_sha512_final(e,s))){var n=(t._free(e),p(_,r));return v(a),n}g(a,"invalid usage")}function $e(e){var r=[];i(e);var a=new l(208).address;if(0==(0|t._crypto_hash_sha512_init(a))){var _=a;return v(r),_}g(r,"invalid usage")}function er(e,r,a){var _=[];i(a),f(_,e,"state_address");var s=u(r=m(_,r,"message_chunk")),n=r.length;_.push(s),0!=(0|t._crypto_hash_sha512_update(e,s,n))&&g(_,"invalid usage"),v(_)}function rr(e,r,a,s,n){var c=[];i(n),f(c,e,"subkey_len"),("number"!=typeof e||(0|e)!==e||e<0)&&b(c,"subkey_len must be an unsigned integer"),f(c,r,"subkey_id"),("number"!=typeof r||(0|r)!==r||r<0)&&b(c,"subkey_id must be an unsigned integer"),"string"!=typeof a&&b(c,"ctx must be a string"),a=_(a+"\0"),null!=h&&a.length-1!==h&&b(c,"invalid ctx length");var o=u(a),h=a.length-1;c.push(o),s=m(c,s,"key");var y,d=0|t._crypto_kdf_keybytes();s.length!==d&&b(c,"invalid key length"),y=u(s),c.push(y);var g=new l(0|e),E=g.address;c.push(E),t._crypto_kdf_derive_from_key(E,e,r,r>>>24>>>8,o,y);var x=p(g,n);return v(c),x}function tr(e){var r=[];i(e);var a=new l(0|t._crypto_kdf_keybytes()),_=a.address;r.push(_),t._crypto_kdf_keygen(_);var s=p(a,e);return v(r),s}function ar(e,r,a,_){var s=[];i(_),e=m(s,e,"clientPublicKey");var n,c=0|t._crypto_kx_publickeybytes();e.length!==c&&b(s,"invalid clientPublicKey length"),n=u(e),s.push(n),r=m(s,r,"clientSecretKey");var o,h=0|t._crypto_kx_secretkeybytes();r.length!==h&&b(s,"invalid clientSecretKey length"),o=u(r),s.push(o),a=m(s,a,"serverPublicKey");var y,d=0|t._crypto_kx_publickeybytes();a.length!==d&&b(s,"invalid serverPublicKey length"),y=u(a),s.push(y);var f=new l(0|t._crypto_kx_sessionkeybytes()),E=f.address;s.push(E);var x=new l(0|t._crypto_kx_sessionkeybytes()),k=x.address;if(s.push(k),0==(0|t._crypto_kx_client_session_keys(E,k,n,o,y))){var S=p({sharedRx:f,sharedTx:x},_);return v(s),S}g(s,"invalid usage")}function _r(e){var r=[];i(e);var a=new l(0|t._crypto_kx_publickeybytes()),_=a.address;r.push(_);var s=new l(0|t._crypto_kx_secretkeybytes()),n=s.address;if(r.push(n),0==(0|t._crypto_kx_keypair(_,n))){var c={publicKey:p(a,e),privateKey:p(s,e),keyType:"x25519"};return v(r),c}g(r,"internal error")}function sr(e,r){var a=[];i(r),e=m(a,e,"seed");var _,s=0|t._crypto_kx_seedbytes();e.length!==s&&b(a,"invalid seed length"),_=u(e),a.push(_);var n=new l(0|t._crypto_kx_publickeybytes()),c=n.address;a.push(c);var o=new l(0|t._crypto_kx_secretkeybytes()),h=o.address;if(a.push(h),0==(0|t._crypto_kx_seed_keypair(c,h,_))){var y={publicKey:p(n,r),privateKey:p(o,r),keyType:"x25519"};return v(a),y}g(a,"internal error")}function nr(e,r,a,_){var s=[];i(_),e=m(s,e,"serverPublicKey");var n,c=0|t._crypto_kx_publickeybytes();e.length!==c&&b(s,"invalid serverPublicKey length"),n=u(e),s.push(n),r=m(s,r,"serverSecretKey");var o,h=0|t._crypto_kx_secretkeybytes();r.length!==h&&b(s,"invalid serverSecretKey length"),o=u(r),s.push(o),a=m(s,a,"clientPublicKey");var y,d=0|t._crypto_kx_publickeybytes();a.length!==d&&b(s,"invalid clientPublicKey length"),y=u(a),s.push(y);var f=new l(0|t._crypto_kx_sessionkeybytes()),E=f.address;s.push(E);var x=new l(0|t._crypto_kx_sessionkeybytes()),k=x.address;if(s.push(k),0==(0|t._crypto_kx_server_session_keys(E,k,n,o,y))){var S=p({sharedRx:f,sharedTx:x},_);return v(s),S}g(s,"invalid usage")}function cr(e,r,a){var _=[];i(a);var s=u(e=m(_,e,"message")),n=e.length;_.push(s),r=m(_,r,"key");var c,o=0|t._crypto_onetimeauth_keybytes();r.length!==o&&b(_,"invalid key length"),c=u(r),_.push(c);var h=new l(0|t._crypto_onetimeauth_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_onetimeauth(y,s,n,0,c))){var d=p(h,a);return v(_),d}g(_,"invalid usage")}function or(e,r){var a=[];i(r),f(a,e,"state_address");var _=new l(0|t._crypto_onetimeauth_bytes()),s=_.address;if(a.push(s),0==(0|t._crypto_onetimeauth_final(e,s))){var n=(t._free(e),p(_,r));return v(a),n}g(a,"invalid usage")}function hr(e,r){var a=[];i(r);var _=null;null!=e&&(_=u(e=m(a,e,"key")),e.length,a.push(_));var s=new l(144).address;if(0==(0|t._crypto_onetimeauth_init(s,_))){var n=s;return v(a),n}g(a,"invalid usage")}function pr(e){var r=[];i(e);var a=new l(0|t._crypto_onetimeauth_keybytes()),_=a.address;r.push(_),t._crypto_onetimeauth_keygen(_);var s=p(a,e);return v(r),s}function yr(e,r,a){var _=[];i(a),f(_,e,"state_address");var s=u(r=m(_,r,"message_chunk")),n=r.length;_.push(s),0!=(0|t._crypto_onetimeauth_update(e,s,n))&&g(_,"invalid usage"),v(_)}function ir(e,r,a){var _=[];e=m(_,e,"hash");var s,n=0|t._crypto_onetimeauth_bytes();e.length!==n&&b(_,"invalid hash length"),s=u(e),_.push(s);var c=u(r=m(_,r,"message")),o=r.length;_.push(c),a=m(_,a,"key");var h,p=0|t._crypto_onetimeauth_keybytes();a.length!==p&&b(_,"invalid key length"),h=u(a),_.push(h);var y=0==(0|t._crypto_onetimeauth_verify(s,c,o,0,h));return v(_),y}function lr(e,r,a,_,s,n,c){var o=[];i(c),f(o,e,"keyLength"),("number"!=typeof e||(0|e)!==e||e<0)&&b(o,"keyLength must be an unsigned integer");var h=u(r=m(o,r,"password")),y=r.length;o.push(h),a=m(o,a,"salt");var d,E=0|t._crypto_pwhash_saltbytes();a.length!==E&&b(o,"invalid salt length"),d=u(a),o.push(d),f(o,_,"opsLimit"),("number"!=typeof _||(0|_)!==_||_<0)&&b(o,"opsLimit must be an unsigned integer"),f(o,s,"memLimit"),("number"!=typeof s||(0|s)!==s||s<0)&&b(o,"memLimit must be an unsigned integer"),f(o,n,"algorithm"),("number"!=typeof n||(0|n)!==n||n<0)&&b(o,"algorithm must be an unsigned integer");var x=new l(0|e),k=x.address;if(o.push(k),0==(0|t._crypto_pwhash(k,e,0,h,y,0,d,_,0,s,n))){var S=p(x,c);return v(o),S}g(o,"invalid usage")}function ur(e,r,a,_,s,n){var c=[];i(n),f(c,e,"keyLength"),("number"!=typeof e||(0|e)!==e||e<0)&&b(c,"keyLength must be an unsigned integer");var o=u(r=m(c,r,"password")),h=r.length;c.push(o),a=m(c,a,"salt");var y,d=0|t._crypto_pwhash_scryptsalsa208sha256_saltbytes();a.length!==d&&b(c,"invalid salt length"),y=u(a),c.push(y),f(c,_,"opsLimit"),("number"!=typeof _||(0|_)!==_||_<0)&&b(c,"opsLimit must be an unsigned integer"),f(c,s,"memLimit"),("number"!=typeof s||(0|s)!==s||s<0)&&b(c,"memLimit must be an unsigned integer");var E=new l(0|e),x=E.address;if(c.push(x),0==(0|t._crypto_pwhash_scryptsalsa208sha256(x,e,0,o,h,0,y,_,0,s))){var k=p(E,n);return v(c),k}g(c,"invalid usage")}function dr(e,r,a,_,s,n,c){var o=[];i(c);var h=u(e=m(o,e,"password")),y=e.length;o.push(h);var d=u(r=m(o,r,"salt")),E=r.length;o.push(d),f(o,a,"opsLimit"),("number"!=typeof a||(0|a)!==a||a<0)&&b(o,"opsLimit must be an unsigned integer"),f(o,_,"r"),("number"!=typeof _||(0|_)!==_||_<0)&&b(o,"r must be an unsigned integer"),f(o,s,"p"),("number"!=typeof s||(0|s)!==s||s<0)&&b(o,"p must be an unsigned integer"),f(o,n,"keyLength"),("number"!=typeof n||(0|n)!==n||n<0)&&b(o,"keyLength must be an unsigned integer");var x=new l(0|n),k=x.address;if(o.push(k),0==(0|t._crypto_pwhash_scryptsalsa208sha256_ll(h,y,d,E,a,0,_,s,k,n))){var S=p(x,c);return v(o),S}g(o,"invalid usage")}function vr(e,r,a,_){var s=[];i(_);var n=u(e=m(s,e,"password")),c=e.length;s.push(n),f(s,r,"opsLimit"),("number"!=typeof r||(0|r)!==r||r<0)&&b(s,"opsLimit must be an unsigned integer"),f(s,a,"memLimit"),("number"!=typeof a||(0|a)!==a||a<0)&&b(s,"memLimit must be an unsigned integer");var o=new l(0|t._crypto_pwhash_scryptsalsa208sha256_strbytes()).address;if(s.push(o),0==(0|t._crypto_pwhash_scryptsalsa208sha256_str(o,n,c,0,r,0,a))){var h=t.UTF8ToString(o);return v(s),h}g(s,"invalid usage")}function gr(e,r,a){var s=[];i(a),"string"!=typeof e&&b(s,"hashed_password must be a string"),e=_(e+"\0"),null!=c&&e.length-1!==c&&b(s,"invalid hashed_password length");var n=u(e),c=e.length-1;s.push(n);var o=u(r=m(s,r,"password")),h=r.length;s.push(o);var p=0==(0|t._crypto_pwhash_scryptsalsa208sha256_str_verify(n,o,h,0));return v(s),p}function br(e,r,a,_){var s=[];i(_);var n=u(e=m(s,e,"password")),c=e.length;s.push(n),f(s,r,"opsLimit"),("number"!=typeof r||(0|r)!==r||r<0)&&b(s,"opsLimit must be an unsigned integer"),f(s,a,"memLimit"),("number"!=typeof a||(0|a)!==a||a<0)&&b(s,"memLimit must be an unsigned integer");var o=new l(0|t._crypto_pwhash_strbytes()).address;if(s.push(o),0==(0|t._crypto_pwhash_str(o,n,c,0,r,0,a))){var h=t.UTF8ToString(o);return v(s),h}g(s,"invalid usage")}function fr(e,r,a,s){var n=[];i(s),"string"!=typeof e&&b(n,"hashed_password must be a string"),e=_(e+"\0"),null!=o&&e.length-1!==o&&b(n,"invalid hashed_password length");var c=u(e),o=e.length-1;n.push(c),f(n,r,"opsLimit"),("number"!=typeof r||(0|r)!==r||r<0)&&b(n,"opsLimit must be an unsigned integer"),f(n,a,"memLimit"),("number"!=typeof a||(0|a)!==a||a<0)&&b(n,"memLimit must be an unsigned integer");var h=0!=(0|t._crypto_pwhash_str_needs_rehash(c,r,0,a));return v(n),h}function mr(e,r,a){var s=[];i(a),"string"!=typeof e&&b(s,"hashed_password must be a string"),e=_(e+"\0"),null!=c&&e.length-1!==c&&b(s,"invalid hashed_password length");var n=u(e),c=e.length-1;s.push(n);var o=u(r=m(s,r,"password")),h=r.length;s.push(o);var p=0==(0|t._crypto_pwhash_str_verify(n,o,h,0));return v(s),p}function Er(e,r,a){var _=[];i(a),e=m(_,e,"privateKey");var s,n=0|t._crypto_scalarmult_scalarbytes();e.length!==n&&b(_,"invalid privateKey length"),s=u(e),_.push(s),r=m(_,r,"publicKey");var c,o=0|t._crypto_scalarmult_bytes();r.length!==o&&b(_,"invalid publicKey length"),c=u(r),_.push(c);var h=new l(0|t._crypto_scalarmult_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_scalarmult(y,s,c))){var d=p(h,a);return v(_),d}g(_,"weak public key")}function xr(e,r){var a=[];i(r),e=m(a,e,"privateKey");var _,s=0|t._crypto_scalarmult_scalarbytes();e.length!==s&&b(a,"invalid privateKey length"),_=u(e),a.push(_);var n=new l(0|t._crypto_scalarmult_bytes()),c=n.address;if(a.push(c),0==(0|t._crypto_scalarmult_base(c,_))){var o=p(n,r);return v(a),o}g(a,"unknown error")}function kr(e,r,a){var _=[];i(a),e=m(_,e,"n");var s,n=0|t._crypto_scalarmult_ed25519_scalarbytes();e.length!==n&&b(_,"invalid n length"),s=u(e),_.push(s),r=m(_,r,"p");var c,o=0|t._crypto_scalarmult_ed25519_bytes();r.length!==o&&b(_,"invalid p length"),c=u(r),_.push(c);var h=new l(0|t._crypto_scalarmult_ed25519_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_scalarmult_ed25519(y,s,c))){var d=p(h,a);return v(_),d}g(_,"invalid point or scalar is 0")}function Sr(e,r){var a=[];i(r),e=m(a,e,"scalar");var _,s=0|t._crypto_scalarmult_ed25519_scalarbytes();e.length!==s&&b(a,"invalid scalar length"),_=u(e),a.push(_);var n=new l(0|t._crypto_scalarmult_ed25519_bytes()),c=n.address;if(a.push(c),0==(0|t._crypto_scalarmult_ed25519_base(c,_))){var o=p(n,r);return v(a),o}g(a,"scalar is 0")}function Tr(e,r){var a=[];i(r),e=m(a,e,"scalar");var _,s=0|t._crypto_scalarmult_ed25519_scalarbytes();e.length!==s&&b(a,"invalid scalar length"),_=u(e),a.push(_);var n=new l(0|t._crypto_scalarmult_ed25519_bytes()),c=n.address;if(a.push(c),0==(0|t._crypto_scalarmult_ed25519_base_noclamp(c,_))){var o=p(n,r);return v(a),o}g(a,"scalar is 0")}function wr(e,r,a){var _=[];i(a),e=m(_,e,"n");var s,n=0|t._crypto_scalarmult_ed25519_scalarbytes();e.length!==n&&b(_,"invalid n length"),s=u(e),_.push(s),r=m(_,r,"p");var c,o=0|t._crypto_scalarmult_ed25519_bytes();r.length!==o&&b(_,"invalid p length"),c=u(r),_.push(c);var h=new l(0|t._crypto_scalarmult_ed25519_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_scalarmult_ed25519_noclamp(y,s,c))){var d=p(h,a);return v(_),d}g(_,"invalid point or scalar is 0")}function Yr(e,r,a){var _=[];i(a),e=m(_,e,"scalar");var s,n=0|t._crypto_scalarmult_ristretto255_scalarbytes();e.length!==n&&b(_,"invalid scalar length"),s=u(e),_.push(s),r=m(_,r,"element");var c,o=0|t._crypto_scalarmult_ristretto255_bytes();r.length!==o&&b(_,"invalid element length"),c=u(r),_.push(c);var h=new l(0|t._crypto_scalarmult_ristretto255_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_scalarmult_ristretto255(y,s,c))){var d=p(h,a);return v(_),d}g(_,"result is identity element")}function Br(e,r){var a=[];i(r),e=m(a,e,"scalar");var _,s=0|t._crypto_core_ristretto255_scalarbytes();e.length!==s&&b(a,"invalid scalar length"),_=u(e),a.push(_);var n=new l(0|t._crypto_core_ristretto255_bytes()),c=n.address;if(a.push(c),0==(0|t._crypto_scalarmult_ristretto255_base(c,_))){var o=p(n,r);return v(a),o}g(a,"scalar is 0")}function Ar(e,r,a,_){var s=[];i(_);var n=u(e=m(s,e,"message")),c=e.length;s.push(n),r=m(s,r,"nonce");var o,h=0|t._crypto_secretbox_noncebytes();r.length!==h&&b(s,"invalid nonce length"),o=u(r),s.push(o),a=m(s,a,"key");var y,d=0|t._crypto_secretbox_keybytes();a.length!==d&&b(s,"invalid key length"),y=u(a),s.push(y);var f=new l(0|c),E=f.address;s.push(E);var x=new l(0|t._crypto_secretbox_macbytes()),k=x.address;if(s.push(k),0==(0|t._crypto_secretbox_detached(E,k,n,c,0,o,y))){var S=p({mac:x,cipher:f},_);return v(s),S}g(s,"invalid usage")}function Kr(e,r,a,_){var s=[];i(_);var n=u(e=m(s,e,"message")),c=e.length;s.push(n),r=m(s,r,"nonce");var o,h=0|t._crypto_secretbox_noncebytes();r.length!==h&&b(s,"invalid nonce length"),o=u(r),s.push(o),a=m(s,a,"key");var y,d=0|t._crypto_secretbox_keybytes();a.length!==d&&b(s,"invalid key length"),y=u(a),s.push(y);var f=new l(c+t._crypto_secretbox_macbytes()|0),E=f.address;if(s.push(E),0==(0|t._crypto_secretbox_easy(E,n,c,0,o,y))){var x=p(f,_);return v(s),x}g(s,"invalid usage")}function Mr(e){var r=[];i(e);var a=new l(0|t._crypto_secretbox_keybytes()),_=a.address;r.push(_),t._crypto_secretbox_keygen(_);var s=p(a,e);return v(r),s}function Ir(e,r,a,_,s){var n=[];i(s);var c=u(e=m(n,e,"ciphertext")),o=e.length;n.push(c),r=m(n,r,"mac");var h,y=0|t._crypto_secretbox_macbytes();r.length!==y&&b(n,"invalid mac length"),h=u(r),n.push(h),a=m(n,a,"nonce");var d,f=0|t._crypto_secretbox_noncebytes();a.length!==f&&b(n,"invalid nonce length"),d=u(a),n.push(d),_=m(n,_,"key");var E,x=0|t._crypto_secretbox_keybytes();_.length!==x&&b(n,"invalid key length"),E=u(_),n.push(E);var k=new l(0|o),S=k.address;if(n.push(S),0==(0|t._crypto_secretbox_open_detached(S,c,h,o,0,d,E))){var T=p(k,s);return v(n),T}g(n,"wrong secret key for the given ciphertext")}function Nr(e,r,a,_){var s=[];i(_),e=m(s,e,"ciphertext");var n,c=t._crypto_secretbox_macbytes(),o=e.length;o<c&&b(s,"ciphertext is too short"),n=u(e),s.push(n),r=m(s,r,"nonce");var h,y=0|t._crypto_secretbox_noncebytes();r.length!==y&&b(s,"invalid nonce length"),h=u(r),s.push(h),a=m(s,a,"key");var d,f=0|t._crypto_secretbox_keybytes();a.length!==f&&b(s,"invalid key length"),d=u(a),s.push(d);var E=new l(o-t._crypto_secretbox_macbytes()|0),x=E.address;if(s.push(x),0==(0|t._crypto_secretbox_open_easy(x,n,o,0,h,d))){var k=p(E,_);return v(s),k}g(s,"wrong secret key for the given ciphertext")}function Lr(e,r,a){var _=[];i(a),e=m(_,e,"header");var s,n=0|t._crypto_secretstream_xchacha20poly1305_headerbytes();e.length!==n&&b(_,"invalid header length"),s=u(e),_.push(s),r=m(_,r,"key");var c,o=0|t._crypto_secretstream_xchacha20poly1305_keybytes();r.length!==o&&b(_,"invalid key length"),c=u(r),_.push(c);var h=new l(52).address;if(0==(0|t._crypto_secretstream_xchacha20poly1305_init_pull(h,s,c))){var p=h;return v(_),p}g(_,"invalid usage")}function Ur(e,r){var a=[];i(r),e=m(a,e,"key");var _,s=0|t._crypto_secretstream_xchacha20poly1305_keybytes();e.length!==s&&b(a,"invalid key length"),_=u(e),a.push(_);var n=new l(52).address,c=new l(0|t._crypto_secretstream_xchacha20poly1305_headerbytes()),o=c.address;if(a.push(o),0==(0|t._crypto_secretstream_xchacha20poly1305_init_push(n,o,_))){var h={state:n,header:p(c,r)};return v(a),h}g(a,"invalid usage")}function Or(e){var r=[];i(e);var a=new l(0|t._crypto_secretstream_xchacha20poly1305_keybytes()),_=a.address;r.push(_),t._crypto_secretstream_xchacha20poly1305_keygen(_);var s=p(a,e);return v(r),s}function Cr(e,r,a,_){var s=[];i(_),f(s,e,"state_address"),r=m(s,r,"cipher");var n,c=t._crypto_secretstream_xchacha20poly1305_abytes(),o=r.length;o<c&&b(s,"cipher is too short"),n=u(r),s.push(n);var h=null,y=0;null!=a&&(h=u(a=m(s,a,"ad")),y=a.length,s.push(h));var g=new l(o-t._crypto_secretstream_xchacha20poly1305_abytes()|0),E=g.address;s.push(E);var x,k=(x=d(1),s.push(x),(k=0===t._crypto_secretstream_xchacha20poly1305_pull(e,E,0,x,n,o,0,h,y)&&{tag:t.HEAPU8[x],message:g})&&{message:p(k.message,_),tag:k.tag});return v(s),k}function Rr(e,r,a,_,s){var n=[];i(s),f(n,e,"state_address");var c=u(r=m(n,r,"message_chunk")),o=r.length;n.push(c);var h=null,y=0;null!=a&&(h=u(a=m(n,a,"ad")),y=a.length,n.push(h)),f(n,_,"tag"),("number"!=typeof _||(0|_)!==_||_<0)&&b(n,"tag must be an unsigned integer");var d=new l(o+t._crypto_secretstream_xchacha20poly1305_abytes()|0),E=d.address;if(n.push(E),0==(0|t._crypto_secretstream_xchacha20poly1305_push(e,E,0,c,o,0,h,y,0,_))){var x=p(d,s);return v(n),x}g(n,"invalid usage")}function Pr(e,r){var a=[];return i(r),f(a,e,"state_address"),t._crypto_secretstream_xchacha20poly1305_rekey(e),v(a),!0}function Gr(e,r,a){var _=[];i(a);var s=u(e=m(_,e,"message")),n=e.length;_.push(s),r=m(_,r,"key");var c,o=0|t._crypto_shorthash_keybytes();r.length!==o&&b(_,"invalid key length"),c=u(r),_.push(c);var h=new l(0|t._crypto_shorthash_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_shorthash(y,s,n,0,c))){var d=p(h,a);return v(_),d}g(_,"invalid usage")}function Xr(e){var r=[];i(e);var a=new l(0|t._crypto_shorthash_keybytes()),_=a.address;r.push(_),t._crypto_shorthash_keygen(_);var s=p(a,e);return v(r),s}function Dr(e,r,a){var _=[];i(a);var s=u(e=m(_,e,"message")),n=e.length;_.push(s),r=m(_,r,"key");var c,o=0|t._crypto_shorthash_siphashx24_keybytes();r.length!==o&&b(_,"invalid key length"),c=u(r),_.push(c);var h=new l(0|t._crypto_shorthash_siphashx24_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_shorthash_siphashx24(y,s,n,0,c))){var d=p(h,a);return v(_),d}g(_,"invalid usage")}function Fr(e,r,a){var _=[];i(a);var s=u(e=m(_,e,"message")),n=e.length;_.push(s),r=m(_,r,"privateKey");var c,o=0|t._crypto_sign_secretkeybytes();r.length!==o&&b(_,"invalid privateKey length"),c=u(r),_.push(c);var h=new l(e.length+t._crypto_sign_bytes()|0),y=h.address;if(_.push(y),0==(0|t._crypto_sign(y,null,s,n,0,c))){var d=p(h,a);return v(_),d}g(_,"invalid usage")}function Vr(e,r,a){var _=[];i(a);var s=u(e=m(_,e,"message")),n=e.length;_.push(s),r=m(_,r,"privateKey");var c,o=0|t._crypto_sign_secretkeybytes();r.length!==o&&b(_,"invalid privateKey length"),c=u(r),_.push(c);var h=new l(0|t._crypto_sign_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_sign_detached(y,null,s,n,0,c))){var d=p(h,a);return v(_),d}g(_,"invalid usage")}function Hr(e,r){var a=[];i(r),e=m(a,e,"edPk");var _,s=0|t._crypto_sign_publickeybytes();e.length!==s&&b(a,"invalid edPk length"),_=u(e),a.push(_);var n=new l(0|t._crypto_scalarmult_scalarbytes()),c=n.address;if(a.push(c),0==(0|t._crypto_sign_ed25519_pk_to_curve25519(c,_))){var o=p(n,r);return v(a),o}g(a,"invalid key")}function qr(e,r){var a=[];i(r),e=m(a,e,"edSk");var _,s=0|t._crypto_sign_secretkeybytes();e.length!==s&&b(a,"invalid edSk length"),_=u(e),a.push(_);var n=new l(0|t._crypto_scalarmult_scalarbytes()),c=n.address;if(a.push(c),0==(0|t._crypto_sign_ed25519_sk_to_curve25519(c,_))){var o=p(n,r);return v(a),o}g(a,"invalid key")}function jr(e,r){var a=[];i(r),e=m(a,e,"privateKey");var _,s=0|t._crypto_sign_secretkeybytes();e.length!==s&&b(a,"invalid privateKey length"),_=u(e),a.push(_);var n=new l(0|t._crypto_sign_publickeybytes()),c=n.address;if(a.push(c),0==(0|t._crypto_sign_ed25519_sk_to_pk(c,_))){var o=p(n,r);return v(a),o}g(a,"invalid key")}function zr(e,r){var a=[];i(r),e=m(a,e,"privateKey");var _,s=0|t._crypto_sign_secretkeybytes();e.length!==s&&b(a,"invalid privateKey length"),_=u(e),a.push(_);var n=new l(0|t._crypto_sign_seedbytes()),c=n.address;if(a.push(c),0==(0|t._crypto_sign_ed25519_sk_to_seed(c,_))){var o=p(n,r);return v(a),o}g(a,"invalid key")}function Wr(e,r,a){var _=[];i(a),f(_,e,"state_address"),r=m(_,r,"privateKey");var s,n=0|t._crypto_sign_secretkeybytes();r.length!==n&&b(_,"invalid privateKey length"),s=u(r),_.push(s);var c=new l(0|t._crypto_sign_bytes()),o=c.address;if(_.push(o),0==(0|t._crypto_sign_final_create(e,o,null,s))){var h=(t._free(e),p(c,a));return v(_),h}g(_,"invalid usage")}function Jr(e,r,a,_){var s=[];i(_),f(s,e,"state_address"),r=m(s,r,"signature");var n,c=0|t._crypto_sign_bytes();r.length!==c&&b(s,"invalid signature length"),n=u(r),s.push(n),a=m(s,a,"publicKey");var o,h=0|t._crypto_sign_publickeybytes();a.length!==h&&b(s,"invalid publicKey length"),o=u(a),s.push(o);var p=0==(0|t._crypto_sign_final_verify(e,n,o));return v(s),p}function Qr(e){var r=[];i(e);var a=new l(208).address;if(0==(0|t._crypto_sign_init(a))){var _=a;return v(r),_}g(r,"internal error")}function Zr(e){var r=[];i(e);var a=new l(0|t._crypto_sign_publickeybytes()),_=a.address;r.push(_);var s=new l(0|t._crypto_sign_secretkeybytes()),n=s.address;if(r.push(n),0==(0|t._crypto_sign_keypair(_,n))){var c={publicKey:p(a,e),privateKey:p(s,e),keyType:"ed25519"};return v(r),c}g(r,"internal error")}function $r(e,r,a){var _=[];i(a),e=m(_,e,"signedMessage");var s,n=t._crypto_sign_bytes(),c=e.length;c<n&&b(_,"signedMessage is too short"),s=u(e),_.push(s),r=m(_,r,"publicKey");var o,h=0|t._crypto_sign_publickeybytes();r.length!==h&&b(_,"invalid publicKey length"),o=u(r),_.push(o);var y=new l(c-t._crypto_sign_bytes()|0),d=y.address;if(_.push(d),0==(0|t._crypto_sign_open(d,null,s,c,0,o))){var f=p(y,a);return v(_),f}g(_,"incorrect signature for the given public key")}function et(e,r){var a=[];i(r),e=m(a,e,"seed");var _,s=0|t._crypto_sign_seedbytes();e.length!==s&&b(a,"invalid seed length"),_=u(e),a.push(_);var n=new l(0|t._crypto_sign_publickeybytes()),c=n.address;a.push(c);var o=new l(0|t._crypto_sign_secretkeybytes()),h=o.address;if(a.push(h),0==(0|t._crypto_sign_seed_keypair(c,h,_))){var y={publicKey:p(n,r),privateKey:p(o,r),keyType:"ed25519"};return v(a),y}g(a,"invalid usage")}function rt(e,r,a){var _=[];i(a),f(_,e,"state_address");var s=u(r=m(_,r,"message_chunk")),n=r.length;_.push(s),0!=(0|t._crypto_sign_update(e,s,n,0))&&g(_,"invalid usage"),v(_)}function tt(e,r,a){var _=[];e=m(_,e,"signature");var s,n=0|t._crypto_sign_bytes();e.length!==n&&b(_,"invalid signature length"),s=u(e),_.push(s);var c=u(r=m(_,r,"message")),o=r.length;_.push(c),a=m(_,a,"publicKey");var h,p=0|t._crypto_sign_publickeybytes();a.length!==p&&b(_,"invalid publicKey length"),h=u(a),_.push(h);var y=0==(0|t._crypto_sign_verify_detached(s,c,o,0,h));return v(_),y}function at(e,r,a,_){var s=[];i(_),f(s,e,"outLength"),("number"!=typeof e||(0|e)!==e||e<0)&&b(s,"outLength must be an unsigned integer"),r=m(s,r,"key");var n,c=0|t._crypto_stream_chacha20_keybytes();r.length!==c&&b(s,"invalid key length"),n=u(r),s.push(n),a=m(s,a,"nonce");var o,h=0|t._crypto_stream_chacha20_noncebytes();a.length!==h&&b(s,"invalid nonce length"),o=u(a),s.push(o);var y=new l(0|e),d=y.address;s.push(d),t._crypto_stream_chacha20(d,e,0,o,n);var g=p(y,_);return v(s),g}function _t(e,r,a,_){var s=[];i(_);var n=u(e=m(s,e,"input_message")),c=e.length;s.push(n),r=m(s,r,"nonce");var o,h=0|t._crypto_stream_chacha20_ietf_noncebytes();r.length!==h&&b(s,"invalid nonce length"),o=u(r),s.push(o),a=m(s,a,"key");var y,d=0|t._crypto_stream_chacha20_ietf_keybytes();a.length!==d&&b(s,"invalid key length"),y=u(a),s.push(y);var f=new l(0|c),E=f.address;if(s.push(E),0===t._crypto_stream_chacha20_ietf_xor(E,n,c,0,o,y)){var x=p(f,_);return v(s),x}g(s,"invalid usage")}function st(e,r,a,_,s){var n=[];i(s);var c=u(e=m(n,e,"input_message")),o=e.length;n.push(c),r=m(n,r,"nonce");var h,y=0|t._crypto_stream_chacha20_ietf_noncebytes();r.length!==y&&b(n,"invalid nonce length"),h=u(r),n.push(h),f(n,a,"nonce_increment"),("number"!=typeof a||(0|a)!==a||a<0)&&b(n,"nonce_increment must be an unsigned integer"),_=m(n,_,"key");var d,E=0|t._crypto_stream_chacha20_ietf_keybytes();_.length!==E&&b(n,"invalid key length"),d=u(_),n.push(d);var x=new l(0|o),k=x.address;if(n.push(k),0===t._crypto_stream_chacha20_ietf_xor_ic(k,c,o,0,h,a,d)){var S=p(x,s);return v(n),S}g(n,"invalid usage")}function nt(e){var r=[];i(e);var a=new l(0|t._crypto_stream_chacha20_keybytes()),_=a.address;r.push(_),t._crypto_stream_chacha20_keygen(_);var s=p(a,e);return v(r),s}function ct(e,r,a,_){var s=[];i(_);var n=u(e=m(s,e,"input_message")),c=e.length;s.push(n),r=m(s,r,"nonce");var o,h=0|t._crypto_stream_chacha20_noncebytes();r.length!==h&&b(s,"invalid nonce length"),o=u(r),s.push(o),a=m(s,a,"key");var y,d=0|t._crypto_stream_chacha20_keybytes();a.length!==d&&b(s,"invalid key length"),y=u(a),s.push(y);var f=new l(0|c),E=f.address;if(s.push(E),0===t._crypto_stream_chacha20_xor(E,n,c,0,o,y)){var x=p(f,_);return v(s),x}g(s,"invalid usage")}function ot(e,r,a,_,s){var n=[];i(s);var c=u(e=m(n,e,"input_message")),o=e.length;n.push(c),r=m(n,r,"nonce");var h,y=0|t._crypto_stream_chacha20_noncebytes();r.length!==y&&b(n,"invalid nonce length"),h=u(r),n.push(h),f(n,a,"nonce_increment"),("number"!=typeof a||(0|a)!==a||a<0)&&b(n,"nonce_increment must be an unsigned integer"),_=m(n,_,"key");var d,E=0|t._crypto_stream_chacha20_keybytes();_.length!==E&&b(n,"invalid key length"),d=u(_),n.push(d);var x=new l(0|o),k=x.address;if(n.push(k),0===t._crypto_stream_chacha20_xor_ic(k,c,o,0,h,a,0,d)){var S=p(x,s);return v(n),S}g(n,"invalid usage")}function ht(e){var r=[];i(e);var a=new l(0|t._crypto_stream_keybytes()),_=a.address;r.push(_),t._crypto_stream_keygen(_);var s=p(a,e);return v(r),s}function pt(e){var r=[];i(e);var a=new l(0|t._crypto_stream_xchacha20_keybytes()),_=a.address;r.push(_),t._crypto_stream_xchacha20_keygen(_);var s=p(a,e);return v(r),s}function yt(e,r,a,_){var s=[];i(_);var n=u(e=m(s,e,"input_message")),c=e.length;s.push(n),r=m(s,r,"nonce");var o,h=0|t._crypto_stream_xchacha20_noncebytes();r.length!==h&&b(s,"invalid nonce length"),o=u(r),s.push(o),a=m(s,a,"key");var y,d=0|t._crypto_stream_xchacha20_keybytes();a.length!==d&&b(s,"invalid key length"),y=u(a),s.push(y);var f=new l(0|c),E=f.address;if(s.push(E),0===t._crypto_stream_xchacha20_xor(E,n,c,0,o,y)){var x=p(f,_);return v(s),x}g(s,"invalid usage")}function it(e,r,a,_,s){var n=[];i(s);var c=u(e=m(n,e,"input_message")),o=e.length;n.push(c),r=m(n,r,"nonce");var h,y=0|t._crypto_stream_xchacha20_noncebytes();r.length!==y&&b(n,"invalid nonce length"),h=u(r),n.push(h),f(n,a,"nonce_increment"),("number"!=typeof a||(0|a)!==a||a<0)&&b(n,"nonce_increment must be an unsigned integer"),_=m(n,_,"key");var d,E=0|t._crypto_stream_xchacha20_keybytes();_.length!==E&&b(n,"invalid key length"),d=u(_),n.push(d);var x=new l(0|o),k=x.address;if(n.push(k),0===t._crypto_stream_xchacha20_xor_ic(k,c,o,0,h,a,0,d)){var S=p(x,s);return v(n),S}g(n,"invalid usage")}function lt(e,r){var a=[];i(r),f(a,e,"length"),("number"!=typeof e||(0|e)!==e||e<0)&&b(a,"length must be an unsigned integer");var _=new l(0|e),s=_.address;a.push(s),t._randombytes_buf(s,e);var n=p(_,r);return v(a),n}function ut(e,r,a){var _=[];i(a),f(_,e,"length"),("number"!=typeof e||(0|e)!==e||e<0)&&b(_,"length must be an unsigned integer"),r=m(_,r,"seed");var s,n=0|t._randombytes_seedbytes();r.length!==n&&b(_,"invalid seed length"),s=u(r),_.push(s);var c=new l(0|e),o=c.address;_.push(o),t._randombytes_buf_deterministic(o,e,s);var h=p(c,a);return v(_),h}function dt(e){i(e),t._randombytes_close()}function vt(e){i(e);var r=t._randombytes_random()>>>0;return v([]),r}function gt(e,r){var a=[];i(r);for(var _=t._malloc(24),s=0;s<6;s++)t.setValue(_+4*s,t.Runtime.addFunction(e[["implementation_name","random","stir","uniform","buf","close"][s]]),"i32");0!=(0|t._randombytes_set_implementation(_))&&g(a,"unsupported implementation"),v(a)}function bt(e){i(e),t._randombytes_stir()}function ft(e,r){var a=[];i(r),f(a,e,"upper_bound"),("number"!=typeof e||(0|e)!==e||e<0)&&b(a,"upper_bound must be an unsigned integer");var _=t._randombytes_uniform(e)>>>0;return v(a),_}function mt(){var e=t._sodium_version_string(),r=t.UTF8ToString(e);return v([]),r}return l.prototype.to_Uint8Array=function(){var e=new Uint8Array(this.length);return e.set(t.HEAPU8.subarray(this.address,this.address+this.length)),e},e.add=function(e,r){if(!(e instanceof Uint8Array&&r instanceof Uint8Array))throw new TypeError("Only Uint8Array instances can added");var t=e.length,a=0,_=0;if(r.length!=e.length)throw new TypeError("Arguments must have the same length");for(_=0;_<t;_++)a>>=8,a+=e[_]+r[_],e[_]=255&a},e.base64_variants=c,e.compare=function(e,r){if(!(e instanceof Uint8Array&&r instanceof Uint8Array))throw new TypeError("Only Uint8Array instances can be compared");if(e.length!==r.length)throw new TypeError("Only instances of identical length can be compared");for(var t=0,a=1,_=e.length;_-- >0;)t|=r[_]-e[_]>>8&a,a&=(r[_]^e[_])-1>>8;return t+t+a-1},e.from_base64=function(e,r){r=o(r);var a,_=[],s=new l(3*(e=m(_,e,"input")).length/4),n=u(e),c=d(4),h=d(4);return _.push(n),_.push(s.address),_.push(s.result_bin_len_p),_.push(s.b64_end_p),0!==t._sodium_base642bin(s.address,s.length,n,e.length,0,c,h,r)&&g(_,"invalid input"),t.getValue(h,"i32")-n!==e.length&&g(_,"incomplete input"),s.length=t.getValue(c,"i32"),a=s.to_Uint8Array(),v(_),a},e.from_hex=function(e){var r,a=[],_=new l((e=m(a,e,"input")).length/2),s=u(e),n=d(4);return a.push(s),a.push(_.address),a.push(_.hex_end_p),0!==t._sodium_hex2bin(_.address,_.length,s,e.length,0,0,n)&&g(a,"invalid input"),t.getValue(n,"i32")-s!==e.length&&g(a,"incomplete input"),r=_.to_Uint8Array(),v(a),r},e.from_string=_,e.increment=function(e){if(!(e instanceof Uint8Array))throw new TypeError("Only Uint8Array instances can be incremented");for(var r=256,t=0,a=e.length;t<a;t++)r>>=8,r+=e[t],e[t]=255&r},e.is_zero=function(e){if(!(e instanceof Uint8Array))throw new TypeError("Only Uint8Array instances can be checked");for(var r=0,t=0,a=e.length;t<a;t++)r|=e[t];return 0===r},e.libsodium=r,e.memcmp=function(e,r){if(!(e instanceof Uint8Array&&r instanceof Uint8Array))throw new TypeError("Only Uint8Array instances can be compared");if(e.length!==r.length)throw new TypeError("Only instances of identical length can be compared");for(var t=0,a=0,_=e.length;a<_;a++)t|=e[a]^r[a];return 0===t},e.memzero=function(e){if(!(e instanceof Uint8Array))throw new TypeError("Only Uint8Array instances can be wiped");for(var r=0,t=e.length;r<t;r++)e[r]=0},e.output_formats=function(){return["uint8array","text","hex","base64"]},e.pad=function(e,r){if(!(e instanceof Uint8Array))throw new TypeError("buffer must be a Uint8Array");if((r|=0)<=0)throw new Error("block size must be > 0");var a,_=[],s=d(4),n=1,c=0,o=0|e.length,h=new l(o+r);_.push(s),_.push(h.address);for(var p=h.address,y=h.address+o+r;p<y;p++)t.HEAPU8[p]=e[c],c+=n=1&~((65535&((o-=n)>>>48|o>>>32|o>>>16|o))-1>>16);return 0!==t._sodium_pad(s,h.address,e.length,r,h.length)&&g(_,"internal error"),h.length=t.getValue(s,"i32"),a=h.to_Uint8Array(),v(_),a},e.unpad=function(e,r){if(!(e instanceof Uint8Array))throw new TypeError("buffer must be a Uint8Array");if((r|=0)<=0)throw new Error("block size must be > 0");var a=[],_=u(e),s=d(4);return a.push(_),a.push(s),0!==t._sodium_unpad(s,_,e.length,r)&&g(a,"unsupported/invalid padding"),e=(e=new Uint8Array(e)).subarray(0,t.getValue(s,"i32")),v(a),e},e.ready=a,e.symbols=function(){return Object.keys(e).sort()},e.to_base64=h,e.to_hex=n,e.to_string=s,e}var t="object"==typeof e.sodium&&"function"==typeof e.sodium.onload?e.sodium.onload:null;"function"==typeof define&&define.amd?define(["exports","libsodium"],r): true&&"string"!=typeof exports.nodeName?r(exports,__nccwpck_require__(1626)):e.sodium=r(e.commonJsStrict={},e.libsodium),t&&e.sodium.ready.then((function(){t(e.sodium)}))}(this);


/***/ }),

/***/ 1626:
/***/ (function(module, exports, __nccwpck_require__) {

!function(A){function I(A){"use strict";var I;void 0===(I=A)&&(I={});var g=I;"object"!=typeof g.sodium&&("object"==typeof global?g=global:"object"==typeof window&&(g=window));var C=I;return I.ready=new Promise((function(A,I){(Q=C).onAbort=I,Q.print=function(A){},Q.printErr=function(A){},Q.onRuntimeInitialized=function(){try{Q._crypto_secretbox_keybytes(),A()}catch(A){I(A)}},Q.useBackupModule=function(){return new Promise((function(A,I){(Q={}).onAbort=I,Q.onRuntimeInitialized=function(){Object.keys(C).forEach((function(A){"getRandomValue"!==A&&delete C[A]})),Object.keys(Q).forEach((function(A){C[A]=Q[A]})),A()};var g,B,Q=void 0!==Q?Q:{},i=Object.assign({},Q),E="object"==typeof window,o="function"==typeof importScripts,a="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,f="";if(a){var c=__nccwpck_require__(7147),e=__nccwpck_require__(1017);f=o?e.dirname(f)+"/":__dirname+"/",g=(A,I)=>(A=function(A){return A.startsWith("file://")}(A)?new URL(A):e.normalize(A),c.readFileSync(A,I?void 0:"utf8")),B=A=>{var I=g(A,!0);return I.buffer||(I=new Uint8Array(I)),I},!Q.thisProgram&&process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2), true&&(module.exports=Q),Q.inspect=()=>"[Emscripten Module object]"}else(E||o)&&(o?f=self.location.href:"undefined"!=typeof document&&document.currentScript&&(f=document.currentScript.src),f=0!==f.indexOf("blob:")?f.substr(0,f.replace(/[?#].*/,"").lastIndexOf("/")+1):"",g=A=>{var I=new XMLHttpRequest;return I.open("GET",A,!1),I.send(null),I.responseText},o&&(B=A=>{var I=new XMLHttpRequest;return I.open("GET",A,!1),I.responseType="arraybuffer",I.send(null),new Uint8Array(I.response)}));Q.print;var r,D=Q.printErr||void 0;Object.assign(Q,i),i=null,Q.arguments&&Q.arguments,Q.thisProgram&&Q.thisProgram,Q.quit&&Q.quit,Q.wasmBinary&&(r=Q.wasmBinary),Q.noExitRuntime;var t,y={Memory:function(A){this.buffer=new ArrayBuffer(65536*A.initial)},Module:function(A){},Instance:function(A,I){this.exports=function(A){for(var I,g=new Uint8Array(123),C=25;C>=0;--C)g[48+C]=52+C,g[65+C]=C,g[97+C]=26+C;function B(A,I,C){for(var B,Q,i=0,E=I,o=C.length,a=I+(3*o>>2)-("="==C[o-2])-("="==C[o-1]);i<o;i+=4)B=g[C.charCodeAt(i+1)],Q=g[C.charCodeAt(i+2)],A[E++]=g[C.charCodeAt(i)]<<2|B>>4,E<a&&(A[E++]=B<<4|Q>>2),E<a&&(A[E++]=Q<<6|g[C.charCodeAt(i+3)])}function Q(){throw new Error("abort")}return g[43]=62,g[47]=63,function(A){var g=A.a,C=g.a,i=C.buffer;C.grow=function(A){A|=0;var g=0|hI(),B=g+A|0;if(g<B&&B<65536){var Q=new ArrayBuffer(c(B,65536));new Int8Array(Q).set(E),E=new Int8Array(Q),new Int16Array(Q),o=new Int32Array(Q),a=new Uint8Array(Q),new Uint16Array(Q),f=new Uint32Array(Q),new Float32Array(Q),new Float64Array(Q),i=Q,C.buffer=i,I=a}return g};var E=new Int8Array(i),o=(new Int16Array(i),new Int32Array(i)),a=new Uint8Array(i),f=(new Uint16Array(i),new Uint32Array(i)),c=(new Float32Array(i),new Float64Array(i),Math.imul),e=(Math.fround,Math.abs,Math.clz32),r=(Math.min,Math.max,Math.floor,Math.ceil,Math.trunc,Math.sqrt,g.b),D=g.c,t=g.d,y=g.e,w=102096,h=0;function n(A,I){var g,C,B,Q,i,o=0,f=0,c=0,e=0,r=0,D=0,t=0,y=0,w=0,n=0,s=0,k=0,F=0,S=0,H=0,G=0,_=0,M=0,p=0,N=0,J=0,U=0,Y=0,d=0,K=0,b=0,P=0,v=0,L=0,R=0,u=0,x=0,m=0,l=0,z=0,q=0,X=0,j=0,T=0,O=0,V=0,Z=0,W=0,$=0,AA=0,IA=0,gA=0,CA=0,BA=0,QA=0,iA=0,EA=0,oA=0,aA=0,fA=0,cA=0,eA=0,rA=0,tA=0,yA=0,wA=0,hA=0,nA=0,sA=0,kA=0,FA=0,SA=0,HA=0,GA=0,_A=0,MA=0,pA=0,NA=0,JA=0;rA=a[I+40|0]|a[I+41|0]<<8|a[I+42|0]<<16|a[I+43|0]<<24,yA=o=a[I+44|0]|a[I+45|0]<<8|a[I+46|0]<<16|a[I+47|0]<<24,gA=a[I+104|0]|a[I+105|0]<<8|a[I+106|0]<<16|a[I+107|0]<<24,wA=o=a[I+108|0]|a[I+109|0]<<8|a[I+110|0]<<16|a[I+111|0]<<24,o=a[I+68|0]|a[I+69|0]<<8|a[I+70|0]<<16|a[I+71|0]<<24,X=a[I+64|0]|a[I+65|0]<<8|a[I+66|0]<<16|a[I+67|0]<<24,BA=o,MA=o=a[I+36|0]|a[I+37|0]<<8|a[I+38|0]<<16|a[I+39|0]<<24,_=o,oA=a[I+120|0]|a[I+121|0]<<8|a[I+122|0]<<16|a[I+123|0]<<24,kA=o=a[I+124|0]|a[I+125|0]<<8|a[I+126|0]<<16|a[I+127|0]<<24,B=o=a[I+92|0]|a[I+93|0]<<8|a[I+94|0]<<16|a[I+95|0]<<24,g=a[I+88|0]|a[I+89|0]<<8|a[I+90|0]<<16|a[I+91|0]<<24,q=o,EA=a[I+80|0]|a[I+81|0]<<8|a[I+82|0]<<16|a[I+83|0]<<24,nA=o=a[I+84|0]|a[I+85|0]<<8|a[I+86|0]<<16|a[I+87|0]<<24,j=o,QA=a[A+16|0]|a[A+17|0]<<8|a[A+18|0]<<16|a[A+19|0]<<24,o=(fA=a[A+52|0]|a[A+53|0]<<8|a[A+54|0]<<16|a[A+55|0]<<24)+_|0,l=(aA=a[A+48|0]|a[A+49|0]<<8|a[A+50|0]<<16|a[A+51|0]<<24)+(cA=a[I+32|0]|a[I+33|0]<<8|a[I+34|0]<<16|a[I+35|0]<<24)|0,o=(a[A+20|0]|a[A+21|0]<<8|a[A+22|0]<<16|a[A+23|0]<<24)+(aA>>>0>l>>>0?o+1|0:o)|0,o=(QA=(f=l)>>>0>(l=l+QA|0)>>>0?o+1|0:o)+yA|0,iA=tA=l+rA|0,tA=o=tA>>>0<l>>>0?o+1|0:o,l=DA(l^(a[A+80|0]|a[A+81|0]<<8|a[A+82|0]<<16|a[A+83|0]<<24)^-79577749,QA^(a[A+84|0]|a[A+85|0]<<8|a[A+86|0]<<16|a[A+87|0]<<24)^528734635,32),HA=o=h,o=o+1013904242|0,QA=l,V=o=(l=l-23791573|0)>>>0<4271175723?o+1|0:o,fA=DA(l^aA,o^fA,40),o=(o=tA)+(tA=h)|0,aA=DA(QA^(w=aA=fA+iA|0),HA^(n=w>>>0<fA>>>0?o+1|0:o),48),o=V+(x=h)|0,S=o=(aA=l+(s=aA)|0)>>>0<l>>>0?o+1|0:o,aA=o=DA(fA^(F=aA),tA^o,1),V=l=h,tA=a[I+24|0]|a[I+25|0]<<8|a[I+26|0]<<16|a[I+27|0]<<24,HA=o=a[I+28|0]|a[I+29|0]<<8|a[I+30|0]<<16|a[I+31|0]<<24,eA=a[A+8|0]|a[A+9|0]<<8|a[A+10|0]<<16|a[A+11|0]<<24,l=(fA=a[I+16|0]|a[I+17|0]<<8|a[I+18|0]<<16|a[I+19|0]<<24)+(QA=a[A+40|0]|a[A+41|0]<<8|a[A+42|0]<<16|a[A+43|0]<<24)|0,o=(pA=a[I+20|0]|a[I+21|0]<<8|a[I+22|0]<<16|a[I+23|0]<<24)+(JA=a[A+44|0]|a[A+45|0]<<8|a[A+46|0]<<16|a[A+47|0]<<24)|0,o=(a[A+12|0]|a[A+13|0]<<8|a[A+14|0]<<16|a[A+15|0]<<24)+(l>>>0<QA>>>0?o+1|0:o)|0,o=HA+(iA=(f=l)>>>0>(l=l+eA|0)>>>0?o+1|0:o)|0,o=(eA=l+tA|0)>>>0<l>>>0?o+1|0:o,f=DA(l^(a[A+72|0]|a[A+73|0]<<8|a[A+74|0]<<16|a[A+75|0]<<24)^725511199,iA^(a[A+76|0]|a[A+77|0]<<8|a[A+78|0]<<16|a[A+79|0]<<24)^-1694144372,32),D=DA(QA^(c=f-2067093701|0),JA^(R=(K=l=h)-((f>>>0<2067093701)+1150833018|0)|0),40),o=(m=h)+o|0,o=(d=(H=l=D+eA|0)>>>0<D>>>0?o+1|0:o)+V|0,o=(H>>>0>(l=H+aA|0)>>>0?o+1|0:o)+j|0,o=(QA=(e=l)>>>0>(l=l+EA|0)>>>0?o+1|0:o)+q|0,v=q=l+g|0,y=o=q>>>0<l>>>0?o+1|0:o,k=aA,FA=V,V=l,iA=QA,aA=a[I+8|0]|a[I+9|0]<<8|a[I+10|0]<<16|a[I+11|0]<<24,l=o=a[I+12|0]|a[I+13|0]<<8|a[I+14|0]<<16|a[I+15|0]<<24,JA=o=a[0|A]|a[A+1|0]<<8|a[A+2|0]<<16|a[A+3|0]<<24,Q=QA=a[A+4|0]|a[A+5|0]<<8|a[A+6|0]<<16|a[A+7|0]<<24,j=o,o=(GA=a[I+4|0]|a[I+5|0]<<8|a[I+6|0]<<16|a[I+7|0]<<24)+(r=a[A+36|0]|a[A+37|0]<<8|a[A+38|0]<<16|a[A+39|0]<<24)|0,o=Q+((q=a[A+32|0]|a[A+33|0]<<8|a[A+34|0]<<16|a[A+35|0]<<24)>>>0>(e=q+(QA=a[0|I]|a[I+1|0]<<8|a[I+2|0]<<16|a[I+3|0]<<24)|0)>>>0?o+1|0:o)|0,o=(eA=(j=e+j|0)>>>0<e>>>0?o+1|0:o)+l|0,sA=e=j+aA|0,e=o=e>>>0<j>>>0?o+1|0:o,t=q,q=DA(j^(a[0|(o=A- -64|0)]|a[o+1|0]<<8|a[o+2|0]<<16|a[o+3|0]<<24)^-1377402159,eA^(a[o+4|0]|a[o+5|0]<<8|a[o+6|0]<<16|a[o+7|0]<<24)^1359893119,32),eA=o=h,o=o+1779033703|0,j=q,J=o=(q=q-205731576|0)>>>0<4089235720?o+1|0:o,r=DA(t^(G=q),o^r,40),o=(P=h)+e|0,t=DA(j^(e=q=r+sA|0),eA^(M=r>>>0>e>>>0?o+1|0:o),48),o=DA(t^V,(W=h)^iA,32),O=q=h,L=o,C=o=a[I+60|0]|a[I+61|0]<<8|a[I+62|0]<<16|a[I+63|0]<<24,eA=sA=a[I+56|0]|a[I+57|0]<<8|a[I+58|0]<<16|a[I+59|0]<<24,N=a[A+24|0]|a[A+25|0]<<8|a[A+26|0]<<16|a[A+27|0]<<24,q=(iA=a[I+48|0]|a[I+49|0]<<8|a[I+50|0]<<16|a[I+51|0]<<24)+(j=a[A+56|0]|a[A+57|0]<<8|a[A+58|0]<<16|a[A+59|0]<<24)|0,o=(_A=a[I+52|0]|a[I+53|0]<<8|a[I+54|0]<<16|a[I+55|0]<<24)+(b=a[A+60|0]|a[A+61|0]<<8|a[A+62|0]<<16|a[A+63|0]<<24)|0,o=(a[A+28|0]|a[A+29|0]<<8|a[A+30|0]<<16|a[A+31|0]<<24)+(q>>>0<j>>>0?o+1|0:o)|0,o=C+(V=(p=q)>>>0>(q=N+q|0)>>>0?o+1|0:o)|0,o=(N=q+eA|0)>>>0<q>>>0?o+1|0:o,V=DA(q^(a[A+88|0]|a[A+89|0]<<8|a[A+90|0]<<16|a[A+91|0]<<24)^327033209,V^(a[A+92|0]|a[A+93|0]<<8|a[A+94|0]<<16|a[A+95|0]<<24)^1541459225,32),j=DA(j^(eA=V+1595750129|0),(p=b)^(b=(U=q=h)-((V>>>0<2699217167)+1521486533|0)|0),40),o=(IA=h)+o|0,q=DA((N=q=j+N|0)^V,U^(p=N>>>0<j>>>0?o+1|0:o),48),o=b+($=h)|0,Y=o=(q=eA+(b=q)|0)>>>0<eA>>>0?o+1|0:o,o=O+o|0,T=k^(V=L+(U=q)|0),k=o=V>>>0<U>>>0?o+1|0:o,eA=DA(T,o^FA,40),o=(FA=h)+y|0,q=DA(v=L^(y=q=eA+v|0),O^(L=y>>>0<eA>>>0?o+1|0:o),48),o=k+(CA=h)|0,O=o=(k=V+(v=q)|0)>>>0<V>>>0?o+1|0:o,q=(u=DA(k^eA,FA^o,1))+(V=a[I+72|0]|a[I+73|0]<<8|a[I+74|0]<<16|a[I+75|0]<<24)|0,o=(hA=h)+(FA=a[I+76|0]|a[I+77|0]<<8|a[I+78|0]<<16|a[I+79|0]<<24)|0,SA=q,z=q>>>0<V>>>0?o+1|0:o,Z=wA,q=a[I+96|0]|a[I+97|0]<<8|a[I+98|0]<<16|a[I+99|0]<<24,eA=o=a[I+100|0]|a[I+101|0]<<8|a[I+102|0]<<16|a[I+103|0]<<24,j=(o=w)+(w=DA(U^j,Y^IA,1))|0,o=(U=h)+n|0,o=(w>>>0>j>>>0?o+1|0:o)+eA|0,o=(n=(n=j)>>>0>(j=q+j|0)>>>0?o+1|0:o)+Z|0,T=Y=j+gA|0,Y=o=Y>>>0<j>>>0?o+1|0:o,H=DA(f^H,d^K,48),d=o=DA(H^j,(K=h)^n,32),o=J+W|0,o=(IA=j=h)+(G=(j=t+G|0)>>>0<t>>>0?o+1|0:o)|0,J=o=(n=j)>>>0>(t=n+d|0)>>>0?o+1|0:o,w=DA(t^w,U^o,40),o=(W=h)+Y|0,o=(U=w>>>0>(Y=j=w+T|0)>>>0?o+1|0:o)+z|0,o=(f=Y>>>0>(j=Y+SA|0)>>>0?o+1|0:o)+kA|0,SA=z=j+oA|0,z=o=z>>>0<j>>>0?o+1|0:o,T=j,Z=f,j=a[I+116|0]|a[I+117|0]<<8|a[I+118|0]<<16|a[I+119|0]<<24,I=a[I+112|0]|a[I+113|0]<<8|a[I+114|0]<<16|a[I+115|0]<<24,r=DA(r^n,G^P,1),o=(P=h)+p|0,o=((f=r+N|0)>>>0<r>>>0?o+1|0:o)+j|0,o=(n=(G=f)>>>0>(f=I+f|0)>>>0?o+1|0:o)+kA|0,NA=G=f+oA|0,G=o=G>>>0<f>>>0?o+1|0:o,o=DA(f^s,n^x,32),AA=f=h,s=o,n=f,o=K+R|0,H=f=c+H|0,N=o=f>>>0<c>>>0?o+1|0:o,o=o+n|0,p=f=f+s|0,x=o=H>>>0>f>>>0?o+1|0:o,n=DA(f^r,P^o,40),o=(P=h)+G|0,s=DA((f=n+NA|0)^s,AA^(c=f>>>0<n>>>0?o+1|0:o),48),o=DA(s^T,(NA=h)^Z,32),AA=r=h,G=o,T=r,D=DA(D^H,N^m,1),o=M+(H=h)|0,o=((r=e)>>>0>(e=e+D|0)>>>0?o+1|0:o)+BA|0,o=(e=(r=e+X|0)>>>0<e>>>0?o+1|0:o)+FA|0,Z=M=r+V|0,M=o=M>>>0<r>>>0?o+1|0:o,N=D,r=DA(r^b,e^$,32),o=(b=h)+S|0,F=DA(N^(e=D=r+F|0),(S=r>>>0>e>>>0?o+1|0:o)^H,40),o=($=h)+M|0,H=D=F+Z|0,D=DA(r^D,b^(M=D>>>0<F>>>0?o+1|0:o),48),o=S+(i=h)|0,S=D,b=o=(D=e+D|0)>>>0<e>>>0?o+1|0:o,o=o+T|0,o=(N=D)>>>0>(D=D+G|0)>>>0?o+1|0:o,T=D,D^=u,u=o,r=DA(D,hA^o,40),o=(hA=h)+z|0,z=D=r+SA|0,o=B+(Z=r>>>0>D>>>0?o+1|0:o)|0,SA=D=D+g|0,K=o=D>>>0<g>>>0?o+1|0:o,D=f,R=gA,m=wA,f=DA(d^Y,U^IA,48),o=J+(IA=h)|0,d=f,J=o=(e=t+f|0)>>>0<t>>>0?o+1|0:o,f=DA(e^w,W^o,1),o=(t=h)+m|0,o=((w=f+R|0)>>>0<f>>>0?o+1|0:o)+c|0,o=_A+(D=(c=D+w|0)>>>0<w>>>0?o+1|0:o)|0,Y=w=c+iA|0,w=o=w>>>0<iA>>>0?o+1|0:o,c=DA(c^S,D^i,32),o=O+(U=h)|0,S=c,k=o=(c=k+c|0)>>>0<k>>>0?o+1|0:o,D=DA(f^c,o^t,40),o=(o=w)+(w=h)|0,t=f=D+Y|0,f=DA(f^S,U^(Y=f>>>0<D>>>0?o+1|0:o),48),o=k+(W=h)|0,U=f,O=o=(k=c+f|0)>>>0<c>>>0?o+1|0:o,f=DA(D^k,w^o,1),o=(w=h)+K|0,o=C+(D=(c=f+SA|0)>>>0<f>>>0?o+1|0:o)|0,SA=S=c+sA|0,S=o=S>>>0<sA>>>0?o+1|0:o,K=f,R=w,o=x+NA|0,o=(f=s+p|0)>>>0<s>>>0?o+1|0:o,s=f,p=o,o=DA(f^n,P^o,1),n=w=h,f=o,o=M+j|0,o=((H=I+H|0)>>>0<I>>>0?o+1|0:o)+w|0,o=nA+(H=(w=f+H|0)>>>0<H>>>0?o+1|0:o)|0,x=M=w+EA|0,M=o=M>>>0<EA>>>0?o+1|0:o,w=DA(w^v,H^CA,32),o=J+(v=h)|0,H=w,J=o=(J=e)>>>0>(e=e+w|0)>>>0?o+1|0:o,w=DA(f^e,o^n,40),o=(P=h)+M|0,n=f=w+x|0,f=DA(M=f^H,v^(H=f>>>0<w>>>0?o+1|0:o),48),o=J+(CA=h)|0,J=f,M=f=e+f|0,v=o=f>>>0<e>>>0?o+1|0:o,x=c,m=D,f=DA(F^N,b^$,1),o=(e=h)+_|0,o=L+((c=f+cA|0)>>>0<f>>>0?o+1|0:o)|0,o=BA+(D=(c=c+y|0)>>>0<y>>>0?o+1|0:o)|0,L=y=c+X|0,y=o=y>>>0<c>>>0?o+1|0:o,F=f,f=(c=DA(c^d,D^IA,32))+s|0,o=(s=h)+p|0,D=f,e=DA(f^F,(d=f>>>0<c>>>0?o+1|0:o)^e,40),o=(IA=h)+y|0,y=f=e+L|0,N=DA(f^c,s^(L=f>>>0<e>>>0?o+1|0:o),48),c=DA(N^x,(o=m)^(m=h),32),o=(x=h)+v|0,s=f=c+M|0,F=DA(f^K,(p=f>>>0<c>>>0?o+1|0:o)^R,40),o=(K=h)+S|0,S=f=F+SA|0,f=DA(f^c,x^(b=f>>>0<F>>>0?o+1|0:o),48),o=p+($=h)|0,p=f,x=o=(c=s)>>>0>(s=s+f|0)>>>0?o+1|0:o,f=DA(s^F,K^o,1),o=kA+(SA=h)|0,K=f,NA=f=oA+f|0,F=o=f>>>0<oA>>>0?o+1|0:o,c=rA,f=DA(w^M,P^v,1),o=Y+(w=h)|0,o=((M=t)>>>0>(t=f+t|0)>>>0?o+1|0:o)+yA|0,o=(M=(c=c+t|0)>>>0<t>>>0?o+1|0:o)+HA|0,R=t=c+tA|0,Y=o=t>>>0<c>>>0?o+1|0:o,v=f,t=DA(G^z,Z^AA,48),o=DA(t^c,(P=h)^M,32),AA=f=h,G=o,c=f,o=d+m|0,o=(f=D+N|0)>>>0<D>>>0?o+1|0:o,D=f,d=o,o=o+c|0,M=f=f+G|0,N=o=D>>>0>f>>>0?o+1|0:o,c=DA(f^v,o^w,40),o=(o=Y)+(Y=h)|0,v=f=c+R|0,z=o=f>>>0<c>>>0?o+1|0:o,o=o+F|0,Z=o=(w=f+NA|0)>>>0<f>>>0?o+1|0:o,F=o,f=DA(e^D,d^IA,1),o=l+(e=h)|0,o=H+((D=f+aA|0)>>>0<aA>>>0?o+1|0:o)|0,o=eA+(n=(D=D+n|0)>>>0<n>>>0?o+1|0:o)|0,R=H=D+q|0,H=o=H>>>0<q>>>0?o+1|0:o,d=f,o=DA(D^U,n^W,32),m=f=h,D=o,n=f,o=P+u|0,U=f=t+T|0,u=o=f>>>0<t>>>0?o+1|0:o,o=o+n|0,o=(t=f+D|0)>>>0<f>>>0?o+1|0:o,f=t^d,d=o,n=DA(f,o^e,40),o=(W=h)+H|0,e=f=n+R|0,T=DA(f^D,m^(H=f>>>0<n>>>0?o+1|0:o),48),o=DA(T^w,(IA=h)^F,32),NA=f=h,R=o,F=f,f=DA(r^U,u^hA,1),o=L+(r=h)|0,o=GA+((D=f+y|0)>>>0<y>>>0?o+1|0:o)|0,o=(y=(D=D+QA|0)>>>0<QA>>>0?o+1|0:o)+pA|0,U=L=D+fA|0,L=o=L>>>0<D>>>0?o+1|0:o,D=DA(D^J,y^CA,32),o=O+(u=h)|0,J=D,y=r,r=o=(D=k+D|0)>>>0<k>>>0?o+1|0:o,y=DA(f^D,y^o,40),o=(CA=h)+L|0,k=f=y+U|0,f=DA(U=f^J,u^(J=f>>>0<y>>>0?o+1|0:o),48),o=r+(P=h)|0,r=f,L=f=D+f|0,U=o=f>>>0<D>>>0?o+1|0:o,o=o+F|0,O=o=(F=f+R|0)>>>0<f>>>0?o+1|0:o,D=DA(F^K,SA^o,40),o=Z+(u=h)|0,o=((f=D+w|0)>>>0<w>>>0?o+1|0:o)+wA|0,w=f,Z=f=f+gA|0,K=o=w>>>0>f>>>0?o+1|0:o,m=BA,w=DA(G^v,z^AA,48),o=(hA=h)+N|0,G=f=w+M|0,o=DA(f^c,(M=f>>>0<w>>>0?o+1|0:o)^Y,1),Y=c=h,f=o,o=H+B|0,o=((e=e+g|0)>>>0<g>>>0?o+1|0:o)+c|0,o=(e=(c=f+e|0)>>>0<e>>>0?o+1|0:o)+m|0,N=H=c+X|0,H=o=H>>>0<c>>>0?o+1|0:o,c=DA(c^r,e^P,32),o=x+(v=h)|0,s=o=(r=c+s|0)>>>0<s>>>0?o+1|0:o,e=DA(f^r,o^Y,40),o=(z=h)+H|0,H=f=e+N|0,c=DA(f^c,v^(Y=f>>>0<e>>>0?o+1|0:o),48),o=s+(N=h)|0,v=o=(s=c+r|0)>>>0<r>>>0?o+1|0:o,f=DA(e^s,z^o,1),o=(z=h)+K|0,o=FA+((r=f+Z|0)>>>0<f>>>0?o+1|0:o)|0,o=(e=(r=r+V|0)>>>0<V>>>0?o+1|0:o)+_|0,SA=_=r+cA|0,_=o=_>>>0<r>>>0?o+1|0:o,x=f,m=r,P=e,r=rA,f=DA(y^L,U^CA,1),o=b+(y=h)|0,o=((e=S)>>>0>(S=f+S|0)>>>0?o+1|0:o)+yA|0,o=pA+(e=(r=r+S|0)>>>0<S>>>0?o+1|0:o)|0,b=S=r+fA|0,L=o=S>>>0<fA>>>0?o+1|0:o,S=f,e=o=DA(r^w,e^hA,32),o=d+IA|0,o=(U=f=h)+(t=(f=t+T|0)>>>0<t>>>0?o+1|0:o)|0,d=o=(w=f+e|0)>>>0<f>>>0?o+1|0:o,S=DA(w^S,o^y,40),o=(IA=h)+L|0,L=DA(b=(r=S+b|0)^e,U^(e=r>>>0<S>>>0?o+1|0:o),48),o=DA(L^m,(CA=h)^P,32),hA=y=h,b=o,U=y,f=DA(f^n,t^W,1),o=eA+(y=h)|0,o=J+((t=f+q|0)>>>0<q>>>0?o+1|0:o)|0,o=GA+(k=(t=t+k|0)>>>0<k>>>0?o+1|0:o)|0,m=n=t+QA|0,n=o=n>>>0<QA>>>0?o+1|0:o,J=f,T=y,t=DA(t^p,k^$,32),o=(p=h)+M|0,y=f=t+G|0,k=DA(f^J,(G=f>>>0<t>>>0?o+1|0:o)^T,40),o=(W=h)+n|0,J=f=k+m|0,f=DA(f^t,p^(M=f>>>0<k>>>0?o+1|0:o),48),o=G+(m=h)|0,n=f,G=f=y+f|0,p=o=f>>>0<y>>>0?o+1|0:o,o=o+U|0,U=f=f+b|0,t=z,z=o=G>>>0>f>>>0?o+1|0:o,t=DA(f^x,t^o,40),o=(o=_)+(_=h)|0,T=f=t+SA|0,x=o=f>>>0<t>>>0?o+1|0:o,y=e,f=DA(R^Z,K^NA,48),o=O+($=h)|0,O=f,e=(f=F+f|0)^D,D=o=f>>>0<F>>>0?o+1|0:o,e=DA(e,o^u,1),o=(u=h)+y|0,o=C+((r=e+r|0)>>>0<e>>>0?o+1|0:o)|0,o=(y=(r=r+sA|0)>>>0<sA>>>0?o+1|0:o)+l|0,Z=F=r+aA|0,F=o=F>>>0<r>>>0?o+1|0:o,r=DA(r^n,y^m,32),o=v+(K=h)|0,v=r,s=o=(y=s+r|0)>>>0<s>>>0?o+1|0:o,e=DA(e^y,u^o,40),o=(o=F)+(F=h)|0,n=r=e+Z|0,r=DA(R=r^v,K^(v=r>>>0<e>>>0?o+1|0:o),48),o=s+(SA=h)|0,u=r,Z=o=(s=y+r|0)>>>0<y>>>0?o+1|0:o,r=DA(e^s,F^o,1),o=(F=h)+x|0,o=B+((e=r+T|0)>>>0<r>>>0?o+1|0:o)|0,o=j+(y=(e=e+g|0)>>>0<g>>>0?o+1|0:o)|0,NA=K=I+e|0,K=o=K>>>0<I>>>0?o+1|0:o,R=r,m=F,F=e,P=y,r=DA(k^G,p^W,1),o=(y=h)+Y|0,o=nA+((e=r+H|0)>>>0<r>>>0?o+1|0:o)|0,o=(k=(e=e+EA|0)>>>0<EA>>>0?o+1|0:o)+j|0,Y=H=I+e|0,H=o=H>>>0<e>>>0?o+1|0:o,G=r,e=o=DA(e^O,k^$,32),k=r=h,o=d+CA|0,d=o=(r=w+L|0)>>>0<w>>>0?o+1|0:o,o=o+k|0,o=(w=r)>>>0>(r=r+e|0)>>>0?o+1|0:o,L=r,r^=G,G=o,y=DA(r,o^y,40),o=(W=h)+H|0,k=DA(H=(r=y+Y|0)^e,k^(e=r>>>0<y>>>0?o+1|0:o),48),o=DA(k^F,(o=P)^(P=h),32),$=F=h,H=o,Y=D,D=c,o=DA(w^S,d^IA,1),p=c=h,w=o,o=M+HA|0,o=((S=J+tA|0)>>>0<tA>>>0?o+1|0:o)+c|0,S=o=(c=w+S|0)>>>0<S>>>0?o+1|0:o,D=DA(c^D,o^N,32),o=(o=Y)+(Y=h)|0,w=DA((f=D+f|0)^w,p^(d=f>>>0<D>>>0?o+1|0:o),40),o=S+(IA=h)|0,J=w,o=_A+((M=c)>>>0>(c=c+w|0)>>>0?o+1|0:o)|0,M=o=(w=c+iA|0)>>>0<iA>>>0?o+1|0:o,c=DA(D^w,Y^o,48),o=d+(CA=h)|0,N=f,D=c,d=f=f+c|0,Y=o=N>>>0>f>>>0?o+1|0:o,o=o+F|0,N=o=(F=f+H|0)>>>0<f>>>0?o+1|0:o,f=(S=DA(F^R,o^m,40))+NA|0,o=(NA=h)+K|0,p=f,O=f>>>0<S>>>0?o+1|0:o,f=DA(b^T,x^hA,48),o=(b=h)+z|0,U=c=f+U|0,R=_,_=o=c>>>0<f>>>0?o+1|0:o,o=DA(c^t,R^o,1),T=c=h,t=o,o=e+C|0,o=((r=r+sA|0)>>>0<sA>>>0?o+1|0:o)+c|0,o=FA+(r=(c=r+t|0)>>>0<r>>>0?o+1|0:o)|0,x=e=c+V|0,e=o=e>>>0<V>>>0?o+1|0:o,c=DA(c^D,r^CA,32),o=Z+(K=h)|0,z=c,c=(D=s+c|0)^t,t=o=D>>>0<s>>>0?o+1|0:o,r=DA(c,T^o,40),o=(o=e)+(e=h)|0,T=c=r+x|0,c=DA(s=c^z,K^(z=c>>>0<r>>>0?o+1|0:o),48),o=t+(CA=h)|0,Z=c,D=o=(c=D+c|0)>>>0<D>>>0?o+1|0:o,r=DA(c^r,e^o,1),o=(s=h)+O|0,o=kA+((e=r+p|0)>>>0<r>>>0?o+1|0:o)|0,o=(t=(e=e+oA|0)>>>0<oA>>>0?o+1|0:o)+BA|0,AA=x=e+X|0,x=o=x>>>0<e>>>0?o+1|0:o,K=r,R=e,m=t,r=DA(J^d,Y^IA,1),o=(Y=h)+wA|0,o=v+(r>>>0>(e=r+gA|0)>>>0?o+1|0:o)|0,t=o=(e=e+n|0)>>>0<n>>>0?o+1|0:o,o=DA(f^e,o^b,32),b=f=h,n=o,o=G+P|0,o=(f=k+L|0)>>>0<k>>>0?o+1|0:o,k=f,d=o,o=b+o|0,G=f=f+n|0,J=o=k>>>0>f>>>0?o+1|0:o,f=DA(f^r,Y^o,40),o=t+(P=h)|0,L=f,o=eA+((f=e+f|0)>>>0<e>>>0?o+1|0:o)|0,o=(f=f+q|0)>>>0<q>>>0?o+1|0:o,Y=f,f^=n,n=o,t=DA(f,b^o,48),o=DA(t^R,(o=m)^(m=h),32),IA=f=h,b=o,v=f,f=DA(y^k,d^W,1),o=HA+(e=h)|0,o=M+((r=f+tA|0)>>>0<tA>>>0?o+1|0:o)|0,o=(y=(r=r+w|0)>>>0<w>>>0?o+1|0:o)+l|0,M=k=r+aA|0,k=o=k>>>0<r>>>0?o+1|0:o,w=f,d=e,f=(r=DA(r^u,y^SA,32))+U|0,o=(U=h)+_|0,e=f,y=DA(y=f^w,(w=f>>>0<r>>>0?o+1|0:o)^d,40),o=(W=h)+k|0,k=f=y+M|0,r=DA(f^r,U^(_=f>>>0<y>>>0?o+1|0:o),48),o=w+(d=h)|0,M=f=r+e|0,U=o=f>>>0<e>>>0?o+1|0:o,o=o+v|0,v=o=(w=f+b|0)>>>0<f>>>0?o+1|0:o,e=DA(w^K,o^s,40),o=(u=h)+x|0,x=f=e+AA|0,K=o=f>>>0<e>>>0?o+1|0:o,f=c,s=D,D=r,c=DA(H^p,O^$,48),o=N+(AA=h)|0,H=c,F=o=(r=F+c|0)>>>0<F>>>0?o+1|0:o,o=DA(r^S,NA^o,1),N=c=h,S=o,o=n+MA|0,o=((n=Y+cA|0)>>>0<cA>>>0?o+1|0:o)+c|0,n=o=(c=n+S|0)>>>0<n>>>0?o+1|0:o,D=DA(c^D,o^d,32),o=(Y=h)+s|0,S=DA((f=D+f|0)^S,N^(s=f>>>0<D>>>0?o+1|0:o),40),o=n+(p=h)|0,o=GA+((n=c)>>>0>(c=c+S|0)>>>0?o+1|0:o)|0,d=o=(n=c+QA|0)>>>0<QA>>>0?o+1|0:o,c=DA(D^n,Y^o,48),o=s+($=h)|0,Y=c,N=o=(s=f+c|0)>>>0<f>>>0?o+1|0:o,f=DA(s^S,p^o,1),o=(S=h)+K|0,o=nA+((c=f+x|0)>>>0<f>>>0?o+1|0:o)|0,o=kA+(D=(c=c+EA|0)>>>0<EA>>>0?o+1|0:o)|0,hA=p=c+oA|0,p=o=p>>>0<oA>>>0?o+1|0:o,O=f,R=c,f=DA(y^M,U^W,1),o=(y=h)+z|0,o=pA+((c=f+T|0)>>>0<f>>>0?o+1|0:o)|0,o=_A+(M=(c=c+fA|0)>>>0<fA>>>0?o+1|0:o)|0,T=U=c+iA|0,U=o=U>>>0<iA>>>0?o+1|0:o,z=f,o=DA(c^H,M^AA,32),AA=f=h,c=o,o=J+m|0,G=f=t+G|0,H=o=f>>>0<t>>>0?o+1|0:o,o=AA+o|0,J=o=(t=f+c|0)>>>0<f>>>0?o+1|0:o,y=DA(t^z,o^y,40),o=(m=h)+U|0,M=f=y+T|0,z=DA(f^c,AA^(U=f>>>0<y>>>0?o+1|0:o),48),o=DA(z^R,(AA=h)^D,32),W=f=h,T=o,D=f,c=rA,f=DA(G^L,H^P,1),o=_+(H=h)|0,o=((G=k)>>>0>(k=f+k|0)>>>0?o+1|0:o)+yA|0,o=nA+(k=(c=c+k|0)>>>0<k>>>0?o+1|0:o)|0,G=_=c+EA|0,_=o=_>>>0<EA>>>0?o+1|0:o,c=DA(c^Z,k^CA,32),o=F+(L=h)|0,F=c,o=(c=r+c|0)>>>0<r>>>0?o+1|0:o,r=H,H=o,r=DA(f^c,r^o,40),o=(P=h)+_|0,k=f=r+G|0,f=DA(f^F,L^(_=f>>>0<r>>>0?o+1|0:o),48),o=H+(R=h)|0,H=f,G=f=c+f|0,L=o=f>>>0<c>>>0?o+1|0:o,o=o+D|0,o=(F=f+T|0)>>>0<f>>>0?o+1|0:o,f=F^O,O=o,S=DA(f,o^S,40),o=(CA=h)+p|0,p=f=S+hA|0,Z=f>>>0<S>>>0?o+1|0:o,f=DA(b^x,K^IA,48),o=v+(IA=h)|0,b=f,o=(f=w+f|0)>>>0<w>>>0?o+1|0:o,w=f,v=o,o=DA(f^e,o^u,1),u=f=h,D=o,o=U+FA|0,o=((c=M+V|0)>>>0<V>>>0?o+1|0:o)+f|0,o=GA+(c=(f=c+D|0)>>>0<c>>>0?o+1|0:o)|0,M=e=f+QA|0,e=o=e>>>0<QA>>>0?o+1|0:o,f=DA(f^H,c^R,32),o=N+(U=h)|0,H=f,s=o=(c=s+f|0)>>>0<s>>>0?o+1|0:o,D=DA(c^D,u^o,40),o=(u=h)+e|0,M=f=D+M|0,f=DA(e=f^H,U^(H=f>>>0<D>>>0?o+1|0:o),48),o=s+(hA=h)|0,s=f,N=o=(e=c+f|0)>>>0<c>>>0?o+1|0:o,f=DA(e^D,u^o,1),o=(U=h)+Z|0,o=HA+((c=f+p|0)>>>0<f>>>0?o+1|0:o)|0,o=(D=(c=c+tA|0)>>>0<tA>>>0?o+1|0:o)+wA|0,SA=u=c+gA|0,u=o=u>>>0<c>>>0?o+1|0:o,x=f,K=c,R=D,f=DA(r^G,P^L,1),o=pA+(D=h)|0,o=d+((c=f+fA|0)>>>0<fA>>>0?o+1|0:o)|0,o=MA+(r=(c=c+n|0)>>>0<n>>>0?o+1|0:o)|0,L=n=c+cA|0,n=o=n>>>0<cA>>>0?o+1|0:o,d=f,G=D,o=DA(c^b,r^IA,32),b=f=h,r=o,c=f,o=J+AA|0,o=(f=t+z|0)>>>0<t>>>0?o+1|0:o,t=f,J=o,o=o+c|0,o=(D=f+r|0)>>>0<f>>>0?o+1|0:o,f=D^d,d=o,f=DA(f,o^G,40),o=(o=n)+(n=h)|0,G=c=f+L|0,L=o=c>>>0<f>>>0?o+1|0:o,b=DA(c^r,b^o,48),o=DA(b^K,(o=R)^(R=h),32),P=c=h,z=o,c=DA(t^y,J^m,1),o=(t=h)+yA|0,o=_+((r=c+rA|0)>>>0<c>>>0?o+1|0:o)|0,o=C+(y=(r=r+k|0)>>>0<k>>>0?o+1|0:o)|0,m=k=r+sA|0,k=o=k>>>0<sA>>>0?o+1|0:o,_=c,J=t,r=DA(r^Y,y^$,32),o=(Y=h)+v|0,t=c=r+w|0,c=(y=DA(c^_,(w=c>>>0<r>>>0?o+1|0:o)^J,40))+m|0,o=(m=h)+k|0,_=c,c=DA(c^r,Y^(J=c>>>0<y>>>0?o+1|0:o),48),o=w+(AA=h)|0,Y=c,v=c=t+c|0,K=o=c>>>0<t>>>0?o+1|0:o,o=P+o|0,o=(r=c+z|0)>>>0<c>>>0?o+1|0:o,c=U,U=o,t=DA(r^x,c^o,40),o=(IA=h)+u|0,k=c=t+SA|0,o=DA(c^z,P^(u=c>>>0<t>>>0?o+1|0:o),48),P=c=h,z=o,c=f,o=d+R|0,d=f=D+b|0,b=o=f>>>0<D>>>0?o+1|0:o,o=DA(f^c,o^n,1),D=c=h,f=o,o=J+B|0,o=((w=_+g|0)>>>0<g>>>0?o+1|0:o)+c|0,o=eA+(w=(c=f+w|0)>>>0<w>>>0?o+1|0:o)|0,R=n=c+q|0,n=o=n>>>0<q>>>0?o+1|0:o,_=f,J=D,f=DA(p^T,Z^W,48),o=O+(W=h)|0,p=f,o=(f=F+f|0)>>>0<F>>>0?o+1|0:o,F=f,c=DA(c^s,w^hA,32),O=o,o=o+(T=h)|0,D=f=c+f|0,w=DA(f^_,(s=f>>>0<c>>>0?o+1|0:o)^J,40),o=(Z=h)+n|0,n=f=w+R|0,f=DA(f^c,T^(_=f>>>0<w>>>0?o+1|0:o),48),o=s+($=h)|0,J=f,T=o=(s=D+f|0)>>>0<D>>>0?o+1|0:o,f=DA(w^s,Z^o,1),o=GA+(R=h)|0,Z=f,hA=f=QA+f|0,D=o=f>>>0<QA>>>0?o+1|0:o,f=DA(S^F,O^CA,1),o=(w=h)+L|0,o=_A+((c=f+G|0)>>>0<f>>>0?o+1|0:o)|0,o=BA+(F=(c=c+iA|0)>>>0<iA>>>0?o+1|0:o)|0,O=S=c+X|0,S=o=S>>>0<X>>>0?o+1|0:o,G=w,c=DA(c^Y,F^AA,32),o=N+(AA=h)|0,L=c,o=(w=e+c|0)>>>0<e>>>0?o+1|0:o,e=G,G=o,F=DA(f^w,e^o,40),o=(CA=h)+S|0,Y=f=F+O|0,o=(N=f>>>0<F>>>0?o+1|0:o)+D|0,S=o=(D=f+hA|0)>>>0<f>>>0?o+1|0:o,O=o=DA(D^z,o^P,32),x=f=h,f=DA(y^v,K^m,1),o=(e=h)+H|0,o=j+((c=f+M|0)>>>0<f>>>0?o+1|0:o)|0,o=(y=(c=I+c|0)>>>0<I>>>0?o+1|0:o)+l|0,K=H=c+aA|0,H=o=H>>>0<c>>>0?o+1|0:o,M=f,v=e,c=DA(c^p,y^W,32),o=(p=h)+b|0,e=f=c+d|0,f=(y=DA(f^M,(d=f>>>0<c>>>0?o+1|0:o)^v,40))+K|0,o=(K=h)+H|0,H=f,f=DA(f^c,p^(M=f>>>0<y>>>0?o+1|0:o),48),o=d+(W=h)|0,d=f,p=o=(f=e+f|0)>>>0<e>>>0?o+1|0:o,o=o+x|0,b=o=(e=f)>>>0>(f=f+O|0)>>>0?o+1|0:o,c=DA(f^Z,R^o,40),o=S+(R=h)|0,v=c,o=B+((c=D+c|0)>>>0<D>>>0?o+1|0:o)|0,Z=c=c+g|0,D=c^O,O=o=c>>>0<g>>>0?o+1|0:o,c=DA(D,x^o,48),o=b+(x=h)|0,b=o=(S=f+c|0)>>>0<f>>>0?o+1|0:o,f=o=DA(S^v,R^o,1),v=D=h,D=DA(e^y,p^K,1),o=_+(y=h)|0,o=_A+((e=D+n|0)>>>0<n>>>0?o+1|0:o)|0,o=nA+(n=(e=e+iA|0)>>>0<iA>>>0?o+1|0:o)|0,R=_=e+EA|0,_=o=_>>>0<EA>>>0?o+1|0:o,p=D,K=y,o=U+P|0,o=(D=r+z|0)>>>0<r>>>0?o+1|0:o,U=D,L=DA(Y^L,N^AA,48),y=DA(e^L,n^(AA=h),32),Y=o,o=o+(hA=h)|0,n=D=y+D|0,D=DA(D^p,(N=D>>>0<y>>>0?o+1|0:o)^K,40),o=(p=h)+_|0,K=o=(r=D+R|0)>>>0<D>>>0?o+1|0:o,o=o+v|0,o=C+((z=r)>>>0>(r=f+r|0)>>>0?o+1|0:o)|0,o=(e=(r=r+sA|0)>>>0<sA>>>0?o+1|0:o)+yA|0,SA=_=r+rA|0,R=o=_>>>0<r>>>0?o+1|0:o,m=f,P=r,o=DA(t^U,Y^IA,1),t=r=h,f=o,o=M+pA|0,o=((_=H+fA|0)>>>0<fA>>>0?o+1|0:o)+r|0,o=eA+(_=(r=f+_|0)>>>0<_>>>0?o+1|0:o)|0,Y=H=r+q|0,H=o=H>>>0<q>>>0?o+1|0:o,M=f,o=DA(r^J,_^$,32),U=f=h,r=o,_=f,o=G+AA|0,G=f=w+L|0,J=o=f>>>0<w>>>0?o+1|0:o,o=o+_|0,o=(w=f+r|0)>>>0<f>>>0?o+1|0:o;f=w^M,M=o,_=DA(f,o^t,40),o=(AA=h)+H|0,L=DA(H=(f=_+Y|0)^r,U^(r=f>>>0<_>>>0?o+1|0:o),48),o=DA(o=L^P,(P=h)^e,32),IA=e=h,Y=o,H=e,e=DA(F^G,J^CA,1),o=BA+(F=h)|0,o=u+((t=e+X|0)>>>0<X>>>0?o+1|0:o)|0,o=HA+(k=(t=t+k|0)>>>0<k>>>0?o+1|0:o)|0,J=G=t+tA|0,G=o=G>>>0<tA>>>0?o+1|0:o,t=DA(t^d,k^W,32),o=T+(U=h)|0,d=t,s=o=(t=s+t|0)>>>0<s>>>0?o+1|0:o,k=DA(e^t,o^F,40),o=(W=h)+G|0,F=e=k+J|0,e=DA(G=e^d,U^(d=e>>>0<k>>>0?o+1|0:o),48),o=s+($=h)|0,G=e,J=e=t+e|0,U=o=e>>>0<t>>>0?o+1|0:o,o=o+H|0,o=(t=e+Y|0)>>>0<e>>>0?o+1|0:o,e=v,v=o,s=DA(t^m,e^o,40),o=(u=h)+R|0,H=e=s+SA|0,e=DA(R=e^Y,IA^(Y=e>>>0<s>>>0?o+1|0:o),48),o=v+(IA=h)|0,v=e,t=o=(e=t+e|0)>>>0<t>>>0?o+1|0:o,u=o=DA(e^s,u^o,1),CA=o,T=s=h,s=r,r=D,D=DA(y^z,K^hA,48),o=N+(hA=h)|0,N=D,o=(D=n+D|0)>>>0<n>>>0?o+1|0:o,n=f,f=r^D,r=o,f=DA(f,o^p,1),o=(p=h)+s|0,o=MA+(f>>>0>(y=n+f|0)>>>0?o+1|0:o)|0,o=wA+(n=(y=y+cA|0)>>>0<cA>>>0?o+1|0:o)|0,z=s=y+gA|0,s=o=s>>>0<gA>>>0?o+1|0:o,y=DA(y^G,n^$,32),o=b+(K=h)|0,G=o=(n=y+S|0)>>>0<S>>>0?o+1|0:o,S=DA(f^n,p^o,40),o=($=h)+s|0,p=f=S+z|0,y=DA(f^y,K^(b=f>>>0<S>>>0?o+1|0:o),48),o=G+(z=h)|0,K=f=y+n|0,G=f,R=o=f>>>0<n>>>0?o+1|0:o,n=D,s=r,o=M+P|0,o=(f=w+L|0)>>>0<w>>>0?o+1|0:o,w=f,f^=_,_=o,o=DA(f,AA^o,1),m=f=h,M=o,r=o,o=d+l|0,o=((D=F+aA|0)>>>0<aA>>>0?o+1|0:o)+f|0,F=o=(f=D)>>>0>(D=r+D|0)>>>0?o+1|0:o,r=DA(c^D,o^x,32),o=(o=s)+(s=h)|0,L=f=r+n|0,c=DA(c=f^M,m^(M=f>>>0<r>>>0?o+1|0:o),40),o=F+(x=h)|0,o=FA+((f=c+D|0)>>>0<D>>>0?o+1|0:o)|0,m=o=(n=f+V|0)>>>0<V>>>0?o+1|0:o,s=DA(r^n,s^o,48),SA=o=h,f=DA(k^J,U^W,1),o=(r=h)+O|0,o=kA+((D=f+Z|0)>>>0<f>>>0?o+1|0:o)|0,o=j+(k=(D=D+oA|0)>>>0<oA>>>0?o+1|0:o)|0,O=F=I+D|0,J=o=F>>>0<I>>>0?o+1|0:o,U=f,F=DA(D^N,k^hA,32),o=(W=h)+_|0,_=f=F+w|0,D=DA(f^U,(N=f>>>0<F>>>0?o+1|0:o)^r,40),o=(o=J)+(J=h)|0,U=f=D+O|0,O=o=f>>>0<D>>>0?o+1|0:o,r=o,o=j+T|0,o=((k=I+u|0)>>>0<I>>>0?o+1|0:o)+r|0,d=o=(r=f+k|0)>>>0<k>>>0?o+1|0:o,f=DA(r^s,SA^o,32),o=(u=h)+R|0,w=DA((k=f+G|0)^CA,(o=k>>>0<f>>>0?o+1|0:o)^T,40),T=o,o=wA+(G=h)|0,o=d+((Z=w+gA|0)>>>0<gA>>>0?o+1|0:o)|0,o=(d=r+Z|0)>>>0<r>>>0?o+1|0:o,r=u,u=o,r=DA(f^d,r^o,48),o=(o=T)+(T=h)|0,f=w^(k=r+k|0),w=o=k>>>0<r>>>0?o+1|0:o,Z=o=DA(f,o^G,1),CA=o,P=f=h,G=e,AA=t,e=D,D=DA(F^U,O^W,48),o=N+(U=h)|0,F=f=D+_|0,_=o=f>>>0<_>>>0?o+1|0:o,e=DA(f^e,o^J,1),o=(O=h)+MA|0,o=m+((f=e+cA|0)>>>0<e>>>0?o+1|0:o)|0,n=o=(t=f+n|0)>>>0<n>>>0?o+1|0:o,f=DA(t^y,o^z,32),o=(J=h)+AA|0,G=y=f+G|0,N=o=y>>>0<f>>>0?o+1|0:o,e=DA(e^y,o^O,40),o=nA+(hA=h)|0,O=e,o=n+((e=EA+e|0)>>>0<EA>>>0?o+1|0:o)|0,t=o=(e=e+t|0)>>>0<t>>>0?o+1|0:o,y=DA(f^e,o^J,48),o=(o=N)+(N=h)|0,z=f=y+G|0,J=f,m=o=f>>>0<y>>>0?o+1|0:o,o=M+SA|0,G=(f=s+L|0)^c,c=o=f>>>0<s>>>0?o+1|0:o,o=DA(G,o^x,1),x=n=h,G=o,o=b+eA|0,o=((s=p+q|0)>>>0<q>>>0?o+1|0:o)+n|0,M=o=(M=s)>>>0>(s=s+G|0)>>>0?o+1|0:o,L=n=DA(s^v,IA^o,32),p=o=h,o=o+_|0,b=n=n+F|0,v=o=L>>>0>n>>>0?o+1|0:o,n=DA(n^G,x^o,40),o=yA+(x=h)|0,o=M+((F=n+rA|0)>>>0<rA>>>0?o+1|0:o)|0,F=o=(G=s)>>>0>(s=s+F|0)>>>0?o+1|0:o,G=DA(s^L,o^p,48),IA=o=h,_=o,S=DA(S^K,R^$,1),M=o=h,L=D,o=o+l|0,o=Y+((D=S+aA|0)>>>0<aA>>>0?o+1|0:o)|0,o=(D=D+H|0)>>>0<H>>>0?o+1|0:o,H=D^L,L=o,H=DA(H,o^U,32),o=($=h)+c|0,Y=f=H+f|0,c=DA(f^S,(c=M)^(M=f>>>0<H>>>0?o+1|0:o),40),o=kA+(p=h)|0,o=L+((f=c+oA|0)>>>0<oA>>>0?o+1|0:o)|0,L=f=f+D|0,U=o=f>>>0<D>>>0?o+1|0:o,D=o,o=P+_A|0,o=((S=Z+iA|0)>>>0<iA>>>0?o+1|0:o)+D|0,Z=o=(D=f+S|0)>>>0<S>>>0?o+1|0:o,f=DA(D^G,o^_,32),o=(K=h)+m|0,_=DA((S=f+J|0)^CA,(o=S>>>0<f>>>0?o+1|0:o)^P,40),R=J=h,P=o,o=J+HA|0,o=Z+((J=_+tA|0)>>>0<tA>>>0?o+1|0:o)|0,Z=o=(J=D+J|0)>>>0<D>>>0?o+1|0:o,D=DA(f^J,o^K,48),o=(K=h)+P|0,f=(S=D+S|0)^_,_=o=S>>>0<D>>>0?o+1|0:o,R=o=DA(f,o^R,1),P=f=h,AA=k,W=y,y=c,c=DA(H^L,U^$,48),o=(H=h)+M|0,M=f=c+Y|0,L=o=f>>>0<c>>>0?o+1|0:o,y=DA(f^y,o^p,1),o=(p=h)+GA|0,o=((f=y+QA|0)>>>0<y>>>0?o+1|0:o)+F|0,s=o=(k=f+s|0)>>>0<f>>>0?o+1|0:o,f=DA(k^W,o^N,32),o=(F=h)+w|0,Y=w=f+AA|0,N=o=w>>>0<f>>>0?o+1|0:o,y=DA(y^w,o^p,40),o=C+(W=h)|0,p=y,o=s+((y=sA+y|0)>>>0<sA>>>0?o+1|0:o)|0,U=o=(w=y+k|0)>>>0<k>>>0?o+1|0:o,y=DA(f^w,o^F,48),o=(o=N)+(N=h)|0,Y=f=y+Y|0,AA=o=f>>>0<y>>>0?o+1|0:o,s=r,k=e,o=v+IA|0,r=o=(f=G+b|0)>>>0<G>>>0?o+1|0:o,e=DA(f^n,o^x,1),o=(n=h)+BA|0,o=((F=e+X|0)>>>0<e>>>0?o+1|0:o)+t|0,t=DA(s^(k=k+F|0),(o=k>>>0<F>>>0?o+1|0:o)^T,32),F=o,G=e,o=(s=h)+L|0,o=(e=t+M|0)>>>0<t>>>0?o+1|0:o,M=e,e^=G,G=o,e=DA(e,o^n,40),o=B+(L=h)|0,o=((n=e+g|0)>>>0<g>>>0?o+1|0:o)+F|0,b=o=(F=n)>>>0>(n=n+k|0)>>>0?o+1|0:o,s=DA(t^n,o^s,48),IA=o=h,k=o,t=DA(z^O,m^hA,1),v=o=h,O=r,o=o+FA|0,o=u+((r=t+V|0)>>>0<V>>>0?o+1|0:o)|0,F=H,H=o=(r=r+d|0)>>>0<d>>>0?o+1|0:o,F=DA(c^r,F^o,32),o=($=h)+O|0,d=f=F+f|0,c=DA(f^t,(c=v)^(v=f>>>0<F>>>0?o+1|0:o),40),o=pA+(O=h)|0,o=H+((f=c+fA|0)>>>0<fA>>>0?o+1|0:o)|0,u=f=f+r|0,z=o=f>>>0<r>>>0?o+1|0:o,r=o,o=P+eA|0,o=((t=q+R|0)>>>0<q>>>0?o+1|0:o)+r|0,H=o=(r=f+t|0)>>>0<t>>>0?o+1|0:o,f=DA(r^s,o^k,32),o=(T=h)+AA|0,k=DA((t=f+Y|0)^R,(o=t>>>0<f>>>0?o+1|0:o)^P,40),R=o,o=l+(x=h)|0,o=H+((m=k+aA|0)>>>0<aA>>>0?o+1|0:o)|0,o=(H=r+m|0)>>>0<r>>>0?o+1|0:o,r=T,T=o,r=DA(f^H,r^o,48),o=(o=R)+(R=h)|0,f=(t=r+t|0)^k,k=o=t>>>0<r>>>0?o+1|0:o,x=o=DA(f,o^x,1),m=f=h,P=y,y=c,c=DA(F^u,z^$,48),o=(o=v)+(v=h)|0,d=f=c+d|0,F=O,O=o=f>>>0<c>>>0?o+1|0:o,y=DA(f^y,F^o,1),o=(u=h)+HA|0,o=b+((f=y+tA|0)>>>0<y>>>0?o+1|0:o)|0,F=n,n=f+n|0,f=N,N=o=F>>>0>n>>>0?o+1|0:o,f=DA(n^P,f^o,32),o=(o=_)+(_=h)|0,b=o=(F=f+S|0)>>>0<f>>>0?o+1|0:o,S=F,y=DA(y^F,o^u,40),o=FA+($=h)|0,u=y,o=N+((y=V+y|0)>>>0<V>>>0?o+1|0:o)|0,N=o=(F=y+n|0)>>>0<n>>>0?o+1|0:o,y=DA(f^F,o^_,48),o=(o=b)+(b=h)|0,z=f=y+S|0,P=o=f>>>0<y>>>0?o+1|0:o,S=D,o=G+IA|0,D=o=(f=s+M|0)>>>0<s>>>0?o+1|0:o,e=DA(f^e,o^L,1),o=wA+(s=h)|0,o=U+((n=e+gA|0)>>>0<gA>>>0?o+1|0:o)|0,G=(n=w+n|0)^S,S=o=n>>>0<w>>>0?o+1|0:o,w=DA(G,o^K,32),_=o=h,G=e,o=o+O|0,o=(e=w+d|0)>>>0<w>>>0?o+1|0:o,M=e,e^=G,G=o,e=DA(e,o^s,40),o=B+(L=h)|0,o=S+((s=e+g|0)>>>0<g>>>0?o+1|0:o)|0,U=o=(s=n+s|0)>>>0<n>>>0?o+1|0:o,S=DA(w^s,o^_,48),IA=o=h,n=o,w=DA(p^Y,W^AA,1),d=o=h,Y=D,o=o+C|0,o=Z+((D=w+sA|0)>>>0<sA>>>0?o+1|0:o)|0,J=o=(D=D+J|0)>>>0<J>>>0?o+1|0:o,_=DA(c^D,o^v,32),o=(CA=h)+Y|0,Y=f=_+f|0,c=DA(f^w,(p=f>>>0<_>>>0?o+1|0:o)^d,40),o=j+(v=h)|0,o=J+((f=I+c|0)>>>0<I>>>0?o+1|0:o)|0,J=f=f+D|0,O=o=f>>>0<D>>>0?o+1|0:o,D=o,o=m+kA|0,o=((w=x+oA|0)>>>0<oA>>>0?o+1|0:o)+D|0,d=o=(D=f+w|0)>>>0<w>>>0?o+1|0:o,f=DA(D^S,o^n,32),o=(Z=h)+P|0,n=DA((w=f+z|0)^x,(o=w>>>0<f>>>0?o+1|0:o)^m,40),K=o,o=MA+(x=h)|0,o=d+((m=n+cA|0)>>>0<cA>>>0?o+1|0:o)|0,o=(d=D+m|0)>>>0<D>>>0?o+1|0:o,D=Z,Z=o,D=DA(f^d,D^o,48),o=(o=K)+(K=h)|0,f=(w=D+w|0)^n,n=o=w>>>0<D>>>0?o+1|0:o,x=o=DA(f,o^x,1),hA=o,m=f=h,AA=t,W=y,t=c,c=DA(_^J,O^CA,48),o=(_=h)+p|0,J=f=c+Y|0,Y=o=f>>>0<c>>>0?o+1|0:o,t=DA(f^t,o^v,1),o=(v=h)+yA|0,o=U+((f=t+rA|0)>>>0<t>>>0?o+1|0:o)|0,s=o=(y=f+s|0)>>>0<s>>>0?o+1|0:o,f=DA(y^W,o^b,32),o=(p=h)+k|0,b=o=(k=f+AA|0)>>>0<f>>>0?o+1|0:o,t=DA(t^k,o^v,40),o=GA+(CA=h)|0,U=t,o=s+((t=QA+t|0)>>>0<QA>>>0?o+1|0:o)|0,s=t+y|0,t=p,p=o=s>>>0<y>>>0?o+1|0:o,t=DA(f^s,t^o,48),o=(o=b)+(b=h)|0,v=f=t+k|0,O=o=f>>>0<t>>>0?o+1|0:o,y=r,o=G+IA|0,r=o=(f=S+M|0)>>>0<S>>>0?o+1|0:o,e=DA(f^e,o^L,1),o=(S=h)+pA|0,o=N+((k=e+fA|0)>>>0<e>>>0?o+1|0:o)|0,y=DA(y^(k=k+F|0),(o=k>>>0<F>>>0?o+1|0:o)^R,32),G=F=h,F=o,M=e,o=G+Y|0,o=(e=y+J|0)>>>0<y>>>0?o+1|0:o,J=e,e^=M,M=o,e=DA(e,o^S,40),o=nA+(L=h)|0,o=((S=e+EA|0)>>>0<EA>>>0?o+1|0:o)+F|0,N=G,G=o=(F=k+S|0)>>>0<S>>>0?o+1|0:o,S=DA(y^F,N^o,48),IA=o=h,k=o,y=DA(z^u,P^$,1),Y=o=h,N=r,o=o+BA|0,o=T+((r=y+X|0)>>>0<X>>>0?o+1|0:o)|0,H=o=(r=r+H|0)>>>0<H>>>0?o+1|0:o,_=DA(c^r,o^_,32),o=($=h)+N|0,N=f=_+f|0,c=DA(f^y,(c=Y)^(Y=f>>>0<_>>>0?o+1|0:o),40),o=_A+(u=h)|0,o=H+((f=c+iA|0)>>>0<iA>>>0?o+1|0:o)|0,z=f=f+r|0,T=o=f>>>0<r>>>0?o+1|0:o,r=o,o=m+B|0,o=((y=x+g|0)>>>0<g>>>0?o+1|0:o)+r|0,H=o=(r=f+y|0)>>>0<y>>>0?o+1|0:o,f=DA(r^S,o^k,32),o=(x=h)+O|0,k=DA((y=f+v|0)^hA,(o=y>>>0<f>>>0?o+1|0:o)^m,40),m=o,o=HA+(R=h)|0,o=H+((P=k+tA|0)>>>0<tA>>>0?o+1|0:o)|0,o=(H=r+P|0)>>>0<r>>>0?o+1|0:o,r=x,x=o,r=DA(f^H,r^o,48),o=(o=m)+(m=h)|0,f=(y=r+y|0)^k,k=o=y>>>0<r>>>0?o+1|0:o,R=o=DA(f,o^R,1),P=f=h,AA=w,W=t,t=c,c=DA(_^z,T^$,48),o=(_=h)+Y|0,Y=f=c+N|0,N=o=f>>>0<c>>>0?o+1|0:o,t=DA(f^t,o^u,1),o=(u=h)+GA|0,o=G+((f=t+QA|0)>>>0<t>>>0?o+1|0:o)|0,F=o=(w=f+F|0)>>>0<F>>>0?o+1|0:o,f=DA(w^W,o^b,32),o=(G=h)+n|0,b=o=(n=f+AA|0)>>>0<f>>>0?o+1|0:o,t=DA(t^n,o^u,40),o=BA+($=h)|0,u=t,o=F+((t=X+t|0)>>>0<X>>>0?o+1|0:o)|0,F=t+w|0,t=G,G=o=F>>>0<w>>>0?o+1|0:o,t=DA(f^F,t^o,48),o=(o=b)+(b=h)|0,z=f=t+n|0,T=o=f>>>0<t>>>0?o+1|0:o,w=D,o=M+IA|0,D=o=(f=S+J|0)>>>0<S>>>0?o+1|0:o,e=DA(f^e,o^L,1),o=_A+(S=h)|0,o=p+((n=e+iA|0)>>>0<iA>>>0?o+1|0:o)|0,s=o=(n=n+s|0)>>>0<s>>>0?o+1|0:o,w=DA(w^n,o^K,32),J=o=h,M=e,o=o+N|0,o=(e=w+Y|0)>>>0<w>>>0?o+1|0:o,L=e,e^=M,M=o,e=DA(e,o^S,40),o=kA+(Y=h)|0,o=s+((S=e+oA|0)>>>0<oA>>>0?o+1|0:o)|0,o=(s=n+S|0)>>>0<n>>>0?o+1|0:o,n=J,J=o,S=DA(w^s,n^o,48),IA=o=h,n=o,w=DA(U^v,O^CA,1),N=o=h,p=D,o=o+j|0,o=Z+((D=I+w|0)>>>0<I>>>0?o+1|0:o)|0,d=o=(D=D+d|0)>>>0<d>>>0?o+1|0:o,_=DA(c^D,o^_,32),o=(CA=h)+p|0,p=f=_+f|0,c=DA(f^w,(c=N)^(N=f>>>0<_>>>0?o+1|0:o),40),o=FA+(U=h)|0,o=d+((f=c+V|0)>>>0<V>>>0?o+1|0:o)|0,v=f=f+D|0,O=o=f>>>0<D>>>0?o+1|0:o,D=o,o=P+wA|0,o=((w=R+gA|0)>>>0<gA>>>0?o+1|0:o)+D|0,d=o=(D=f+w|0)>>>0<w>>>0?o+1|0:o,f=DA(D^S,o^n,32),o=(Z=h)+T|0,n=DA((w=f+z|0)^R,(o=w>>>0<f>>>0?o+1|0:o)^P,40),R=o,o=C+(K=h)|0,o=d+((P=n+sA|0)>>>0<sA>>>0?o+1|0:o)|0,o=(d=D+P|0)>>>0<D>>>0?o+1|0:o,D=Z,Z=o,D=DA(f^d,D^o,48),o=(o=R)+(R=h)|0,f=(w=D+w|0)^n,n=o=w>>>0<D>>>0?o+1|0:o,K=o=DA(f,o^K,1),P=f=h,AA=y,W=t,t=c,c=DA(_^v,O^CA,48),o=(_=h)+N|0,N=f=c+p|0,p=o=f>>>0<c>>>0?o+1|0:o,t=DA(f^t,o^U,1),o=(U=h)+eA|0,o=J+((f=t+q|0)>>>0<t>>>0?o+1|0:o)|0,s=o=(y=f+s|0)>>>0<s>>>0?o+1|0:o,f=DA(y^W,o^b,32),o=(J=h)+k|0,b=o=(k=f+AA|0)>>>0<f>>>0?o+1|0:o,t=DA(t^k,o^U,40),o=pA+(CA=h)|0,U=t,o=s+((t=fA+t|0)>>>0<fA>>>0?o+1|0:o)|0,s=t+y|0,t=J,J=o=s>>>0<y>>>0?o+1|0:o,t=DA(f^s,t^o,48),o=(o=b)+(b=h)|0,v=f=t+k|0,O=o=f>>>0<t>>>0?o+1|0:o,y=r,o=M+IA|0,r=o=(f=S+L|0)>>>0<S>>>0?o+1|0:o,e=DA(f^e,o^Y,1),o=(S=h)+nA|0,o=G+((k=e+EA|0)>>>0<e>>>0?o+1|0:o)|0,F=o=(k=k+F|0)>>>0<F>>>0?o+1|0:o,y=DA(y^k,o^m,32),G=o=h,M=e,o=o+p|0,o=(e=y+N|0)>>>0<y>>>0?o+1|0:o,L=e,e^=M,M=o,e=DA(e,o^S,40),o=yA+(Y=h)|0,o=F+((S=e+rA|0)>>>0<rA>>>0?o+1|0:o)|0,N=G,G=o=(F=k+S|0)>>>0<k>>>0?o+1|0:o,S=DA(y^F,N^o,48),IA=o=h,k=o,y=DA(z^u,T^$,1),N=o=h,p=r,o=o+l|0,o=x+((r=y+aA|0)>>>0<aA>>>0?o+1|0:o)|0,H=o=(r=r+H|0)>>>0<H>>>0?o+1|0:o,_=DA(c^r,o^_,32),o=($=h)+p|0,p=f=_+f|0,c=DA(f^y,(c=N)^(N=f>>>0<_>>>0?o+1|0:o),40),o=MA+(u=h)|0,o=H+((f=c+cA|0)>>>0<cA>>>0?o+1|0:o)|0,z=f=f+r|0,T=o=f>>>0<r>>>0?o+1|0:o,r=o,o=P+C|0,o=((y=K+sA|0)>>>0<sA>>>0?o+1|0:o)+r|0,H=o=(r=f+y|0)>>>0<y>>>0?o+1|0:o,f=DA(r^S,o^k,32),o=(x=h)+O|0,k=DA((y=f+v|0)^K,(o=y>>>0<f>>>0?o+1|0:o)^P,40),m=o,o=_A+(K=h)|0,o=H+((P=k+iA|0)>>>0<iA>>>0?o+1|0:o)|0,o=(H=r+P|0)>>>0<r>>>0?o+1|0:o,r=x,x=o,r=DA(f^H,r^o,48),o=(o=m)+(m=h)|0,f=(y=r+y|0)^k,k=o=y>>>0<r>>>0?o+1|0:o,K=o=DA(f,o^K,1),P=f=h,AA=w,W=t,t=c,c=DA(_^z,T^$,48),o=(_=h)+N|0,N=f=c+p|0,p=o=f>>>0<c>>>0?o+1|0:o,t=DA(f^t,o^u,1),o=(u=h)+l|0,o=G+((f=t+aA|0)>>>0<t>>>0?o+1|0:o)|0,F=o=(w=f+F|0)>>>0<F>>>0?o+1|0:o,f=DA(w^W,o^b,32),o=(G=h)+n|0,b=o=(n=f+AA|0)>>>0<f>>>0?o+1|0:o,t=DA(t^n,o^u,40),o=yA+($=h)|0,u=t,o=F+((t=rA+t|0)>>>0<rA>>>0?o+1|0:o)|0,F=t+w|0,t=G,G=o=F>>>0<w>>>0?o+1|0:o,t=DA(f^F,t^o,48),o=(o=b)+(b=h)|0,z=f=t+n|0,T=o=f>>>0<t>>>0?o+1|0:o,w=D,o=M+IA|0,D=o=(f=S+L|0)>>>0<S>>>0?o+1|0:o,e=DA(f^e,o^Y,1),o=nA+(S=h)|0,o=J+((n=e+EA|0)>>>0<EA>>>0?o+1|0:o)|0,s=o=(n=n+s|0)>>>0<s>>>0?o+1|0:o,w=DA(w^n,o^R,32),J=o=h,M=e,o=o+p|0,o=(e=w+N|0)>>>0<w>>>0?o+1|0:o,L=e,e^=M,M=o,e=DA(e,o^S,40),o=pA+(Y=h)|0,o=s+((S=e+fA|0)>>>0<fA>>>0?o+1|0:o)|0,o=(s=n+S|0)>>>0<n>>>0?o+1|0:o,n=J,J=o,S=DA(w^s,n^o,48),IA=o=h,n=o,w=DA(U^v,O^CA,1),N=o=h,p=D,o=o+BA|0,o=Z+((D=w+X|0)>>>0<X>>>0?o+1|0:o)|0,d=o=(D=D+d|0)>>>0<d>>>0?o+1|0:o,_=DA(c^D,o^_,32),o=(CA=h)+p|0,p=f=_+f|0,c=DA(f^w,(c=N)^(N=f>>>0<_>>>0?o+1|0:o),40),o=MA+(U=h)|0,o=d+((f=c+cA|0)>>>0<cA>>>0?o+1|0:o)|0,v=f=f+D|0,O=o=f>>>0<D>>>0?o+1|0:o,D=o,o=P+FA|0,o=((w=K+V|0)>>>0<V>>>0?o+1|0:o)+D|0,d=o=(D=f+w|0)>>>0<w>>>0?o+1|0:o,f=DA(D^S,o^n,32),o=(Z=h)+T|0,n=DA((w=f+z|0)^K,(o=w>>>0<f>>>0?o+1|0:o)^P,40),R=o,o=j+(K=h)|0,o=d+((P=I+n|0)>>>0<I>>>0?o+1|0:o)|0,o=(d=D+P|0)>>>0<D>>>0?o+1|0:o,D=Z,Z=o,D=DA(f^d,D^o,48),o=(o=R)+(R=h)|0,f=(w=D+w|0)^n,n=o=w>>>0<D>>>0?o+1|0:o,K=o=DA(f,o^K,1),P=f=h,AA=y,W=t,t=c,c=DA(_^v,O^CA,48),o=(_=h)+N|0,N=f=c+p|0,p=o=f>>>0<c>>>0?o+1|0:o,t=DA(f^t,o^U,1),o=(U=h)+kA|0,o=J+((f=t+oA|0)>>>0<t>>>0?o+1|0:o)|0,s=o=(y=f+s|0)>>>0<s>>>0?o+1|0:o,f=DA(y^W,o^b,32),o=(J=h)+k|0,b=o=(k=f+AA|0)>>>0<f>>>0?o+1|0:o,t=DA(t^k,o^U,40),o=B+(CA=h)|0,U=t,o=s+((t=g+t|0)>>>0<g>>>0?o+1|0:o)|0,s=t+y|0,t=J,J=o=s>>>0<y>>>0?o+1|0:o,t=DA(f^s,t^o,48),o=(o=b)+(b=h)|0,v=f=t+k|0,O=o=f>>>0<t>>>0?o+1|0:o,y=r,o=M+IA|0,r=o=(f=S+L|0)>>>0<S>>>0?o+1|0:o,e=DA(f^e,o^Y,1),o=(S=h)+wA|0,o=G+((k=e+gA|0)>>>0<e>>>0?o+1|0:o)|0,F=o=(k=k+F|0)>>>0<F>>>0?o+1|0:o,y=DA(y^k,o^m,32),G=o=h,M=e,o=o+p|0,o=(e=y+N|0)>>>0<y>>>0?o+1|0:o,L=e,e^=M,M=o,e=DA(e,o^S,40),o=GA+(Y=h)|0,o=F+((S=e+QA|0)>>>0<QA>>>0?o+1|0:o)|0,N=G,G=o=(F=k+S|0)>>>0<k>>>0?o+1|0:o,S=DA(y^F,N^o,48),IA=o=h,k=o,y=DA(z^u,T^$,1),N=o=h,p=r,o=o+HA|0,o=x+((r=y+tA|0)>>>0<tA>>>0?o+1|0:o)|0,H=o=(r=r+H|0)>>>0<H>>>0?o+1|0:o,_=DA(c^r,o^_,32),o=($=h)+p|0,p=f=_+f|0,c=DA(f^y,(c=N)^(N=f>>>0<_>>>0?o+1|0:o),40),o=eA+(u=h)|0,o=H+((f=c+q|0)>>>0<q>>>0?o+1|0:o)|0,z=f=f+r|0,T=o=f>>>0<r>>>0?o+1|0:o,r=o,o=P+MA|0,o=((y=K+cA|0)>>>0<cA>>>0?o+1|0:o)+r|0,H=o=(r=f+y|0)>>>0<y>>>0?o+1|0:o,f=DA(r^S,o^k,32),o=(x=h)+O|0,k=DA((y=f+v|0)^K,(o=y>>>0<f>>>0?o+1|0:o)^P,40),m=o,o=yA+(K=h)|0,o=H+((P=k+rA|0)>>>0<rA>>>0?o+1|0:o)|0,o=(H=r+P|0)>>>0<r>>>0?o+1|0:o,r=x,x=o,r=DA(f^H,r^o,48),o=(o=m)+(m=h)|0,f=(y=r+y|0)^k,k=o=y>>>0<r>>>0?o+1|0:o,K=o=DA(f,o^K,1),P=f=h,AA=w,W=t,t=c,c=DA(_^z,T^$,48),o=(_=h)+N|0,N=f=c+p|0,p=o=f>>>0<c>>>0?o+1|0:o,t=DA(f^t,o^u,1),o=(u=h)+_A|0,o=G+((f=t+iA|0)>>>0<t>>>0?o+1|0:o)|0,F=o=(w=f+F|0)>>>0<F>>>0?o+1|0:o,f=DA(w^W,o^b,32),o=(G=h)+n|0,b=o=(n=f+AA|0)>>>0<f>>>0?o+1|0:o,t=DA(t^n,o^u,40),o=C+($=h)|0,u=t,o=F+((t=sA+t|0)>>>0<sA>>>0?o+1|0:o)|0,F=t+w|0,t=G,G=o=F>>>0<w>>>0?o+1|0:o,t=DA(f^F,t^o,48),o=(o=b)+(b=h)|0,z=f=t+n|0,T=o=f>>>0<t>>>0?o+1|0:o,w=D,o=M+IA|0,D=o=(f=S+L|0)>>>0<S>>>0?o+1|0:o,e=DA(f^e,o^Y,1),o=GA+(S=h)|0,o=J+((n=e+QA|0)>>>0<QA>>>0?o+1|0:o)|0,s=o=(n=n+s|0)>>>0<s>>>0?o+1|0:o,w=DA(w^n,o^R,32),J=o=h,M=e,o=o+p|0,o=(e=w+N|0)>>>0<w>>>0?o+1|0:o,L=e,e^=M,M=o,e=DA(e,o^S,40),o=l+(Y=h)|0,o=s+((S=e+aA|0)>>>0<aA>>>0?o+1|0:o)|0,o=(s=n+S|0)>>>0<n>>>0?o+1|0:o,n=J,J=o,S=DA(w^s,n^o,48),IA=o=h,n=o,w=DA(U^v,O^CA,1),N=o=h,p=D,o=o+pA|0,o=Z+((D=w+fA|0)>>>0<fA>>>0?o+1|0:o)|0,d=o=(D=D+d|0)>>>0<d>>>0?o+1|0:o,_=DA(c^D,o^_,32),o=(CA=h)+p|0,p=f=_+f|0,c=DA(f^w,(c=N)^(N=f>>>0<_>>>0?o+1|0:o),40),o=HA+(U=h)|0,o=d+((f=c+tA|0)>>>0<tA>>>0?o+1|0:o)|0,v=f=f+D|0,O=o=f>>>0<D>>>0?o+1|0:o,D=o,o=P+nA|0,o=((w=K+EA|0)>>>0<EA>>>0?o+1|0:o)+D|0,d=o=(D=f+w|0)>>>0<w>>>0?o+1|0:o,f=DA(D^S,o^n,32),o=(Z=h)+T|0,n=DA((w=f+z|0)^K,(o=w>>>0<f>>>0?o+1|0:o)^P,40),R=o,o=B+(K=h)|0,o=d+((P=n+g|0)>>>0<g>>>0?o+1|0:o)|0,o=(d=D+P|0)>>>0<D>>>0?o+1|0:o,D=Z,Z=o,D=DA(f^d,D^o,48),o=(o=R)+(R=h)|0,f=(w=D+w|0)^n,n=o=w>>>0<D>>>0?o+1|0:o,K=o=DA(f,o^K,1),P=f=h,AA=y,W=t,t=c,c=DA(_^v,O^CA,48),o=(_=h)+N|0,N=f=c+p|0,p=o=f>>>0<c>>>0?o+1|0:o,t=DA(f^t,o^U,1),o=(v=h)+BA|0,o=J+((f=t+X|0)>>>0<t>>>0?o+1|0:o)|0,s=o=(y=f+s|0)>>>0<s>>>0?o+1|0:o,f=DA(y^W,o^b,32),o=(J=h)+k|0,b=k=f+AA|0,U=o=k>>>0<f>>>0?o+1|0:o,t=DA(t^k,o^v,40),o=FA+(AA=h)|0,v=t,o=s+((t=V+t|0)>>>0<V>>>0?o+1|0:o)|0,k=t+y|0,t=J,J=o=k>>>0<y>>>0?o+1|0:o,t=DA(f^k,t^o,48),o=(o=U)+(U=h)|0,b=f=t+b|0,O=o=f>>>0<t>>>0?o+1|0:o,y=r,o=M+IA|0,r=o=(f=S+L|0)>>>0<S>>>0?o+1|0:o,e=DA(f^e,o^Y,1),o=(S=h)+j|0,o=G+((s=I+e|0)>>>0<e>>>0?o+1|0:o)|0,F=o=(s=s+F|0)>>>0<F>>>0?o+1|0:o,G=y=DA(y^s,o^m,32),M=o=h,L=e,o=o+p|0,o=(e=y+N|0)>>>0<y>>>0?o+1|0:o,Y=e,e^=L,L=o,e=DA(e,o^S,40),o=kA+(N=h)|0,o=F+((y=e+oA|0)>>>0<oA>>>0?o+1|0:o)|0,p=(y=y+s|0)^G,G=o=y>>>0<s>>>0?o+1|0:o,s=DA(p,o^M,48),m=o=h,S=o,M=F=DA(z^u,T^$,1),p=o=h,u=r,o=o+eA|0,o=x+((r=F+q|0)>>>0<q>>>0?o+1|0:o)|0,o=(r=r+H|0)>>>0<H>>>0?o+1|0:o,H=_,_=o,F=DA(c^r,H^o,32),o=(W=h)+u|0,H=f=F+f|0,c=DA(c=f^M,(M=f>>>0<F>>>0?o+1|0:o)^p,40),o=wA+(p=h)|0,o=_+((f=c+gA|0)>>>0<gA>>>0?o+1|0:o)|0,_=f=f+r|0,u=o=f>>>0<r>>>0?o+1|0:o,r=o,o=P+FA|0,o=((x=V)>>>0>(V=K+V|0)>>>0?o+1|0:o)+r|0,FA=o=(f=f+V|0)>>>0<V>>>0?o+1|0:o,V=DA(f^s,o^S,32),o=(z=h)+O|0,S=DA((r=b+V|0)^K,(o=r>>>0<V>>>0?o+1|0:o)^P,40),x=o,o=kA+(T=h)|0,o=FA+((K=oA)>>>0>(oA=S+oA|0)>>>0?o+1|0:o)|0,o=(oA=f+oA|0)>>>0<f>>>0?o+1|0:o,f=V^oA,V=o;kA=DA(f,o^z,48),o=(FA=h)+x|0,r=o=(f=r+kA|0)>>>0<kA>>>0?o+1|0:o,o=DA(f^S,o^T,1),S=h,z=o,T=w,w=gA,x=wA,wA=DA(F^_,u^W,48),o=(F=h)+M|0,M=w,H=o=(gA=H+wA|0)>>>0<wA>>>0?o+1|0:o,w=DA(c^(_=gA),o^p,1),o=(p=h)+x|0,o=G+(w>>>0>(gA=M+w|0)>>>0?o+1|0:o)|0,c=o=(gA=y+gA|0)>>>0<y>>>0?o+1|0:o,t=DA(t^gA,o^U,32),o=(o=n)+(n=h)|0,G=y=t+T|0,M=o=y>>>0<t>>>0?o+1|0:o,y=DA(y^w,o^p,40),o=(p=h)+_A|0,o=(y>>>0>(iA=y+iA|0)>>>0?o+1|0:o)+c|0,c=o=(c=iA)>>>0>(iA=gA+iA|0)>>>0?o+1|0:o,t=DA(t^iA,o^n,48),o=(w=h)+M|0,n=gA=t+G|0,_A=o=gA>>>0<t>>>0?o+1|0:o,G=I,M=j,o=L+m|0,gA=o=(I=s+Y|0)>>>0<s>>>0?o+1|0:o,j=DA(I^e,o^N,1),o=(s=h)+M|0,o=J+((e=G+j|0)>>>0<j>>>0?o+1|0:o)|0,D=DA((e=e+k|0)^D,(o=e>>>0<k>>>0?o+1|0:o)^R,32),G=o,J=EA,EA=j,o=(k=h)+H|0,H=s,s=o=(j=D+_|0)>>>0<D>>>0?o+1|0:o,EA=DA(j^EA,H^o,40),o=(_=h)+nA|0,o=((nA=J+EA|0)>>>0<EA>>>0?o+1|0:o)+G|0,G=nA,e=D^(nA=e+nA|0),D=o=G>>>0>nA>>>0?o+1|0:o,o=DA(e,o^k,48),L=e=h,k=o,H=X,G=BA,X=DA(b^v,O^AA,1),M=o=h,o=o+MA|0,o=Z+((X=(J=X)+cA|0)>>>0<cA>>>0?o+1|0:o)|0,cA=o=(X=d+X|0)>>>0<d>>>0?o+1|0:o,BA=DA(X^wA,o^F,32),o=(d=h)+gA|0,gA=I=BA+I|0,wA=DA(I^J,(F=I>>>0<BA>>>0?o+1|0:o)^M,40),o=(o=G)+(G=h)|0,o=cA+((I=wA+H|0)>>>0<wA>>>0?o+1|0:o)|0,cA=I=I+X|0,MA=o=I>>>0<X>>>0?o+1|0:o,X=o,o=S+GA|0,o=((J=QA)>>>0>(QA=z+QA|0)>>>0?o+1|0:o)+X|0,GA=o=(X=I+QA|0)>>>0<QA>>>0?o+1|0:o,QA=DA(k^X,o^e,32),o=(J=h)+_A|0,e=I=QA+n|0,I=DA(I^z,(H=S)^(S=I>>>0<QA>>>0?o+1|0:o),40),o=pA+(M=h)|0,pA=I,o=GA+((I=fA+I|0)>>>0<fA>>>0?o+1|0:o)|0,o=(I=I+X|0)>>>0<X>>>0?o+1|0:o,GA=I,Y=(a[A+8|0]|a[A+9|0]<<8|a[A+10|0]<<16|a[A+11|0]<<24)^I,H=o,N=o^(a[A+12|0]|a[A+13|0]<<8|a[A+14|0]<<16|a[A+15|0]<<24),X=DA(BA^cA,d^MA,48),o=(cA=h)+F|0,F=I=X+gA|0,MA=o=I>>>0<X>>>0?o+1|0:o,BA=rA,o=s+L|0,rA=o=(I=k+j|0)>>>0<j>>>0?o+1|0:o,EA=DA(I^EA,o^_,1),o=(k=h)+yA|0,o=((BA=EA+BA|0)>>>0<EA>>>0?o+1|0:o)+c|0,BA=o=(yA=BA+iA|0)>>>0<BA>>>0?o+1|0:o,gA=DA(yA^kA,o^FA,32),o=(j=h)+MA|0,iA=o=(fA=gA+F|0)>>>0<gA>>>0?o+1|0:o,kA=gA,gA=DA(EA^fA,o^k,40),o=(c=h)+HA|0,o=(gA>>>0>(EA=gA+tA|0)>>>0?o+1|0:o)+BA|0,s=j,j=o=(yA=EA+yA|0)>>>0<EA>>>0?o+1|0:o,EA=DA(kA^(tA=yA),s^o,48),o=(k=h)+iA|0,o=(BA=EA+fA|0)>>>0<EA>>>0?o+1|0:o,fA=BA,BA^=Y,E[A+8|0]=BA,E[A+9|0]=BA>>>8,E[A+10|0]=BA>>>16,E[A+11|0]=BA>>>24,iA=o,o^=N,E[A+12|0]=o,E[A+13|0]=o>>>8,E[A+14|0]=o>>>16,E[A+15|0]=o>>>24,yA=I,BA=rA,I=X,X=DA(y^n,p^_A,1),o=(HA=h)+B|0,o=(X>>>0>(rA=X+g|0)>>>0?o+1|0:o)+V|0,oA=o=(n=rA)>>>0>(rA=oA+rA|0)>>>0?o+1|0:o,I=DA(I^rA,o^cA,32),o=(o=BA)+(BA=h)|0,cA=o=(yA=I+yA|0)>>>0<I>>>0?o+1|0:o,kA=I,yA=DA(X^(V=yA),o^HA,40),o=(y=h)+C|0,o=oA+((I=yA+sA|0)>>>0<yA>>>0?o+1|0:o)|0,o=(I=I+rA|0)>>>0<rA>>>0?o+1|0:o,oA=I,I^=kA,kA=o,rA=DA(I,o^BA,48),o=(n=h)+cA|0,V=I=rA+V|0,cA=I>>>0<rA>>>0?o+1|0:o,wA=I=DA(F^wA,G^MA,1),HA=o=h,o=o+l|0,o=D+((I=I+aA|0)>>>0<aA>>>0?o+1|0:o)|0,l=o=(X=I+nA|0)>>>0<nA>>>0?o+1|0:o,I=(BA=DA(t^X,o^w,32))+f|0,o=(f=h)+r|0,nA=I,I=(aA=DA(D=I^wA,(wA=I>>>0<BA>>>0?o+1|0:o)^HA,40))+q|0,o=(q=h)+eA|0,o=l+(I>>>0<aA>>>0?o+1|0:o)|0,o=(l=I+X|0)>>>0<X>>>0?o+1|0:o,X=l^JA^V,E[0|(I=A)]=X,E[I+1|0]=X>>>8,E[I+2|0]=X>>>16,E[I+3|0]=X>>>24,X=o^Q^cA,E[I+4|0]=X,E[I+5|0]=X>>>8,E[I+6|0]=X>>>16,E[I+7|0]=X>>>24,X=(BA=DA(l^BA,o^f,48))+nA|0,o=(nA=h)+wA|0,o=(wA=X>>>0<BA>>>0?o+1|0:o)^(a[I+20|0]|a[I+21|0]<<8|a[I+22|0]<<16|a[I+23|0]<<24)^kA,l=(a[I+16|0]|a[I+17|0]<<8|a[I+18|0]<<16|a[I+19|0]<<24)^oA^X,E[I+16|0]=l,E[I+17|0]=l>>>8,E[I+18|0]=l>>>16,E[I+19|0]=l>>>24,E[I+20|0]=o,E[I+21|0]=o>>>8,E[I+22|0]=o>>>16,E[I+23|0]=o>>>24,I=DA(QA^GA,H^J,48),l=h,oA=a[A+36|0]|a[A+37|0]<<8|a[A+38|0]<<16|a[A+39|0]<<24,o=(a[A+32|0]|a[A+33|0]<<8|a[A+34|0]<<16|a[A+35|0]<<24)^DA(gA^fA,c^iA,1)^I,E[A+32|0]=o,E[A+33|0]=o>>>8,E[A+34|0]=o>>>16,E[A+35|0]=o>>>24,o=h^oA^l,E[A+36|0]=o,E[A+37|0]=o>>>8,E[A+38|0]=o>>>16,E[A+39|0]=o>>>24,o=S+l|0,o=(oA=I+e|0)>>>0<I>>>0?o+1|0:o,gA=(a[(I=A)+28|0]|a[I+29|0]<<8|a[I+30|0]<<16|a[I+31|0]<<24)^j^o,l=(a[I+24|0]|a[I+25|0]<<8|a[I+26|0]<<16|a[I+27|0]<<24)^tA^oA,E[I+24|0]=l,E[I+25|0]=l>>>8,E[I+26|0]=l>>>16,E[I+27|0]=l>>>24,E[I+28|0]=gA,E[I+29|0]=gA>>>8,E[I+30|0]=gA>>>16,E[I+31|0]=gA>>>24,gA=a[I+44|0]|a[I+45|0]<<8|a[I+46|0]<<16|a[I+47|0]<<24,I=rA^(a[I+40|0]|a[I+41|0]<<8|a[I+42|0]<<16|a[I+43|0]<<24)^DA(X^aA,q^wA,1),E[A+40|0]=I,E[A+41|0]=I>>>8,E[A+42|0]=I>>>16,E[A+43|0]=I>>>24,I=n^h^gA,E[A+44|0]=I,E[A+45|0]=I>>>8,E[A+46|0]=I>>>16,E[A+47|0]=I>>>24,X=a[A+60|0]|a[A+61|0]<<8|a[A+62|0]<<16|a[A+63|0]<<24,I=BA^(a[A+56|0]|a[A+57|0]<<8|a[A+58|0]<<16|a[A+59|0]<<24)^DA(V^yA,y^cA,1),E[A+56|0]=I,E[A+57|0]=I>>>8,E[A+58|0]=I>>>16,E[A+59|0]=I>>>24,I=nA^h^X,E[A+60|0]=I,E[A+61|0]=I>>>8,E[A+62|0]=I>>>16,E[A+63|0]=I>>>24,X=a[A+52|0]|a[A+53|0]<<8|a[A+54|0]<<16|a[A+55|0]<<24,I=EA^(a[A+48|0]|a[A+49|0]<<8|a[A+50|0]<<16|a[A+51|0]<<24)^DA(oA^pA,o^M,1),E[A+48|0]=I,E[A+49|0]=I>>>8,E[A+50|0]=I>>>16,E[A+51|0]=I>>>24,I=k^h^X,E[A+52|0]=I,E[A+53|0]=I>>>8,E[A+54|0]=I>>>16,E[A+55|0]=I>>>24}function s(A,I,g,C,B,Q,i){var f,c,e,r,D,t,y,n,s,k,S,H,G,_,M,p,J,U,Y,d,K,b,P,v,L,x,m,l,z,q,X,j,T,O,V,Z,W,$,AA,IA,gA,CA,BA,QA,iA,EA,oA,fA,eA=0,rA=0,DA=0,tA=0,yA=0,wA=0,hA=0,nA=0,sA=0,FA=0,SA=0,HA=0,GA=0,_A=0,pA=0,NA=0,JA=0,UA=0,YA=0,dA=0,KA=0,bA=0,PA=0,vA=0,LA=0,RA=0,uA=0,xA=0,mA=0,lA=0,zA=0,qA=0,XA=0,jA=0,TA=0,OA=0,VA=0,ZA=0,WA=0,$A=0,AI=0,II=0,gI=0,CI=0,BI=0,QI=0;return w=e=w-560|0,cA(DA=e+352|0),i&&R(DA,35136,34,0),aA(e+288|0,Q,32,0),R(tA=e+352|0,e+320|0,32,0),R(tA,g,C,B),N(tA,nA=e+224|0),sA=a[(rA=Q)+32|0]|a[rA+33|0]<<8|a[rA+34|0]<<16|a[rA+35|0]<<24,SA=a[rA+36|0]|a[rA+37|0]<<8|a[rA+38|0]<<16|a[rA+39|0]<<24,yA=a[rA+40|0]|a[rA+41|0]<<8|a[rA+42|0]<<16|a[rA+43|0]<<24,eA=a[rA+44|0]|a[rA+45|0]<<8|a[rA+46|0]<<16|a[rA+47|0]<<24,DA=a[rA+48|0]|a[rA+49|0]<<8|a[rA+50|0]<<16|a[rA+51|0]<<24,Q=a[rA+52|0]|a[rA+53|0]<<8|a[rA+54|0]<<16|a[rA+55|0]<<24,wA=a[rA+60|0]|a[rA+61|0]<<8|a[rA+62|0]<<16|a[rA+63|0]<<24,rA=a[rA+56|0]|a[rA+57|0]<<8|a[rA+58|0]<<16|a[rA+59|0]<<24,E[A+56|0]=rA,E[A+57|0]=rA>>>8,E[A+58|0]=rA>>>16,E[A+59|0]=rA>>>24,E[A+60|0]=wA,E[A+61|0]=wA>>>8,E[A+62|0]=wA>>>16,E[A+63|0]=wA>>>24,E[A+48|0]=DA,E[A+49|0]=DA>>>8,E[A+50|0]=DA>>>16,E[A+51|0]=DA>>>24,E[A+52|0]=Q,E[A+53|0]=Q>>>8,E[A+54|0]=Q>>>16,E[A+55|0]=Q>>>24,E[A+40|0]=yA,E[A+41|0]=yA>>>8,E[A+42|0]=yA>>>16,E[A+43|0]=yA>>>24,E[A+44|0]=eA,E[A+45|0]=eA>>>8,E[A+46|0]=eA>>>16,E[A+47|0]=eA>>>24,E[0|(Q=A+32|0)]=sA,E[Q+1|0]=sA>>>8,E[Q+2|0]=sA>>>16,E[Q+3|0]=sA>>>24,E[Q+4|0]=SA,E[Q+5|0]=SA>>>8,E[Q+6|0]=SA>>>16,E[Q+7|0]=SA>>>24,F(nA),u(e,nA),MA(A,e),cA(tA),i&&R(tA,35136,34,0),R(i=e+352|0,A,64,0),R(i,g,C,B),N(i,hA=e+160|0),F(hA),E[e+288|0]=248&a[e+288|0],E[e+319|0]=63&a[e+319|0]|64,g=a[23+(A=c=e+288|0)|0],yA=kA(r=a[A+21|0]|a[A+22|0]<<8|g<<16&2031616,0,D=(a[hA+28|0]|a[hA+29|0]<<8|a[hA+30|0]<<16|a[hA+31|0]<<24)>>>7|0,0),DA=h,g=(A=a[hA+27|0])>>>24|0,B=A<<8|(eA=a[hA+23|0]|a[hA+24|0]<<8|a[hA+25|0]<<16|a[hA+26|0]<<24)>>>24,A=kA(t=2097151&((3&(SA=(A=(C=a[hA+28|0])>>>16|0)|g))<<30|(g=(C<<=16)|B)>>>2),0,y=(i=a[c+23|0]|a[c+24|0]<<8|a[c+25|0]<<16|a[c+26|0]<<24)>>>5&2097151,0),g=h+DA|0,C=A>>>0>(B=A+yA|0)>>>0?g+1|0:g,A=kA(n=(g=a[hA+23|0])<<16&2031616|a[hA+21|0]|a[hA+22|0]<<8,0,s=(a[c+28|0]|a[c+29|0]<<8|a[c+30|0]<<16|a[c+31|0]<<24)>>>7|0,0),C=h+C|0,DA=g=A+B|0,B=A>>>0>g>>>0?C+1|0:C,C=(A=a[c+27|0])>>>24|0,i=A<<8|i>>>24,A=kA(k=2097151&((3&(C|=g=(A=a[c+28|0])>>>16|0))<<30|(g=(A<<=16)|i)>>>2),0,S=eA>>>5&2097151,0),g=h+B|0,rA=C=A+DA|0,B=A>>>0>C>>>0?g+1|0:g,eA=kA(y,0,S,0),DA=h,g=(A=a[c+19|0])>>>24|0,i=A<<8|(JA=a[c+15|0]|a[c+16|0]<<8|a[c+17|0]<<16|a[c+18|0]<<24)>>>24,C=g,g=kA(H=(7&(C|=g=(A=a[c+20|0])>>>16|0))<<29|(g=(A<<=16)|i)>>>3,SA=C>>>3|0,D,0),A=h+DA|0,A=g>>>0>(C=g+eA|0)>>>0?A+1|0:A,i=(g=kA(r,0,t,0))+C|0,C=h+A|0,g=g>>>0>(eA=i)>>>0?C+1|0:C,C=(A=a[hA+19|0])>>>24|0,DA=A<<8|(NA=a[hA+15|0]|a[hA+16|0]<<8|a[hA+17|0]<<16|a[hA+18|0]<<24)>>>24,A=kA(G=(7&(yA=(A=(i=a[hA+20|0])>>>16|0)|C))<<29|(C=(i<<=16)|DA)>>>3,_=yA>>>3|0,s,0),g=h+g|0,g=A>>>0>(C=A+eA|0)>>>0?g+1|0:g,A=kA(n,0,k,0),g=h+g|0,sA=g=A>>>0>(nA=A+C|0)>>>0?g+1|0:g,HA=A=g-((nA>>>0<4293918720)-1|0)|0,C=(g=A>>>21|0)+B|0,eA=C=(A=(2097151&A)<<11|(yA=nA- -1048576|0)>>>21)>>>0>(rA=A+rA|0)>>>0?C+1|0:C,_A=A=C-((rA>>>0<4293918720)-1|0)|0,wA=(2097151&A)<<11|(DA=rA- -1048576|0)>>>21,i=A>>>21|0,A=kA(s,0,S,0),g=h,C=A,A=kA(D,0,y,0),g=h+g|0,g=A>>>0>(C=C+A|0)>>>0?g+1|0:g,GA=(A=C)+(C=kA(t,0,k,0))|0,A=h+g|0,A=C>>>0>GA>>>0?A+1|0:A,tA=GA-(g=-2097152&(C=GA- -1048576|0))|0,g=(A-((131071&(B=A-((GA>>>0<4293918720)-1|0)|0))+(g>>>0>GA>>>0)|0)|0)+i|0,z=g=(A=tA+wA|0)>>>0<tA>>>0?g+1|0:g,q=A,tA=kA(A,g,470296,0),wA=h,g=kA(D,0,k,0),A=h,i=g,g=kA(t,0,s,0),A=h+A|0,g=g>>>0>(i=i+g|0)>>>0?A+1|0:A,A=B>>>21|0,B=(2097151&B)<<11|C>>>21,C=A+g|0,bA=B=(C=B>>>0>(i=B+i|0)>>>0?C+1|0:C)-((i>>>0<4293918720)-1|0)|0,A=i-(g=-2097152&(KA=i- -1048576|0))|0,X=i=C-((131071&B)+(g>>>0>i>>>0)|0)|0,j=g=rA-(C=-2097152&DA)|0,T=B=eA-((C>>>0>rA>>>0)+_A|0)|0,O=A,C=kA(A,i,666643,0),A=h+wA|0,A=C>>>0>(i=C+tA|0)>>>0?A+1|0:A,C=kA(g,B,654183,0),g=h+A|0,FA=B=C+i|0,DA=C>>>0>B>>>0?g+1|0:g,GA=nA-(A=-2097152&yA)|0,HA=sA-((A>>>0>nA>>>0)+HA|0)|0,g=kA(t,0,H,SA),C=h,B=(A=g)+(g=kA(M=JA>>>6&2097151,0,D,0))|0,A=h+C|0,A=g>>>0>B>>>0?A+1|0:A,g=kA(y,0,n,0),C=h+A|0,C=g>>>0>(B=g+B|0)>>>0?C+1|0:C,A=kA(r,0,S,0),g=h+C|0,g=A>>>0>(B=A+B|0)>>>0?g+1|0:g,C=kA(s,0,p=NA>>>6&2097151,0),A=h+g|0,A=C>>>0>(B=C+B|0)>>>0?A+1|0:A,C=kA(k,0,G,_),g=h+A|0,nA=B=C+B|0,i=C>>>0>B>>>0?g+1|0:g,g=(A=a[c+14|0])>>>24|0,B=A<<8|(sA=a[c+10|0]|a[c+11|0]<<8|a[c+12|0]<<16|a[c+13|0]<<24)>>>24,g=kA(J=2097151&((1&(g|=A=(C=a[c+15|0])>>>16|0))<<31|(A=(C<<=16)|B)>>>1),0,D,0),A=h,C=g,g=kA(t,0,M,0),A=h+A|0,A=g>>>0>(C=C+g|0)>>>0?A+1|0:A,B=(g=kA(S,0,H,SA))+C|0,C=h+A|0,C=g>>>0>B>>>0?C+1|0:C,A=kA(y,0,G,_),g=h+C|0,g=A>>>0>(B=A+B|0)>>>0?g+1|0:g,A=kA(r,0,n,0),g=h+g|0,yA=C=A+B|0,B=A>>>0>C>>>0?g+1|0:g,g=(A=a[hA+14|0])>>>24|0,eA=A<<8|(rA=a[hA+10|0]|a[hA+11|0]<<8|a[hA+12|0]<<16|a[hA+13|0]<<24)>>>24,C=g,g=(A=a[hA+15|0])>>>16|0,g=kA(U=2097151&((1&(g|=C))<<31|(A=A<<16|eA)>>>1),0,s,0),A=h+B|0,A=g>>>0>(C=g+yA|0)>>>0?A+1|0:A,g=kA(k,0,p,0),A=h+A|0,eA=A=g>>>0>(yA=g+C|0)>>>0?A+1|0:A,PA=g=A-((yA>>>0<4293918720)-1|0)|0,C=(A=g>>>21|0)+i|0,wA=C=(g=(2097151&g)<<11|(tA=yA- -1048576|0)>>>21)>>>0>(_A=g+nA|0)>>>0?C+1|0:C,YA=g=C-((_A>>>0<4293918720)-1|0)|0,A=(A=g>>>21|0)+HA|0,V=A=(g=(C=(2097151&g)<<11|(nA=_A- -1048576|0)>>>21)+GA|0)>>>0<C>>>0?A+1|0:A,Z=g,A=kA(g,A,-997805,-1),g=h+DA|0,FA=C=A+FA|0,DA=A>>>0>C>>>0?g+1|0:g,GA=(RA=a[23+(f=e+224|0)|0]|a[f+24|0]<<8|a[f+25|0]<<16|a[f+26|0]<<24)>>>5&2097151,C=kA(Y=(A=a[c+2|0])<<16&2031616|a[0|c]|a[c+1|0]<<8,0,S,0),g=h,B=(A=kA(n,0,d=(i=a[c+2|0]|a[c+3|0]<<8|a[c+4|0]<<16|a[c+5|0]<<24)>>>5&2097151,0))+C|0,C=h+g|0,C=A>>>0>B>>>0?C+1|0:C,A=kA(K=(a[c+7|0]|a[c+8|0]<<8|a[c+9|0]<<16|a[c+10|0]<<24)>>>7&2097151,0,p,0),g=h+C|0,g=A>>>0>(B=A+B|0)>>>0?g+1|0:g,C=kA(U,0,b=sA>>>4&2097151,0),A=h+g|0,sA=B=C+B|0,B=C>>>0>B>>>0?A+1|0:A,i=(g=a[c+6|0])<<8|i>>>24,C=A=g>>>24|0,g=(A=a[c+7|0])>>>16|0,g=kA(P=2097151&((3&(g|=C))<<30|(A=A<<16|i)>>>2),0,G,_),A=h+B|0,A=g>>>0>(C=g+sA|0)>>>0?A+1|0:A,B=(g=kA(M,0,v=(a[hA+7|0]|a[hA+8|0]<<8|a[hA+9|0]<<16|a[hA+10|0]<<24)>>>7&2097151,0))+C|0,C=h+A|0,C=g>>>0>B>>>0?C+1|0:C,g=kA(J,0,dA=rA>>>4&2097151,0),A=h+C|0,i=g>>>0>(B=g+B|0)>>>0?A+1|0:A,A=(g=a[hA+6|0])>>>24|0,sA=g<<8|(rA=a[hA+2|0]|a[hA+3|0]<<8|a[hA+4|0]<<16|a[hA+5|0]<<24)>>>24,g=A,A=kA(H,SA,L=2097151&((3&(g|=C=(A=a[hA+7|0])>>>16|0))<<30|(A=A<<16|sA)>>>2),0),g=h+i|0,g=A>>>0>(C=A+B|0)>>>0?g+1|0:g,B=C,C=kA(x=(A=a[hA+2|0])<<16&2031616|a[0|hA]|a[hA+1|0]<<8,0,y,0),A=h+g|0,A=C>>>0>(B=B+C|0)>>>0?A+1|0:A,g=kA(r,0,m=rA>>>5&2097151,0),A=h+A|0,A=g>>>0>(C=g+B|0)>>>0?A+1|0:A,g=C,sA=C=C+GA|0,i=g=g>>>0>C>>>0?A+1|0:A,B=a[f+21|0]|a[f+22|0]<<8,A=kA(n,0,Y,0),g=h,rA=(C=A)+(A=kA(G,_,d,0))|0,C=h+g|0,C=A>>>0>rA>>>0?C+1|0:C,A=kA(U,0,K,0),g=h+C|0,g=A>>>0>(rA=A+rA|0)>>>0?g+1|0:g,A=kA(b,0,dA,0),g=h+g|0,g=A>>>0>(C=A+rA|0)>>>0?g+1|0:g,rA=(A=C)+(C=kA(p,0,P,0))|0,A=h+g|0,A=C>>>0>rA>>>0?A+1|0:A,g=kA(M,0,L,0),A=h+A|0,A=g>>>0>(C=g+rA|0)>>>0?A+1|0:A,rA=(g=kA(J,0,v,0))+C|0,C=h+A|0,C=g>>>0>rA>>>0?C+1|0:C,A=kA(H,SA,m,0),g=h+C|0,g=A>>>0>(rA=A+rA|0)>>>0?g+1|0:g,A=kA(r,0,x,0),g=h+g|0,A=A>>>0>(C=A+rA|0)>>>0?g+1|0:g,g=(g=C)>>>0>(C=C+B|0)>>>0?A+1|0:A,B=C,C=(A=a[f+23|0])<<16&2031616,A=g,C=A=C>>>0>(B=B+C|0)>>>0?A+1|0:A,hA=A=A-((B>>>0<4293918720)-1|0)|0,g=(g=A>>>21|0)+i|0,A=(g=(i=sA=(A=(2097151&A)<<11|(rA=B- -1048576|0)>>>21)+sA|0)>>>0<A>>>0?g+1|0:g)+DA|0,A=(DA=i+FA|0)>>>0<i>>>0?A+1|0:A,JA=i- -1048576|0,pA=i=g-((i>>>0<4293918720)-1|0)|0,UA=DA-(g=-2097152&JA)|0,vA=A-((g>>>0>DA>>>0)+i|0)|0,sA=B,DA=C,A=kA(j,T,470296,0),g=h,C=A,A=kA(q,z,666643,0),g=h+g|0,g=A>>>0>(C=C+A|0)>>>0?g+1|0:g,B=(A=C)+(C=kA(Z,V,654183,0))|0,A=h+g|0,NA=B,i=C>>>0>B>>>0?A+1|0:A,g=kA(G,_,Y,0),A=h,C=g,g=kA(p,0,d,0),A=h+A|0,A=g>>>0>(C=C+g|0)>>>0?A+1|0:A,B=(g=C)+(C=kA(K,0,dA,0))|0,g=h+A|0,g=C>>>0>B>>>0?g+1|0:g,A=kA(b,0,v,0),C=h+g|0,C=A>>>0>(B=A+B|0)>>>0?C+1|0:C,A=kA(U,0,P,0),g=h+C|0,g=A>>>0>(B=A+B|0)>>>0?g+1|0:g,C=kA(M,0,m,0),A=h+g|0,A=C>>>0>(B=C+B|0)>>>0?A+1|0:A,g=kA(J,0,L,0),A=h+A|0,A=g>>>0>(C=g+B|0)>>>0?A+1|0:A,B=(g=C)+(C=kA(H,SA,x,0))|0,g=h+A|0,GA=B,C=C>>>0>B>>>0?g+1|0:g,g=(A=a[f+19|0])>>>24|0,HA=A<<8|(FA=a[f+15|0]|a[f+16|0]<<8|a[f+17|0]<<16|a[f+18|0]<<24)>>>24,C=((LA=(A=(B=a[f+20|0])>>>16|0)|g)>>>3|0)+C|0,GA=B=(g=(7&LA)<<29|(g=(B<<=16)|HA)>>>3)+GA|0,B=g>>>0>B>>>0?C+1|0:C,HA=FA>>>6&2097151,A=kA(p,0,Y,0),g=h,C=A,A=kA(U,0,d,0),g=h+g|0,g=A>>>0>(C=C+A|0)>>>0?g+1|0:g,FA=(A=C)+(C=kA(K,0,v,0))|0,A=h+g|0,A=C>>>0>FA>>>0?A+1|0:A,C=kA(b,0,L,0),g=h+A|0,g=C>>>0>(FA=C+FA|0)>>>0?g+1|0:g,C=kA(P,0,dA,0),A=h+g|0,A=C>>>0>(FA=C+FA|0)>>>0?A+1|0:A,g=kA(M,0,x,0),C=h+A|0,C=g>>>0>(FA=g+FA|0)>>>0?C+1|0:C,A=kA(J,0,m,0),g=h+C|0,A=A>>>0>(FA=A+FA|0)>>>0?g+1|0:g,TA=A=(xA=FA+HA|0)>>>0<FA>>>0?A+1|0:A,II=A=A-((xA>>>0<4293918720)-1|0)|0,C=(2097151&A)<<11|(XA=xA- -1048576|0)>>>21,A=(A>>>21|0)+B|0,VA=A=C>>>0>(OA=C+GA|0)>>>0?A+1|0:A,gI=A=A-((OA>>>0<4293918720)-1|0)|0,C=(2097151&A)<<11|(lA=OA- -1048576|0)>>>21,A=(A>>>21|0)+i|0,g=(C>>>0>(B=C+NA|0)>>>0?A+1|0:A)+DA|0,DA=(C=B+sA|0)-(A=-2097152&rA)|0,hA=A=(g=C>>>0<B>>>0?g+1|0:g)-((A>>>0>C>>>0)+hA|0)|0,CI=A=A-((DA>>>0<4293918720)-1|0)|0,C=(2097151&A)<<11|(zA=DA- -1048576|0)>>>21,A=(A>>21)+vA|0,B=A=C>>>0>(i=C+UA|0)>>>0?A+1|0:A,AI=A=A-((i>>>0<4293918720)-1|0)|0,qA=(2097151&A)<<11|(NA=i- -1048576|0)>>>21,sA=A>>21,LA=_A-(A=-2097152&nA)|0,YA=wA-((A>>>0>_A>>>0)+YA|0)|0,A=kA(D,0,s,0),jA=g=h,UA=A,FA=A- -1048576|0,mA=g=g-((A>>>0<4293918720)-1|0)|0,W=A=g>>>21|0,A=kA(l=(2097151&g)<<11|FA>>>21,A,-683901,-1),g=h+eA|0,g=A>>>0>(C=A+yA|0)>>>0?g+1|0:g,nA=C-(A=-2097152&tA)|0,rA=g-((A>>>0>C>>>0)+PA|0)|0,g=kA(S,0,M,0),A=h,C=g,g=kA(D,0,b,0),A=h+A|0,A=g>>>0>(C=C+g|0)>>>0?A+1|0:A,g=kA(t,0,J,0),A=h+A|0,A=g>>>0>(C=g+C|0)>>>0?A+1|0:A,eA=(g=C)+(C=kA(n,0,H,SA))|0,g=h+A|0,g=C>>>0>eA>>>0?g+1|0:g,A=kA(y,0,p,0),C=h+g|0,C=A>>>0>(eA=A+eA|0)>>>0?C+1|0:C,A=kA(r,0,G,_),g=h+C|0,g=A>>>0>(eA=A+eA|0)>>>0?g+1|0:g,C=kA(s,0,dA,0),A=h+g|0,A=C>>>0>(eA=C+eA|0)>>>0?A+1|0:A,g=kA(k,0,U,0),A=h+A|0,yA=C=g+eA|0,eA=g>>>0>C>>>0?A+1|0:A,A=kA(t,0,b,0),g=h,C=A,A=kA(D,0,K,0),g=h+g|0,g=A>>>0>(C=C+A|0)>>>0?g+1|0:g,wA=(A=kA(n,0,M,0))+C|0,C=h+g|0,C=A>>>0>wA>>>0?C+1|0:C,A=kA(S,0,J,0),g=h+C|0,g=A>>>0>(wA=A+wA|0)>>>0?g+1|0:g,C=kA(H,SA,G,_),A=h+g|0,A=C>>>0>(wA=C+wA|0)>>>0?A+1|0:A,g=kA(y,0,U,0),A=h+A|0,A=g>>>0>(C=g+wA|0)>>>0?A+1|0:A,wA=(g=C)+(C=kA(r,0,p,0))|0,g=h+A|0,g=C>>>0>wA>>>0?g+1|0:g,A=kA(s,0,v,0),C=h+g|0,C=A>>>0>(wA=A+wA|0)>>>0?C+1|0:C,A=kA(k,0,dA,0),g=h+C|0,HA=g=A>>>0>(GA=A+wA|0)>>>0?g+1|0:g,WA=A=g-((GA>>>0<4293918720)-1|0)|0,g=(2097151&A)<<11|(_A=GA- -1048576|0)>>>21,A=(A>>>21|0)+eA|0,tA=A=g>>>0>(PA=g+yA|0)>>>0?A+1|0:A,uA=A=A-((PA>>>0<4293918720)-1|0)|0,g=(C=A>>>21|0)+rA|0,nA=g=(A=(2097151&A)<<11|(wA=PA- -1048576|0)>>>21)>>>0>(vA=A+nA|0)>>>0?g+1|0:g,ZA=A=g-((vA>>>0<4293918720)-1|0)|0,eA=(2097151&A)<<11|(rA=vA- -1048576|0)>>>21,A=(A>>21)+YA|0,$=A=(g=eA+LA|0)>>>0<eA>>>0?A+1|0:A,AA=g,A=kA(g,A,-683901,-1),g=h+sA|0,qA=C=A+qA|0,sA=A>>>0>C>>>0?g+1|0:g,A=kA(t,0,Y,0),g=h,C=A,A=kA(S,0,d,0),g=h+g|0,g=A>>>0>(C=C+A|0)>>>0?g+1|0:g,eA=(A=C)+(C=kA(G,_,K,0))|0,A=h+g|0,A=C>>>0>eA>>>0?A+1|0:A,g=kA(p,0,b,0),C=h+A|0,C=g>>>0>(eA=g+eA|0)>>>0?C+1|0:C,g=kA(n,0,P,0),A=h+C|0,A=g>>>0>(eA=g+eA|0)>>>0?A+1|0:A,C=kA(M,0,dA,0),g=h+A|0,g=C>>>0>(eA=C+eA|0)>>>0?g+1|0:g,A=kA(J,0,U,0),g=h+g|0,g=A>>>0>(C=A+eA|0)>>>0?g+1|0:g,eA=(A=C)+(C=kA(H,SA,v,0))|0,A=h+g|0,A=C>>>0>eA>>>0?A+1|0:A,g=kA(y,0,m,0),C=h+A|0,C=g>>>0>(eA=g+eA|0)>>>0?C+1|0:C,g=kA(r,0,L,0),A=h+C|0,A=g>>>0>(eA=g+eA|0)>>>0?A+1|0:A,C=kA(k,0,x,0),g=h+A|0,YA=eA=C+eA|0,C=C>>>0>eA>>>0?g+1|0:g,g=(A=a[f+27|0])>>>24|0,yA=A<<8|RA>>>24,eA=2097151&((3&(g|=A=(eA=a[f+28|0])>>>16|0))<<30|(A=(eA<<=16)|yA)>>>2),g=C,yA=A=eA+YA|0,eA=A>>>0<eA>>>0?g+1|0:g,LA=kA(O,X,470296,0),YA=h,A=(C=(2097151&bA)<<11|KA>>>21)+(UA-(g=-2097152&FA)|0)|0,g=jA-((524287&mA)+(g>>>0>UA>>>0)|0)+(bA>>>21)|0,IA=g=A>>>0<C>>>0?g+1|0:g,gA=A,g=kA(A,g,666643,0),A=h+YA|0,A=g>>>0>(C=g+LA|0)>>>0?A+1|0:A,FA=(g=kA(q,z,654183,0))+C|0,C=h+A|0,C=g>>>0>FA>>>0?C+1|0:C,g=kA(j,T,-997805,-1),A=h+C|0,A=g>>>0>(FA=g+FA|0)>>>0?A+1|0:A,C=kA(Z,V,136657,0),g=h+A|0,JA=(A=(2097151&pA)<<11|JA>>>21)+(FA=C+FA|0)|0,g=(pA>>>21|0)+(C>>>0>FA>>>0?g+1|0:g)|0,mA=FA=eA-((yA>>>0<4293918720)-1|0)|0,A=(A>>>0>JA>>>0?g+1|0:g)+eA|0,g=(eA=yA+JA|0)-(C=-2097152&(jA=yA- -1048576|0))|0,C=(A=(A=eA>>>0<JA>>>0?A+1|0:A)-((C>>>0>eA>>>0)+FA|0)|0)+sA|0,LA=eA=A-((g>>>0<4293918720)-1|0)|0,UA=(C=(yA=g+qA|0)>>>0<g>>>0?C+1|0:C)-(((g=-2097152&(YA=g- -1048576|0))>>>0>yA>>>0)+eA|0)|0,RA=A=yA-g|0,eA=i,i=B,$A=vA-(A=-2097152&rA)|0,FA=nA-((A>>>0>vA>>>0)+ZA|0)|0,A=kA(gA,IA,-683901,-1),g=h,B=(C=A)+(A=kA(l,W,136657,0))|0,C=h+g|0,g=tA+(A>>>0>B>>>0?C+1|0:C)|0,wA=(C=B+PA|0)-(A=-2097152&wA)|0,nA=(g=C>>>0<PA>>>0?g+1|0:g)-((A>>>0>C>>>0)+uA|0)|0,g=kA(l,W,-997805,-1),A=h+HA|0,A=g>>>0>(C=g+GA|0)>>>0?A+1|0:A,B=(g=kA(gA,IA,136657,0))+C|0,C=h+A|0,C=g>>>0>B>>>0?C+1|0:C,A=kA(O,X,-683901,-1),g=h+C|0,g=A>>>0>(B=A+B|0)>>>0?g+1|0:g,rA=B-(A=-2097152&_A)|0,sA=g-((A>>>0>B>>>0)+WA|0)|0,g=kA(S,0,b,0),A=h,C=g,g=kA(t,0,K,0),A=h+A|0,A=g>>>0>(C=C+g|0)>>>0?A+1|0:A,B=(g=kA(D,0,P,0))+C|0,C=h+A|0,C=g>>>0>B>>>0?C+1|0:C,A=kA(G,_,M,0),g=h+C|0,g=A>>>0>(B=A+B|0)>>>0?g+1|0:g,C=kA(n,0,J,0),A=h+g|0,A=C>>>0>(B=C+B|0)>>>0?A+1|0:A,C=kA(H,SA,p,0),g=h+A|0,g=C>>>0>(B=C+B|0)>>>0?g+1|0:g,C=kA(y,0,dA,0),A=h+g|0,A=C>>>0>(B=C+B|0)>>>0?A+1|0:A,g=kA(r,0,U,0),C=h+A|0,C=g>>>0>(B=g+B|0)>>>0?C+1|0:C,A=kA(s,0,L,0),g=h+C|0,g=A>>>0>(B=A+B|0)>>>0?g+1|0:g,C=kA(k,0,v,0),A=h+g|0,yA=B=C+B|0,B=C>>>0>B>>>0?A+1|0:A,A=kA(S,0,K,0),g=h,C=A,A=kA(D,0,d,0),g=h+g|0,g=A>>>0>(C=C+A|0)>>>0?g+1|0:g,tA=(A=C)+(C=kA(n,0,b,0))|0,A=h+g|0,A=C>>>0>tA>>>0?A+1|0:A,g=kA(t,0,P,0),C=h+A|0,C=g>>>0>(tA=g+tA|0)>>>0?C+1|0:C,A=kA(M,0,p,0),g=h+C|0,g=A>>>0>(tA=A+tA|0)>>>0?g+1|0:g,C=kA(G,_,J,0),A=h+g|0,A=C>>>0>(tA=C+tA|0)>>>0?A+1|0:A,C=kA(H,SA,U,0),g=h+A|0,g=C>>>0>(tA=C+tA|0)>>>0?g+1|0:g,C=kA(y,0,v,0),A=h+g|0,A=C>>>0>(tA=C+tA|0)>>>0?A+1|0:A,g=kA(r,0,dA,0),C=h+A|0,C=g>>>0>(tA=g+tA|0)>>>0?C+1|0:C,tA=(A=kA(s,0,m,0))+tA|0,g=h+C|0,C=kA(k,0,L,0),A=h+(A>>>0>tA>>>0?g+1|0:g)|0,vA=A=C>>>0>(ZA=C+tA|0)>>>0?A+1|0:A,BA=A=A-((ZA>>>0<4293918720)-1|0)|0,C=(2097151&A)<<11|(bA=ZA- -1048576|0)>>>21,A=(A>>>21|0)+B|0,KA=A=C>>>0>(qA=C+yA|0)>>>0?A+1|0:A,QA=A=A-((qA>>>0<4293918720)-1|0)|0,C=(2097151&A)<<11|(pA=qA- -1048576|0)>>>21,A=(A>>>21|0)+sA|0,JA=A=C>>>0>(PA=C+rA|0)>>>0?A+1|0:A,iA=A=A-((PA>>>0<4293918720)-1|0)|0,C=(2097151&A)<<11|(HA=PA- -1048576|0)>>>21,A=(A>>21)+nA|0,B=A=C>>>0>(rA=C+wA|0)>>>0?A+1|0:A,nA=A=A-((rA>>>0<4293918720)-1|0)|0,sA=(2097151&A)<<11|(C=rA- -1048576|0)>>>21,A=(A>>21)+FA|0,WA=A=(yA=sA+$A|0)>>>0<sA>>>0?A+1|0:A,uA=yA,A=kA(yA,A,-683901,-1),g=h,yA=A,A=kA(AA,$,136657,0),g=h+g|0,A=(A>>>0>(yA=yA+A|0)>>>0?g+1|0:g)+i|0,BI=(i=eA+yA|0)-(g=-2097152&NA)|0,QI=(A=i>>>0<yA>>>0?A+1|0:A)-((g>>>0>i>>>0)+AI|0)|0,sA=DA,yA=hA,DA=kA(uA,WA,136657,0),i=h,$A=A=rA-(g=-2097152&C)|0,CA=B=B-((g>>>0>rA>>>0)+nA|0)|0,C=kA(AA,$,-997805,-1),g=h+i|0,g=C>>>0>(DA=C+DA|0)>>>0?g+1|0:g,C=kA(A,B,-683901,-1),A=h+g|0,AI=B=C+DA|0,eA=C>>>0>B>>>0?A+1|0:A,A=kA(Z,V,470296,0),g=h,B=(C=A)+(A=kA(j,T,666643,0))|0,C=h+g|0,g=VA+(A>>>0>B>>>0?C+1|0:C)|0,FA=A=B+OA|0,i=g=A>>>0<OA>>>0?g+1|0:g,g=kA(Z,V,666643,0),A=h+TA|0,A=g>>>0>(C=g+xA|0)>>>0?A+1|0:A,wA=C-(g=-2097152&XA)|0,GA=A-((g>>>0>C>>>0)+II|0)|0,g=kA(U,0,Y,0),A=h,C=g,g=kA(d,0,dA,0),A=h+A|0,A=g>>>0>(C=C+g|0)>>>0?A+1|0:A,B=(g=C)+(C=kA(K,0,L,0))|0,g=h+A|0,g=C>>>0>B>>>0?g+1|0:g,C=kA(b,0,m,0),A=h+g|0,A=C>>>0>(B=C+B|0)>>>0?A+1|0:A,g=kA(P,0,v,0),C=h+A|0,C=g>>>0>(B=g+B|0)>>>0?C+1|0:C,A=kA(J,0,x,0),g=h+C|0,rA=B=A+B|0,B=A>>>0>B>>>0?g+1|0:g,g=(A=a[f+14|0])>>>24|0,DA=A<<8|(nA=a[f+10|0]|a[f+11|0]<<8|a[f+12|0]<<16|a[f+13|0]<<24)>>>24,g=2097151&((1&(g|=C=(A=a[f+15|0])>>>16|0))<<31|(A=DA|A<<16)>>>1),A=B,rA=C=g+rA|0,B=g>>>0>C>>>0?A+1|0:A,DA=nA>>>4&2097151,A=kA(Y,0,dA,0),g=h,C=A,A=kA(d,0,v,0),g=h+g|0,g=A>>>0>(C=C+A|0)>>>0?g+1|0:g,A=kA(K,0,m,0),g=h+g|0,g=A>>>0>(C=A+C|0)>>>0?g+1|0:g,nA=(A=C)+(C=kA(b,0,x,0))|0,A=h+g|0,A=C>>>0>nA>>>0?A+1|0:A,g=kA(P,0,L,0),C=h+A|0,A=g>>>0>(nA=g+nA|0)>>>0?C+1|0:C,hA=A=(XA=DA+nA|0)>>>0<nA>>>0?A+1|0:A,EA=A=A-((XA>>>0<4293918720)-1|0)|0,g=(C=A>>>21|0)+B|0,_A=g=(A=(2097151&A)<<11|(NA=XA- -1048576|0)>>>21)>>>0>(VA=A+rA|0)>>>0?g+1|0:g,oA=A=g-((VA>>>0<4293918720)-1|0)|0,g=(2097151&A)<<11|(tA=VA- -1048576|0)>>>21,A=(A>>>21|0)+GA|0,nA=A=g>>>0>(wA=g+wA|0)>>>0?A+1|0:A,fA=A=A-((wA>>>0<4293918720)-1|0)|0,g=(C=A>>21)+i|0,II=g=(g=(A=(2097151&A)<<11|(rA=wA- -1048576|0)>>>21)>>>0>(B=A+FA|0)>>>0?g+1|0:g)-(((C=-2097152&lA)>>>0>B>>>0)+gI|0)|0,lA=A=B-C|0,DA=A- -1048576|0,gI=A=g-((A>>>0<4293918720)-1|0)|0,C=(g=A>>21)+eA|0,g=((A=(2097151&A)<<11|DA>>>21)>>>0>(B=A+AI|0)>>>0?C+1|0:C)+yA|0,xA=g=(g=(A=B)>>>0>(B=B+sA|0)>>>0?g+1|0:g)-(((C=-2097152&zA)>>>0>B>>>0)+CI|0)|0,yA=A=B-C|0,i=A- -1048576|0,TA=A=g-((A>>>0<4293918720)-1|0)|0,C=(g=A>>21)+QI|0,zA=A=(C=(A=(2097151&A)<<11|i>>>21)>>>0>(eA=A+BI|0)>>>0?C+1|0:C)-((eA>>>0<4293918720)-1|0)|0,FA=RA- -1048576|0,GA=UA-((RA>>>0<4293918720)-1|0)|0,sA=(2097151&A)<<11|(B=eA- -1048576|0)>>>21,A=(A>>21)+UA|0,CI=(RA=sA+RA|0)-(g=-2097152&FA)|0,BI=(sA>>>0>RA>>>0?A+1|0:A)-((g>>>0>RA>>>0)+GA|0)|0,QI=eA-(A=-2097152&B)|0,AI=C-((A>>>0>eA>>>0)+zA|0)|0,OA=yA-(A=-2097152&i)|0,RA=xA-((A>>>0>yA>>>0)+TA|0)|0,A=kA(uA,WA,-997805,-1),g=h,C=A,A=kA(AA,$,654183,0),g=h+g|0,g=A>>>0>(C=C+A|0)>>>0?g+1|0:g,B=(A=C)+(C=kA($A,CA,136657,0))|0,A=h+g|0,g=II+(C>>>0>B>>>0?A+1|0:A)|0,xA=(C=B+lA|0)-(A=-2097152&DA)|0,TA=(g=C>>>0<lA>>>0?g+1|0:g)-((A>>>0>C>>>0)+gI|0)|0,lA=PA-(A=-2097152&HA)|0,UA=JA-((A>>>0>PA>>>0)+iA|0)|0,g=kA(gA,IA,-997805,-1),A=h,C=g,g=kA(l,W,654183,0),A=h+A|0,A=g>>>0>(C=C+g|0)>>>0?A+1|0:A,B=(g=C)+(C=kA(O,X,136657,0))|0,g=h+A|0,g=C>>>0>B>>>0?g+1|0:g,A=kA(q,z,-683901,-1),C=h+g|0,g=KA+(A>>>0>(B=A+B|0)>>>0?C+1|0:C)|0,HA=(C=B+qA|0)-(A=-2097152&pA)|0,JA=(g=C>>>0<qA>>>0?g+1|0:g)-((A>>>0>C>>>0)+QA|0)|0,g=kA(gA,IA,654183,0),A=h,C=g,g=kA(l,W,470296,0),A=h+A|0,A=g>>>0>(C=C+g|0)>>>0?A+1|0:A,B=(g=kA(O,X,-997805,-1))+C|0,C=h+A|0,g=vA+(g>>>0>B>>>0?C+1|0:C)|0,g=(A=B+ZA|0)>>>0<ZA>>>0?g+1|0:g,C=A,A=kA(q,z,136657,0),g=h+g|0,g=A>>>0>(C=C+A|0)>>>0?g+1|0:g,B=(A=C)+(C=kA(j,T,-683901,-1))|0,A=h+g|0,DA=B-(g=-2097152&bA)|0,i=(C>>>0>B>>>0?A+1|0:A)-((g>>>0>B>>>0)+BA|0)|0,B=(a[f+28|0]|a[f+29|0]<<8|a[f+30|0]<<16|a[f+31|0]<<24)>>>7|0,A=kA(D,0,Y,0),g=h,eA=(C=A)+(A=kA(t,0,d,0))|0,C=h+g|0,C=A>>>0>eA>>>0?C+1|0:C,A=kA(n,0,K,0),g=h+C|0,g=A>>>0>(eA=A+eA|0)>>>0?g+1|0:g,C=kA(G,_,b,0),A=h+g|0,A=C>>>0>(eA=C+eA|0)>>>0?A+1|0:A,C=kA(S,0,P,0),g=h+A|0,g=C>>>0>(eA=C+eA|0)>>>0?g+1|0:g,C=kA(M,0,U,0),A=h+g|0,A=C>>>0>(eA=C+eA|0)>>>0?A+1|0:A,g=kA(p,0,J,0),C=h+A|0,C=g>>>0>(eA=g+eA|0)>>>0?C+1|0:C,A=kA(H,SA,dA,0),g=h+C|0,g=A>>>0>(eA=A+eA|0)>>>0?g+1|0:g,C=kA(y,0,L,0),A=h+g|0,A=C>>>0>(eA=C+eA|0)>>>0?A+1|0:A,C=kA(r,0,v,0),g=h+A|0,g=C>>>0>(eA=C+eA|0)>>>0?g+1|0:g,C=kA(s,0,x,0),A=h+g|0,A=C>>>0>(eA=C+eA|0)>>>0?A+1|0:A,g=kA(k,0,m,0),C=h+A|0,g=C=g>>>0>(eA=g+eA|0)>>>0?C+1|0:C,KA=(C=(2097151&mA)<<11|jA>>>21)+(A=B+eA|0)|0,A=(mA>>>21|0)+(g=A>>>0<eA>>>0?g+1|0:g)|0,sA=A=C>>>0>KA>>>0?A+1|0:A,zA=g=A-((KA>>>0<4293918720)-1|0)|0,C=(A=g>>>21|0)+i|0,yA=C=(g=(2097151&g)<<11|(SA=KA- -1048576|0)>>>21)>>>0>(pA=g+DA|0)>>>0?C+1|0:C,jA=g=C-((pA>>>0<4293918720)-1|0)|0,A=(A=g>>21)+JA|0,DA=A=(g=(2097151&g)<<11|(eA=pA- -1048576|0)>>>21)>>>0>(HA=g+HA|0)>>>0?A+1|0:A,bA=g=A-((HA>>>0<4293918720)-1|0)|0,C=(A=g>>21)+UA|0,mA=C=(g=(B=(2097151&g)<<11|(i=HA- -1048576|0)>>>21)+lA|0)>>>0<B>>>0?C+1|0:C,UA=g,A=kA(g,C,-683901,-1),g=h+TA|0,JA=C=A+xA|0,B=A>>>0>C>>>0?g+1|0:g,g=kA(AA,$,470296,0),A=h+nA|0,A=g>>>0>(wA=g+wA|0)>>>0?A+1|0:A,g=kA(uA,WA,654183,0),A=h+(A-(((C=-2097152&rA)>>>0>wA>>>0)+fA|0)|0)|0,A=g>>>0>(rA=g+(wA-C|0)|0)>>>0?A+1|0:A,C=kA($A,CA,-997805,-1),g=h+A|0,g=C>>>0>(rA=C+rA|0)>>>0?g+1|0:g,vA=C=HA-(A=-2097152&i)|0,dA=DA=DA-((A>>>0>HA>>>0)+bA|0)|0,rA=(i=kA(UA,mA,136657,0))+rA|0,A=h+g|0,C=kA(C,DA,-683901,-1),g=h+(i>>>0>rA>>>0?A+1|0:A)|0,DA=g=C>>>0>(nA=C+rA|0)>>>0?g+1|0:g,bA=A=g-((nA>>>0<4293918720)-1|0)|0,g=(2097151&A)<<11|(i=nA- -1048576|0)>>>21,A=(A>>21)+B|0,HA=g=(A=g>>>0>(rA=g+JA|0)>>>0?A+1|0:A)-((rA>>>0<4293918720)-1|0)|0,wA=(2097151&g)<<11|(B=rA- -1048576|0)>>>21,g=(g>>21)+RA|0,OA=JA=wA+OA|0,JA=wA>>>0>JA>>>0?g+1|0:g,RA=rA-(g=-2097152&B)|0,ZA=A-((g>>>0>rA>>>0)+HA|0)|0,xA=nA-(A=-2097152&i)|0,TA=DA-((A>>>0>nA>>>0)+bA|0)|0,A=kA(AA,$,666643,0),C=_A+h|0,C=(i=A+VA|0)>>>0<VA>>>0?C+1|0:C,B=(A=kA(uA,WA,470296,0))+(i-(g=-2097152&tA)|0)|0,g=h+(C-((g>>>0>i>>>0)+oA|0)|0)|0,g=A>>>0>B>>>0?g+1|0:g,C=kA($A,CA,654183,0),A=h+g|0,rA=B=C+B|0,B=C>>>0>B>>>0?A+1|0:A,i=pA-(A=-2097152&eA)|0,DA=yA-((A>>>0>pA>>>0)+jA|0)|0,A=kA(gA,IA,470296,0),g=h,C=A,A=kA(l,W,666643,0),g=h+g|0,g=A>>>0>(C=C+A|0)>>>0?g+1|0:g,A=kA(O,X,654183,0),g=h+g|0,g=A>>>0>(C=A+C|0)>>>0?g+1|0:g,eA=(A=C)+(C=kA(q,z,-997805,-1))|0,A=h+g|0,A=C>>>0>eA>>>0?A+1|0:A,g=kA(j,T,136657,0),A=h+A|0,A=g>>>0>(C=g+eA|0)>>>0?A+1|0:A,eA=(g=kA(Z,V,-683901,-1))+C|0,C=h+A|0,g=sA+(g>>>0>eA>>>0?C+1|0:C)|0,pA=(C=(2097151&LA)<<11|YA>>>21)+((eA=eA+KA|0)-(A=-2097152&SA)|0)|0,A=((g=eA>>>0<KA>>>0?g+1|0:g)-((A>>>0>eA>>>0)+zA|0)|0)+(LA>>21)|0,HA=A=C>>>0>pA>>>0?A+1|0:A,lA=A=A-((pA>>>0<4293918720)-1|0)|0,g=i,i=(2097151&A)<<11|(tA=pA- -1048576|0)>>>21,A=(A>>21)+DA|0,bA=A=(C=g+i|0)>>>0<i>>>0?A+1|0:A,KA=C,A=kA(C,A,-683901,-1),g=h+B|0,g=A>>>0>(C=A+rA|0)>>>0?g+1|0:g,B=(A=C)+(C=kA(UA,mA,-997805,-1))|0,A=h+g|0,A=C>>>0>B>>>0?A+1|0:A,g=kA(vA,dA,136657,0),C=h+A|0,YA=B=g+B|0,yA=g>>>0>B>>>0?C+1|0:C,rA=XA-(A=-2097152&NA)|0,sA=hA-((A>>>0>XA>>>0)+EA|0)|0,g=kA(Y,0,v,0),A=h,C=g,g=kA(d,0,L,0),A=h+A|0,A=g>>>0>(C=C+g|0)>>>0?A+1|0:A,g=kA(K,0,x,0),A=h+A|0,A=g>>>0>(C=g+C|0)>>>0?A+1|0:A,B=(g=kA(P,0,m,0))+C|0,C=h+A|0,g=g>>>0>B>>>0?C+1|0:C,SA=C=(A=(a[f+7|0]|a[f+8|0]<<8|a[f+9|0]<<16|a[f+10|0]<<24)>>>7&2097151)+B|0,eA=A>>>0>C>>>0?g+1|0:g,A=kA(Y,0,L,0),g=h,C=A,A=kA(d,0,m,0),g=h+g|0,g=A>>>0>(C=C+A|0)>>>0?g+1|0:g,B=(A=C)+(C=kA(P,0,x,0))|0,A=h+g|0,DA=B,B=C>>>0>B>>>0?A+1|0:A,A=(g=a[f+6|0])>>>24|0,i=g<<8|(zA=a[f+2|0]|a[f+3|0]<<8|a[f+4|0]<<16|a[f+5|0]<<24)>>>24,C=A,g=(A=a[f+7|0])>>>16|0,g|=C,C=B,i=C=(A=2097151&((3&g)<<30|(A=A<<16|i)>>>2))>>>0>(DA=A+DA|0)>>>0?C+1|0:C,qA=A=C-((DA>>>0<4293918720)-1|0)|0,C=(2097151&A)<<11|(_A=DA- -1048576|0)>>>21,A=(A>>>21|0)+eA|0,wA=A=C>>>0>(hA=C+SA|0)>>>0?A+1|0:A,jA=A=A-((hA>>>0<4293918720)-1|0)|0,C=(g=A>>>21|0)+sA|0,C=(A=(2097151&A)<<11|(nA=hA- -1048576|0)>>>21)>>>0>(B=A+rA|0)>>>0?C+1|0:C,g=kA(uA,WA,666643,0),A=h+C|0,A=g>>>0>(B=g+B|0)>>>0?A+1|0:A,g=kA($A,CA,470296,0),A=h+A|0,A=g>>>0>(C=g+B|0)>>>0?A+1|0:A,B=(g=C)+(C=kA(KA,bA,136657,0))|0,g=h+A|0,g=C>>>0>B>>>0?g+1|0:g,A=kA(UA,mA,654183,0),g=h+g|0,g=A>>>0>(C=A+B|0)>>>0?g+1|0:g,rA=(A=kA(vA,dA,-997805,-1))+C|0,C=h+g|0,sA=C=A>>>0>rA>>>0?C+1|0:C,LA=A=C-((rA>>>0<4293918720)-1|0)|0,C=(2097151&A)<<11|(SA=rA- -1048576|0)>>>21,A=(A>>21)+yA|0,YA=C=(A=C>>>0>(B=C+YA|0)>>>0?A+1|0:A)-((B>>>0<4293918720)-1|0)|0,eA=(2097151&C)<<11|(yA=B- -1048576|0)>>>21,C=(C>>21)+TA|0,PA=NA=eA+xA|0,NA=eA>>>0>NA>>>0?C+1|0:C,eA=B,g=A,B=(pA-(A=-2097152&tA)|0)+(tA=(2097151&GA)<<11|FA>>>21)|0,A=(HA-((A>>>0>pA>>>0)+lA|0)|0)+(GA>>21)|0,FA=A=B>>>0<tA>>>0?A+1|0:A,xA=A=A-((B>>>0<4293918720)-1|0)|0,pA=C=A>>21,A=kA(uA=(2097151&A)<<11|(GA=B- -1048576|0)>>>21,C,-683901,-1),g=h+g|0,g=A>>>0>(C=A+eA|0)>>>0?g+1|0:g,TA=C-(A=-2097152&yA)|0,XA=g-((A>>>0>C>>>0)+YA|0)|0,g=kA(uA,pA,136657,0),A=h+sA|0,A=g>>>0>(C=g+rA|0)>>>0?A+1|0:A,VA=C-(g=-2097152&SA)|0,LA=A-((g>>>0>C>>>0)+LA|0)|0,g=kA($A,CA,666643,0),A=h+(wA-(((C=-2097152&nA)>>>0>hA>>>0)+jA|0)|0)|0,A=g>>>0>(eA=g+(hA-C|0)|0)>>>0?A+1|0:A,C=kA(KA,bA,-997805,-1),g=h+A|0,g=C>>>0>(eA=C+eA|0)>>>0?g+1|0:g,A=kA(UA,mA,470296,0),C=h+g|0,C=A>>>0>(eA=A+eA|0)>>>0?C+1|0:C,g=kA(vA,dA,654183,0),A=h+C|0,YA=eA=g+eA|0,sA=g>>>0>eA>>>0?A+1|0:A,C=zA>>>5&2097151,A=kA(Y,0,m,0),g=h,yA=A,A=kA(d,0,x,0),g=h+g|0,A=A>>>0>(eA=yA+A|0)>>>0?g+1|0:g,yA=g=C+eA|0,C=A=g>>>0<eA>>>0?A+1|0:A,hA=(g=kA(Y,0,x,0))+(A=(A=a[f+2|0])<<16&2031616|a[0|f]|a[f+1|0]<<8)|0,g=h,tA=g=A>>>0>hA>>>0?g+1|0:g,lA=g=g-((hA>>>0<4293918720)-1|0)|0,A=(A=g>>>21|0)+C|0,nA=A=(g=(2097151&g)<<11|(wA=hA- -1048576|0)>>>21)>>>0>(HA=g+yA|0)>>>0?A+1|0:A,zA=g=A-((HA>>>0<4293918720)-1|0)|0,C=(2097151&g)<<11|(rA=HA- -1048576|0)>>>21,g=(g>>>21|0)+i|0,g=C>>>0>(eA=C+DA|0)>>>0?g+1|0:g,C=kA(KA,bA,654183,0),A=h+(g-(((i=-2097152&_A)>>>0>eA>>>0)+qA|0)|0)|0,A=C>>>0>(DA=C+(eA-i|0)|0)>>>0?A+1|0:A,g=kA(UA,mA,666643,0),A=h+A|0,A=g>>>0>(C=g+DA|0)>>>0?A+1|0:A,SA=(g=C)+(C=kA(vA,dA,470296,0))|0,g=h+A|0,yA=g=C>>>0>SA>>>0?g+1|0:g,jA=g=g-((SA>>>0<4293918720)-1|0)|0,C=(A=g>>21)+sA|0,_A=g=(C=(g=(2097151&g)<<11|(eA=SA- -1048576|0)>>>21)>>>0>(DA=g+YA|0)>>>0?C+1|0:C)-((DA>>>0<4293918720)-1|0)|0,sA=(2097151&g)<<11|(i=DA- -1048576|0)>>>21,g=(g>>21)+LA|0,mA=UA=sA+VA|0,sA=sA>>>0>UA>>>0?g+1|0:g,A=kA(uA,pA,-997805,-1),g=h+C|0,g=A>>>0>(DA=A+DA|0)>>>0?g+1|0:g,LA=DA-(A=-2097152&i)|0,YA=g-((A>>>0>DA>>>0)+_A|0)|0,g=kA(uA,pA,654183,0),A=h+yA|0,A=g>>>0>(C=g+SA|0)>>>0?A+1|0:A,UA=C-(g=-2097152&eA)|0,_A=A-((g>>>0>C>>>0)+jA|0)|0,A=kA(KA,bA,470296,0),C=h+(nA-(((g=-2097152&rA)>>>0>HA>>>0)+zA|0)|0)|0,C=A>>>0>(i=A+(HA-g|0)|0)>>>0?C+1|0:C,g=kA(vA,dA,666643,0),A=h+C|0,DA=i=g+i|0,C=g>>>0>i>>>0?A+1|0:A,g=kA(KA,bA,666643,0),A=h+(tA-((4095&lA)+((i=-2097152&wA)>>>0>hA>>>0)|0)|0)|0,SA=A=g>>>0>(rA=g+(hA-i|0)|0)>>>0?A+1|0:A,tA=A=A-((rA>>>0<4293918720)-1|0)|0,i=(2097151&A)<<11|(yA=rA- -1048576|0)>>>21,A=(A>>21)+C|0,C=A=i>>>0>(eA=i+DA|0)>>>0?A+1|0:A,wA=A=A-((eA>>>0<4293918720)-1|0)|0,i=(2097151&A)<<11|(DA=eA- -1048576|0)>>>21,A=(A>>21)+_A|0,i=i>>>0>(nA=i+UA|0)>>>0?A+1|0:A,A=kA(uA,pA,470296,0),C=h+C|0,C=A>>>0>(g=A+eA|0)>>>0?C+1|0:C,eA=g-(A=-2097152&DA)|0,DA=C-((A>>>0>g>>>0)+wA|0)|0,g=kA(uA,pA,666643,0),A=h+(SA-(((C=-2097152&yA)>>>0>rA>>>0)+tA|0)|0)|0,g=(C=(A=g>>>0>(HA=g+(rA-C|0)|0)>>>0?A+1|0:A)>>21)+DA|0,A=(A=(g=(A=(2097151&A)<<11|HA>>>21)>>>0>(_A=A+eA|0)>>>0?g+1|0:g)>>21)+i|0,g=(g=(A=(g=(2097151&g)<<11|_A>>>21)>>>0>(tA=g+nA|0)>>>0?A+1|0:A)>>21)+YA|0,C=(A=(g=(A=(2097151&A)<<11|tA>>>21)>>>0>(i=A+LA|0)>>>0?g+1|0:g)>>21)+sA|0,A=(g=(C=(g=(2097151&g)<<11|i>>>21)>>>0>(wA=g+mA|0)>>>0?C+1|0:C)>>21)+XA|0,g=(C=(A=(C=(2097151&C)<<11|wA>>>21)>>>0>(nA=C+TA|0)>>>0?A+1|0:A)>>21)+NA|0,A=(A=(g=(A=(2097151&A)<<11|nA>>>21)>>>0>(rA=A+PA|0)>>>0?g+1|0:g)>>21)+ZA|0,g=(g=(A=(g=(2097151&g)<<11|rA>>>21)>>>0>(sA=g+RA|0)>>>0?A+1|0:A)>>21)+JA|0,C=(A=(g=(A=(2097151&A)<<11|sA>>>21)>>>0>(SA=A+OA|0)>>>0?g+1|0:g)>>21)+AI|0,A=(g=(C=(g=(2097151&g)<<11|SA>>>21)>>>0>(yA=g+QI|0)>>>0?C+1|0:C)>>21)+BI|0,DA=(GA=B-(g=-2097152&GA)|0)+((2097151&(A=(C=(2097151&C)<<11|yA>>>21)>>>0>(eA=C+CI|0)>>>0?A+1|0:A))<<11|eA>>>21)|0,A=(FA-((g>>>0>B>>>0)+xA|0)|0)+(A>>21)|0,GA=g=(A=DA>>>0<GA>>>0?A+1|0:A)>>21,HA=(A=kA(NA=(2097151&A)<<11|DA>>>21,g,666643,0))+(g=2097151&HA)|0,A=h,B=A=g>>>0>HA>>>0?A+1|0:A,E[0|Q]=HA,E[Q+1|0]=(255&A)<<24|HA>>>8,A=2097151&_A,g=kA(NA,GA,470296,0)+A|0,C=h,A=(B>>21)+(A>>>0>g>>>0?C+1|0:C)|0,A=(FA=(2097151&B)<<11|HA>>>21)>>>0>(_A=FA+g|0)>>>0?A+1|0:A,E[Q+4|0]=(2047&A)<<21|_A>>>11,g=A,C=_A,E[Q+3|0]=(7&A)<<29|C>>>3,E[Q+2|0]=31&((65535&B)<<16|HA>>>16)|C<<5,B=2097151&tA,tA=kA(NA,GA,654183,0)+B|0,A=h,_A=(2097151&g)<<11|C>>>21,g=(g>>21)+(B=B>>>0>tA>>>0?A+1|0:A)|0,A=g=(tA=_A+tA|0)>>>0<_A>>>0?g+1|0:g,E[Q+6|0]=(63&A)<<26|tA>>>6,B=tA,tA=0,E[Q+5|0]=tA<<13|(1572864&C)>>>19|B<<2,C=2097151&i,i=kA(NA,GA,-997805,-1)+C|0,g=h,g=C>>>0>i>>>0?g+1|0:g,tA=(2097151&(C=A))<<11|B>>>21,C=(A>>=21)+g|0,C=(i=tA+i|0)>>>0<tA>>>0?C+1|0:C,E[Q+9|0]=(511&C)<<23|i>>>9,E[Q+8|0]=(1&C)<<31|i>>>1,g=0,E[Q+7|0]=g<<18|(2080768&B)>>>14|i<<7,g=2097151&wA,B=kA(NA,GA,136657,0)+g|0,A=h,A=g>>>0>B>>>0?A+1|0:A,wA=(2097151&(g=C))<<11|i>>>21,g=A+(C=g>>21)|0,g=(B=wA+B|0)>>>0<wA>>>0?g+1|0:g,E[Q+12|0]=(4095&g)<<20|B>>>12,C=B,E[Q+11|0]=(15&g)<<28|C>>>4,B=0,E[Q+10|0]=B<<15|(1966080&i)>>>17|C<<4,B=2097151&nA,i=kA(NA,GA,-683901,-1)+B|0,A=h,A=B>>>0>i>>>0?A+1|0:A,B=g,g=A+(g>>=21)|0,g=(B=(nA=i)+(i=(2097151&B)<<11|C>>>21)|0)>>>0<i>>>0?g+1|0:g,E[Q+14|0]=(127&g)<<25|B>>>7,i=0,E[Q+13|0]=i<<12|(1048576&C)>>>20|B<<1,A=g>>21,C=(g=(2097151&g)<<11|B>>>21)>>>0>(i=g+(2097151&rA)|0)>>>0?A+1|0:A,E[Q+17|0]=(1023&C)<<22|i>>>10,E[Q+16|0]=(3&C)<<30|i>>>2,g=0,E[Q+15|0]=g<<17|(2064384&B)>>>15|i<<6,A=C>>21,A=(g=(2097151&C)<<11|i>>>21)>>>0>(C=g+(2097151&sA)|0)>>>0?A+1|0:A,E[Q+20|0]=(8191&A)<<19|C>>>13,E[Q+19|0]=(31&A)<<27|C>>>5,B=(g=2097151&SA)+(SA=(2097151&A)<<11|C>>>21)|0,g=A>>21,g=B>>>0<SA>>>0?g+1|0:g,SA=B,E[Q+21|0]=B,sA=0,E[Q+18|0]=sA<<14|(1835008&i)>>>18|C<<3,E[Q+22|0]=(255&g)<<24|B>>>8,C=g>>21,C=(B=(i=(2097151&g)<<11|B>>>21)+(2097151&yA)|0)>>>0<i>>>0?C+1|0:C,E[Q+25|0]=(2047&C)<<21|B>>>11,E[Q+24|0]=(7&C)<<29|B>>>3,E[Q+23|0]=31&((65535&g)<<16|SA>>>16)|B<<5,A=C>>21,A=(g=(2097151&C)<<11|B>>>21)>>>0>(C=g+(2097151&eA)|0)>>>0?A+1|0:A,E[Q+27|0]=(63&A)<<26|C>>>6,i=0,E[Q+26|0]=i<<13|(1572864&B)>>>19|C<<2,g=A>>21,g=(A=(B=(2097151&A)<<11|C>>>21)+(2097151&DA)|0)>>>0<B>>>0?g+1|0:g,E[Q+31|0]=(131071&g)<<15|A>>>17,E[Q+30|0]=(511&g)<<23|A>>>9,E[Q+29|0]=(1&g)<<31|A>>>1,B=0,E[Q+28|0]=B<<18|(2080768&C)>>>14|A<<7,iI(c,64),iI(f,64),I&&(o[I>>2]=64,o[I+4>>2]=0),w=e+560|0,0}function k(A,I,g,C){for(var B=0,Q=0,i=0,E=0,f=0,c=0,e=0,r=0,D=0,t=0,y=0,w=0,n=0,s=0,k=0,F=0,S=0,H=0,G=0,_=0,M=0,p=0,N=0,J=0,U=0,Y=0,d=0,K=0,b=0,P=0,v=0,L=0,R=0,u=0,x=0,m=0,l=0;i=(B=f<<3)+g|0,Q=a[0|(B=I+B|0)]|a[B+1|0]<<8|a[B+2|0]<<16|a[B+3|0]<<24,M=a[B+4|0]|a[B+5|0]<<8|a[B+6|0]<<16|a[B+7|0]<<24,c=Q<<24|(65280&Q)<<8,e=(E=16711680&Q)<<24,E=E>>>8|0,B=(D=-16777216&Q)>>>24|0,o[i>>2]=e|D<<8|-16777216&((255&M)<<24|Q>>>8)|16711680&((16777215&M)<<8|Q>>>24)|M>>>8&65280|M>>>24,Q=B|E|c,B=0,o[i+4>>2]=Q|B|B,16!=(0|(f=f+1|0)););for(I=o[A+4>>2],o[C>>2]=o[A>>2],o[C+4>>2]=I,I=o[A+60>>2],o[C+56>>2]=o[A+56>>2],o[C+60>>2]=I,I=o[A+52>>2],o[C+48>>2]=o[A+48>>2],o[C+52>>2]=I,I=o[A+44>>2],o[C+40>>2]=o[A+40>>2],o[C+44>>2]=I,I=o[A+36>>2],o[C+32>>2]=o[A+32>>2],o[C+36>>2]=I,I=o[A+28>>2],o[C+24>>2]=o[A+24>>2],o[C+28>>2]=I,I=o[A+20>>2],o[C+16>>2]=o[A+16>>2],o[C+20>>2]=I,I=o[A+12>>2],o[C+8>>2]=o[A+8>>2],o[C+12>>2]=I;i=o[C+56>>2],E=o[C+60>>2],B=o[(I=M=(p=l<<3)+g|0)>>2],I=o[I+4>>2],S=Q=o[C+36>>2],Q=DA(s=o[C+32>>2],Q,50),f=h,Q=DA(s,S,46)^Q,f^=h,Q=DA(s,S,23)^Q,I=(h^f)+I|0,I=(B=Q+B|0)>>>0<Q>>>0?I+1|0:I,B=(f=o[(Q=p+34368|0)>>2])+B|0,I=o[Q+4>>2]+I|0,I=B>>>0<f>>>0?I+1|0:I,Q=(f=((e=o[C+48>>2])^(t=o[C+40>>2]))&s^e)+B|0,B=(((k=o[C+52>>2])^(H=o[C+44>>2]))&S^k)+I|0,I=(Q>>>0<f>>>0?B+1|0:B)+E|0,I=(i=Q+i|0)>>>0<Q>>>0?I+1|0:I,f=(Q=o[C+24>>2])+i|0,B=o[C+28>>2]+I|0,y=B=Q>>>0>f>>>0?B+1|0:B,o[C+24>>2]=f,o[C+28>>2]=B,F=B=o[C+4>>2],B=DA(Q=o[C>>2],B,36),E=h,B=DA(Q,F,30)^B,E^=h,D=i+(DA(Q,F,25)^B)|0,B=I+(h^E)|0,B=i>>>0>D>>>0?B+1|0:B,c=(I=D)+(D=Q&((E=o[C+16>>2])|(i=o[C+8>>2]))|i&E)|0,I=(I=B)+(F&((B=o[C+20>>2])|(w=o[C+12>>2]))|B&w)|0,D=I=c>>>0<D>>>0?I+1|0:I,o[C+56>>2]=c,o[C+60>>2]=I,r=E,n=B,_=o[(I=v=(G=8|p)+g|0)>>2],J=o[I+4>>2],B=((S^H)&y^H)+k|0,B=(I=(E=(t^s)&f^t)+e|0)>>>0<E>>>0?B+1|0:B,E=DA(f,y,50),e=h,E=DA(f,y,46)^E,e^=h,E=(k=DA(f,y,23)^E)+I|0,I=(h^e)+B|0,I=(E>>>0<k>>>0?I+1|0:I)+J|0,I=(B=E+_|0)>>>0<E>>>0?I+1|0:I,E=(E=B)+(e=o[(B=G+34368|0)>>2])|0,B=o[B+4>>2]+I|0,B=(I=E>>>0<e>>>0?B+1|0:B)+n|0,k=B=(e=E+r|0)>>>0<E>>>0?B+1|0:B,o[C+16>>2]=e,o[C+20>>2]=B,I=I+((w|F)&D|w&F)|0,I=(B=E+((Q|i)&c|Q&i)|0)>>>0<E>>>0?I+1|0:I,E=DA(c,D,36),r=h,E=DA(c,D,30)^E,r^=h,n=B,B=DA(c,D,25)^E,I=(h^r)+I|0,r=I=B>>>0>(E=n+B|0)>>>0?I+1|0:I,o[C+48>>2]=E,o[C+52>>2]=I,n=i,G=w,I=(w=o[(B=d=(i=16|p)+g|0)>>2])+t|0,B=o[B+4>>2]+H|0,B=I>>>0<w>>>0?B+1|0:B,i=(t=I)+(w=o[(I=i+34368|0)>>2])|0,I=o[I+4>>2]+B|0,I=((y^S)&k^S)+(I=i>>>0<w>>>0?I+1|0:I)|0,I=(B=(B=i)+(i=(f^s)&e^s)|0)>>>0<i>>>0?I+1|0:I,i=DA(e,k,50),w=h,i=DA(e,k,46)^i,w^=h,i=(t=DA(e,k,23)^i)+B|0,B=(h^w)+I|0,B=(t=i>>>0<t>>>0?B+1|0:B)+G|0,G=B=(w=i)>>>0>(i=i+n|0)>>>0?B+1|0:B,o[C+8>>2]=i,o[C+12>>2]=B,I=DA(E,r,36),B=h,I=DA(E,r,30)^I,B^=h,H=DA(E,r,25)^I,I=((D|F)&r|D&F)+(h^B)|0,B=t+((n=H+((Q|c)&E|Q&c)|0)>>>0<H>>>0?I+1|0:I)|0,w=B=(t=w+n|0)>>>0<w>>>0?B+1|0:B,o[C+40>>2]=t,o[C+44>>2]=B,n=Q,B=(B=s)+(s=o[(I=L=(Q=24|p)+g|0)>>2])|0,I=o[I+4>>2]+S|0,I=B>>>0<s>>>0?I+1|0:I,Q=(H=B)+(s=o[(B=Q+34368|0)>>2])|0,B=o[B+4>>2]+I|0,B=(y^(y^k)&G)+(B=Q>>>0<s>>>0?B+1|0:B)|0,B=(I=(I=Q)+(Q=f^(f^e)&i)|0)>>>0<Q>>>0?B+1|0:B,Q=DA(i,G,50),s=h,Q=DA(i,G,46)^Q,s^=h,Q=(S=DA(i,G,23)^Q)+I|0,I=(h^s)+B|0,B=(I=Q>>>0<S>>>0?I+1|0:I)+F|0,S=B=(F=Q+n|0)>>>0<Q>>>0?B+1|0:B,o[C>>2]=F,o[C+4>>2]=B,B=DA(t,w,36),s=h,B=DA(t,w,30)^B,n=h^s,H=DA(t,w,25)^B,B=((D|r)&w|D&r)+(h^n)|0,I=I+((s=H+((E|c)&t|E&c)|0)>>>0<H>>>0?B+1|0:B)|0,s=I=(n=Q+s|0)>>>0<Q>>>0?I+1|0:I,o[C+32>>2]=n,o[C+36>>2]=I,Q=o[(B=P=(I=32|p)+g|0)>>2],B=y+o[B+4>>2]|0,B=(Q=Q+f|0)>>>0<f>>>0?B+1|0:B,Q=(f=o[(I=I+34368|0)>>2])+Q|0,I=o[I+4>>2]+B|0,I=(k^(k^G)&S)+(I=Q>>>0<f>>>0?I+1|0:I)|0,I=(B=(B=Q)+(Q=e^(i^e)&F)|0)>>>0<Q>>>0?I+1|0:I,Q=DA(F,S,50),f=h,Q=DA(F,S,46)^Q,f^=h,Q=(y=DA(F,S,23)^Q)+B|0,B=(h^f)+I|0,H=B=Q>>>0<y>>>0?B+1|0:B,I=B,B=DA(n,s,36),f=h,B=DA(n,s,30)^B,y=h^f,_=DA(n,s,25)^B,B=((r|w)&s|r&w)+(h^y)|0,I=((f=_+((E|t)&n|E&t)|0)>>>0<_>>>0?B+1|0:B)+I|0,f=I=(y=Q+f|0)>>>0<f>>>0?I+1|0:I,o[C+24>>2]=y,o[C+28>>2]=I,B=D+H|0,H=B=(D=Q+c|0)>>>0<Q>>>0?B+1|0:B,o[C+56>>2]=D,o[C+60>>2]=B,Q=o[(I=K=(B=40|p)+g|0)>>2],I=k+o[I+4>>2]|0,I=(Q=Q+e|0)>>>0<e>>>0?I+1|0:I,Q=(c=o[(B=B+34368|0)>>2])+Q|0,B=o[B+4>>2]+I|0,B=(G^(S^G)&H)+(B=Q>>>0<c>>>0?B+1|0:B)|0,B=(I=(I=Q)+(Q=i^(i^F)&D)|0)>>>0<Q>>>0?B+1|0:B,Q=DA(D,H,50),c=h,Q=DA(D,H,46)^Q,c^=h,Q=(e=DA(D,H,23)^Q)+I|0,I=(h^c)+B|0,I=Q>>>0<e>>>0?I+1|0:I,B=DA(y,f,36),c=h,B=DA(y,f,30)^B,e=h^c,k=DA(y,f,25)^B,B=((w|s)&f|w&s)+(h^e)|0,B=((c=k+((t|n)&y|t&n)|0)>>>0<k>>>0?B+1|0:B)+I|0,c=B=(e=Q+c|0)>>>0<c>>>0?B+1|0:B,o[C+16>>2]=e,o[C+20>>2]=B,I=I+r|0,_=I=(r=Q+E|0)>>>0<E>>>0?I+1|0:I,o[C+48>>2]=r,o[C+52>>2]=I,Q=o[(B=Y=(I=48|p)+g|0)>>2],B=G+o[B+4>>2]|0,B=(Q=Q+i|0)>>>0<i>>>0?B+1|0:B,Q=(i=o[(I=I+34368|0)>>2])+Q|0,I=o[I+4>>2]+B|0,I=(S^(S^H)&_)+(I=Q>>>0<i>>>0?I+1|0:I)|0,I=(B=(B=Q)+(Q=F^(D^F)&r)|0)>>>0<Q>>>0?I+1|0:I,Q=DA(r,_,50),i=h,Q=DA(r,_,46)^Q,i^=h,Q=(E=DA(r,_,23)^Q)+B|0,B=(h^i)+I|0,E=B=Q>>>0<E>>>0?B+1|0:B,I=B,B=DA(e,c,36),i=h,B=DA(e,c,30)^B,k=h^i,G=DA(e,c,25)^B,B=((f|s)&c|f&s)+(h^k)|0,I=((i=G+((y|n)&e|y&n)|0)>>>0<G>>>0?B+1|0:B)+I|0,k=I=(B=i)>>>0>(i=Q+i|0)>>>0?I+1|0:I,o[C+8>>2]=i,o[C+12>>2]=I,B=E+w|0,G=B=(J=Q+t|0)>>>0<Q>>>0?B+1|0:B,o[C+40>>2]=J,o[C+44>>2]=B,Q=o[(I=b=(B=56|p)+g|0)>>2],I=S+o[I+4>>2]|0,I=(Q=Q+F|0)>>>0<F>>>0?I+1|0:I,Q=(E=o[(B=B+34368|0)>>2])+Q|0,B=o[B+4>>2]+I|0,B=(H^(H^_)&G)+(B=Q>>>0<E>>>0?B+1|0:B)|0,B=(I=(I=Q)+(Q=D^(D^r)&J)|0)>>>0<Q>>>0?B+1|0:B,Q=DA(J,G,50),E=h,Q=DA(J,G,46)^Q,E^=h,Q=(w=DA(J,G,23)^Q)+I|0,I=(h^E)+B|0,I=Q>>>0<w>>>0?I+1|0:I,B=DA(i,k,36),E=h,B=DA(i,k,30)^B,w=h^E,t=DA(i,k,25)^B,B=((f|c)&k|f&c)+(h^w)|0,B=((E=t+((e|y)&i|e&y)|0)>>>0<t>>>0?B+1|0:B)+I|0,w=B=(w=E)>>>0>(E=Q+E|0)>>>0?B+1|0:B,o[C>>2]=E,o[C+4>>2]=B,I=I+s|0,S=I=(t=Q+n|0)>>>0<Q>>>0?I+1|0:I,o[C+32>>2]=t,o[C+36>>2]=I,Q=o[(B=R=(I=64|p)+g|0)>>2],B=H+o[B+4>>2]|0,B=(Q=Q+D|0)>>>0<D>>>0?B+1|0:B,Q=(D=o[(I=I+34368|0)>>2])+Q|0,I=o[I+4>>2]+B|0,I=(_^(G^_)&S)+(I=Q>>>0<D>>>0?I+1|0:I)|0,I=(B=(B=Q)+(Q=r^(r^J)&t)|0)>>>0<Q>>>0?I+1|0:I,Q=DA(t,S,50),D=h,Q=DA(t,S,46)^Q,D^=h,Q=(F=DA(t,S,23)^Q)+B|0,B=(h^D)+I|0,s=B=Q>>>0<F>>>0?B+1|0:B,I=B,B=DA(E,w,36),D=h,B=DA(E,w,30)^B,F=h^D,n=DA(E,w,25)^B,B=((c|k)&w|c&k)+(h^F)|0,I=((D=n+((i|e)&E|i&e)|0)>>>0<n>>>0?B+1|0:B)+I|0,D=I=(F=Q+D|0)>>>0<D>>>0?I+1|0:I,o[C+56>>2]=F,o[C+60>>2]=I,B=f+s|0,H=B=(f=Q+y|0)>>>0<Q>>>0?B+1|0:B,o[C+24>>2]=f,o[C+28>>2]=B,Q=o[(I=U=(B=72|p)+g|0)>>2],I=_+o[I+4>>2]|0,I=(Q=Q+r|0)>>>0<r>>>0?I+1|0:I,Q=(r=o[(B=B+34368|0)>>2])+Q|0,B=o[B+4>>2]+I|0,B=(G^(S^G)&H)+(B=Q>>>0<r>>>0?B+1|0:B)|0,B=(I=(I=Q)+(Q=J^(t^J)&f)|0)>>>0<Q>>>0?B+1|0:B,Q=DA(f,H,50),r=h,Q=DA(f,H,46)^Q,r^=h,Q=(s=DA(f,H,23)^Q)+I|0,I=(h^r)+B|0,I=Q>>>0<s>>>0?I+1|0:I,B=DA(F,D,36),r=h,B=DA(F,D,30)^B,s=h^r,n=DA(F,D,25)^B,B=((w|k)&D|w&k)+(h^s)|0,B=((r=n+((i|E)&F|i&E)|0)>>>0<n>>>0?B+1|0:B)+I|0,r=B=(s=Q+r|0)>>>0<r>>>0?B+1|0:B,o[C+48>>2]=s,o[C+52>>2]=B,I=I+c|0,_=I=(c=Q+e|0)>>>0<Q>>>0?I+1|0:I,o[C+16>>2]=c,o[C+20>>2]=I,I=(I=J)+(e=o[(B=J=(Q=80|p)+g|0)>>2])|0,B=o[B+4>>2]+G|0,B=I>>>0<e>>>0?B+1|0:B,Q=(y=I)+(e=o[(I=Q+34368|0)>>2])|0,I=o[I+4>>2]+B|0,I=(S^(S^H)&_)+(I=Q>>>0<e>>>0?I+1|0:I)|0,I=(B=(B=Q)+(Q=t^(f^t)&c)|0)>>>0<Q>>>0?I+1|0:I,Q=DA(c,_,50),e=h,Q=DA(c,_,46)^Q,e^=h,Q=(n=DA(c,_,23)^Q)+B|0,B=(h^e)+I|0,y=B=Q>>>0<n>>>0?B+1|0:B,I=B,B=DA(s,r,36),e=h,B=DA(s,r,30)^B,n=h^e,G=DA(s,r,25)^B,B=((D|w)&r|D&w)+(h^n)|0,I=((e=G+((E|F)&s|E&F)|0)>>>0<G>>>0?B+1|0:B)+I|0,e=I=(n=Q+e|0)>>>0<e>>>0?I+1|0:I,o[C+40>>2]=n,o[C+44>>2]=I,B=y+k|0,k=B=(y=Q+i|0)>>>0<i>>>0?B+1|0:B,o[C+8>>2]=y,o[C+12>>2]=B,B=34368+(I=88|p)|0,i=o[(I=N=I+g|0)>>2],Q=o[B>>2]+i|0,I=o[B+4>>2]+o[I+4>>2]|0,B=S+(Q>>>0<i>>>0?I+1|0:I)|0,B=(H^(H^_)&k)+(B=(I=Q+t|0)>>>0<t>>>0?B+1|0:B)|0,B=(I=(Q=f^(f^c)&y)+I|0)>>>0<Q>>>0?B+1|0:B,Q=DA(y,k,50),i=h,Q=DA(y,k,46)^Q,i^=h,Q=(t=DA(y,k,23)^Q)+I|0,I=(h^i)+B|0,I=Q>>>0<t>>>0?I+1|0:I,B=DA(n,e,36),i=h,B=DA(n,e,30)^B,t=h^i,G=DA(n,e,25)^B,B=((D|r)&e|D&r)+(h^t)|0,B=((i=G+((s|F)&n|s&F)|0)>>>0<G>>>0?B+1|0:B)+I|0,t=B=(t=i)>>>0>(i=Q+i|0)>>>0?B+1|0:B,o[C+32>>2]=i,o[C+36>>2]=B,I=I+w|0,w=I=(B=E)>>>0>(E=Q+E|0)>>>0?I+1|0:I,o[C>>2]=E,o[C+4>>2]=I,B=34368+(I=96|p)|0,G=o[(I=u=I+g|0)>>2],Q=o[B>>2]+G|0,B=o[B+4>>2]+o[I+4>>2]|0,I=H+(Q>>>0<G>>>0?B+1|0:B)|0,I=(B=Q+f|0)>>>0<f>>>0?I+1|0:I,Q=(f=c^(c^y)&E)+B|0,B=(_^(k^_)&w)+I|0,B=Q>>>0<f>>>0?B+1|0:B,I=DA(E,w,50),f=h,I=DA(E,w,46)^I,f^=h,H=Q,Q=DA(E,w,23)^I,B=(h^f)+B|0,S=B=(I=H+Q|0)>>>0<Q>>>0?B+1|0:B,Q=I,I=DA(i,t,36),f=h,I=DA(i,t,30)^I,G=h^f,H=DA(i,t,25)^I,I=((e|r)&t|e&r)+(h^G)|0,B=((f=H+((s|n)&i|s&n)|0)>>>0<H>>>0?I+1|0:I)+B|0,f=B=(G=Q+f|0)>>>0<f>>>0?B+1|0:B,o[C+24>>2]=G,o[C+28>>2]=B,B=D+S|0,D=B=(F=Q+F|0)>>>0<Q>>>0?B+1|0:B,o[C+56>>2]=F,o[C+60>>2]=B,B=34368+(I=104|p)|0,S=o[(I=m=I+g|0)>>2],Q=o[B>>2]+S|0,I=o[B+4>>2]+o[I+4>>2]|0,B=_+(Q>>>0<S>>>0?I+1|0:I)|0,B=(I=Q+c|0)>>>0<c>>>0?B+1|0:B,Q=(c=y^(E^y)&F)+I|0,I=(k^(w^k)&D)+B|0,I=Q>>>0<c>>>0?I+1|0:I,B=DA(F,D,50),c=h,B=DA(F,D,46)^B,c^=h,S=DA(F,D,23)^B,B=(h^c)+I|0,H=B=(Q=S+Q|0)>>>0<S>>>0?B+1|0:B,I=B,B=DA(G,f,36),c=h,B=DA(G,f,30)^B,S=h^c,_=DA(G,f,25)^B,B=((e|t)&f|e&t)+(h^S)|0,I=((c=_+((i|n)&G|i&n)|0)>>>0<_>>>0?B+1|0:B)+I|0,c=I=(S=Q+c|0)>>>0<c>>>0?I+1|0:I,o[C+16>>2]=S,o[C+20>>2]=I,I=r+H|0,r=I=(s=Q+s|0)>>>0<Q>>>0?I+1|0:I,o[C+48>>2]=s,o[C+52>>2]=I,B=34368+(I=112|p)|0,H=o[(Q=_=I+g|0)>>2],I=o[B>>2]+H|0,B=o[B+4>>2]+o[Q+4>>2]|0,B=k+(I>>>0<H>>>0?B+1|0:B)|0,B=(w^(D^w)&r)+(B=(I=I+y|0)>>>0<y>>>0?B+1|0:B)|0,B=(I=(Q=E^(E^F)&s)+I|0)>>>0<Q>>>0?B+1|0:B,Q=DA(s,r,50),y=h,Q=DA(s,r,46)^Q,y^=h,Q=(k=DA(s,r,23)^Q)+I|0,I=(h^y)+B|0,H=I=Q>>>0<k>>>0?I+1|0:I,B=I,I=DA(S,c,36),y=h,I=DA(S,c,30)^I,k=h^y,x=DA(S,c,25)^I,I=((f|t)&c|f&t)+(h^k)|0,B=((y=x+((i|G)&S|i&G)|0)>>>0<x>>>0?I+1|0:I)+B|0,y=B=(k=Q+y|0)>>>0<y>>>0?B+1|0:B,o[C+8>>2]=k,o[C+12>>2]=B,B=e+H|0,Q=B=(e=Q+n|0)>>>0<Q>>>0?B+1|0:B,o[C+40>>2]=e,o[C+44>>2]=B,B=34368+(I=120|p)|0,p=o[(I=n=I+g|0)>>2],H=o[B>>2]+p|0,B=o[B+4>>2]+o[I+4>>2]|0,I=w+(H>>>0<p>>>0?B+1|0:B)|0,I=(D^(D^r)&Q)+(I=(B=E+H|0)>>>0<E>>>0?I+1|0:I)|0,I=(B=(E=F^(s^F)&e)+B|0)>>>0<E>>>0?I+1|0:I,E=DA(e,Q,50),D=h,E=DA(e,Q,46)^E,D^=h,Q=(E=DA(e,Q,23)^E)+B|0,B=(h^D)+I|0,B=Q>>>0<E>>>0?B+1|0:B,E=Q,D=B,I=B,B=DA(k,y,36),e=h,B=DA(k,y,30)^B,r=h^e,w=DA(k,y,25)^B,B=((f|c)&y|f&c)+(h^r)|0,I=((e=w+((S|G)&k|S&G)|0)>>>0<w>>>0?B+1|0:B)+I|0,I=(Q=Q+e|0)>>>0<e>>>0?I+1|0:I,o[C>>2]=Q,o[C+4>>2]=I,B=D+t|0,B=(r=i)>>>0>(i=i+E|0)>>>0?B+1|0:B,o[C+32>>2]=i,o[C+36>>2]=B,64!=(0|l);)c=((l=l+16|0)<<3)+g|0,E=o[M>>2],f=o[M+4>>2],x=o[U>>2],D=I=o[U+4>>2],B=I,Q=I=o[_+4>>2],I=DA(G=o[_>>2],I,45),i=h,r=((63&Q)<<26|G>>>6)^(I=DA(G,Q,3)^I),I=(Q>>>6^(e=h^i))+B|0,B=((i=r+x|0)>>>0<r>>>0?I+1|0:I)+f|0,B=(I=i+E|0)>>>0<i>>>0?B+1|0:B,E=i=o[v+4>>2],i=DA(f=o[v>>2],i,63),e=h,i=((127&E)<<25|f>>>7)^DA(f,E,56)^i,B=(h^e^E>>>7)+B|0,i=B=i>>>0>(S=i+I|0)>>>0?B+1|0:B,o[c>>2]=S,o[c+4>>2]=B,f=(_=o[J>>2])+f|0,I=(c=o[J+4>>2])+E|0,B=f>>>0<_>>>0?I+1|0:I,E=I=o[n+4>>2],I=DA(H=o[n>>2],I,45),e=h,r=f,f=((63&E)<<26|H>>>6)^DA(H,E,3)^I,B=(h^e^E>>>6)+B|0,f=f>>>0>(r=r+f|0)>>>0?B+1|0:B,B=DA(e=o[d>>2],I=o[d+4>>2],63),w=h,y=r,r=((127&I)<<25|e>>>7)^DA(e,I,56)^B,B=(h^w^I>>>7)+f|0,f=B=r>>>0>(k=y+r|0)>>>0?B+1|0:B,o[M+136>>2]=k,o[M+140>>2]=B,B=(J=o[N>>2])+e|0,I=(e=o[N+4>>2])+I|0,r=DA(S,i,45),w=h,r=(t=((63&i)<<26|S>>>6)^DA(S,i,3)^r)+B|0,B=(h^w^i>>>6)+(B>>>0<J>>>0?I+1|0:I)|0,B=r>>>0<t>>>0?B+1|0:B,w=I=o[L+4>>2],I=DA(t=o[L>>2],I,63),F=h,y=r,r=((127&w)<<25|t>>>7)^DA(t,w,56)^I,B=(h^F^w>>>7)+B|0,r=B=r>>>0>(p=y+r|0)>>>0?B+1|0:B,o[M+144>>2]=p,o[M+148>>2]=B,t=(v=o[u>>2])+t|0,I=(I=w)+(w=o[u+4>>2])|0,B=t>>>0<v>>>0?I+1|0:I,I=DA(k,f,45),F=h,s=((63&f)<<26|k>>>6)^DA(k,f,3)^I,B=(h^F^f>>>6)+B|0,B=(t=s+t|0)>>>0<s>>>0?B+1|0:B,F=I=o[P+4>>2],I=DA(s=o[P>>2],I,63),n=h,y=t,t=((127&F)<<25|s>>>7)^DA(s,F,56)^I,B=(h^n^F>>>7)+B|0,t=B=t>>>0>(d=y+t|0)>>>0?B+1|0:B,o[M+152>>2]=d,o[M+156>>2]=B,I=(L=o[m>>2])+s|0,B=(B=F)+(F=o[m+4>>2])|0,s=DA(p,r,45),n=h,s=((63&r)<<26|p>>>6)^DA(p,r,3)^s,B=(h^n^r>>>6)+(I>>>0<L>>>0?B+1|0:B)|0,s=(y=s+I|0)>>>0<s>>>0?B+1|0:B,B=DA(n=o[K>>2],I=o[K+4>>2],63),P=h,N=y,y=((127&I)<<25|n>>>7)^(B=DA(n,I,56)^B),B=(I>>>7^(K=h^P))+s|0,s=B=y>>>0>(P=N+y|0)>>>0?B+1|0:B,o[M+160>>2]=P,o[M+164>>2]=B,I=I+Q|0,I=(B=n+G|0)>>>0<n>>>0?I+1|0:I,n=DA(d,t,45),y=h,n=(K=((63&t)<<26|d>>>6)^DA(d,t,3)^n)+B|0,B=(h^y^t>>>6)+I|0,B=n>>>0<K>>>0?B+1|0:B,y=o[Y>>2],Y=I=o[Y+4>>2],I=DA(y,I,63),K=h,I=DA(y,Y,56)^I,N=n,B=(Y>>>7^(U=h^K))+B|0,n=B=(n=((127&Y)<<25|y>>>7)^I)>>>0>(K=N+n|0)>>>0?B+1|0:B,o[M+168>>2]=K,o[M+172>>2]=B,I=E+Y|0,I=(B=y+H|0)>>>0<y>>>0?I+1|0:I,N=y=o[b+4>>2],y=DA(U=o[b>>2],y,63),Y=h,y=(b=((127&N)<<25|U>>>7)^DA(U,N,56)^y)+B|0,B=(h^Y^N>>>7)+I|0,I=y>>>0<b>>>0?B+1|0:B,B=DA(P,s,45),Y=h,B=DA(P,s,3)^B,b=h^Y,Y=y,I=(s>>>6^b)+I|0,y=I=(y=((63&s)<<26|P>>>6)^B)>>>0>(Y=Y+y|0)>>>0?I+1|0:I,o[M+176>>2]=Y,o[M+180>>2]=I,u=o[R>>2],R=I=o[R+4>>2],b=I,I=DA(x,D,63),B=h,m=((127&D)<<25|x>>>7)^DA(x,D,56)^I,I=(h^B^D>>>7)+f|0,B=((k=m+k|0)>>>0<m>>>0?I+1|0:I)+b|0,B=(I=k+u|0)>>>0<k>>>0?B+1|0:B,f=DA(Y,y,45),k=h,b=(f=((63&y)<<26|Y>>>6)^DA(Y,y,3)^f)+I|0,I=(h^k^y>>>6)+B|0,f=I=f>>>0>b>>>0?I+1|0:I,o[M+192>>2]=b,o[M+196>>2]=I,B=i+N|0,B=(I=S+U|0)>>>0<U>>>0?B+1|0:B,k=DA(u,R,63),U=h,N=((127&R)<<25|u>>>7)^DA(u,R,56)^k,B=(h^U^R>>>7)+B|0,I=(k=N+I|0)>>>0<N>>>0?B+1|0:B,B=DA(K,n,45),U=h,B=DA(K,n,3)^B,R=k,I=(n>>>6^(N=h^U))+I|0,k=I=(k=((63&n)<<26|K>>>6)^B)>>>0>(U=R+k|0)>>>0?I+1|0:I,o[M+184>>2]=U,o[M+188>>2]=I,I=DA(J,e,63),B=h,I=((127&e)<<25|J>>>7)^DA(J,e,56)^I,B=(h^B^e>>>7)+c|0,I=t+(I>>>0>(N=I+_|0)>>>0?B+1|0:B)|0,I=(B=d+N|0)>>>0<d>>>0?I+1|0:I,t=DA(b,f,45),d=h,t=DA(b,f,3)^t,N=h^d,d=(t^=(63&f)<<26|b>>>6)+B|0,B=(f>>>6^N)+I|0,t=B=t>>>0>d>>>0?B+1|0:B,o[M+208>>2]=d,o[M+212>>2]=B,I=DA(_,c,63),B=h,N=DA(_,c,56)^I,B=((I=c>>>7|0)^h^B)+D|0,I=r+((c=(_=N^((127&c)<<25|_>>>7))+x|0)>>>0<_>>>0?B+1|0:B)|0,I=(B=c+p|0)>>>0<p>>>0?I+1|0:I,D=DA(U,k,45),c=h,r=(D=((63&k)<<26|U>>>6)^DA(U,k,3)^D)+B|0,B=(h^c^k>>>6)+I|0,D=B=D>>>0>r>>>0?B+1|0:B,o[M+200>>2]=r,o[M+204>>2]=B,I=DA(L,F,63),B=h,_=((127&F)<<25|L>>>7)^DA(L,F,56)^I,I=(h^B^F>>>7)+w|0,B=n+((c=_+v|0)>>>0<_>>>0?I+1|0:I)|0,B=(I=c+K|0)>>>0<K>>>0?B+1|0:B,c=DA(d,t,45),n=h,_=I,I=t>>>6|0,c=((63&t)<<26|d>>>6)^DA(d,t,3)^c,B=(I^h^n)+B|0,c=B=c>>>0>(t=_+c|0)>>>0?B+1|0:B,o[M+224>>2]=t,o[M+228>>2]=B,I=DA(v,w,63),B=h,I=DA(v,w,56)^I,n=h^B,_=((127&w)<<25|v>>>7)^I,I=((B=w>>>7|0)^n)+e|0,B=s+((w=_+J|0)>>>0<_>>>0?I+1|0:I)|0,B=(I=w+P|0)>>>0<P>>>0?B+1|0:B,e=DA(r,D,45),w=h,n=I,I=D>>>6|0,D=((63&D)<<26|r>>>6)^DA(r,D,3)^e,I=(I^h^w)+B|0,D=I=(e=n+D|0)>>>0<D>>>0?I+1|0:I,o[M+216>>2]=e,o[M+220>>2]=I,I=DA(H,E,63),B=h,w=((127&E)<<25|H>>>7)^DA(H,E,56)^I,B=(h^B^E>>>7)+Q|0,B=k+((I=w+G|0)>>>0<w>>>0?B+1|0:B)|0,I=(r=I+U|0)>>>0<U>>>0?B+1|0:B,B=DA(t,c,45),w=h,n=r,r=DA(t,c,3)^B,B=c>>>6|0,c=n+(r^=(63&c)<<26|t>>>6)|0,I=(B^h^w)+I|0,o[M+240>>2]=c,o[M+244>>2]=c>>>0<r>>>0?I+1|0:I,I=DA(G,Q,63),B=h,I=DA(G,Q,56)^I,c=h^B,B=((B=Q>>>7|0)^c)+F|0,I=y+((I^=(127&Q)<<25|G>>>7)>>>0>(Q=I+L|0)>>>0?B+1|0:B)|0,I=(B=Q+Y|0)>>>0<Y>>>0?I+1|0:I,Q=DA(e,D,45),c=h,r=B,B=D>>>6|0,Q=((63&D)<<26|e>>>6)^DA(e,D,3)^Q,B=(B^h^c)+I|0,Q=B=Q>>>0>(D=r+Q|0)>>>0?B+1|0:B,o[M+232>>2]=D,o[M+236>>2]=B,I=DA(S,i,63),B=h,r=DA(S,i,56)^I,B=((I=i>>>7|0)^h^B)+E|0,I=f+((i=(c=r^((127&i)<<25|S>>>7))+H|0)>>>0<c>>>0?B+1|0:B)|0,I=(B=i+b|0)>>>0<b>>>0?I+1|0:I,i=DA(D,Q,45),E=h,r=B,B=Q>>>6|0,Q=r+(i=((63&Q)<<26|D>>>6)^DA(D,Q,3)^i)|0,B=(B^h^E)+I|0,o[M+248>>2]=Q,o[M+252>>2]=Q>>>0<i>>>0?B+1|0:B;I=I+o[A+4>>2]|0,I=(g=Q+o[A>>2]|0)>>>0<Q>>>0?I+1|0:I,o[A>>2]=g,o[A+4>>2]=I,B=o[A+12>>2]+o[C+12>>2]|0,I=(g=o[C+8>>2])+o[A+8>>2]|0,o[A+8>>2]=I,o[A+12>>2]=I>>>0<g>>>0?B+1|0:B,B=o[A+20>>2]+o[C+20>>2]|0,I=(g=o[C+16>>2])+o[A+16>>2]|0,o[A+16>>2]=I,o[A+20>>2]=I>>>0<g>>>0?B+1|0:B,I=o[A+28>>2]+o[C+28>>2]|0,g=(B=o[C+24>>2])+o[A+24>>2]|0,o[A+24>>2]=g,o[A+28>>2]=g>>>0<B>>>0?I+1|0:I,B=o[A+36>>2]+o[C+36>>2]|0,I=(g=o[C+32>>2])+o[A+32>>2]|0,o[A+32>>2]=I,o[A+36>>2]=I>>>0<g>>>0?B+1|0:B,I=o[A+44>>2]+o[C+44>>2]|0,g=(B=o[C+40>>2])+o[A+40>>2]|0,o[A+40>>2]=g,o[A+44>>2]=g>>>0<B>>>0?I+1|0:I,B=o[A+52>>2]+o[C+52>>2]|0,I=(g=o[C+48>>2])+o[A+48>>2]|0,o[A+48>>2]=I,o[A+52>>2]=I>>>0<g>>>0?B+1|0:B,B=o[A+60>>2]+o[C+60>>2]|0,I=(g=o[C+56>>2])+o[A+56>>2]|0,o[A+56>>2]=I,o[A+60>>2]=I>>>0<g>>>0?B+1|0:B}function F(A){var I,g,C,B,Q,i,o,f,c,e,r=0,D=0,t=0,y=0,w=0,n=0,s=0,k=0,F=0,S=0,H=0,G=0,_=0,M=0,p=0,N=0,J=0,U=0,Y=0,d=0,K=0,b=0,P=0,v=0,L=0,R=0,u=0,x=0,m=0,l=0,z=0,q=0,X=0,j=0,T=0,O=0,V=0,Z=0;y=(G=a[A+44|0]|a[A+45|0]<<8|a[A+46|0]<<16|a[A+47|0]<<24)>>>5&2097151,t=kA(b=(a[A+60|0]|a[A+61|0]<<8|a[A+62|0]<<16|a[A+63|0]<<24)>>>3|0,0,-683901,-1),D=(r=a[A+44|0])<<16&2031616|a[A+42|0]|a[A+43|0]<<8,r=h,k=r=D>>>0>(F=t+D|0)>>>0?r+1|0:r,N=r=r-((F>>>0<4293918720)-1|0)|0,t=r>>21,r=(D=y)+(y=(2097151&r)<<11|(n=F- -1048576|0)>>>21)|0,D=t,l=D=r>>>0<y>>>0?D+1|0:D,z=r,Y=kA(r,D,-683901,-1),S=h,s=kA(I=(a[A+49|0]|a[A+50|0]<<8|a[A+51|0]<<16|a[A+52|0]<<24)>>>7&2097151,0,-997805,-1),t=(r=a[A+27|0])>>>24|0,y=r<<8|(_=a[A+23|0]|a[A+24|0]<<8|a[A+25|0]<<16|a[A+26|0]<<24)>>>24,D=(r=a[A+28|0])>>>16|0,D=2097151&((3&(D|=t))<<30|(r=y|r<<16)>>>2),r=h,r=D>>>0>(t=D+s|0)>>>0?r+1|0:r,D=kA(u=(M=a[A+52|0]|a[A+53|0]<<8|a[A+54|0]<<16|a[A+55|0]<<24)>>>4&2097151,0,654183,0),r=h+r|0,s=t=D+t|0,t=D>>>0>t>>>0?r+1|0:r,w=(D=a[A+48|0])<<8|G>>>24,D=r=D>>>24|0,r=kA(g=2097151&((3&(G=(r=(y=a[A+49|0])>>>16|0)|D))<<30|(D=(y<<=16)|w)>>>2),0,136657,0),t=h+t|0,t=r>>>0>(D=r+s|0)>>>0?t+1|0:t,y=(r=kA(C=(a[A+57|0]|a[A+58|0]<<8|a[A+59|0]<<16|a[A+60|0]<<24)>>>6&2097151,0,666643,0))+D|0,D=h+t|0,s=y,t=r>>>0>y>>>0?D+1|0:D,D=(r=a[A+56|0])>>>24|0,w=r<<8|M>>>24,D=kA(B=2097151&((1&(M=(r=(y=a[A+57|0])>>>16|0)|D))<<31|(D=(y<<=16)|w)>>>1),0,470296,0),r=h+t|0,D=(r=(t=y=D+s|0)>>>0<D>>>0?r+1|0:r)+S|0,D=t>>>0>(y=t+Y|0)>>>0?D+1|0:D,J=t- -1048576|0,U=t=r-((t>>>0<4293918720)-1|0)|0,S=y-(r=-2097152&J)|0,Y=D-((r>>>0>y>>>0)+t|0)|0,D=kA(I,0,654183,0),r=h,r=D>>>0>(t=D+(_>>>5&2097151)|0)>>>0?r+1|0:r,y=(D=t)+(t=kA(u,0,470296,0))|0,D=h+r|0,D=t>>>0>y>>>0?D+1|0:D,r=kA(g,X,-997805,-1),D=h+D|0,D=r>>>0>(t=r+y|0)>>>0?D+1|0:D,y=(r=t)+(t=kA(B,j,666643,0))|0,r=h+D|0,w=y,y=t>>>0>y>>>0?r+1|0:r,s=(t=kA(I,0,470296,0))+(r=(r=a[A+23|0])<<16&2031616|a[A+21|0]|a[A+22|0]<<8)|0,t=h,t=r>>>0>s>>>0?t+1|0:t,s=(D=kA(u,0,666643,0))+s|0,r=h+t|0,t=kA(g,X,654183,0),D=h+(D>>>0>s>>>0?r+1|0:r)|0,M=D=t>>>0>(_=t+s|0)>>>0?D+1|0:D,R=D=D-((_>>>0<4293918720)-1|0)|0,r=(r=D>>>21|0)+y|0,t=r=(D=(2097151&D)<<11|(s=_- -1048576|0)>>>21)>>>0>(w=D+w|0)>>>0?r+1|0:r,H=D=r-((w>>>0<4293918720)-1|0)|0,r=S,S=(2097151&D)<<11|(y=w- -1048576|0)>>>21,D=(D>>21)+Y|0,G=S=(D=S>>>0>(p=r+S|0)>>>0?D+1|0:D)-((p>>>0<4293918720)-1|0)|0,x=p-(r=-2097152&(Y=p- -1048576|0))|0,T=D-((r>>>0>p>>>0)+S|0)|0,r=kA(z,l,136657,0),t=h+t|0,t=r>>>0>(D=r+w|0)>>>0?t+1|0:t,K=D-(r=-2097152&y)|0,m=t-((r>>>0>D>>>0)+H|0)|0,p=F-(r=-2097152&n)|0,N=k-((r>>>0>F>>>0)+N|0)|0,k=kA(b,0,136657,0),D=(r=a[A+40|0])>>>24|0,y=r<<8|(n=a[A+36|0]|a[A+37|0]<<8|a[A+38|0]<<16|a[A+39|0]<<24)>>>24,t=(r=a[A+41|0])>>>16|0,D=(t|=D)>>>3|0,t=(7&t)<<29|(r=y|r<<16)>>>3,r=D+h|0,r=t>>>0>(y=t+k|0)>>>0?r+1|0:r,D=kA(C,0,-683901,-1),r=h+r|0,r=D>>>0>(t=D+y|0)>>>0?r+1|0:r,w=t,D=kA(b,0,-997805,-1),t=h,t=D>>>0>(y=D+(n>>>6&2097151)|0)>>>0?t+1|0:t,n=(D=y)+(y=kA(C,0,136657,0))|0,D=h+t|0,t=kA(B,j,-683901,-1),D=h+(y>>>0>n>>>0?D+1|0:D)|0,S=D=t>>>0>(P=t+n|0)>>>0?D+1|0:D,O=t=D-((P>>>0<4293918720)-1|0)|0,r=r+(D=t>>21)|0,n=r=(t=(2097151&t)<<11|(F=P- -1048576|0)>>>21)>>>0>(H=t+w|0)>>>0?r+1|0:r,v=r=r-((H>>>0<4293918720)-1|0)|0,D=(D=r>>21)+N|0,q=D=(r=(t=(2097151&r)<<11|(w=H- -1048576|0)>>>21)+p|0)>>>0<t>>>0?D+1|0:D,L=r,D=kA(r,D,-683901,-1),r=h+m|0,d=t=D+K|0,y=D>>>0>t>>>0?r+1|0:r,m=_-(r=-2097152&s)|0,N=M-((4095&R)+(r>>>0>_>>>0)|0)|0,_=kA(I,0,666643,0),r=(D=a[A+19|0])>>>24|0,s=D<<8|(M=a[A+15|0]|a[A+16|0]<<8|a[A+17|0]<<16|a[A+18|0]<<24)>>>24,t=r,D=(7&(t|=D=(r=a[A+20|0])>>>16|0))<<29|(D=(r<<=16)|s)>>>3,t=h+(t>>>3|0)|0,t=D>>>0>(s=D+_|0)>>>0?t+1|0:t,r=kA(g,X,470296,0),D=h+t|0,r=r>>>0>(s=r+s|0)>>>0?D+1|0:D,t=kA(g,X,666643,0),D=h,_=D=t>>>0>(K=t+(M>>>6&2097151)|0)>>>0?D+1|0:D,V=t=D-((K>>>0<4293918720)-1|0)|0,r=r+(D=t>>>21|0)|0,M=r=(t=(2097151&t)<<11|(k=K- -1048576|0)>>>21)>>>0>(p=t+s|0)>>>0?r+1|0:r,Z=r=r-((p>>>0<4293918720)-1|0)|0,D=(D=r>>>21|0)+N|0,D=(r=(2097151&r)<<11|(s=p- -1048576|0)>>>21)>>>0>(t=r+m|0)>>>0?D+1|0:D,N=(r=t)+(t=kA(z,l,-997805,-1))|0,r=h+D|0,r=t>>>0>N>>>0?r+1|0:r,R=D=H-(t=-2097152&w)|0,Q=w=n-((t>>>0>H>>>0)+v|0)|0,t=kA(L,q,136657,0),r=h+r|0,r=t>>>0>(n=t+N|0)>>>0?r+1|0:r,t=kA(D,w,-683901,-1),D=h+r|0,n=D=t>>>0>(N=t+n|0)>>>0?D+1|0:D,v=r=D-((N>>>0<4293918720)-1|0)|0,D=(2097151&r)<<11|(w=N- -1048576|0)>>>21,r=(r>>21)+y|0,d=D=(r=D>>>0>(H=D+d|0)>>>0?r+1|0:r)-((H>>>0<4293918720)-1|0)|0,m=(2097151&D)<<11|(y=H- -1048576|0)>>>21,D=(D>>21)+T|0,o=x=m+x|0,m=x>>>0<m>>>0?D+1|0:D,f=H-(D=-2097152&y)|0,c=r-((D>>>0>H>>>0)+d|0)|0,x=N-(r=-2097152&w)|0,T=n-((r>>>0>N>>>0)+v|0)|0,t=(r=kA(z,l,654183,0))+(p-(D=-2097152&s)|0)|0,D=h+(M-((2147483647&Z)+(D>>>0>p>>>0)|0)|0)|0,D=r>>>0>t>>>0?D+1|0:D,r=kA(L,q,-997805,-1),D=h+D|0,D=r>>>0>(t=r+t|0)>>>0?D+1|0:D,y=(r=t)+(t=kA(R,Q,136657,0))|0,r=h+D|0,d=y,n=t>>>0>y>>>0?r+1|0:r,p=P-(r=-2097152&F)|0,H=S-((r>>>0>P>>>0)+O|0)|0,M=kA(u,0,-683901,-1),r=(D=a[A+35|0])>>>24|0,y=D<<8|(s=a[A+31|0]|a[A+32|0]<<8|a[A+33|0]<<16|a[A+34|0]<<24)>>>24,t=r,D=(r=a[A+36|0])>>>16|0,D|=t,t=h,t=(r=2097151&((1&D)<<31|(r=r<<16|y)>>>1))>>>0>(D=r+M|0)>>>0?t+1|0:t,y=(r=kA(b,0,654183,0))+D|0,D=h+t|0,D=r>>>0>y>>>0?D+1|0:D,t=kA(C,0,-997805,-1),r=h+D|0,r=t>>>0>(y=t+y|0)>>>0?r+1|0:r,D=kA(B,j,136657,0),r=h+r|0,w=t=D+y|0,y=D>>>0>t>>>0?r+1|0:r,r=kA(I,0,-683901,-1),D=h,D=r>>>0>(t=r+(s>>>4&2097151)|0)>>>0?D+1|0:D,s=(r=kA(u,0,136657,0))+t|0,t=h+D|0,t=r>>>0>s>>>0?t+1|0:t,r=kA(b,0,470296,0),D=h+t|0,D=r>>>0>(s=r+s|0)>>>0?D+1|0:D,s=(t=kA(C,0,654183,0))+s|0,r=h+D|0,D=kA(B,j,-997805,-1),r=h+(t>>>0>s>>>0?r+1|0:r)|0,M=r=D>>>0>(S=D+s|0)>>>0?r+1|0:r,e=D=r-((S>>>0<4293918720)-1|0)|0,t=(r=D>>21)+y|0,N=D=(t=(D=(2097151&D)<<11|(s=S- -1048576|0)>>>21)>>>0>(F=D+w|0)>>>0?t+1|0:t)-((F>>>0<4293918720)-1|0)|0,r=(r=D>>21)+H|0,v=r=(D=(y=(2097151&D)<<11|(w=F- -1048576|0)>>>21)+p|0)>>>0<y>>>0?r+1|0:r,y=d,d=D,r=kA(D,r,-683901,-1),D=h+n|0,H=y=y+r|0,y=r>>>0>y>>>0?D+1|0:D,n=(r=kA(z,l,470296,0))+(K-(D=-2097152&k)|0)|0,D=h+(_-((2047&V)+(D>>>0>K>>>0)|0)|0)|0,D=r>>>0>n>>>0?D+1|0:D,k=(r=n)+(n=kA(L,q,654183,0))|0,r=h+D|0,r=n>>>0>k>>>0?r+1|0:r,n=kA(R,Q,-997805,-1),D=h+r|0,D=n>>>0>(k=n+k|0)>>>0?D+1|0:D,P=w=F-(r=-2097152&w)|0,i=n=t-((r>>>0>F>>>0)+N|0)|0,t=kA(d,v,136657,0),r=h+D|0,r=t>>>0>(k=t+k|0)>>>0?r+1|0:r,t=kA(w,n,-683901,-1),D=h+r|0,n=D=t>>>0>(_=t+k|0)>>>0?D+1|0:D,N=r=D-((_>>>0<4293918720)-1|0)|0,D=(2097151&r)<<11|(w=_- -1048576|0)>>>21,r=(r>>21)+y|0,H=D=(r=D>>>0>(k=D+H|0)>>>0?r+1|0:r)-((k>>>0<4293918720)-1|0)|0,F=(2097151&D)<<11|(y=k- -1048576|0)>>>21,D=(D>>21)+T|0,O=p=F+x|0,p=F>>>0>p>>>0?D+1|0:D,V=k-(D=-2097152&y)|0,Z=r-((D>>>0>k>>>0)+H|0)|0,x=_-(r=-2097152&w)|0,T=n-((r>>>0>_>>>0)+N|0)|0,n=kA(z,l,666643,0),r=(D=a[A+14|0])>>>24|0,y=D<<8|(N=a[A+10|0]|a[A+11|0]<<8|a[A+12|0]<<16|a[A+13|0]<<24)>>>24,t=r,D=(r=a[A+15|0])>>>16|0,D|=t,t=h,t=(r=2097151&((1&D)<<31|(r=r<<16|y)>>>1))>>>0>(D=r+n|0)>>>0?t+1|0:t,y=(r=D)+(D=kA(L,q,470296,0))|0,r=h+t|0,r=D>>>0>y>>>0?r+1|0:r,D=kA(R,Q,654183,0),r=h+r|0,r=D>>>0>(t=D+y|0)>>>0?r+1|0:r,y=(D=t)+(t=kA(d,v,-997805,-1))|0,D=h+r|0,D=t>>>0>y>>>0?D+1|0:D,r=kA(P,i,136657,0),D=h+D|0,_=t=r+y|0,y=r>>>0>t>>>0?D+1|0:D,s=S-(r=-2097152&s)|0,n=M-((r>>>0>S>>>0)+e|0)|0,t=kA(I,0,136657,0),r=h,r=(D=(a[A+28|0]|a[A+29|0]<<8|a[A+30|0]<<16|a[A+31|0]<<24)>>>7&2097151)>>>0>(t=D+t|0)>>>0?r+1|0:r,w=(D=t)+(t=kA(u,0,-997805,-1))|0,D=h+r|0,D=t>>>0>w>>>0?D+1|0:D,r=kA(g,X,-683901,-1),D=h+D|0,D=r>>>0>(t=r+w|0)>>>0?D+1|0:D,w=(r=kA(b,0,666643,0))+t|0,t=h+D|0,t=r>>>0>w>>>0?t+1|0:t,D=kA(C,0,470296,0),r=h+t|0,r=D>>>0>(w=D+w|0)>>>0?r+1|0:r,D=kA(B,j,654183,0),r=h+r|0,D=(U>>21)+(D>>>0>(t=D+w|0)>>>0?r+1|0:r)|0,F=D=(w=(2097151&U)<<11|J>>>21)>>>0>(J=w+t|0)>>>0?D+1|0:D,H=r=D-((J>>>0<4293918720)-1|0)|0,w=(2097151&r)<<11|(k=J- -1048576|0)>>>21,r=(r>>21)+n|0,K=r=(D=w+s|0)>>>0<w>>>0?r+1|0:r,U=D,D=kA(D,r,-683901,-1),r=h+y|0,w=t=D+_|0,y=D>>>0>t>>>0?r+1|0:r,r=kA(L,q,666643,0),D=h,D=r>>>0>(t=r+(N>>>4&2097151)|0)>>>0?D+1|0:D,r=kA(R,Q,470296,0),D=h+D|0,D=r>>>0>(t=r+t|0)>>>0?D+1|0:D,n=(r=kA(d,v,654183,0))+t|0,t=h+D|0,t=r>>>0>n>>>0?t+1|0:t,D=kA(P,i,-997805,-1),r=h+t|0,r=D>>>0>(n=D+n|0)>>>0?r+1|0:r,D=kA(U,K,136657,0),r=h+r|0,M=r=D>>>0>(S=D+n|0)>>>0?r+1|0:r,l=D=r-((S>>>0<4293918720)-1|0)|0,r=w,w=(2097151&D)<<11|(s=S- -1048576|0)>>>21,D=(D>>21)+y|0,L=y=(D=(t=r+w|0)>>>0<w>>>0?D+1|0:D)-((t>>>0<4293918720)-1|0)|0,r=(r=y>>21)+T|0,z=w=(y=(2097151&y)<<11|(n=t- -1048576|0)>>>21)+x|0,_=y>>>0>w>>>0?r+1|0:r,w=t,t=D,y=(J-(D=-2097152&k)|0)+(k=(2097151&G)<<11|Y>>>21)|0,D=(F-((D>>>0>J>>>0)+H|0)|0)+(G>>21)|0,N=D=y>>>0<k>>>0?D+1|0:D,u=D=D-((y>>>0<4293918720)-1|0)|0,Y=r=D>>21,r=kA(b=(2097151&D)<<11|(H=y- -1048576|0)>>>21,r,-683901,-1),t=h+t|0,t=r>>>0>(D=r+w|0)>>>0?t+1|0:t,X=D-(r=-2097152&n)|0,j=t-((r>>>0>D>>>0)+L|0)|0,r=kA(b,Y,136657,0),D=M+h|0,q=(t=r+S|0)-(r=-2097152&s)|0,L=(D=t>>>0<S>>>0?D+1|0:D)-((r>>>0>t>>>0)+l|0)|0,D=kA(R,Q,666643,0),t=h,t=(r=(a[A+7|0]|a[A+8|0]<<8|a[A+9|0]<<16|a[A+10|0]<<24)>>>7&2097151)>>>0>(D=r+D|0)>>>0?t+1|0:t,w=(r=kA(d,v,470296,0))+D|0,D=h+t|0,D=r>>>0>w>>>0?D+1|0:D,r=kA(P,i,654183,0),D=h+D|0,D=r>>>0>(t=r+w|0)>>>0?D+1|0:D,w=(r=t)+(t=kA(U,K,-997805,-1))|0,r=h+D|0,k=w,w=t>>>0>w>>>0?r+1|0:r,M=kA(d,v,666643,0),r=(D=a[A+6|0])>>>24|0,n=D<<8|(J=a[A+2|0]|a[A+3|0]<<8|a[A+4|0]<<16|a[A+5|0]<<24)>>>24,t=r,D=(r=a[A+7|0])>>>16|0,D=2097151&((3&(D|=t))<<30|(r=r<<16|n)>>>2),r=h,r=D>>>0>(t=D+M|0)>>>0?r+1|0:r,n=(D=kA(P,i,470296,0))+t|0,t=h+r|0,t=D>>>0>n>>>0?t+1|0:t,D=kA(U,K,654183,0),r=h+t|0,M=r=D>>>0>(F=D+n|0)>>>0?r+1|0:r,G=r=r-((F>>>0<4293918720)-1|0)|0,D=(t=r>>21)+w|0,S=r=(D=(r=(2097151&r)<<11|(s=F- -1048576|0)>>>21)>>>0>(n=r+k|0)>>>0?D+1|0:D)-((n>>>0<4293918720)-1|0)|0,k=(2097151&r)<<11|(w=n- -1048576|0)>>>21,r=(r>>21)+L|0,L=d=k+q|0,k=k>>>0>d>>>0?r+1|0:r,r=kA(b,Y,-997805,-1),D=h+D|0,D=r>>>0>(t=r+n|0)>>>0?D+1|0:D,R=t-(r=-2097152&w)|0,v=D-((r>>>0>t>>>0)+S|0)|0,D=kA(b,Y,654183,0),r=M+h|0,d=(t=D+F|0)-(D=-2097152&s)|0,G=(r=t>>>0<F>>>0?r+1|0:r)-((D>>>0>t>>>0)+G|0)|0,r=kA(P,i,666643,0),D=h,D=r>>>0>(t=r+(J>>>5&2097151)|0)>>>0?D+1|0:D,r=kA(U,K,470296,0),D=h+D|0,n=t=r+t|0,t=r>>>0>t>>>0?D+1|0:D,w=kA(U,K,666643,0),D=(r=a[A+2|0])<<16&2031616|a[0|A]|a[A+1|0]<<8,r=h,M=r=D>>>0>(S=w+D|0)>>>0?r+1|0:r,K=r=r-((S>>>0<4293918720)-1|0)|0,w=(2097151&r)<<11|(s=S- -1048576|0)>>>21,r=(r>>21)+t|0,t=r=w>>>0>(F=w+n|0)>>>0?r+1|0:r,J=r=r-((F>>>0<4293918720)-1|0)|0,w=(2097151&r)<<11|(n=F- -1048576|0)>>>21,r=(r>>21)+G|0,w=w>>>0>(G=U=w+d|0)>>>0?r+1|0:r,r=kA(b,Y,470296,0),t=t+h|0,t=(D=r+F|0)>>>0<F>>>0?t+1|0:t,F=D-(r=-2097152&n)|0,n=t-((r>>>0>D>>>0)+J|0)|0,D=kA(b,Y,666643,0),r=h+(M-(((t=-2097152&s)>>>0>S>>>0)+K|0)|0)|0,D=(t=(r=D>>>0>(U=D+(S-t|0)|0)>>>0?r+1|0:r)>>21)+n|0,r=(r=(D=(r=(2097151&r)<<11|U>>>21)>>>0>(J=r+F|0)>>>0?D+1|0:D)>>21)+w|0,D=(D=(r=(D=(2097151&D)<<11|J>>>21)>>>0>(G=D+G|0)>>>0?r+1|0:r)>>21)+v|0,t=(r=(D=(r=(2097151&r)<<11|G>>>21)>>>0>(w=r+R|0)>>>0?D+1|0:D)>>21)+k|0,r=(D=(t=(D=(2097151&D)<<11|w>>>21)>>>0>(Y=D+L|0)>>>0?t+1|0:t)>>21)+j|0,D=(t=(r=(t=(2097151&t)<<11|Y>>>21)>>>0>(S=t+X|0)>>>0?r+1|0:r)>>21)+_|0,r=(r=(D=(r=(2097151&r)<<11|S>>>21)>>>0>(F=r+z|0)>>>0?D+1|0:D)>>21)+Z|0,D=(D=(r=(D=(2097151&D)<<11|F>>>21)>>>0>(_=D+V|0)>>>0?r+1|0:r)>>21)+p|0,t=(r=(D=(r=(2097151&r)<<11|_>>>21)>>>0>(k=r+O|0)>>>0?D+1|0:D)>>21)+c|0,r=(D=(t=(D=(2097151&D)<<11|k>>>21)>>>0>(M=D+f|0)>>>0?t+1|0:t)>>21)+m|0,n=(H=y-(D=-2097152&H)|0)+((2097151&(r=(t=(2097151&t)<<11|M>>>21)>>>0>(s=t+o|0)>>>0?r+1|0:r))<<11|s>>>21)|0,r=(N-((D>>>0>y>>>0)+u|0)|0)+(r>>21)|0,H=D=(r=n>>>0<H>>>0?r+1|0:r)>>21,U=(r=kA(p=(2097151&r)<<11|n>>>21,D,666643,0))+(D=2097151&U)|0,r=h,y=r=D>>>0>U>>>0?r+1|0:r,E[0|A]=U,E[A+1|0]=(255&r)<<24|U>>>8,r=2097151&J,D=kA(p,H,470296,0)+r|0,t=h,r=(y>>21)+(r>>>0>D>>>0?t+1|0:t)|0,r=(N=(2097151&y)<<11|U>>>21)>>>0>(J=N+D|0)>>>0?r+1|0:r,E[A+4|0]=(2047&r)<<21|J>>>11,D=r,t=J,E[A+3|0]=(7&r)<<29|t>>>3,E[A+2|0]=31&((65535&y)<<16|U>>>16)|t<<5,y=2097151&G,G=kA(p,H,654183,0)+y|0,r=h,J=(2097151&D)<<11|t>>>21,D=(D>>21)+(y=y>>>0>G>>>0?r+1|0:r)|0,r=D=(G=J+G|0)>>>0<J>>>0?D+1|0:D,E[A+6|0]=(63&r)<<26|G>>>6,y=G,G=0,E[A+5|0]=G<<13|(1572864&t)>>>19|y<<2,t=2097151&w,w=kA(p,H,-997805,-1)+t|0,D=h,D=t>>>0>w>>>0?D+1|0:D,G=(2097151&(t=r))<<11|y>>>21,t=(r>>=21)+D|0,t=(w=G+w|0)>>>0<G>>>0?t+1|0:t,E[A+9|0]=(511&t)<<23|w>>>9,E[A+8|0]=(1&t)<<31|w>>>1,D=0,E[A+7|0]=D<<18|(2080768&y)>>>14|w<<7,D=2097151&Y,y=kA(p,H,136657,0)+D|0,r=h,r=D>>>0>y>>>0?r+1|0:r,Y=(2097151&(D=t))<<11|w>>>21,D=r+(t=D>>21)|0,D=(y=Y+y|0)>>>0<Y>>>0?D+1|0:D,E[A+12|0]=(4095&D)<<20|y>>>12,t=y,E[A+11|0]=(15&D)<<28|t>>>4,y=0,E[A+10|0]=y<<15|(1966080&w)>>>17|t<<4,y=2097151&S,w=kA(p,H,-683901,-1)+y|0,r=h,r=y>>>0>w>>>0?r+1|0:r,y=D,D=r+(D>>=21)|0,D=(y=(d=w)+(w=(2097151&y)<<11|t>>>21)|0)>>>0<w>>>0?D+1|0:D,E[A+14|0]=(127&D)<<25|y>>>7,w=0,E[A+13|0]=w<<12|(1048576&t)>>>20|y<<1,r=D>>21,t=(D=(2097151&D)<<11|y>>>21)>>>0>(w=D+(2097151&F)|0)>>>0?r+1|0:r,E[A+17|0]=(1023&t)<<22|w>>>10,E[A+16|0]=(3&t)<<30|w>>>2,D=0,E[A+15|0]=D<<17|(2064384&y)>>>15|w<<6,r=t>>21,r=(D=(2097151&t)<<11|w>>>21)>>>0>(t=D+(2097151&_)|0)>>>0?r+1|0:r,E[A+20|0]=(8191&r)<<19|t>>>13,E[A+19|0]=(31&r)<<27|t>>>5,y=(D=2097151&k)+(k=(2097151&r)<<11|t>>>21)|0,D=r>>21,D=y>>>0<k>>>0?D+1|0:D,k=y,E[A+21|0]=y,_=0,E[A+18|0]=_<<14|(1835008&w)>>>18|t<<3,E[A+22|0]=(255&D)<<24|y>>>8,t=D>>21,t=(y=(w=(2097151&D)<<11|y>>>21)+(2097151&M)|0)>>>0<w>>>0?t+1|0:t,E[A+25|0]=(2047&t)<<21|y>>>11,E[A+24|0]=(7&t)<<29|y>>>3,E[A+23|0]=31&((65535&D)<<16|k>>>16)|y<<5,r=t>>21,r=(D=(2097151&t)<<11|y>>>21)>>>0>(t=D+(2097151&s)|0)>>>0?r+1|0:r,E[A+27|0]=(63&r)<<26|t>>>6,w=0,E[A+26|0]=w<<13|(1572864&y)>>>19|t<<2,D=r>>21,D=(r=(y=(2097151&r)<<11|t>>>21)+(2097151&n)|0)>>>0<y>>>0?D+1|0:D,E[A+31|0]=(131071&D)<<15|r>>>17,E[A+30|0]=(511&D)<<23|r>>>9,E[A+29|0]=(1&D)<<31|r>>>1,y=0,E[A+28|0]=y<<18|(2080768&t)>>>14|r<<7}function S(A,I,g,C,B,Q){var i,f=0,e=0,r=0,D=0,t=0,y=0,h=0,n=0,s=0,k=0,S=0,_=0,M=0,p=0,J=0,Y=0,d=0,K=0,L=0,u=0,x=0,m=0,l=0,z=0,q=0,X=0,j=0,T=0,O=0,V=0,Z=0,$=0,AA=0,IA=0,gA=0,CA=0,BA=0,QA=0;for(w=i=w-592|0,p=-1,S=A+32|0,k=32,_=1;J=a[2672+(t=k-1|0)|0],r=(t=((e=a[t+S|0])^J)-1>>8&_)&(y=a[S+(k=k-2|0)|0])-(D=a[k+2672|0])>>8|255&(e-J>>>8&_|r),_=t&(D^y)-1>>8,k;);if(255&r&&!(rA(A)|!(((127&(-1^a[B+31|0])|a[B+1|0]&a[B+2|0]&a[B+3|0]&a[B+4|0]&a[B+5|0]&a[B+6|0]&a[B+7|0]&a[B+8|0]&a[B+9|0]&a[B+10|0]&a[B+11|0]&a[B+12|0]&a[B+13|0]&a[B+14|0]&a[B+15|0]&a[B+16|0]&a[B+17|0]&a[B+18|0]&a[B+19|0]&a[B+20|0]&a[B+21|0]&a[B+22|0]&a[B+23|0]&a[B+24|0]&a[B+25|0]&a[B+26|0]&a[B+27|0]&a[B+28|0]&a[B+30|0]&a[B+29|0]^255)-1&236-a[0|B]^-1)>>>8&1)||rA(B)||U(t=i+128|0,B))){for(cA(e=i+384|0),Q&&R(e,35136,34,0),R(e,A,32,0),R(e,B,32,0),R(e,I,g,C),N(e,g=i+320|0),F(g),C=i+8|0,B=0,I=0,w=f=w-2272|0;e=g+(B>>>3|0)|0,E[(Q=f+2016|0)+B|0]=a[0|e]>>>(6&B)&1,E[(r=Q)+(Q=1|B)|0]=a[0|e]>>>(7&Q)&1,256!=(0|(B=B+2|0)););for(;;){I=(g=I)+1|0;A:if(!(g>>>0>254)&&a[0|(r=(B=f+2016|0)+g|0)]){I:if(B=E[0|(D=I+B|0)])if((0|(B=(e=B<<1)+(Q=E[0|r])|0))<=15)E[0|r]=B,E[0|D]=0;else{if((0|(B=Q-e|0))<-15)break A;for(E[0|r]=B,B=I;;){if(!a[0|(Q=(f+2016|0)+B|0)]){E[0|Q]=1;break I}if(E[0|Q]=0,Q=B>>>0<255,B=B+1|0,!Q)break}}if(!(g>>>0>253)){I:if(Q=E[0|(y=(B=g+2|0)+(f+2016|0)|0)])if((0|(Q=(D=Q<<2)+(e=E[0|r])|0))>=16){if((0|(Q=e-D|0))<-15)break A;for(E[0|r]=Q;;){if(a[0|(Q=(f+2016|0)+B|0)]){if(E[0|Q]=0,Q=B>>>0<255,B=B+1|0,Q)continue;break I}break}E[0|Q]=1}else E[0|r]=Q,E[0|y]=0;if(!(g>>>0>252)){I:if(Q=E[0|(y=(B=g+3|0)+(f+2016|0)|0)])if((0|(Q=(D=Q<<3)+(e=E[0|r])|0))>=16){if((0|(Q=e-D|0))<-15)break A;for(E[0|r]=Q;;){if(a[0|(Q=(f+2016|0)+B|0)]){if(E[0|Q]=0,Q=B>>>0<255,B=B+1|0,Q)continue;break I}break}E[0|Q]=1}else E[0|r]=Q,E[0|y]=0;if(!(g>>>0>251)){I:if(Q=E[0|(y=(B=g+4|0)+(f+2016|0)|0)])if((0|(Q=(D=Q<<4)+(e=E[0|r])|0))>=16){if((0|(Q=e-D|0))<-15)break A;for(E[0|r]=Q;;){if(a[0|(Q=(f+2016|0)+B|0)]){if(E[0|Q]=0,Q=B>>>0<255,B=B+1|0,Q)continue;break I}break}E[0|Q]=1}else E[0|r]=Q,E[0|y]=0;if(!(g>>>0>250)){I:if(Q=E[0|(y=(B=g+5|0)+(f+2016|0)|0)])if((0|(Q=(D=Q<<5)+(e=E[0|r])|0))>=16){if((0|(Q=e-D|0))<-15)break A;for(E[0|r]=Q;;){if(a[0|(Q=(f+2016|0)+B|0)]){if(E[0|Q]=0,Q=B>>>0<255,B=B+1|0,Q)continue;break I}break}E[0|Q]=1}else E[0|r]=Q,E[0|y]=0;if(!(g>>>0>249)&&(g=E[0|(D=(B=g+6|0)+(f+2016|0)|0)]))if((0|(g=(e=g<<6)+(Q=E[0|r])|0))>=16){if((0|(g=Q-e|0))<-15)break A;for(E[0|r]=g;;){if(a[0|(g=(f+2016|0)+B|0)]){if(E[0|g]=0,g=B>>>0<255,B=B+1|0,g)continue;break A}break}E[0|g]=1}else E[0|r]=g,E[0|D]=0}}}}}if(256==(0|I))break}for(B=0;g=S+(B>>>3|0)|0,E[(I=f+1760|0)+B|0]=a[0|g]>>>(6&B)&1,E[(Q=I)+(I=1|B)|0]=a[0|g]>>>(7&I)&1,256!=(0|(B=B+2|0)););for(I=0;;){I=(g=I)+1|0;A:if(!(g>>>0>254)&&a[0|(r=(B=f+1760|0)+g|0)]){I:if(B=E[0|(D=I+B|0)])if((0|(B=(e=B<<1)+(Q=E[0|r])|0))<=15)E[0|r]=B,E[0|D]=0;else{if((0|(B=Q-e|0))<-15)break A;for(E[0|r]=B,B=I;;){if(!a[0|(Q=(f+1760|0)+B|0)]){E[0|Q]=1;break I}if(E[0|Q]=0,Q=B>>>0<255,B=B+1|0,!Q)break}}if(!(g>>>0>253)){I:if(Q=E[0|(y=(B=g+2|0)+(f+1760|0)|0)])if((0|(Q=(D=Q<<2)+(e=E[0|r])|0))>=16){if((0|(Q=e-D|0))<-15)break A;for(E[0|r]=Q;;){if(a[0|(Q=(f+1760|0)+B|0)]){if(E[0|Q]=0,Q=B>>>0<255,B=B+1|0,Q)continue;break I}break}E[0|Q]=1}else E[0|r]=Q,E[0|y]=0;if(!(g>>>0>252)){I:if(Q=E[0|(y=(B=g+3|0)+(f+1760|0)|0)])if((0|(Q=(D=Q<<3)+(e=E[0|r])|0))>=16){if((0|(Q=e-D|0))<-15)break A;for(E[0|r]=Q;;){if(a[0|(Q=(f+1760|0)+B|0)]){if(E[0|Q]=0,Q=B>>>0<255,B=B+1|0,Q)continue;break I}break}E[0|Q]=1}else E[0|r]=Q,E[0|y]=0;if(!(g>>>0>251)){I:if(Q=E[0|(y=(B=g+4|0)+(f+1760|0)|0)])if((0|(Q=(D=Q<<4)+(e=E[0|r])|0))>=16){if((0|(Q=e-D|0))<-15)break A;for(E[0|r]=Q;;){if(a[0|(Q=(f+1760|0)+B|0)]){if(E[0|Q]=0,Q=B>>>0<255,B=B+1|0,Q)continue;break I}break}E[0|Q]=1}else E[0|r]=Q,E[0|y]=0;if(!(g>>>0>250)){I:if(Q=E[0|(y=(B=g+5|0)+(f+1760|0)|0)])if((0|(Q=(D=Q<<5)+(e=E[0|r])|0))>=16){if((0|(Q=e-D|0))<-15)break A;for(E[0|r]=Q;;){if(a[0|(Q=(f+1760|0)+B|0)]){if(E[0|Q]=0,Q=B>>>0<255,B=B+1|0,Q)continue;break I}break}E[0|Q]=1}else E[0|r]=Q,E[0|y]=0;if(!(g>>>0>249)&&(g=E[0|(D=(B=g+6|0)+(f+1760|0)|0)]))if((0|(g=(e=g<<6)+(Q=E[0|r])|0))>=16){if((0|(g=Q-e|0))<-15)break A;for(E[0|r]=g;;){if(a[0|(g=(f+1760|0)+B|0)]){if(E[0|g]=0,g=B>>>0<255,B=B+1|0,g)continue;break A}break}E[0|g]=1}else E[0|r]=g,E[0|D]=0}}}}}if(256==(0|I))break}for(W(B=f+480|0,t),I=o[t+36>>2],o[f+192>>2]=o[t+32>>2],o[f+196>>2]=I,I=o[t+28>>2],o[f+184>>2]=o[t+24>>2],o[f+188>>2]=I,I=o[t+20>>2],o[f+176>>2]=o[t+16>>2],o[f+180>>2]=I,I=o[t+12>>2],o[f+168>>2]=o[t+8>>2],o[f+172>>2]=I,I=o[t+4>>2],o[f+160>>2]=o[t>>2],o[f+164>>2]=I,I=o[t+52>>2],o[f+208>>2]=o[t+48>>2],o[f+212>>2]=I,I=o[t+60>>2],o[f+216>>2]=o[t+56>>2],o[f+220>>2]=I,I=o[4+(g=t- -64|0)>>2],o[f+224>>2]=o[g>>2],o[f+228>>2]=I,I=o[t+76>>2],o[f+232>>2]=o[t+72>>2],o[f+236>>2]=I,I=o[t+44>>2],o[f+200>>2]=o[t+40>>2],o[f+204>>2]=I,I=o[t+92>>2],o[f+248>>2]=o[t+88>>2],o[f+252>>2]=I,I=o[t+100>>2],o[f+256>>2]=o[t+96>>2],o[f+260>>2]=I,I=o[t+108>>2],o[f+264>>2]=o[t+104>>2],o[f+268>>2]=I,I=o[t+116>>2],o[f+272>>2]=o[t+112>>2],o[f+276>>2]=I,I=o[t+84>>2],o[f+240>>2]=o[t+80>>2],o[f+244>>2]=I,G(Q=f+320|0,g=f+160|0),H(f,Q,h=f+440|0),H(f+40|0,n=f+360|0,s=f+400|0),H(f+80|0,s,h),H(f+120|0,Q,n),b(Q,f,B),H(g,Q,h),H(Y=f+200|0,n,s),H(d=f+240|0,s,h),H(M=f+280|0,Q,n),W(I=f+640|0,g),b(Q,f,I),H(g,Q,h),H(Y,n,s),H(d,s,h),H(M,Q,n),W(I=f+800|0,g),b(Q,f,I),H(g,Q,h),H(Y,n,s),H(d,s,h),H(M,Q,n),W(I=f+960|0,g),b(Q,f,I),H(g,Q,h),H(Y,n,s),H(d,s,h),H(M,Q,n),W(I=f+1120|0,g),b(Q,f,I),H(g,Q,h),H(Y,n,s),H(d,s,h),H(M,Q,n),W(I=f+1280|0,g),b(Q,f,I),H(g,Q,h),H(Y,n,s),H(d,s,h),H(M,Q,n),W(I=f+1440|0,g),b(Q,f,I),H(g,Q,h),H(Y,n,s),H(d,s,h),H(M,Q,n),W(f+1600|0,g),o[C+32>>2]=0,o[C+36>>2]=0,o[C+24>>2]=0,o[C+28>>2]=0,o[C+16>>2]=0,o[C+20>>2]=0,o[C+8>>2]=0,o[C+12>>2]=0,o[C>>2]=0,o[C+4>>2]=0,o[C+44>>2]=0,o[C+48>>2]=0,o[(j=C+40|0)>>2]=1,o[C+52>>2]=0,o[C+56>>2]=0,o[C+60>>2]=0,o[C+64>>2]=0,o[C+68>>2]=0,o[C+72>>2]=0,o[C+84>>2]=0,o[C+88>>2]=0,o[C+76>>2]=0,o[C+80>>2]=1,o[C+92>>2]=0,o[C+96>>2]=0,o[C+100>>2]=0,o[C+104>>2]=0,o[C+108>>2]=0,o[C+112>>2]=0,o[C+116>>2]=0,IA=C+80|0,I=255;;){A:{I:{if(!a[(g=f+2016|0)+I|0]&&!a[(B=f+1760|0)+I|0]){if(!(a[(Q=g)+(g=I-1|0)|0]|a[g+B|0]))break I;I=g}if((0|I)<0)break A;for(;G(B=f+320|0,C),(0|(Q=E[(g=I)+(f+2016|0)|0]))>0?(H(I=f+160|0,B,h),H(Y,n,s),H(d,s,h),H(M,B,n),b(B,I,(f+480|0)+c((254&Q)>>>1|0,160)|0)):(0|Q)>=0||(H(I=f+160|0,B=f+320|0,h),H(Y,n,s),H(d,s,h),H(M,B,n),P(B,I,(f+480|0)+c((0-Q&254)>>>1|0,160)|0)),(0|(q=E[g+(f+1760|0)|0]))>0?(H(I=f+160|0,B=f+320|0,h),H(Y,n,s),H(d,s,h),H(M,B,n),v(B,I,c((254&q)>>>1|0,120)+1488|0)):(0|q)>=0||(H(f+160|0,X=f+320|0,h),H(Y,n,s),H(d,s,h),H(M,X,n),K=o[f+160>>2],L=o[f+200>>2],u=o[f+164>>2],x=o[f+204>>2],m=o[f+168>>2],l=o[f+208>>2],z=o[f+172>>2],k=o[f+212>>2],S=o[f+176>>2],_=o[f+216>>2],p=o[f+180>>2],J=o[f+220>>2],r=o[f+184>>2],y=o[f+224>>2],D=o[f+188>>2],e=o[f+228>>2],t=o[f+192>>2],Q=o[f+232>>2],B=o[f+236>>2],I=o[f+196>>2],o[f+396>>2]=B-I,o[f+392>>2]=Q-t,o[f+388>>2]=e-D,o[f+384>>2]=y-r,o[f+380>>2]=J-p,o[f+376>>2]=_-S,o[f+372>>2]=k-z,o[f+368>>2]=l-m,o[f+364>>2]=x-u,o[f+360>>2]=L-K,o[f+356>>2]=I+B,o[f+352>>2]=Q+t,o[f+348>>2]=e+D,o[f+344>>2]=r+y,o[f+340>>2]=p+J,o[f+336>>2]=S+_,o[f+332>>2]=k+z,o[f+328>>2]=m+l,o[f+324>>2]=u+x,o[f+320>>2]=K+L,H(s,X,40+(I=c((0-q&254)>>>1|0,120)+1488|0)|0),H(n,n,I),H(h,I+80|0,M),gA=o[f+276>>2],CA=o[f+272>>2],q=o[f+268>>2],X=o[f+264>>2],r=o[f+260>>2],y=o[f+256>>2],D=o[f+252>>2],e=o[f+248>>2],t=o[f+244>>2],Q=o[f+240>>2],T=o[f+360>>2],O=o[f+400>>2],V=o[f+364>>2],Z=o[f+404>>2],$=o[f+368>>2],AA=o[f+408>>2],K=o[f+372>>2],L=o[f+412>>2],u=o[f+376>>2],x=o[f+416>>2],m=o[f+380>>2],l=o[f+420>>2],z=o[f+384>>2],k=o[f+424>>2],S=o[f+388>>2],_=o[f+428>>2],p=o[f+392>>2],J=o[f+432>>2],B=o[f+396>>2],I=o[f+436>>2],o[f+396>>2]=B+I,o[f+392>>2]=p+J,o[f+388>>2]=S+_,o[f+384>>2]=k+z,o[f+380>>2]=m+l,o[f+376>>2]=u+x,o[f+372>>2]=K+L,o[f+368>>2]=$+AA,o[f+364>>2]=V+Z,o[f+360>>2]=T+O,o[f+356>>2]=I-B,o[f+352>>2]=J-p,o[f+348>>2]=_-S,o[f+344>>2]=k-z,o[f+340>>2]=l-m,o[f+336>>2]=x-u,o[f+332>>2]=L-K,o[f+328>>2]=AA-$,o[f+324>>2]=Z-V,o[f+320>>2]=O-T,K=Q<<1,L=o[f+440>>2],o[f+400>>2]=K-L,u=t<<1,x=o[f+444>>2],o[f+404>>2]=u-x,m=e<<1,l=o[f+448>>2],o[f+408>>2]=m-l,z=D<<1,k=o[f+452>>2],o[f+412>>2]=z-k,S=y<<1,_=o[f+456>>2],o[f+416>>2]=S-_,p=r<<1,J=o[f+460>>2],o[f+420>>2]=p-J,r=X<<1,y=o[f+464>>2],o[f+424>>2]=r-y,D=q<<1,e=o[f+468>>2],o[f+428>>2]=D-e,t=CA<<1,Q=o[f+472>>2],o[f+432>>2]=t-Q,B=gA<<1,I=o[f+476>>2],o[f+436>>2]=B-I,o[f+440>>2]=K+L,o[f+444>>2]=u+x,o[f+448>>2]=m+l,o[f+452>>2]=k+z,o[f+456>>2]=S+_,o[f+460>>2]=p+J,o[f+464>>2]=r+y,o[f+468>>2]=e+D,o[f+472>>2]=Q+t,o[f+476>>2]=I+B),H(C,f+320|0,h),H(j,n,s),H(IA,s,h),I=g-1|0,(0|g)>0;);break A}if(I=I-2|0,g)continue}break}w=f+2272|0,MA(I=i+288|0,C),BA=-1,QA=nA(I,A),p=((0|A)==(0|I)?BA:QA)|eA(A,I,32)}return w=i+592|0,p}function H(A,I,g){var C,B,Q,i,E,a,f,e,r,D,t,y,w,n,s,k,F,S,H,G,_,M,p,N,J,U,Y,d,K,b,P,v,L,R,u,x,m,l,z,q,X,j,T,O,V,Z,W,$,AA,IA,gA,CA,BA,QA=0,iA=0,EA=0,oA=0,aA=0,fA=0,cA=0,eA=0,rA=0,DA=0,tA=0,yA=0,wA=0,hA=0,nA=0,sA=0,FA=0,SA=0,HA=0,GA=0,_A=0,MA=0,pA=0,NA=0,JA=0;QA=kA(C=o[g+4>>2],D=C>>31,FA=(k=o[I+20>>2])<<1,P=FA>>31),EA=h,iA=(wA=kA(nA=o[g>>2],Q=nA>>31,B=o[I+24>>2],i=B>>31))+QA|0,QA=h+EA|0,QA=iA>>>0<wA>>>0?QA+1|0:QA,rA=kA(E=o[g+8>>2],w=E>>31,wA=o[I+16>>2],a=wA>>31),EA=h+QA|0,EA=(iA=rA+iA|0)>>>0<rA>>>0?EA+1|0:EA,QA=(rA=kA(t=o[g+12>>2],F=t>>31,N=(S=o[I+12>>2])<<1,v=N>>31))+iA|0,iA=h+EA|0,iA=QA>>>0<rA>>>0?iA+1|0:iA,EA=(hA=kA(n=o[g+16>>2],J=n>>31,rA=o[I+8>>2],f=rA>>31))+QA|0,QA=h+iA|0,QA=EA>>>0<hA>>>0?QA+1|0:QA,iA=EA,EA=kA(H=o[g+20>>2],L=H>>31,U=(G=o[I+4>>2])<<1,R=U>>31),QA=h+QA|0,QA=(iA=iA+EA|0)>>>0<EA>>>0?QA+1|0:QA,Z=cA=o[g+24>>2],EA=(DA=kA(cA,O=cA>>31,hA=o[I>>2],e=hA>>31))+iA|0,iA=h+QA|0,iA=EA>>>0<DA>>>0?iA+1|0:iA,u=o[g+28>>2],QA=(DA=kA(yA=c(u,19),_=yA>>31,Y=(M=o[I+36>>2])<<1,x=Y>>31))+EA|0,EA=h+iA|0,EA=QA>>>0<DA>>>0?EA+1|0:EA,_A=o[g+32>>2],iA=(eA=kA(oA=c(_A,19),s=oA>>31,DA=o[I+32>>2],r=DA>>31))+QA|0,QA=h+EA|0,QA=iA>>>0<eA>>>0?QA+1|0:QA,W=o[g+36>>2],g=kA(eA=c(W,19),y=eA>>31,d=(p=o[I+28>>2])<<1,m=d>>31),QA=h+QA|0,aA=I=g+iA|0,g=I>>>0<g>>>0?QA+1|0:QA,I=kA(wA,a,C,D),QA=h,iA=kA(nA,Q,k,l=k>>31),EA=h+QA|0,EA=(I=iA+I|0)>>>0<iA>>>0?EA+1|0:EA,QA=kA(E,w,S,z=S>>31),iA=h+EA|0,iA=(I=QA+I|0)>>>0<QA>>>0?iA+1|0:iA,EA=kA(rA,f,t,F),QA=h+iA|0,QA=(I=EA+I|0)>>>0<EA>>>0?QA+1|0:QA,iA=kA(n,J,G,q=G>>31),QA=h+QA|0,QA=(I=iA+I|0)>>>0<iA>>>0?QA+1|0:QA,iA=kA(hA,e,H,L),QA=h+QA|0,QA=(I=iA+I|0)>>>0<iA>>>0?QA+1|0:QA,iA=kA(cA=c(cA,19),K=cA>>31,M,X=M>>31),EA=h+QA|0,EA=(I=iA+I|0)>>>0<iA>>>0?EA+1|0:EA,QA=kA(DA,r,yA,_),iA=h+EA|0,iA=(I=QA+I|0)>>>0<QA>>>0?iA+1|0:iA,EA=kA(oA,s,p,j=p>>31),QA=h+iA|0,QA=(I=EA+I|0)>>>0<EA>>>0?QA+1|0:QA,iA=kA(eA,y,B,i),QA=h+QA|0,pA=I=iA+I|0,SA=I>>>0<iA>>>0?QA+1|0:QA,I=kA(C,D,N,v),QA=h,iA=kA(nA,Q,wA,a),QA=h+QA|0,QA=(I=iA+I|0)>>>0<iA>>>0?QA+1|0:QA,iA=kA(rA,f,E,w),EA=h+QA|0,EA=(I=iA+I|0)>>>0<iA>>>0?EA+1|0:EA,QA=kA(t,F,U,R),iA=h+EA|0,iA=(I=QA+I|0)>>>0<QA>>>0?iA+1|0:iA,EA=kA(hA,e,n,J),QA=h+iA|0,QA=(I=EA+I|0)>>>0<EA>>>0?QA+1|0:QA,iA=kA(b=c(H,19),T=b>>31,Y,x),QA=h+QA|0,QA=(I=iA+I|0)>>>0<iA>>>0?QA+1|0:QA,iA=kA(DA,r,cA,K),QA=h+QA|0,QA=(I=iA+I|0)>>>0<iA>>>0?QA+1|0:QA,iA=kA(yA,_,d,m),EA=h+QA|0,EA=(I=iA+I|0)>>>0<iA>>>0?EA+1|0:EA,QA=kA(oA,s,B,i),iA=h+EA|0,iA=(I=QA+I|0)>>>0<QA>>>0?iA+1|0:iA,EA=kA(eA,y,FA,P),QA=h+iA|0,$=I=EA+I|0,AA=QA=I>>>0<EA>>>0?QA+1|0:QA,IA=I=I+33554432|0,gA=QA=I>>>0<33554432?QA+1|0:QA,EA=(67108863&QA)<<6|I>>>26,QA=(QA>>26)+SA|0,pA=I=EA+pA|0,QA=I>>>0<EA>>>0?QA+1|0:QA,CA=I=I+16777216|0,QA=g+(iA=(EA=I>>>0<16777216?QA+1|0:QA)>>25)|0,QA=(I=(EA=(33554431&EA)<<7|I>>>25)+aA|0)>>>0<EA>>>0?QA+1|0:QA,HA=g=(iA=I)+33554432|0,I=QA=g>>>0<33554432?QA+1|0:QA,o[A+24>>2]=iA-(-67108864&g),g=kA(C,D,U,R),QA=h,iA=kA(nA,Q,rA,f),EA=h+QA|0,EA=(g=iA+g|0)>>>0<iA>>>0?EA+1|0:EA,iA=(QA=g)+(g=kA(hA,e,E,w))|0,QA=h+EA|0,QA=g>>>0>iA>>>0?QA+1|0:QA,EA=kA(g=c(t,19),GA=g>>31,Y,x),QA=h+QA|0,QA=(iA=EA+iA|0)>>>0<EA>>>0?QA+1|0:QA,EA=(aA=kA(DA,r,SA=c(n,19),V=SA>>31))+iA|0,iA=h+QA|0,iA=EA>>>0<aA>>>0?iA+1|0:iA,aA=kA(d,m,b,T),QA=h+iA|0,QA=(EA=aA+EA|0)>>>0<aA>>>0?QA+1|0:QA,iA=(aA=kA(B,i,cA,K))+EA|0,EA=h+QA|0,EA=iA>>>0<aA>>>0?EA+1|0:EA,aA=kA(yA,_,FA,P),QA=h+EA|0,QA=(iA=aA+iA|0)>>>0<aA>>>0?QA+1|0:QA,EA=kA(oA,s,wA,a),QA=h+QA|0,QA=(iA=EA+iA|0)>>>0<EA>>>0?QA+1|0:QA,EA=(aA=kA(eA,y,N,v))+iA|0,iA=h+QA|0,tA=EA,NA=EA>>>0<aA>>>0?iA+1|0:iA,QA=kA(hA,e,C,D),iA=h,EA=(aA=kA(nA,Q,G,q))+QA|0,QA=h+iA|0,QA=EA>>>0<aA>>>0?QA+1|0:QA,aA=iA=c(E,19),iA=(fA=kA(iA,MA=iA>>31,M,X))+EA|0,EA=h+QA|0,EA=iA>>>0<fA>>>0?EA+1|0:EA,fA=kA(DA,r,g,GA),QA=h+EA|0,QA=(iA=fA+iA|0)>>>0<fA>>>0?QA+1|0:QA,EA=kA(SA,V,p,j),QA=h+QA|0,QA=(iA=EA+iA|0)>>>0<EA>>>0?QA+1|0:QA,EA=(fA=kA(B,i,b,T))+iA|0,iA=h+QA|0,iA=EA>>>0<fA>>>0?iA+1|0:iA,fA=kA(cA,K,k,l),QA=h+iA|0,QA=(EA=fA+EA|0)>>>0<fA>>>0?QA+1|0:QA,iA=(fA=kA(wA,a,yA,_))+EA|0,EA=h+QA|0,EA=iA>>>0<fA>>>0?EA+1|0:EA,fA=kA(oA,s,S,z),QA=h+EA|0,QA=(iA=fA+iA|0)>>>0<fA>>>0?QA+1|0:QA,EA=kA(eA,y,rA,f),QA=h+QA|0,JA=iA=EA+iA|0,fA=iA>>>0<EA>>>0?QA+1|0:QA,QA=kA(QA=c(C,19),QA>>31,Y,x),iA=h,EA=kA(nA,Q,hA,e),iA=h+iA|0,iA=(QA=EA+QA|0)>>>0<EA>>>0?iA+1|0:iA,EA=(aA=kA(DA,r,aA,MA))+QA|0,QA=h+iA|0,g=(iA=kA(g,GA,d,m))+EA|0,EA=h+(EA>>>0<aA>>>0?QA+1|0:QA)|0,EA=g>>>0<iA>>>0?EA+1|0:EA,iA=kA(B,i,SA,V),QA=h+EA|0,QA=(g=iA+g|0)>>>0<iA>>>0?QA+1|0:QA,iA=kA(FA,P,b,T),QA=h+QA|0,QA=(g=iA+g|0)>>>0<iA>>>0?QA+1|0:QA,EA=kA(wA,a,cA,K),iA=h+QA|0,iA=(g=EA+g|0)>>>0<EA>>>0?iA+1|0:iA,EA=kA(yA,_,N,v),QA=h+iA|0,QA=(g=EA+g|0)>>>0<EA>>>0?QA+1|0:QA,iA=kA(oA,s,rA,f),EA=h+QA|0,EA=(g=iA+g|0)>>>0<iA>>>0?EA+1|0:EA,iA=kA(eA,y,U,R),QA=h+EA|0,aA=g=iA+g|0,GA=QA=g>>>0<iA>>>0?QA+1|0:QA,MA=g=g+33554432|0,BA=QA=g>>>0<33554432?QA+1|0:QA,iA=(EA=QA>>26)+fA|0,fA=g=(QA=(67108863&QA)<<6|g>>>26)+JA|0,QA=g>>>0<QA>>>0?iA+1|0:iA,JA=g=g+16777216|0,iA=(33554431&(QA=g>>>0<16777216?QA+1|0:QA))<<7|g>>>25,QA=(QA>>25)+NA|0,QA=(g=iA+tA|0)>>>0<iA>>>0?QA+1|0:QA,NA=iA=(EA=g)+33554432|0,g=QA=iA>>>0<33554432?QA+1|0:QA,o[A+8>>2]=EA-(-67108864&iA),QA=kA(B,i,C,D),EA=h,iA=(tA=kA(nA,Q,p,j))+QA|0,QA=h+EA|0,QA=iA>>>0<tA>>>0?QA+1|0:QA,EA=kA(E,w,k,l),QA=h+QA|0,QA=(iA=EA+iA|0)>>>0<EA>>>0?QA+1|0:QA,EA=kA(wA,a,t,F),QA=h+QA|0,QA=(iA=EA+iA|0)>>>0<EA>>>0?QA+1|0:QA,tA=kA(n,J,S,z),EA=h+QA|0,EA=(iA=tA+iA|0)>>>0<tA>>>0?EA+1|0:EA,QA=(tA=kA(rA,f,H,L))+iA|0,iA=h+EA|0,iA=QA>>>0<tA>>>0?iA+1|0:iA,EA=(tA=kA(G,q,Z,O))+QA|0,QA=h+iA|0,QA=EA>>>0<tA>>>0?QA+1|0:QA,iA=EA,EA=kA(hA,e,u,tA=u>>31),QA=h+QA|0,QA=(iA=iA+EA|0)>>>0<EA>>>0?QA+1|0:QA,EA=kA(oA,s,M,X),QA=h+QA|0,QA=(iA=EA+iA|0)>>>0<EA>>>0?QA+1|0:QA,sA=kA(eA,y,DA,r),EA=h+QA|0,QA=I>>26,I=(HA=(67108863&I)<<6|HA>>>26)+(iA=sA+iA|0)|0,iA=QA+(iA>>>0<sA>>>0?EA+1|0:EA)|0,QA=(EA=I)>>>0<HA>>>0?iA+1|0:iA,HA=iA=EA+16777216|0,I=QA=iA>>>0<16777216?QA+1|0:QA,o[A+28>>2]=EA-(-33554432&iA),QA=kA(rA,f,C,D),iA=h,sA=kA(nA,Q,S,z),EA=h+iA|0,EA=(QA=sA+QA|0)>>>0<sA>>>0?EA+1|0:EA,sA=kA(E,w,G,q),iA=h+EA|0,iA=(QA=sA+QA|0)>>>0<sA>>>0?iA+1|0:iA,EA=(sA=kA(hA,e,t,F))+QA|0,QA=h+iA|0,QA=EA>>>0<sA>>>0?QA+1|0:QA,iA=EA,EA=kA(SA,V,M,X),QA=h+QA|0,QA=(iA=iA+EA|0)>>>0<EA>>>0?QA+1|0:QA,EA=kA(DA,r,b,T),QA=h+QA|0,QA=(iA=EA+iA|0)>>>0<EA>>>0?QA+1|0:QA,iA=(cA=kA(cA,K,p,j))+iA|0,EA=h+QA|0,QA=(yA=kA(B,i,yA,_))+iA|0,iA=h+(iA>>>0<cA>>>0?EA+1|0:EA)|0,EA=(oA=kA(oA,s,k,l))+QA|0,QA=h+(QA>>>0<yA>>>0?iA+1|0:iA)|0,QA=EA>>>0<oA>>>0?QA+1|0:QA,iA=EA,EA=kA(eA,y,wA,a),QA=h+QA|0,oA=iA=iA+EA|0,QA=(QA=iA>>>0<EA>>>0?QA+1|0:QA)+(iA=g>>26)|0,oA=g=oA+(EA=(67108863&g)<<6|NA>>>26)|0,QA=g>>>0<EA>>>0?QA+1|0:QA,yA=iA=g+16777216|0,g=EA=iA>>>0<16777216?QA+1|0:QA,o[A+12>>2]=oA-(-33554432&iA),QA=kA(C,D,d,m),EA=h,iA=(oA=kA(nA,Q,DA,r))+QA|0,QA=h+EA|0,QA=iA>>>0<oA>>>0?QA+1|0:QA,EA=kA(B,i,E,w),QA=h+QA|0,QA=(iA=EA+iA|0)>>>0<EA>>>0?QA+1|0:QA,oA=kA(t,F,FA,P),EA=h+QA|0,EA=(iA=oA+iA|0)>>>0<oA>>>0?EA+1|0:EA,QA=(oA=kA(wA,a,n,J))+iA|0,iA=h+EA|0,iA=QA>>>0<oA>>>0?iA+1|0:iA,EA=(oA=kA(N,v,H,L))+QA|0,QA=h+iA|0,QA=EA>>>0<oA>>>0?QA+1|0:QA,iA=EA,EA=kA(rA,f,Z,O),QA=h+QA|0,QA=(iA=iA+EA|0)>>>0<EA>>>0?QA+1|0:QA,EA=kA(u,tA,U,R),QA=h+QA|0,QA=(iA=EA+iA|0)>>>0<EA>>>0?QA+1|0:QA,iA=(FA=kA(hA,e,oA=_A,cA=oA>>31))+iA|0,EA=h+QA|0,QA=(eA=kA(eA,y,Y,x))+iA|0,iA=h+(iA>>>0<FA>>>0?EA+1|0:EA)|0,iA=QA>>>0<eA>>>0?iA+1|0:iA,_A=QA,QA=(QA=I>>25)+iA|0,QA=(I=_A+(EA=(33554431&I)<<7|HA>>>25)|0)>>>0<EA>>>0?QA+1|0:QA,eA=iA=(EA=I)+33554432|0,I=QA=iA>>>0<33554432?QA+1|0:QA,o[A+32>>2]=EA-(-67108864&iA),iA=g>>25,g=(yA=(33554431&g)<<7|yA>>>25)+($-(QA=-67108864&IA)|0)|0,QA=iA+(AA-((QA>>>0>$>>>0)+gA|0)|0)|0,QA=g>>>0<yA>>>0?QA+1|0:QA,QA=((67108863&(QA=(g=(iA=g)+33554432|0)>>>0<33554432?QA+1|0:QA))<<6|g>>>26)+(EA=pA-(-33554432&CA)|0)|0,o[A+20>>2]=QA,o[A+16>>2]=iA-(-67108864&g),g=kA(DA,r,C,D),QA=h,iA=kA(nA,Q,M,X),QA=h+QA|0,QA=(g=iA+g|0)>>>0<iA>>>0?QA+1|0:QA,EA=kA(E,w,p,j),iA=h+QA|0,iA=(g=EA+g|0)>>>0<EA>>>0?iA+1|0:iA,QA=kA(B,i,t,F),EA=h+iA|0,EA=(g=QA+g|0)>>>0<QA>>>0?EA+1|0:EA,iA=kA(n,J,k,l),QA=h+EA|0,QA=(g=iA+g|0)>>>0<iA>>>0?QA+1|0:QA,iA=kA(wA,a,H,L),QA=h+QA|0,QA=(g=iA+g|0)>>>0<iA>>>0?QA+1|0:QA,iA=kA(S,z,Z,O),QA=h+QA|0,QA=(g=iA+g|0)>>>0<iA>>>0?QA+1|0:QA,EA=kA(rA,f,u,tA),iA=h+QA|0,iA=(g=EA+g|0)>>>0<EA>>>0?iA+1|0:iA,QA=kA(oA,cA,G,q),EA=h+iA|0,EA=(g=QA+g|0)>>>0<QA>>>0?EA+1|0:EA,iA=kA(hA,e,W,W>>31),QA=h+EA|0,QA=(QA=(g=iA+g|0)>>>0<iA>>>0?QA+1|0:QA)+(iA=I>>26)|0,QA=(I=(EA=g)+(g=(67108863&I)<<6|eA>>>26)|0)>>>0<g>>>0?QA+1|0:QA,QA=(I=(g=I)+16777216|0)>>>0<16777216?QA+1|0:QA,o[A+36>>2]=g-(-33554432&I),EA=fA-(-33554432&JA)|0,iA=aA-(g=-67108864&MA)|0,nA=GA-((g>>>0>aA>>>0)+BA|0)|0,I=(g=kA((33554431&(g=QA))<<7|I>>>25,QA>>=25,19,0))+iA|0,iA=h+nA|0,QA=I>>>0<g>>>0?iA+1|0:iA,QA=((67108863&(QA=(I=(g=I)+33554432|0)>>>0<33554432?QA+1|0:QA))<<6|I>>>26)+EA|0,o[A+4>>2]=QA,o[A>>2]=g-(-67108864&I)}function G(A,I){var g,C,B,Q,i,E,a,f,e,r,D,t,y,n,s,k,F,S,H,G,_,p,N,J=0,U=0,Y=0,d=0,K=0,b=0,P=0,v=0,L=0,R=0,u=0,x=0,m=0,l=0,z=0,q=0,X=0,j=0,T=0,O=0,V=0,Z=0,W=0,$=0,AA=0,IA=0,gA=0,CA=0,BA=0,QA=0,iA=0,EA=0,oA=0,aA=0,fA=0,cA=0;w=g=w-48|0,M(A,I),M(A+80|0,I+40|0),J=kA(l=(W=o[I+92>>2])<<1,i=l>>31,v=(d=o[I+84>>2])<<1,C=v>>31),Y=h,CA=X=o[I+88>>2],U=(u=kA(X,T=X>>31,X,T))+J|0,J=h+Y|0,J=U>>>0<u>>>0?J+1|0:J,Y=kA(K=o[I+96>>2],E=K>>31,u=(L=o[I+80>>2])<<1,B=u>>31),J=h+J|0,J=(U=Y+U|0)>>>0<Y>>>0?J+1|0:J,gA=o[I+108>>2],Y=kA(x=c(gA,38),D=x>>31,gA,n=gA>>31),J=h+J|0,J=(U=Y+U|0)>>>0<Y>>>0?J+1|0:J,Y=U,$=o[I+112>>2],R=kA(b=c($,19),a=b>>31,U=(O=o[I+104>>2])<<1,U>>31),U=h+J|0,U=(Y=Y+R|0)>>>0<R>>>0?U+1|0:U,iA=o[I+116>>2],J=kA(R=c(iA,38),Q=R>>31,j=(V=o[I+100>>2])<<1,e=j>>31),U=h+U|0,EA=J=(J>>>0>(Y=J+Y|0)>>>0?U+1|0:U)<<1|Y>>>31,oA=Y=33554432+(s=Y<<1)|0,aA=J=Y>>>0<33554432?J+1|0:J,P=(67108863&J)<<6|Y>>>26,Z=J>>26,J=kA(v,C,K,E),Y=h,U=(AA=kA(X<<=1,r=X>>31,W,k=W>>31))+J|0,J=h+Y|0,J=U>>>0<AA>>>0?J+1|0:J,Y=(AA=kA(V,t=V>>31,u,B))+U|0,U=h+J|0,U=Y>>>0<AA>>>0?U+1|0:U,BA=kA(b,a,AA=gA<<1,F=AA>>31),J=h+U|0,J=(Y=BA+Y|0)>>>0<BA>>>0?J+1|0:J,U=kA(R,Q,O,f=O>>31),J=h+J|0,U=(U=(U>>>0>(Y=U+Y|0)>>>0?J+1|0:J)<<1|Y>>>31)+Z|0,BA=Y=(J=Y<<1)+P|0,J=U=J>>>0>Y>>>0?U+1|0:U,fA=Y=Y+16777216|0,P=(33554431&(J=Y>>>0<16777216?J+1|0:J))<<7|Y>>>25,Z=J>>25,J=kA(l,i,W,k),Y=h,U=(m=kA(K,E,X,r))+J|0,J=h+Y|0,J=U>>>0<m>>>0?J+1|0:J,Y=kA(v,C,j,e),J=h+J|0,J=(U=Y+U|0)>>>0<Y>>>0?J+1|0:J,Y=(m=kA(u,B,O,f))+U|0,U=h+J|0,U=Y>>>0<m>>>0?U+1|0:U,m=kA(b,a,$,y=$>>31),J=h+U|0,J=(Y=m+Y|0)>>>0<m>>>0?J+1|0:J,m=kA(R,Q,AA,F),U=h+J|0,U=((Y=m+Y|0)>>>0<m>>>0?U+1|0:U)<<1|Y>>>31,Y=(J=P)+(P=Y<<1)|0,J=U+Z|0,J=Y>>>0<P>>>0?J+1|0:J,Z=Y,m=U=Y+33554432|0,Y=J=U>>>0<33554432?J+1|0:J,o[A+144>>2]=Z-(-67108864&U),Z=kA(J=c(V,38),J>>31,V,t),P=h,L=kA(J=L,U=J>>31,J,U),U=h+P|0,U=(J=L+Z|0)>>>0<L>>>0?U+1|0:U,P=(IA=kA(L=c(O,19),S=L>>31,Z=K<<1,H=Z>>31))+J|0,J=h+U|0,J=P>>>0<IA>>>0?J+1|0:J,U=P,P=kA(l,i,x,D),J=h+J|0,J=(U=U+P|0)>>>0<P>>>0?J+1|0:J,P=(IA=kA(b,a,X,r))+U|0,U=h+J|0,U=P>>>0<IA>>>0?U+1|0:U,IA=kA(v,C,R,Q),J=h+U|0,IA=J=((P=IA+P|0)>>>0<IA>>>0?J+1|0:J)<<1|P>>>31,p=U=(P=33554432+(G=P<<1)|0)>>>0<33554432?J+1|0:J,QA=(67108863&U)<<6|P>>>26,cA=U>>26,J=kA(L,S,j,e),z=h,q=d,U=(d=kA(u,B,d,_=d>>31))+J|0,J=h+z|0,J=U>>>0<d>>>0?J+1|0:J,d=(z=kA(K,E,x,D))+U|0,U=h+J|0,U=d>>>0<z>>>0?U+1|0:U,z=kA(b,a,l,i),J=h+U|0,J=(d=z+d|0)>>>0<z>>>0?J+1|0:J,z=kA(R,Q,CA,T),U=h+J|0,U=((d=z+d|0)>>>0<z>>>0?U+1|0:U)<<1|d>>>31,d=(J=QA)+(QA=d<<1)|0,J=U+cA|0,J=d>>>0<QA>>>0?J+1|0:J,cA=d,QA=d=d+16777216|0,N=(33554431&(J=d>>>0<16777216?J+1|0:J))<<7|d>>>25,z=J>>25,J=kA(u,B,CA,T),d=h,U=(q=kA(v,C,q,_))+J|0,J=h+d|0,d=(L=kA(L,S,O,f))+U|0,U=h+(U>>>0<q>>>0?J+1|0:J)|0,U=d>>>0<L>>>0?U+1|0:U,L=kA(j,e,x,D),J=h+U|0,J=(d=L+d|0)>>>0<L>>>0?J+1|0:J,U=d,d=kA(b,a,Z,H),J=h+J|0,J=(U=U+d|0)>>>0<d>>>0?J+1|0:J,d=(L=kA(R,Q,l,i))+U|0,U=h+J|0,J=(J=(d>>>0<L>>>0?U+1|0:U)<<1|d>>>31)+z|0,q=d=(U=d<<1)+N|0,J=U>>>0>d>>>0?J+1|0:J,d=(L=d+33554432|0)>>>0<33554432?J+1|0:J,o[A+128>>2]=q-(-67108864&L),J=kA(X,r,V,t),U=h,q=kA(K,E,l,i),U=h+U|0,U=(J=q+J|0)>>>0<q>>>0?U+1|0:U,q=(z=kA(v,C,O,f))+J|0,J=h+U|0,J=q>>>0<z>>>0?J+1|0:J,z=kA(u,B,gA,n),U=h+J|0,U=(q=z+q|0)>>>0<z>>>0?U+1|0:U,z=kA(R,Q,$,y),J=h+U|0,J=(U=Y>>26)+(((q=z+q|0)>>>0<z>>>0?J+1|0:J)<<1|q>>>31)|0,J=(Y=(m=(67108863&Y)<<6|m>>>26)+(q<<1)|0)>>>0<m>>>0?J+1|0:J,m=Y,U=J,q=J=Y+16777216|0,Y=U=J>>>0<16777216?U+1|0:U,o[A+148>>2]=m-(-33554432&J),J=kA(u,B,W,k),W=h,U=(T=kA(v,C,CA,T))+J|0,J=h+W|0,J=U>>>0<T>>>0?J+1|0:J,x=kA(O,f,x,D),J=h+J|0,J=(U=x+U|0)>>>0<x>>>0?J+1|0:J,b=(x=kA(b,a,j,e))+U|0,U=h+J|0,U=b>>>0<x>>>0?U+1|0:U,J=b,b=kA(R,Q,K,E),U=h+U|0,U=((J=J+b|0)>>>0<b>>>0?U+1|0:U)<<1,b=J,J=(J=U|J>>>31)+(U=d>>26)|0,J=(d=(m=b<<1)+(b=(67108863&d)<<6|L>>>26)|0)>>>0<b>>>0?J+1|0:J,b=d,x=U=d+16777216|0,d=J=U>>>0<16777216?J+1|0:J,o[A+132>>2]=b-(-33554432&U),J=kA(O,f,X,r),b=h,U=(K=kA(K,E,K,E))+J|0,J=h+b|0,J=U>>>0<K>>>0?J+1|0:J,K=kA(l,i,j,e),J=h+J|0,J=(U=K+U|0)>>>0<K>>>0?J+1|0:J,K=kA(v,C,AA,F),J=h+J|0,J=(U=K+U|0)>>>0<K>>>0?J+1|0:J,K=(b=kA(u,B,$,y))+U|0,U=h+J|0,U=K>>>0<b>>>0?U+1|0:U,J=K,K=kA(K=R,Q,R=iA,j=R>>31),U=h+U|0,U=((J=J+K|0)>>>0<K>>>0?U+1|0:U)<<1,K=J,J=(J=U|J>>>31)+(U=Y>>25)|0,J=(Y=(b=K<<1)+(K=(33554431&Y)<<7|q>>>25)|0)>>>0<K>>>0?J+1|0:J,K=Y,b=U=Y+33554432|0,Y=J=U>>>0<33554432?J+1|0:J,o[A+152>>2]=K-(-67108864&U),U=s-(J=-67108864&oA)|0,K=EA-((J>>>0>s>>>0)+aA|0)|0,J=d>>25,d=(x=(33554431&d)<<7|x>>>25)+U|0,U=J+K|0,K=d,J=U=d>>>0<x>>>0?U+1|0:U,J=((67108863&(J=(d=d+33554432|0)>>>0<33554432?J+1|0:J))<<6|d>>>26)+(T=BA-(-33554432&fA)|0)|0,o[A+140>>2]=J,o[A+136>>2]=K-(-67108864&d),J=kA(l,i,O,f),U=h,d=kA(V,t,Z,H),U=h+U|0,U=(J=d+J|0)>>>0<d>>>0?U+1|0:U,d=(l=kA(X,r,gA,n))+J|0,J=h+U|0,J=d>>>0<l>>>0?J+1|0:J,v=kA(v,C,$,y),U=h+J|0,U=(d=v+d|0)>>>0<v>>>0?U+1|0:U,v=kA(u,B,R,j),J=h+U|0,J=(J=((d=v+d|0)>>>0<v>>>0?J+1|0:J)<<1|d>>>31)+(U=Y>>26)|0,U=(Y=(K=d<<1)+(d=(67108863&Y)<<6|b>>>26)|0)>>>0<d>>>0?J+1|0:J,U=(J=Y+16777216|0)>>>0<16777216?U+1|0:U,o[A+156>>2]=Y-(-33554432&J),d=cA-(-33554432&QA)|0,v=G-(Y=-67108864&P)|0,u=IA-((Y>>>0>G>>>0)+p|0)|0,Y=kA((33554431&U)<<7|J>>>25,U>>25,19,0),U=h+u|0,U=(J=Y+v|0)>>>0<Y>>>0?U+1|0:U,Y=J,U=((67108863&(U=(J=J+33554432|0)>>>0<33554432?U+1|0:U))<<6|J>>>26)+d|0,o[A+124>>2]=U,o[A+120>>2]=Y-(-67108864&J),J=o[I+40>>2],U=o[I+44>>2],Y=o[I+4>>2],d=o[I+48>>2],v=o[I+8>>2],u=o[I+52>>2],R=o[I+12>>2],l=o[I+56>>2],K=o[I+16>>2],b=o[I+60>>2],O=o[I+20>>2],j=o[I- -64>>2],X=o[I+24>>2],x=o[I+68>>2],T=o[I+28>>2],V=o[I+72>>2],$=o[I+32>>2],CA=o[I>>2],o[A+76>>2]=o[I+76>>2]+o[I+36>>2],o[A+72>>2]=V+$,o[A+68>>2]=x+T,o[(gA=A- -64|0)>>2]=X+j,o[A+60>>2]=b+O,o[A+56>>2]=K+l,o[A+52>>2]=R+u,o[A+48>>2]=d+v,o[A+44>>2]=U+Y,o[(I=A+40|0)>>2]=J+CA,M(g,I),J=o[A+80>>2],U=o[A+4>>2],Y=o[A+84>>2],d=o[A+8>>2],v=o[A+88>>2],u=o[A+12>>2],R=o[A+92>>2],l=o[A+16>>2],K=o[A+96>>2],b=o[A+20>>2],O=o[A+100>>2],j=o[A+24>>2],X=o[A+104>>2],x=o[A+28>>2],T=o[A+108>>2],V=o[A+32>>2],$=o[A+112>>2],CA=o[A>>2],L=(W=o[A+116>>2])-(AA=o[A+36>>2])|0,o[A+116>>2]=L,Z=$-V|0,o[A+112>>2]=Z,P=T-x|0,o[A+108>>2]=P,iA=X-j|0,o[A+104>>2]=iA,EA=O-b|0,o[A+100>>2]=EA,oA=K-l|0,o[A+96>>2]=oA,aA=R-u|0,o[A+92>>2]=aA,BA=v-d|0,o[A+88>>2]=BA,fA=Y-U|0,o[A+84>>2]=fA,m=J-CA|0,o[A+80>>2]=m,W=W+AA|0,o[A+76>>2]=W,V=V+$|0,o[A+72>>2]=V,x=x+T|0,o[A+68>>2]=x,j=X+j|0,o[gA>>2]=j,b=b+O|0,o[A+60>>2]=b,l=K+l|0,o[A+56>>2]=l,u=R+u|0,o[A+52>>2]=u,d=d+v|0,o[A+48>>2]=d,U=U+Y|0,o[A+44>>2]=U,Y=I,I=J+CA|0,o[Y>>2]=I,J=o[g>>2],Y=o[g+4>>2],v=o[g+8>>2],R=o[g+12>>2],K=o[g+16>>2],O=o[g+20>>2],X=o[g+24>>2],T=o[g+28>>2],$=o[g+32>>2],o[A+36>>2]=o[g+36>>2]-W,o[A+32>>2]=$-V,o[A+28>>2]=T-x,o[A+24>>2]=X-j,o[A+20>>2]=O-b,o[A+16>>2]=K-l,o[A+12>>2]=R-u,o[A+8>>2]=v-d,o[A+4>>2]=Y-U,o[A>>2]=J-I,I=o[A+120>>2],J=o[A+124>>2],U=o[A+128>>2],Y=o[A+132>>2],d=o[A+136>>2],v=o[A+140>>2],u=o[A+144>>2],R=o[A+148>>2],l=o[A+152>>2],o[A+156>>2]=o[A+156>>2]-L,o[A+152>>2]=l-Z,o[A+148>>2]=R-P,o[A+144>>2]=u-iA,o[A+140>>2]=v-EA,o[A+136>>2]=d-oA,o[A+132>>2]=Y-aA,o[A+128>>2]=U-BA,o[A+124>>2]=J-fA,o[A+120>>2]=I-m,w=g+48|0}function _(A,I,g,C){var B=0,Q=0,i=0,E=0,f=0,c=0,e=0,r=0,D=0,t=0,y=0,w=0,h=0,n=0,s=0,k=0,F=0,S=0,H=0,G=0,_=0,M=0,p=0,N=0,J=0,U=0,Y=0;for(B=a[0|I]|a[I+1|0]<<8|a[I+2|0]<<16|a[I+3|0]<<24,o[g>>2]=B<<24|(65280&B)<<8|B>>>8&65280|B>>>24,B=a[I+4|0]|a[I+5|0]<<8|a[I+6|0]<<16|a[I+7|0]<<24,o[g+4>>2]=B<<24|(65280&B)<<8|B>>>8&65280|B>>>24,B=a[I+8|0]|a[I+9|0]<<8|a[I+10|0]<<16|a[I+11|0]<<24,o[g+8>>2]=B<<24|(65280&B)<<8|B>>>8&65280|B>>>24,B=a[I+12|0]|a[I+13|0]<<8|a[I+14|0]<<16|a[I+15|0]<<24,o[g+12>>2]=B<<24|(65280&B)<<8|B>>>8&65280|B>>>24,B=a[I+16|0]|a[I+17|0]<<8|a[I+18|0]<<16|a[I+19|0]<<24,o[g+16>>2]=B<<24|(65280&B)<<8|B>>>8&65280|B>>>24,B=a[I+20|0]|a[I+21|0]<<8|a[I+22|0]<<16|a[I+23|0]<<24,o[g+20>>2]=B<<24|(65280&B)<<8|B>>>8&65280|B>>>24,B=a[I+24|0]|a[I+25|0]<<8|a[I+26|0]<<16|a[I+27|0]<<24,o[g+24>>2]=B<<24|(65280&B)<<8|B>>>8&65280|B>>>24,B=a[I+28|0]|a[I+29|0]<<8|a[I+30|0]<<16|a[I+31|0]<<24,o[g+28>>2]=B<<24|(65280&B)<<8|B>>>8&65280|B>>>24,B=a[I+32|0]|a[I+33|0]<<8|a[I+34|0]<<16|a[I+35|0]<<24,o[g+32>>2]=B<<24|(65280&B)<<8|B>>>8&65280|B>>>24,B=a[I+36|0]|a[I+37|0]<<8|a[I+38|0]<<16|a[I+39|0]<<24,o[g+36>>2]=B<<24|(65280&B)<<8|B>>>8&65280|B>>>24,B=a[I+40|0]|a[I+41|0]<<8|a[I+42|0]<<16|a[I+43|0]<<24,o[g+40>>2]=B<<24|(65280&B)<<8|B>>>8&65280|B>>>24,B=a[I+44|0]|a[I+45|0]<<8|a[I+46|0]<<16|a[I+47|0]<<24,o[g+44>>2]=B<<24|(65280&B)<<8|B>>>8&65280|B>>>24,B=a[I+48|0]|a[I+49|0]<<8|a[I+50|0]<<16|a[I+51|0]<<24,o[g+48>>2]=B<<24|(65280&B)<<8|B>>>8&65280|B>>>24,B=a[I+52|0]|a[I+53|0]<<8|a[I+54|0]<<16|a[I+55|0]<<24,o[g+52>>2]=B<<24|(65280&B)<<8|B>>>8&65280|B>>>24,B=a[I+56|0]|a[I+57|0]<<8|a[I+58|0]<<16|a[I+59|0]<<24,o[g+56>>2]=B<<24|(65280&B)<<8|B>>>8&65280|B>>>24,I=a[I+60|0]|a[I+61|0]<<8|a[I+62|0]<<16|a[I+63|0]<<24,o[g+60>>2]=I<<24|(65280&I)<<8|I>>>8&65280|I>>>24,I=o[A+28>>2],o[C+24>>2]=o[A+24>>2],o[C+28>>2]=I,I=o[A+20>>2],o[C+16>>2]=o[A+16>>2],o[C+20>>2]=I,I=o[A+12>>2],o[C+8>>2]=o[A+8>>2],o[C+12>>2]=I,I=o[A+4>>2],o[C>>2]=o[A>>2],o[C+4>>2]=I;f=o[C+28>>2],B=(I=F<<2)+g|0,i=o[C+16>>2],c=o[B>>2]+(RA(i,26)^RA(i,21)^RA(i,7))|0,r=(f=((Q=o[I+33968>>2]+c|0)+(i&((c=o[C+24>>2])^(D=o[C+20>>2]))^c)|0)+f|0)+o[C+12>>2]|0,o[C+12>>2]=r,f=(y=f+(RA(e=o[C>>2],30)^RA(e,19)^RA(e,10))|0)+(e&((Q=o[C+8>>2])|(E=o[C+4>>2]))|Q&E)|0,o[C+28>>2]=f,Q=(y=Q)+(c=(o[(h=(Q=4|I)+g|0)>>2]+((c+(D^r&(i^D))|0)+(RA(r,26)^RA(r,21)^RA(r,7))|0)|0)+o[Q+33968>>2]|0)|0,o[C+8>>2]=Q,c=(c+(f&(E|e)|E&e)|0)+(RA(f,30)^RA(f,19)^RA(f,10))|0,o[C+24>>2]=c,D=(y=E)+(E=(((D+o[(k=(E=8|I)+g|0)>>2]|0)+o[E+33968>>2]|0)+(i^Q&(i^r))|0)+(RA(Q,26)^RA(Q,21)^RA(Q,7))|0)|0,o[C+4>>2]=D,E=E+((c&(f|e)|f&e)+(RA(c,30)^RA(c,19)^RA(c,10))|0)|0,o[C+20>>2]=E,i=(y=e)+(e=(((i+o[(S=(e=12|I)+g|0)>>2]|0)+o[e+33968>>2]|0)+(r^D&(Q^r))|0)+(RA(D,26)^RA(D,21)^RA(D,7))|0)|0,o[C>>2]=i,e=e+((E&(f|c)|f&c)+(RA(E,30)^RA(E,19)^RA(E,10))|0)|0,o[C+16>>2]=e,r=(t=((((y=r)+o[(H=(r=16|I)+g|0)>>2]|0)+o[r+33968>>2]|0)+(Q^i&(Q^D))|0)+(RA(i,26)^RA(i,21)^RA(i,7))|0)+((e&(E|c)|E&c)+(RA(e,30)^RA(e,19)^RA(e,10))|0)|0,o[C+12>>2]=r,t=f+t|0,o[C+28>>2]=t,f=(Q=(((Q+o[(G=(f=20|I)+g|0)>>2]|0)+o[f+33968>>2]|0)+(D^t&(i^D))|0)+(RA(t,26)^RA(t,21)^RA(t,7))|0)+((r&(E|e)|E&e)+(RA(r,30)^RA(r,19)^RA(r,10))|0)|0,o[C+8>>2]=f,Q=Q+c|0,o[C+24>>2]=Q,c=(D=(((D+o[(_=(c=24|I)+g|0)>>2]|0)+o[c+33968>>2]|0)+(i^Q&(i^t))|0)+(RA(Q,26)^RA(Q,21)^RA(Q,7))|0)+((f&(e|r)|e&r)+(RA(f,30)^RA(f,19)^RA(f,10))|0)|0,o[C+4>>2]=c,D=E+D|0,o[C+20>>2]=D,E=(i=(((i+o[(M=(E=28|I)+g|0)>>2]|0)+o[E+33968>>2]|0)+(t^D&(Q^t))|0)+(RA(D,26)^RA(D,21)^RA(D,7))|0)+((c&(f|r)|f&r)+(RA(c,30)^RA(c,19)^RA(c,10))|0)|0,o[C>>2]=E,i=i+e|0,o[C+16>>2]=i,e=(t=(((t+o[(p=(e=32|I)+g|0)>>2]|0)+o[e+33968>>2]|0)+(Q^i&(Q^D))|0)+(RA(i,26)^RA(i,21)^RA(i,7))|0)+((E&(f|c)|f&c)+(RA(E,30)^RA(E,19)^RA(E,10))|0)|0,o[C+28>>2]=e,t=r+t|0,o[C+12>>2]=t,r=(Q=(((Q+o[(N=(r=36|I)+g|0)>>2]|0)+o[r+33968>>2]|0)+(D^t&(i^D))|0)+(RA(t,26)^RA(t,21)^RA(t,7))|0)+((e&(E|c)|E&c)+(RA(e,30)^RA(e,19)^RA(e,10))|0)|0,o[C+24>>2]=r,Q=Q+f|0,o[C+8>>2]=Q,f=(D=(((D+o[(J=(f=40|I)+g|0)>>2]|0)+o[f+33968>>2]|0)+(i^Q&(i^t))|0)+(RA(Q,26)^RA(Q,21)^RA(Q,7))|0)+((r&(E|e)|E&e)+(RA(r,30)^RA(r,19)^RA(r,10))|0)|0,o[C+20>>2]=f,D=c+D|0,o[C+4>>2]=D,y=(c=44|I)+g|0,c=(i=((i+(o[c+33968>>2]+o[y>>2]|0)|0)+(t^D&(Q^t))|0)+(RA(D,26)^RA(D,21)^RA(D,7))|0)+((f&(e|r)|e&r)+(RA(f,30)^RA(f,19)^RA(f,10))|0)|0,o[C+16>>2]=c,E=E+i|0,o[C>>2]=E,s=(i=48|I)+g|0,i=(t=((t+(o[i+33968>>2]+o[s>>2]|0)|0)+(Q^E&(Q^D))|0)+(RA(E,26)^RA(E,21)^RA(E,7))|0)+((c&(f|r)|f&r)+(RA(c,30)^RA(c,19)^RA(c,10))|0)|0,o[C+12>>2]=i,e=e+t|0,o[C+28>>2]=e,n=(t=52|I)+g|0,Q=(t=(((o[t+33968>>2]+o[n>>2]|0)+Q|0)+(D^e&(E^D))|0)+(RA(e,26)^RA(e,21)^RA(e,7))|0)+((i&(f|c)|f&c)+(RA(i,30)^RA(i,19)^RA(i,10))|0)|0,o[C+8>>2]=Q,r=r+t|0,o[C+24>>2]=r,t=(w=56|I)+g|0,D=(w=(((o[w+33968>>2]+o[t>>2]|0)+D|0)+(E^r&(E^e))|0)+(RA(r,26)^RA(r,21)^RA(r,7))|0)+((Q&(c|i)|c&i)+(RA(Q,30)^RA(Q,19)^RA(Q,10))|0)|0,o[C+4>>2]=D,f=f+w|0,o[C+20>>2]=f,w=(I|=60)+g|0,f=(I=((E+(o[I+33968>>2]+o[w>>2]|0)|0)+(e^f&(e^r))|0)+(RA(f,26)^RA(f,21)^RA(f,7))|0)+((D&(Q|i)|Q&i)+(RA(D,30)^RA(D,19)^RA(D,10))|0)|0,o[C>>2]=f,o[C+16>>2]=I+c,48!=(0|F);)E=o[N>>2],F=F+16|0,I=o[t>>2],f=(Q=o[B>>2]+(E+(RA(I,15)^RA(I,13)^I>>>10)|0)|0)+(RA(c=o[h>>2],25)^RA(c,14)^c>>>3)|0,o[(F<<2)+g>>2]=f,r=(i=(Q=(e=o[J>>2])+c|0)+(RA(c=o[w>>2],15)^RA(c,13)^c>>>10)|0)+(RA(Q=o[k>>2],25)^RA(Q,14)^Q>>>3)|0,o[B+68>>2]=r,D=(y=((i=Q)+(Q=o[y>>2])|0)+(RA(f,15)^RA(f,13)^f>>>10)|0)+(RA(i=o[S>>2],25)^RA(i,14)^i>>>3)|0,o[B+72>>2]=D,t=(w=((y=i)+(i=o[s>>2])|0)+(RA(r,15)^RA(r,13)^r>>>10)|0)+(RA(y=o[H>>2],25)^RA(y,14)^y>>>3)|0,o[B+76>>2]=t,s=(w=((w=y)+(y=o[n>>2])|0)+(RA(D,15)^RA(D,13)^D>>>10)|0)+(RA(n=o[G>>2],25)^RA(n,14)^n>>>3)|0,o[B+80>>2]=s,n=(h=(I+n|0)+(RA(t,15)^RA(t,13)^t>>>10)|0)+(RA(w=o[_>>2],25)^RA(w,14)^w>>>3)|0,o[B+84>>2]=n,w=((c+w|0)+(RA(k=o[M>>2],25)^RA(k,14)^k>>>3)|0)+(RA(s,15)^RA(s,13)^s>>>10)|0,o[B+88>>2]=w,r=((h=o[p>>2])+(r+(RA(E,25)^RA(E,14)^E>>>3)|0)|0)+(RA(w,15)^RA(w,13)^w>>>10)|0,o[B+96>>2]=r,h=((f+k|0)+(RA(h,25)^RA(h,14)^h>>>3)|0)+(RA(n,15)^RA(n,13)^n>>>10)|0,o[B+92>>2]=h,t=(t+(e+(RA(Q,25)^RA(Q,14)^Q>>>3)|0)|0)+(RA(r,15)^RA(r,13)^r>>>10)|0,o[B+104>>2]=t,E=(D+(E+(RA(e,25)^RA(e,14)^e>>>3)|0)|0)+(RA(h,15)^RA(h,13)^h>>>10)|0,o[B+100>>2]=E,e=(n+(i+(RA(y,25)^RA(y,14)^y>>>3)|0)|0)+(RA(t,15)^RA(t,13)^t>>>10)|0,o[B+112>>2]=e,E=(s+(Q+(RA(i,25)^RA(i,14)^i>>>3)|0)|0)+(RA(E,15)^RA(E,13)^E>>>10)|0,o[B+108>>2]=E,U=B,Y=(h+(I+(RA(c,25)^RA(c,14)^c>>>3)|0)|0)+(RA(e,15)^RA(e,13)^e>>>10)|0,o[U+120>>2]=Y,I=(w+(y+(RA(I,25)^RA(I,14)^I>>>3)|0)|0)+(RA(E,15)^RA(E,13)^E>>>10)|0,o[B+116>>2]=I,U=B,Y=(r+(c+(RA(f,25)^RA(f,14)^f>>>3)|0)|0)+(RA(I,15)^RA(I,13)^I>>>10)|0,o[U+124>>2]=Y;o[A>>2]=f+o[A>>2],o[A+4>>2]=o[A+4>>2]+o[C+4>>2],o[A+8>>2]=o[A+8>>2]+o[C+8>>2],o[A+12>>2]=o[A+12>>2]+o[C+12>>2],o[A+16>>2]=o[A+16>>2]+o[C+16>>2],o[A+20>>2]=o[A+20>>2]+o[C+20>>2],o[A+24>>2]=o[A+24>>2]+o[C+24>>2],o[A+28>>2]=o[A+28>>2]+o[C+28>>2]}function M(A,I){var g,C,B,Q,i,E,a,f,e,r,D,t,y,w,n,s,k,F,S,H,G,_,M,p,N,J,U,Y,d,K,b,P,v=0,L=0,R=0,u=0,x=0,m=0,l=0,z=0,q=0,X=0,j=0,T=0,O=0,V=0,Z=0,W=0,$=0,AA=0,IA=0,gA=0,CA=0,BA=0;v=kA(C=(s=o[I+12>>2])<<1,E=C>>31,s,G=s>>31),R=h,L=(q=kA(x=o[I+16>>2],a=x>>31,f=(u=o[I+8>>2])<<1,t=f>>31))+v|0,v=h+R|0,v=L>>>0<q>>>0?v+1|0:v,R=(X=kA(O=(e=o[I+20>>2])<<1,y=O>>31,q=(m=o[I+4>>2])<<1,B=q>>31))+L|0,L=h+v|0,L=R>>>0<X>>>0?L+1|0:L,l=kA(g=o[I+24>>2],r=g>>31,X=(W=o[I>>2])<<1,Q=X>>31),v=h+L|0,v=(R=l+R|0)>>>0<l>>>0?v+1|0:v,L=R,w=o[I+32>>2],R=kA(j=c(w,19),D=j>>31,w,F=w>>31),v=h+v|0,v=(L=L+R|0)>>>0<R>>>0?v+1|0:v,J=o[I+36>>2],R=kA(l=c(J,38),i=l>>31,S=(n=o[I+28>>2])<<1,_=S>>31),I=h+v|0,Z=L=R+L|0,R=L>>>0<R>>>0?I+1|0:I,I=kA(q,B,x,a),v=h,L=kA(f,t,s,G),v=h+v|0,v=(I=L+I|0)>>>0<L>>>0?v+1|0:v,z=kA(e,H=e>>31,X,Q),L=h+v|0,L=(I=z+I|0)>>>0<z>>>0?L+1|0:L,z=kA(j,D,S,_),v=h+L|0,v=(I=z+I|0)>>>0<z>>>0?v+1|0:v,L=kA(l,i,g,r),v=h+v|0,CA=I=L+I|0,T=I>>>0<L>>>0?v+1|0:v,v=kA(q,B,C,E),L=h,M=I=u,u=kA(I,V=I>>31,I,V),I=h+L|0,I=(v=u+v|0)>>>0<u>>>0?I+1|0:I,L=(u=kA(X,Q,x,a))+v|0,v=h+I|0,v=L>>>0<u>>>0?v+1|0:v,I=(u=kA(z=c(n,38),k=z>>31,n,p=n>>31))+L|0,L=h+v|0,L=I>>>0<u>>>0?L+1|0:L,I=(v=I)+(u=kA(j,D,I=g<<1,I>>31))|0,v=h+L|0,v=I>>>0<u>>>0?v+1|0:v,L=I,I=kA(l,i,O,y),v=h+v|0,U=L=L+I|0,Y=v=I>>>0>L>>>0?v+1|0:v,I=v,d=L=L+33554432|0,K=I=L>>>0<33554432?I+1|0:I,v=(v=I>>26)+T|0,CA=I=(L=(67108863&I)<<6|L>>>26)+CA|0,v=I>>>0<L>>>0?v+1|0:v,b=I=I+16777216|0,v=(v=(L=I>>>0<16777216?v+1|0:v)>>25)+R|0,I=(I=(33554431&L)<<7|I>>>25)>>>0>(L=I+Z|0)>>>0?v+1|0:v,Z=v=L+33554432|0,u=I=v>>>0<33554432?I+1|0:I,o[A+24>>2]=L-(-67108864&v),I=kA(X,Q,M,V),v=h,R=kA(q,B,m,$=m>>31),L=h+v|0,L=(I=R+I|0)>>>0<R>>>0?L+1|0:L,T=kA(R=c(g,19),gA=R>>31,g,r),v=h+L|0,v=(I=T+I|0)>>>0<T>>>0?v+1|0:v,L=(T=kA(O,y,z,k))+I|0,I=h+v|0,I=L>>>0<T>>>0?I+1|0:I,AA=kA(j,D,T=x<<1,N=T>>31),v=h+I|0,v=(L=AA+L|0)>>>0<AA>>>0?v+1|0:v,I=L,L=kA(l,i,C,E),v=h+v|0,IA=I=I+L|0,AA=I>>>0<L>>>0?v+1|0:v,I=kA(O,y,R,gA),v=h,m=kA(X,Q,m,$),L=h+v|0,L=(I=m+I|0)>>>0<m>>>0?L+1|0:L,m=kA(x,a,z,k),v=h+L|0,v=(I=m+I|0)>>>0<m>>>0?v+1|0:v,L=(m=kA(j,D,C,E))+I|0,I=h+v|0,I=L>>>0<m>>>0?I+1|0:I,m=kA(l,i,M,V),v=h+I|0,BA=L=m+L|0,$=L>>>0<m>>>0?v+1|0:v,L=kA(I=c(e,38),I>>31,e,H),m=h,I=W,W=L,L=kA(I,v=I>>31,I,v),v=h+m|0,v=(I=W+L|0)>>>0<L>>>0?v+1|0:v,R=kA(R,gA,T,N),L=h+v|0,L=(I=R+I|0)>>>0<R>>>0?L+1|0:L,R=kA(C,E,z,k),v=h+L|0,v=(I=R+I|0)>>>0<R>>>0?v+1|0:v,L=(R=kA(j,D,f,t))+I|0,I=h+v|0,I=L>>>0<R>>>0?I+1|0:I,R=kA(q,B,l,i),v=h+I|0,m=L=R+L|0,W=v=L>>>0<R>>>0?v+1|0:v,gA=L=L+33554432|0,P=v=L>>>0<33554432?v+1|0:v,I=v>>26,v=(67108863&v)<<6|L>>>26,L=I+$|0,$=R=v+BA|0,v=v>>>0>R>>>0?L+1|0:L,BA=L=R+16777216|0,R=(33554431&(v=L>>>0<16777216?v+1|0:v))<<7|L>>>25,v=(v>>25)+AA|0,v=(L=R+IA|0)>>>0<R>>>0?v+1|0:v,AA=I=L+33554432|0,R=v=I>>>0<33554432?v+1|0:v,o[A+8>>2]=L-(-67108864&I),I=kA(f,t,e,H),v=h,L=kA(x,a,C,E),v=h+v|0,v=(I=L+I|0)>>>0<L>>>0?v+1|0:v,L=kA(q,B,g,r),v=h+v|0,v=(I=L+I|0)>>>0<L>>>0?v+1|0:v,L=kA(X,Q,n,p),v=h+v|0,v=(I=L+I|0)>>>0<L>>>0?v+1|0:v,IA=(L=kA(l,i,w,F))+I|0,I=h+v|0,L=(v=u>>26)+(L=L>>>0>IA>>>0?I+1|0:I)|0,Z=I=(u=(67108863&u)<<6|Z>>>26)+IA|0,v=I>>>0<u>>>0?L+1|0:L,IA=I=I+16777216|0,u=v=I>>>0<16777216?v+1|0:v,o[A+28>>2]=Z-(-33554432&I),I=kA(X,Q,s,G),L=h,v=(V=kA(q,B,M,V))+I|0,I=h+L|0,I=v>>>0<V>>>0?I+1|0:I,v=(z=kA(g,r,z,k))+v|0,L=h+I|0,I=(j=kA(j,D,O,y))+v|0,v=h+(v>>>0<z>>>0?L+1|0:L)|0,v=I>>>0<j>>>0?v+1|0:v,L=kA(l,i,x,a),v=h+v|0,v=(v=(I=L+I|0)>>>0<L>>>0?v+1|0:v)+(L=R>>26)|0,I=(L=R=(Z=I)+(I=(67108863&R)<<6|AA>>>26)|0)>>>0<I>>>0?v+1|0:v,j=v=L+16777216|0,R=I=v>>>0<16777216?I+1|0:I,o[A+12>>2]=L-(-33554432&v),I=kA(g,r,f,t),v=h,L=kA(x,a,x,a),v=h+v|0,v=(I=L+I|0)>>>0<L>>>0?v+1|0:v,L=kA(C,E,O,y),v=h+v|0,v=(I=L+I|0)>>>0<L>>>0?v+1|0:v,L=(x=kA(q,B,S,_))+I|0,I=h+v|0,I=L>>>0<x>>>0?I+1|0:I,v=(x=kA(X,Q,w,F))+L|0,L=h+I|0,L=v>>>0<x>>>0?L+1|0:L,I=(x=kA(I=l,i,l=J,O=l>>31))+v|0,v=h+L|0,v=I>>>0<x>>>0?v+1|0:v,L=I,v=(I=u>>25)+v|0,v=(L=L+(u=(33554431&u)<<7|IA>>>25)|0)>>>0<u>>>0?v+1|0:v,x=I=L+33554432|0,u=v=I>>>0<33554432?v+1|0:v,o[A+32>>2]=L-(-67108864&I),v=R>>25,L=(R=(33554431&R)<<7|j>>>25)+(U-(I=-67108864&d)|0)|0,I=v+(Y-((I>>>0>U>>>0)+K|0)|0)|0,I=L>>>0<R>>>0?I+1|0:I,R=L,I=((67108863&(v=(L=L+33554432|0)>>>0<33554432?I+1|0:I))<<6|L>>>26)+(z=CA-(-33554432&b)|0)|0,o[A+20>>2]=I,o[A+16>>2]=R-(-67108864&L),I=kA(C,E,g,r),L=h,v=(R=kA(e,H,T,N))+I|0,I=h+L|0,I=v>>>0<R>>>0?I+1|0:I,L=(R=kA(f,t,n,p))+v|0,v=h+I|0,v=L>>>0<R>>>0?v+1|0:v,I=(R=kA(q,B,w,F))+L|0,L=h+v|0,L=I>>>0<R>>>0?L+1|0:L,R=(v=I)+(I=kA(X,Q,l,O))|0,v=h+L|0,v=(I=I>>>0>R>>>0?v+1|0:v)+(v=u>>26)|0,I=(L=(u=(67108863&u)<<6|x>>>26)+R|0)>>>0<u>>>0?v+1|0:v,I=(v=L+16777216|0)>>>0<16777216?I+1|0:I,o[A+36>>2]=L-(-33554432&v),u=$-(-33554432&BA)|0,R=m-(L=-67108864&gA)|0,q=W-((L>>>0>m>>>0)+P|0)|0,I=kA((33554431&I)<<7|v>>>25,I>>25,19,0),v=h+q|0,I=I>>>0>(L=I+R|0)>>>0?v+1|0:v,I=((67108863&(I=(v=L+33554432|0)>>>0<33554432?I+1|0:I))<<6|v>>>26)+u|0,o[A+4>>2]=I,o[A>>2]=L-(-67108864&v)}function p(A,I,g,C,B){var Q,i,f,c,e,r,D,t,y,h,n,s,k,F,S,H=0,G=0,_=0,M=0,p=0,N=0,J=0,U=0,Y=0,d=0,K=0,b=0,P=0,v=0,L=0,R=0,u=0,x=0,m=0,l=0,z=0,q=0,X=0,j=0,T=0,O=0,V=0,Z=0,W=0,$=0,AA=0,IA=0,gA=0,CA=0;for(Q=w+-64|0,i=o[A+60>>2],f=o[A+56>>2],l=o[A+52>>2],m=o[A+48>>2],c=o[A+44>>2],e=o[A+40>>2],r=o[A+36>>2],D=o[A+32>>2],t=o[A+28>>2],y=o[A+24>>2],h=o[A+20>>2],n=o[A+16>>2],s=o[A+12>>2],k=o[A+8>>2],F=o[A+4>>2],S=o[A>>2];;){if(!B&C>>>0>63|B)H=g;else{if(o[Q+56>>2]=0,o[Q+60>>2]=0,o[Q+48>>2]=0,o[Q+52>>2]=0,o[Q+40>>2]=0,o[Q+44>>2]=0,o[Q+32>>2]=0,o[Q+36>>2]=0,o[Q+24>>2]=0,o[Q+28>>2]=0,o[Q+16>>2]=0,o[Q+20>>2]=0,o[Q+8>>2]=0,o[Q+12>>2]=0,o[Q>>2]=0,o[Q+4>>2]=0,_=0,C|B)for(;E[_+Q|0]=a[I+_|0],!B&(_=_+1|0)>>>0<C>>>0|B;);I=H=Q,T=g}for(z=20,G=S,d=F,K=k,v=s,_=n,g=h,p=y,N=t,J=D,R=r,b=e,M=i,u=f,L=l,P=m,U=c;Y=_,G=RA((_=G+_|0)^P,16),Y=P=RA(Y^(J=G+J|0),12),P=RA((x=_+P|0)^G,8),_=RA(Y^(J=P+J|0),7),M=RA((G=N+v|0)^M,16),N=RA((U=M+U|0)^N,12),v=RA((K=p+K|0)^u,16),p=RA((b=v+b|0)^p,12),u=(q=G+N|0)+_|0,X=RA((K=p+K|0)^v,8),G=RA(u^X,16),v=RA((d=g+d|0)^L,16),g=RA((R=v+R|0)^g,12),Y=_,L=RA((d=g+d|0)^v,8),Y=RA(Y^(_=(j=L+R|0)+G|0),12),u=RA(G^(v=Y+u|0),8),_=RA((R=u+_|0)^Y,7),Y=J,J=K,G=RA(M^q,8),K=RA((M=G+U|0)^N,7),L=RA((J=J+K|0)^L,16),U=RA((N=Y+L|0)^K,12),L=RA(L^(K=U+J|0),8),N=RA((J=N+L|0)^U,7),U=M,M=d,d=RA((b=b+X|0)^p,7),p=U+(P=RA((M=M+d|0)^P,16))|0,U=M,M=RA(p^d,12),P=RA(P^(d=U+M|0),8),p=RA((U=p+P|0)^M,7),Y=b,M=G,G=RA(g^j,7),M=RA(M^(b=G+x|0),16),x=RA((g=Y+M|0)^G,12),M=RA(M^(G=x+b|0),8),g=RA((b=g+M|0)^x,7),z=z-2|0;);if(z=a[I+4|0]|a[I+5|0]<<8|a[I+6|0]<<16|a[I+7|0]<<24,x=a[I+8|0]|a[I+9|0]<<8|a[I+10|0]<<16|a[I+11|0]<<24,q=a[I+12|0]|a[I+13|0]<<8|a[I+14|0]<<16|a[I+15|0]<<24,X=a[I+16|0]|a[I+17|0]<<8|a[I+18|0]<<16|a[I+19|0]<<24,j=a[I+20|0]|a[I+21|0]<<8|a[I+22|0]<<16|a[I+23|0]<<24,Y=a[I+24|0]|a[I+25|0]<<8|a[I+26|0]<<16|a[I+27|0]<<24,O=a[I+28|0]|a[I+29|0]<<8|a[I+30|0]<<16|a[I+31|0]<<24,V=a[I+32|0]|a[I+33|0]<<8|a[I+34|0]<<16|a[I+35|0]<<24,Z=a[I+36|0]|a[I+37|0]<<8|a[I+38|0]<<16|a[I+39|0]<<24,W=a[I+40|0]|a[I+41|0]<<8|a[I+42|0]<<16|a[I+43|0]<<24,$=a[I+44|0]|a[I+45|0]<<8|a[I+46|0]<<16|a[I+47|0]<<24,AA=a[I+48|0]|a[I+49|0]<<8|a[I+50|0]<<16|a[I+51|0]<<24,IA=a[I+52|0]|a[I+53|0]<<8|a[I+54|0]<<16|a[I+55|0]<<24,gA=a[I+56|0]|a[I+57|0]<<8|a[I+58|0]<<16|a[I+59|0]<<24,CA=a[I+60|0]|a[I+61|0]<<8|a[I+62|0]<<16|a[I+63|0]<<24,G=G+S^(a[0|I]|a[I+1|0]<<8|a[I+2|0]<<16|a[I+3|0]<<24),E[0|H]=G,E[H+1|0]=G>>>8,E[H+2|0]=G>>>16,E[H+3|0]=G>>>24,G=M+i^CA,E[H+60|0]=G,E[H+61|0]=G>>>8,E[H+62|0]=G>>>16,E[H+63|0]=G>>>24,G=u+f^gA,E[H+56|0]=G,E[H+57|0]=G>>>8,E[H+58|0]=G>>>16,E[H+59|0]=G>>>24,G=L+l^IA,E[H+52|0]=G,E[H+53|0]=G>>>8,E[H+54|0]=G>>>16,E[H+55|0]=G>>>24,G=P+m^AA,E[H+48|0]=G,E[H+49|0]=G>>>8,E[H+50|0]=G>>>16,E[H+51|0]=G>>>24,G=U+c^$,E[H+44|0]=G,E[H+45|0]=G>>>8,E[H+46|0]=G>>>16,E[H+47|0]=G>>>24,G=b+e^W,E[H+40|0]=G,E[H+41|0]=G>>>8,E[H+42|0]=G>>>16,E[H+43|0]=G>>>24,G=R+r^Z,E[H+36|0]=G,E[H+37|0]=G>>>8,E[H+38|0]=G>>>16,E[H+39|0]=G>>>24,G=J+D^V,E[H+32|0]=G,E[H+33|0]=G>>>8,E[H+34|0]=G>>>16,E[H+35|0]=G>>>24,N=N+t^O,E[H+28|0]=N,E[H+29|0]=N>>>8,E[H+30|0]=N>>>16,E[H+31|0]=N>>>24,p=Y^p+y,E[H+24|0]=p,E[H+25|0]=p>>>8,E[H+26|0]=p>>>16,E[H+27|0]=p>>>24,g=j^g+h,E[H+20|0]=g,E[H+21|0]=g>>>8,E[H+22|0]=g>>>16,E[H+23|0]=g>>>24,g=X^_+n,E[H+16|0]=g,E[H+17|0]=g>>>8,E[H+18|0]=g>>>16,E[H+19|0]=g>>>24,g=q^v+s,E[H+12|0]=g,E[H+13|0]=g>>>8,E[H+14|0]=g>>>16,E[H+15|0]=g>>>24,g=x^K+k,E[H+8|0]=g,E[H+9|0]=g>>>8,E[H+10|0]=g>>>16,E[H+11|0]=g>>>24,g=z^d+F,E[H+4|0]=g,E[H+5|0]=g>>>8,E[H+6|0]=g>>>16,E[H+7|0]=g>>>24,l=!(m=m+1|0)+l|0,!B&C>>>0<=64){if(!(!C|!B&C>>>0>63|0!=(0|B)))for(_=0;E[_+T|0]=a[H+_|0],C>>>0>(_=_+1|0)>>>0;);o[A+52>>2]=l,o[A+48>>2]=m;break}I=I- -64|0,g=H- -64|0,B=B-1|0,B=(C=C+-64|0)>>>0<4294967232?B+1|0:B}}function N(A,I){var g,C=0,B=0,Q=0,i=0,a=0,f=0,c=0;w=g=w-704|0,C=80+((B=o[A+72>>2]>>>3&127)+A|0)|0,B>>>0>=112?(YA(C,35008,128-B|0),k(A,B=A+80|0,g,g+640|0),dA(B,0,112)):YA(C,35008,112-B|0),f=(Q=o[A+64>>2])<<24|(65280&Q)<<8,B=(i=16711680&Q)>>>8|0,c=i<<24,i=(a=-16777216&Q)>>>24|0,C=c|a<<8|-16777216&((255&(C=o[A+68>>2]))<<24|Q>>>8)|16711680&((16777215&C)<<8|Q>>>24)|C>>>8&65280|C>>>24,E[A+192|0]=C,E[A+193|0]=C>>>8,E[A+194|0]=C>>>16,E[A+195|0]=C>>>24,B=(C=B|i|f)|(B=0)|B|0,E[A+196|0]=B,E[A+197|0]=B>>>8,E[A+198|0]=B>>>16,E[A+199|0]=B>>>24,f=(Q=o[A+72>>2])<<24|(65280&Q)<<8,B=(i=16711680&Q)>>>8|0,c=i<<24,i=(a=-16777216&Q)>>>24|0,C=c|a<<8|-16777216&((255&(C=o[A+76>>2]))<<24|Q>>>8)|16711680&((16777215&C)<<8|Q>>>24)|C>>>8&65280|C>>>24,E[A+200|0]=C,E[A+201|0]=C>>>8,E[A+202|0]=C>>>16,E[A+203|0]=C>>>24,B=(C=B|i|f)|(B=0)|B|0,E[A+204|0]=B,E[A+205|0]=B>>>8,E[A+206|0]=B>>>16,E[A+207|0]=B>>>24,k(A,A+80|0,g,g+640|0),f=(Q=o[A>>2])<<24|(65280&Q)<<8,B=(i=16711680&Q)>>>8|0,c=i<<24,i=(a=-16777216&Q)>>>24|0,C=c|a<<8|-16777216&((255&(C=o[A+4>>2]))<<24|Q>>>8)|16711680&((16777215&C)<<8|Q>>>24)|C>>>8&65280|C>>>24,E[0|I]=C,E[I+1|0]=C>>>8,E[I+2|0]=C>>>16,E[I+3|0]=C>>>24,B=(C=B|i|f)|(B=0)|B|0,E[I+4|0]=B,E[I+5|0]=B>>>8,E[I+6|0]=B>>>16,E[I+7|0]=B>>>24,f=(Q=o[A+8>>2])<<24|(65280&Q)<<8,B=(i=16711680&Q)>>>8|0,c=i<<24,i=(a=-16777216&Q)>>>24|0,C=c|a<<8|-16777216&((255&(C=o[A+12>>2]))<<24|Q>>>8)|16711680&((16777215&C)<<8|Q>>>24)|C>>>8&65280|C>>>24,E[I+8|0]=C,E[I+9|0]=C>>>8,E[I+10|0]=C>>>16,E[I+11|0]=C>>>24,B=(C=B|i|f)|(B=0)|B|0,E[I+12|0]=B,E[I+13|0]=B>>>8,E[I+14|0]=B>>>16,E[I+15|0]=B>>>24,f=(Q=o[A+16>>2])<<24|(65280&Q)<<8,B=(i=16711680&Q)>>>8|0,c=i<<24,i=(a=-16777216&Q)>>>24|0,C=c|a<<8|-16777216&((255&(C=o[A+20>>2]))<<24|Q>>>8)|16711680&((16777215&C)<<8|Q>>>24)|C>>>8&65280|C>>>24,E[I+16|0]=C,E[I+17|0]=C>>>8,E[I+18|0]=C>>>16,E[I+19|0]=C>>>24,B=(C=B|i|f)|(B=0)|B|0,E[I+20|0]=B,E[I+21|0]=B>>>8,E[I+22|0]=B>>>16,E[I+23|0]=B>>>24,f=(Q=o[A+24>>2])<<24|(65280&Q)<<8,B=(i=16711680&Q)>>>8|0,c=i<<24,i=(a=-16777216&Q)>>>24|0,C=c|a<<8|-16777216&((255&(C=o[A+28>>2]))<<24|Q>>>8)|16711680&((16777215&C)<<8|Q>>>24)|C>>>8&65280|C>>>24,E[I+24|0]=C,E[I+25|0]=C>>>8,E[I+26|0]=C>>>16,E[I+27|0]=C>>>24,B=(C=B|i|f)|(B=0)|B|0,E[I+28|0]=B,E[I+29|0]=B>>>8,E[I+30|0]=B>>>16,E[I+31|0]=B>>>24,f=(Q=o[A+32>>2])<<24|(65280&Q)<<8,B=(i=16711680&Q)>>>8|0,c=i<<24,i=(a=-16777216&Q)>>>24|0,C=c|a<<8|-16777216&((255&(C=o[A+36>>2]))<<24|Q>>>8)|16711680&((16777215&C)<<8|Q>>>24)|C>>>8&65280|C>>>24,E[I+32|0]=C,E[I+33|0]=C>>>8,E[I+34|0]=C>>>16,E[I+35|0]=C>>>24,B=(C=B|i|f)|(B=0)|B|0,E[I+36|0]=B,E[I+37|0]=B>>>8,E[I+38|0]=B>>>16,E[I+39|0]=B>>>24,f=(Q=o[A+40>>2])<<24|(65280&Q)<<8,B=(i=16711680&Q)>>>8|0,c=i<<24,i=(a=-16777216&Q)>>>24|0,C=c|a<<8|-16777216&((255&(C=o[A+44>>2]))<<24|Q>>>8)|16711680&((16777215&C)<<8|Q>>>24)|C>>>8&65280|C>>>24,E[I+40|0]=C,E[I+41|0]=C>>>8,E[I+42|0]=C>>>16,E[I+43|0]=C>>>24,B=(C=B|i|f)|(B=0)|B|0,E[I+44|0]=B,E[I+45|0]=B>>>8,E[I+46|0]=B>>>16,E[I+47|0]=B>>>24,f=(Q=o[A+48>>2])<<24|(65280&Q)<<8,B=(i=16711680&Q)>>>8|0,c=i<<24,i=(a=-16777216&Q)>>>24|0,C=c|a<<8|-16777216&((255&(C=o[A+52>>2]))<<24|Q>>>8)|16711680&((16777215&C)<<8|Q>>>24)|C>>>8&65280|C>>>24,E[I+48|0]=C,E[I+49|0]=C>>>8,E[I+50|0]=C>>>16,E[I+51|0]=C>>>24,B=(C=B|i|f)|(B=0)|B|0,E[I+52|0]=B,E[I+53|0]=B>>>8,E[I+54|0]=B>>>16,E[I+55|0]=B>>>24,f=(Q=o[A+56>>2])<<24|(65280&Q)<<8,B=(i=16711680&Q)>>>8|0,C=I,c=i<<24,i=(a=-16777216&Q)>>>24|0,I=c|a<<8|-16777216&((255&(I=o[A+60>>2]))<<24|Q>>>8)|16711680&((16777215&I)<<8|Q>>>24)|I>>>8&65280|I>>>24,E[C+56|0]=I,E[C+57|0]=I>>>8,E[C+58|0]=I>>>16,E[C+59|0]=I>>>24,I=(I=B|i|f)|(B=0)|B|0,E[C+60|0]=I,E[C+61|0]=I>>>8,E[C+62|0]=I>>>16,E[C+63|0]=I>>>24,iI(g,704),iI(A,208),w=g+704|0}function J(A,I,g){var C,B=0,i=0,f=0,c=0,e=0,r=0;w=C=w+-64|0;A:{if((g-65&255)>>>0>191){if(B=-1,!(a[A+80|0]|a[A+81|0]<<8|a[A+82|0]<<16|a[A+83|0]<<24|a[A+84|0]|a[A+85|0]<<8|a[A+86|0]<<16|a[A+87|0]<<24)){if((c=a[A+352|0]|a[A+353|0]<<8|a[A+354|0]<<16|a[A+355|0]<<24)>>>0>=129){if(f=a[0|(B=A- -64|0)]|a[B+1|0]<<8|a[B+2|0]<<16|a[B+3|0]<<24,e=i=a[B+4|0]|a[B+5|0]<<8|a[B+6|0]<<16|a[B+7|0]<<24,i=(c=f+128|0)>>>0<128?i+1|0:i,E[0|B]=c,E[B+1|0]=c>>>8,E[B+2|0]=c>>>16,E[B+3|0]=c>>>24,E[B+4|0]=i,E[B+5|0]=i>>>8,E[B+6|0]=i>>>16,E[B+7|0]=i>>>24,i=a[A+76|0]|a[A+77|0]<<8|a[A+78|0]<<16|a[A+79|0]<<24,i=(B=-1==(0|e)&f>>>0>4294967167)>>>0>(f=B+(a[A+72|0]|a[A+73|0]<<8|a[A+74|0]<<16|a[A+75|0]<<24)|0)>>>0?i+1|0:i,E[A+72|0]=f,E[A+73|0]=f>>>8,E[A+74|0]=f>>>16,E[A+75|0]=f>>>24,E[A+76|0]=i,E[A+77|0]=i>>>8,E[A+78|0]=i>>>16,E[A+79|0]=i>>>24,n(A,i=A+96|0),B=(a[A+352|0]|a[A+353|0]<<8|a[A+354|0]<<16|a[A+355|0]<<24)-128|0,E[A+352|0]=B,E[A+353|0]=B>>>8,E[A+354|0]=B>>>16,E[A+355|0]=B>>>24,B>>>0>=129)break A;YA(i,A+224|0,B),c=a[A+352|0]|a[A+353|0]<<8|a[A+354|0]<<16|a[A+355|0]<<24}i=a[0|(B=A- -64|0)]|a[B+1|0]<<8|a[B+2|0]<<16|a[B+3|0]<<24,f=r=a[B+4|0]|a[B+5|0]<<8|a[B+6|0]<<16|a[B+7|0]<<24,f=(e=i+c|0)>>>0<c>>>0?f+1|0:f,E[0|B]=e,E[B+1|0]=e>>>8,E[B+2|0]=e>>>16,E[B+3|0]=e>>>24,E[B+4|0]=f,E[B+5|0]=f>>>8,E[B+6|0]=f>>>16,E[B+7|0]=f>>>24,B=(0|f)==(0|r)&i>>>0>e>>>0|f>>>0<r>>>0,i=a[A+76|0]|a[A+77|0]<<8|a[A+78|0]<<16|a[A+79|0]<<24,i=(f=B+(a[A+72|0]|a[A+73|0]<<8|a[A+74|0]<<16|a[A+75|0]<<24)|0)>>>0<B>>>0?i+1|0:i,E[A+72|0]=f,E[A+73|0]=f>>>8,E[A+74|0]=f>>>16,E[A+75|0]=f>>>24,E[A+76|0]=i,E[A+77|0]=i>>>8,E[A+78|0]=i>>>16,E[A+79|0]=i>>>24,a[A+356|0]&&(E[A+88|0]=255,E[A+89|0]=255,E[A+90|0]=255,E[A+91|0]=255,E[A+92|0]=255,E[A+93|0]=255,E[A+94|0]=255,E[A+95|0]=255),E[A+80|0]=255,E[A+81|0]=255,E[A+82|0]=255,E[A+83|0]=255,E[A+84|0]=255,E[A+85|0]=255,E[A+86|0]=255,E[A+87|0]=255,dA((B=A+96|0)+c|0,0,256-c|0),n(A,B),i=a[A+4|0]|a[A+5|0]<<8|a[A+6|0]<<16|a[A+7|0]<<24,o[C>>2]=a[0|A]|a[A+1|0]<<8|a[A+2|0]<<16|a[A+3|0]<<24,o[C+4>>2]=i,i=a[A+12|0]|a[A+13|0]<<8|a[A+14|0]<<16|a[A+15|0]<<24,o[C+8>>2]=a[A+8|0]|a[A+9|0]<<8|a[A+10|0]<<16|a[A+11|0]<<24,o[C+12>>2]=i,i=a[A+20|0]|a[A+21|0]<<8|a[A+22|0]<<16|a[A+23|0]<<24,o[C+16>>2]=a[A+16|0]|a[A+17|0]<<8|a[A+18|0]<<16|a[A+19|0]<<24,o[C+20>>2]=i,i=a[A+28|0]|a[A+29|0]<<8|a[A+30|0]<<16|a[A+31|0]<<24,o[C+24>>2]=a[A+24|0]|a[A+25|0]<<8|a[A+26|0]<<16|a[A+27|0]<<24,o[C+28>>2]=i,i=a[A+36|0]|a[A+37|0]<<8|a[A+38|0]<<16|a[A+39|0]<<24,o[C+32>>2]=a[A+32|0]|a[A+33|0]<<8|a[A+34|0]<<16|a[A+35|0]<<24,o[C+36>>2]=i,i=a[A+44|0]|a[A+45|0]<<8|a[A+46|0]<<16|a[A+47|0]<<24,o[C+40>>2]=a[A+40|0]|a[A+41|0]<<8|a[A+42|0]<<16|a[A+43|0]<<24,o[C+44>>2]=i,i=a[A+52|0]|a[A+53|0]<<8|a[A+54|0]<<16|a[A+55|0]<<24,o[C+48>>2]=a[A+48|0]|a[A+49|0]<<8|a[A+50|0]<<16|a[A+51|0]<<24,o[C+52>>2]=i,i=a[A+60|0]|a[A+61|0]<<8|a[A+62|0]<<16|a[A+63|0]<<24,o[C+56>>2]=a[A+56|0]|a[A+57|0]<<8|a[A+58|0]<<16|a[A+59|0]<<24,o[C+60>>2]=i,YA(I,C,g),iI(A,64),iI(B,256),B=0}return w=C- -64|0,B}zA(),Q()}D(1280,1142,306,1086),Q()}function U(A,I){var g,C,B,Q,i,f,c,e,r,D,t,y,h,n,s,k,F=0,S=0,G=0,_=0,p=0,N=0,J=0;for(w=g=w-320|0,L(C=A+40|0,I),o[A+84>>2]=0,o[A+88>>2]=0,o[A+80>>2]=1,o[A+92>>2]=0,o[A+96>>2]=0,o[A+100>>2]=0,o[A+104>>2]=0,o[A+108>>2]=0,o[A+112>>2]=0,o[A+116>>2]=0,M(N=g+240|0,C),H(_=g+192|0,N,1344),J=-1,B=o[g+240>>2]-1|0,o[g+240>>2]=B,o[g+192>>2]=o[g+192>>2]+1,Q=o[g+244>>2],i=o[g+248>>2],f=o[g+252>>2],c=o[g+256>>2],e=o[g+260>>2],r=o[g+264>>2],D=o[g+268>>2],t=o[g+272>>2],y=o[g+276>>2],M(p=g+144|0,_),H(p,p,_),M(A,p),H(A,A,_),H(A,A,N),w=S=w-144|0,M(G=S+96|0,A),M(F=S+48|0,G),M(F,F),H(F,A,F),H(G,G,F),M(G,G),H(G,F,G),M(F,G),M(F,F),M(F,F),M(F,F),M(F,F),H(G,F,G),M(F,G),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),H(F,F,G),M(S,F),M(S,S),M(S,S),M(S,S),M(S,S),M(S,S),M(S,S),M(S,S),M(S,S),M(S,S),M(S,S),M(S,S),M(S,S),M(S,S),M(S,S),M(S,S),M(S,S),M(S,S),M(S,S),M(S,S),H(F,S,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),H(G,F,G),M(F,G),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),H(F,F,G),M(S,F),F=1;M(S,S),100!=(0|(F=F+1|0)););H(F=S+48|0,S,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),M(F,F),H(G=S+96|0,F,G),M(G,G),M(G,G),H(A,G,A),w=S+144|0,H(A,A,p),H(A,A,N),M(F=g+96|0,A),H(F,F,_),F=o[g+132>>2],o[g+84>>2]=F-y,S=o[g+128>>2],o[g+80>>2]=S-t,G=o[g+124>>2],o[g+76>>2]=G-D,_=o[g+120>>2],o[g+72>>2]=_-r,p=o[g+116>>2],o[g+68>>2]=p-e,N=o[g+112>>2],o[g+64>>2]=N-c,h=o[g+108>>2],o[g+60>>2]=h-f,n=o[g+104>>2],o[g+56>>2]=n-i,s=o[g+100>>2],o[g+52>>2]=s-Q,k=o[g+96>>2],o[g+48>>2]=k-B,IA(g,g+48|0);A:{if(!fA(g,32)){if(o[g+36>>2]=F+y,o[g+32>>2]=S+t,o[g+28>>2]=G+D,o[g+24>>2]=_+r,o[g+20>>2]=p+e,o[g+16>>2]=N+c,o[g+12>>2]=f+h,o[g+8>>2]=i+n,o[g+4>>2]=Q+s,o[g>>2]=B+k,IA(F=g+288|0,g),!fA(F,32))break A;H(A,A,1392)}IA(g+288|0,A),(1&E[g+288|0])==(a[I+31|0]>>>7|0)&&(o[A>>2]=0-o[A>>2],o[A+36>>2]=0-o[A+36>>2],o[A+32>>2]=0-o[A+32>>2],o[A+28>>2]=0-o[A+28>>2],o[A+24>>2]=0-o[A+24>>2],o[A+20>>2]=0-o[A+20>>2],o[A+16>>2]=0-o[A+16>>2],o[A+12>>2]=0-o[A+12>>2],o[A+8>>2]=0-o[A+8>>2],o[A+4>>2]=0-o[A+4>>2]),H(A+120|0,A,C),J=0}return w=g+320|0,J}function Y(A,I,g){var C,B,Q,i,o,f,c,e,r,D,t,y,w=0,h=0,n=0,s=0,k=0,F=0,S=0,H=0,G=0,_=0,M=0,p=0,N=0,J=0,U=0,Y=0,d=0,K=0,b=0,P=0;for(k=1634760805,h=C=a[0|g]|a[g+1|0]<<8|a[g+2|0]<<16|a[g+3|0]<<24,F=B=a[g+4|0]|a[g+5|0]<<8|a[g+6|0]<<16|a[g+7|0]<<24,S=Q=a[g+8|0]|a[g+9|0]<<8|a[g+10|0]<<16|a[g+11|0]<<24,H=i=a[g+12|0]|a[g+13|0]<<8|a[g+14|0]<<16|a[g+15|0]<<24,p=857760878,G=o=a[0|I]|a[I+1|0]<<8|a[I+2|0]<<16|a[I+3|0]<<24,n=f=a[I+4|0]|a[I+5|0]<<8|a[I+6|0]<<16|a[I+7|0]<<24,M=c=a[I+8|0]|a[I+9|0]<<8|a[I+10|0]<<16|a[I+11|0]<<24,J=e=a[I+12|0]|a[I+13|0]<<8|a[I+14|0]<<16|a[I+15|0]<<24,I=2036477234,s=r=a[g+16|0]|a[g+17|0]<<8|a[g+18|0]<<16|a[g+19|0]<<24,w=1797285236,U=D=a[g+28|0]|a[g+29|0]<<8|a[g+30|0]<<16|a[g+31|0]<<24,N=t=a[g+24|0]|a[g+25|0]<<8|a[g+26|0]<<16|a[g+27|0]<<24,g=y=a[g+20|0]|a[g+21|0]<<8|a[g+22|0]<<16|a[g+23|0]<<24;_=RA(h+p|0,7)^J,Y=RA(_+p|0,9)^N,H=RA(g+k|0,7)^H,d=RA(H+k|0,9)^M,b=RA(d+H|0,13)^g,S=RA(w+s|0,7)^S,K=RA(S+w|0,9)^n,M=RA(S+K|0,13)^s,s=RA(K+M|0,18)^w,n=RA(I+G|0,7)^U,g=b^RA(s+n|0,7),N=Y^RA(g+s|0,9),U=RA(g+N|0,13)^n,w=RA(N+U|0,18)^s,F=RA(I+n|0,9)^F,G=RA(F+n|0,13)^G,I=RA(G+F|0,18)^I,s=RA(I+_|0,7)^M,M=RA(s+I|0,9)^d,J=RA(s+M|0,13)^_,I=RA(M+J|0,18)^I,_=RA(_+Y|0,13)^h,h=RA(_+Y|0,18)^p,G=RA(h+H|0,7)^G,n=RA(G+h|0,9)^K,H=RA(n+G|0,13)^H,p=RA(n+H|0,18)^h,k=RA(d+b|0,18)^k,h=RA(k+S|0,7)^_,F=RA(h+k|0,9)^F,S=RA(h+F|0,13)^S,k=RA(F+S|0,18)^k,_=P>>>0<18,P=P+2|0,_;);w=w+1797285236|0,E[A+60|0]=w,E[A+61|0]=w>>>8,E[A+62|0]=w>>>16,E[A+63|0]=w>>>24,w=U+D|0,E[A+56|0]=w,E[A+57|0]=w>>>8,E[A+58|0]=w>>>16,E[A+59|0]=w>>>24,w=N+t|0,E[A+52|0]=w,E[A+53|0]=w>>>8,E[A+54|0]=w>>>16,E[A+55|0]=w>>>24,g=g+y|0,E[A+48|0]=g,E[A+49|0]=g>>>8,E[A+50|0]=g>>>16,E[A+51|0]=g>>>24,g=s+r|0,E[A+44|0]=g,E[A+45|0]=g>>>8,E[A+46|0]=g>>>16,E[A+47|0]=g>>>24,I=I+2036477234|0,E[A+40|0]=I,E[A+41|0]=I>>>8,E[A+42|0]=I>>>16,E[A+43|0]=I>>>24,I=J+e|0,E[A+36|0]=I,E[A+37|0]=I>>>8,E[A+38|0]=I>>>16,E[A+39|0]=I>>>24,I=M+c|0,E[A+32|0]=I,E[A+33|0]=I>>>8,E[A+34|0]=I>>>16,E[A+35|0]=I>>>24,I=n+f|0,E[A+28|0]=I,E[A+29|0]=I>>>8,E[A+30|0]=I>>>16,E[A+31|0]=I>>>24,I=G+o|0,E[A+24|0]=I,E[A+25|0]=I>>>8,E[A+26|0]=I>>>16,E[A+27|0]=I>>>24,I=p+857760878|0,E[A+20|0]=I,E[A+21|0]=I>>>8,E[A+22|0]=I>>>16,E[A+23|0]=I>>>24,I=H+i|0,E[A+16|0]=I,E[A+17|0]=I>>>8,E[A+18|0]=I>>>16,E[A+19|0]=I>>>24,I=S+Q|0,E[A+12|0]=I,E[A+13|0]=I>>>8,E[A+14|0]=I>>>16,E[A+15|0]=I>>>24,I=F+B|0,E[A+8|0]=I,E[A+9|0]=I>>>8,E[A+10|0]=I>>>16,E[A+11|0]=I>>>24,I=h+C|0,E[A+4|0]=I,E[A+5|0]=I>>>8,E[A+6|0]=I>>>16,E[A+7|0]=I>>>24,I=k+1634760805|0,E[0|A]=I,E[A+1|0]=I>>>8,E[A+2|0]=I>>>16,E[A+3|0]=I>>>24}function d(A,I,g,C){var B=0,Q=0,i=0,E=0,f=0,e=0,r=0,D=0,t=0,y=0,w=0,n=0,s=0,k=0,F=0,S=0,H=0,G=0,_=0,M=0,p=0,N=0,J=0,U=0,Y=0;if(w=o[A+36>>2],t=o[A+32>>2],y=o[A+28>>2],r=o[A+24>>2],D=o[A+20>>2],!C&g>>>0>=16|C)for(p=!a[A+80|0]<<24,s=o[A+4>>2],N=c(s,5),F=o[A+8>>2],_=c(F,5),H=o[A+12>>2],G=c(H,5),M=o[A+16>>2],S=c(M,5),k=o[A>>2];B=kA(i=((a[I+3|0]|a[I+4|0]<<8|a[I+5|0]<<16|a[I+6|0]<<24)>>>2&67108863)+r|0,0,H,0),f=h,D=(E=kA(r=(67108863&(a[0|I]|a[I+1|0]<<8|a[I+2|0]<<16|a[I+3|0]<<24))+D|0,0,M,0))+B|0,B=h+f|0,B=E>>>0>D>>>0?B+1|0:B,f=kA(y=((a[I+6|0]|a[I+7|0]<<8|a[I+8|0]<<16|a[I+9|0]<<24)>>>4&67108863)+y|0,0,F,0),B=h+B|0,B=f>>>0>(D=f+D|0)>>>0?B+1|0:B,f=kA(t=((a[I+9|0]|a[I+10|0]<<8|a[I+11|0]<<16|a[I+12|0]<<24)>>>6|0)+t|0,0,s,0),B=h+B|0,B=f>>>0>(D=f+D|0)>>>0?B+1|0:B,f=kA(w=w+p+((a[I+12|0]|a[I+13|0]<<8|a[I+14|0]<<16|a[I+15|0]<<24)>>>8)|0,0,k,0),B=h+B|0,J=D=f+D|0,D=f>>>0>D>>>0?B+1|0:B,B=kA(i,0,F,0),f=h,E=kA(r,0,H,0),Q=h+f|0,Q=(B=E+B|0)>>>0<E>>>0?Q+1|0:Q,f=(E=kA(y,0,s,0))+B|0,B=h+Q|0,B=E>>>0>f>>>0?B+1|0:B,E=kA(t,0,k,0),B=h+B|0,B=E>>>0>(f=E+f|0)>>>0?B+1|0:B,E=kA(w,0,S,0),B=h+B|0,U=f=E+f|0,f=E>>>0>f>>>0?B+1|0:B,B=kA(i,0,s,0),e=h,E=(Q=kA(r,0,F,0))+B|0,B=h+e|0,B=Q>>>0>E>>>0?B+1|0:B,e=kA(y,0,k,0),Q=h+B|0,Q=(E=e+E|0)>>>0<e>>>0?Q+1|0:Q,e=kA(t,0,S,0),B=h+Q|0,B=(E=e+E|0)>>>0<e>>>0?B+1|0:B,e=kA(w,0,G,0),B=h+B|0,Y=E=e+E|0,E=E>>>0<e>>>0?B+1|0:B,B=kA(i,0,k,0),Q=h,e=(n=kA(r,0,s,0))+B|0,B=h+Q|0,B=e>>>0<n>>>0?B+1|0:B,Q=kA(y,0,S,0),B=h+B|0,B=Q>>>0>(e=Q+e|0)>>>0?B+1|0:B,n=kA(t,0,G,0),Q=h+B|0,Q=(e=n+e|0)>>>0<n>>>0?Q+1|0:Q,n=kA(w,0,_,0),B=h+Q|0,B=(e=n+e|0)>>>0<n>>>0?B+1|0:B,n=e,e=B,B=kA(i,0,S,0),Q=h,i=(r=kA(r,0,k,0))+B|0,B=h+Q|0,B=i>>>0<r>>>0?B+1|0:B,r=kA(y,0,G,0),B=h+B|0,B=(i=r+i|0)>>>0<r>>>0?B+1|0:B,r=kA(t,0,_,0),B=h+B|0,B=(i=r+i|0)>>>0<r>>>0?B+1|0:B,r=kA(w,0,N,0),Q=h+B|0,Q=(i=r+i|0)>>>0<r>>>0?Q+1|0:Q,r=i,B=e,B=(i=(y=(67108863&Q)<<6|i>>>26)+n|0)>>>0<y>>>0?B+1|0:B,y=i,t=(67108863&B)<<6|i>>>26,B=E,B=(i=t+Y|0)>>>0<t>>>0?B+1|0:B,t=i,Q=f,w=B=(i=(67108863&B)<<6|i>>>26)+U|0,f=(67108863&(Q=B>>>0<i>>>0?Q+1|0:Q))<<6|B>>>26,B=D,r=(67108863&y)+((B=c((67108863&((i=f+J|0)>>>0<f>>>0?B+1|0:B))<<6|i>>>26,5)+(67108863&r)|0)>>>26|0)|0,y=67108863&t,t=67108863&w,w=67108863&i,D=67108863&B,I=I+16|0,!(C=C-(g>>>0<16)|0)&(g=g-16|0)>>>0>15|C;);o[A+20>>2]=D,o[A+36>>2]=w,o[A+32>>2]=t,o[A+28>>2]=y,o[A+24>>2]=r}function K(A,I,g,C){A|=0,I|=0;var B=0;return B=-1,(C|=0)-65>>>0<4294967232|(g|=0)>>>0>64||(g&&I?(w=B=w-128|0,!I|((C&=255)-65&255)>>>0<=191|((g&=255)-65&255)>>>0<=191?(zA(),Q()):(dA(A- -64|0,0,293),E[A+56|0]=121,E[A+57|0]=33,E[A+58|0]=126,E[A+59|0]=19,E[A+60|0]=25,E[A+61|0]=205,E[A+62|0]=224,E[A+63|0]=91,E[A+48|0]=107,E[A+49|0]=189,E[A+50|0]=65,E[A+51|0]=251,E[A+52|0]=171,E[A+53|0]=217,E[A+54|0]=131,E[A+55|0]=31,E[A+40|0]=31,E[A+41|0]=108,E[A+42|0]=62,E[A+43|0]=43,E[A+44|0]=140,E[A+45|0]=104,E[A+46|0]=5,E[A+47|0]=155,E[A+32|0]=209,E[A+33|0]=130,E[A+34|0]=230,E[A+35|0]=173,E[A+36|0]=127,E[A+37|0]=82,E[A+38|0]=14,E[A+39|0]=81,E[A+24|0]=241,E[A+25|0]=54,E[A+26|0]=29,E[A+27|0]=95,E[A+28|0]=58,E[A+29|0]=245,E[A+30|0]=79,E[A+31|0]=165,E[A+16|0]=43,E[A+17|0]=248,E[A+18|0]=148,E[A+19|0]=254,E[A+20|0]=114,E[A+21|0]=243,E[A+22|0]=110,E[A+23|0]=60,E[A+8|0]=59,E[A+9|0]=167,E[A+10|0]=202,E[A+11|0]=132,E[A+12|0]=133,E[A+13|0]=174,E[A+14|0]=103,E[A+15|0]=187,C=-222443256^(g<<8|C),E[0|A]=C,E[A+1|0]=C>>>8,E[A+2|0]=C>>>16,E[A+3|0]=C>>>24,C=g>>>24^1779033703,E[A+4|0]=C,E[A+5|0]=C>>>8,E[A+6|0]=C>>>16,E[A+7|0]=C>>>24,dA(g+B|0,0,g<<24>>24>=0?128-g|0:0),g=YA(B,I,g),YA(A+96|0,g,128),I=128+(a[A+352|0]|a[A+353|0]<<8|a[A+354|0]<<16|a[A+355|0]<<24)|0,E[A+352|0]=I,E[A+353|0]=I>>>8,E[A+354|0]=I>>>16,E[A+355|0]=I>>>24,iI(g,128),w=g+128|0)):(((I=255&C)-65&255)>>>0<=191&&(zA(),Q()),dA(A- -64|0,0,293),E[A+56|0]=121,E[A+57|0]=33,E[A+58|0]=126,E[A+59|0]=19,E[A+60|0]=25,E[A+61|0]=205,E[A+62|0]=224,E[A+63|0]=91,E[A+48|0]=107,E[A+49|0]=189,E[A+50|0]=65,E[A+51|0]=251,E[A+52|0]=171,E[A+53|0]=217,E[A+54|0]=131,E[A+55|0]=31,E[A+40|0]=31,E[A+41|0]=108,E[A+42|0]=62,E[A+43|0]=43,E[A+44|0]=140,E[A+45|0]=104,E[A+46|0]=5,E[A+47|0]=155,E[A+32|0]=209,E[A+33|0]=130,E[A+34|0]=230,E[A+35|0]=173,E[A+36|0]=127,E[A+37|0]=82,E[A+38|0]=14,E[A+39|0]=81,E[A+24|0]=241,E[A+25|0]=54,E[A+26|0]=29,E[A+27|0]=95,E[A+28|0]=58,E[A+29|0]=245,E[A+30|0]=79,E[A+31|0]=165,E[A+16|0]=43,E[A+17|0]=248,E[A+18|0]=148,E[A+19|0]=254,E[A+20|0]=114,E[A+21|0]=243,E[A+22|0]=110,E[A+23|0]=60,E[A+8|0]=59,E[A+9|0]=167,E[A+10|0]=202,E[A+11|0]=132,E[A+12|0]=133,E[A+13|0]=174,E[A+14|0]=103,E[A+15|0]=187,I^=-222443256,E[0|A]=I,E[A+1|0]=I>>>8,E[A+2|0]=I>>>16,E[A+3|0]=I>>>24,E[A+4|0]=103,E[A+5|0]=230,E[A+6|0]=9,E[A+7|0]=106),B=0),0|B}function b(A,I,g){var C,B,Q,i,E,a,f,c,e,r,D,t=0,y=0,w=0,h=0,n=0,s=0,k=0,F=0,S=0,G=0,_=0,M=0,p=0,N=0,J=0,U=0,Y=0,d=0,K=0;t=o[I+40>>2],y=o[I+4>>2],h=o[I+44>>2],n=o[I+8>>2],s=o[I+48>>2],k=o[I+12>>2],F=o[I+52>>2],S=o[I+16>>2],G=o[I+56>>2],_=o[I+20>>2],M=o[I+60>>2],p=o[I+24>>2],N=o[(w=I- -64|0)>>2],J=o[I+28>>2],U=o[I+68>>2],Y=o[I+32>>2],d=o[I+72>>2],K=o[I>>2],o[A+36>>2]=o[I+36>>2]+o[I+76>>2],o[A+32>>2]=Y+d,o[A+28>>2]=J+U,o[A+24>>2]=p+N,o[A+20>>2]=_+M,o[A+16>>2]=S+G,o[A+12>>2]=k+F,o[A+8>>2]=n+s,o[A+4>>2]=y+h,o[A>>2]=t+K,h=o[I+40>>2],t=o[I+4>>2],n=o[I+44>>2],s=o[I+8>>2],k=o[I+48>>2],F=o[I+12>>2],S=o[I+52>>2],G=o[I+16>>2],_=o[I+56>>2],M=o[I+20>>2],p=o[I+60>>2],N=o[I+24>>2],w=o[w>>2],y=o[I+28>>2],J=o[I+68>>2],U=o[I+32>>2],Y=o[I+72>>2],d=o[I>>2],o[A+76>>2]=o[I+76>>2]-o[I+36>>2],o[A+72>>2]=Y-U,o[A+68>>2]=J-y,o[(y=A- -64|0)>>2]=w-N,o[A+60>>2]=p-M,o[A+56>>2]=_-G,o[A+52>>2]=S-F,o[A+48>>2]=k-s,o[A+44>>2]=n-t,o[(t=A+40|0)>>2]=h-d,H(A+80|0,A,g),H(t,t,g+40|0),H(A+120|0,g+120|0,I+120|0),H(A,I+80|0,g+80|0),K=o[A+4>>2],Q=o[A+8>>2],i=o[A+12>>2],E=o[A+16>>2],a=o[A+20>>2],f=o[A+24>>2],c=o[A+28>>2],e=o[A+32>>2],r=o[A+36>>2],I=o[t>>2],g=o[A+80>>2],h=o[A+44>>2],n=o[A+84>>2],s=o[A+48>>2],k=o[A+88>>2],F=o[A+52>>2],S=o[A+92>>2],G=o[A+56>>2],_=o[A+96>>2],M=o[A+60>>2],p=o[A+100>>2],w=o[y>>2],N=o[A+104>>2],J=o[A+68>>2],U=o[A+108>>2],Y=o[A+72>>2],d=o[A+112>>2],D=o[A>>2],C=o[A+76>>2],B=o[A+116>>2],o[A+76>>2]=C+B,o[A+72>>2]=Y+d,o[A+68>>2]=J+U,o[y>>2]=w+N,o[A+60>>2]=M+p,o[A+56>>2]=G+_,o[A+52>>2]=F+S,o[A+48>>2]=s+k,o[A+44>>2]=h+n,o[t>>2]=I+g,o[A+36>>2]=B-C,o[A+32>>2]=d-Y,o[A+28>>2]=U-J,o[A+24>>2]=N-w,o[A+20>>2]=p-M,o[A+16>>2]=_-G,o[A+12>>2]=S-F,o[A+8>>2]=k-s,o[A+4>>2]=n-h,o[A>>2]=g-I,I=r<<1,g=o[A+156>>2],o[A+156>>2]=I-g,t=e<<1,y=o[A+152>>2],o[A+152>>2]=t-y,h=c<<1,n=o[A+148>>2],o[A+148>>2]=h-n,s=f<<1,k=o[A+144>>2],o[A+144>>2]=s-k,F=a<<1,S=o[A+140>>2],o[A+140>>2]=F-S,G=E<<1,_=o[A+136>>2],o[A+136>>2]=G-_,M=i<<1,p=o[A+132>>2],o[A+132>>2]=M-p,w=Q<<1,N=o[A+128>>2],o[A+128>>2]=w-N,J=K<<1,U=o[A+124>>2],o[A+124>>2]=J-U,Y=D<<1,d=o[A+120>>2],o[A+120>>2]=Y-d,o[A+112>>2]=t+y,o[A+108>>2]=h+n,o[A+104>>2]=s+k,o[A+100>>2]=F+S,o[A+96>>2]=G+_,o[A+92>>2]=M+p,o[A+88>>2]=w+N,o[A+84>>2]=J+U,o[A+80>>2]=Y+d,o[A+116>>2]=I+g}function P(A,I,g){var C,B,Q,i,E,a,f,c,e,r,D,t=0,y=0,w=0,h=0,n=0,s=0,k=0,F=0,S=0,G=0,_=0,M=0,p=0,N=0,J=0,U=0,Y=0,d=0,K=0;t=o[I+40>>2],y=o[I+4>>2],h=o[I+44>>2],n=o[I+8>>2],s=o[I+48>>2],k=o[I+12>>2],F=o[I+52>>2],S=o[I+16>>2],G=o[I+56>>2],_=o[I+20>>2],M=o[I+60>>2],p=o[I+24>>2],N=o[(w=I- -64|0)>>2],J=o[I+28>>2],U=o[I+68>>2],Y=o[I+32>>2],d=o[I+72>>2],K=o[I>>2],o[A+36>>2]=o[I+36>>2]+o[I+76>>2],o[A+32>>2]=Y+d,o[A+28>>2]=J+U,o[A+24>>2]=p+N,o[A+20>>2]=_+M,o[A+16>>2]=S+G,o[A+12>>2]=k+F,o[A+8>>2]=n+s,o[A+4>>2]=y+h,o[A>>2]=t+K,h=o[I+40>>2],t=o[I+4>>2],n=o[I+44>>2],s=o[I+8>>2],k=o[I+48>>2],F=o[I+12>>2],S=o[I+52>>2],G=o[I+16>>2],_=o[I+56>>2],M=o[I+20>>2],p=o[I+60>>2],N=o[I+24>>2],w=o[w>>2],y=o[I+28>>2],J=o[I+68>>2],U=o[I+32>>2],Y=o[I+72>>2],d=o[I>>2],o[A+76>>2]=o[I+76>>2]-o[I+36>>2],o[A+72>>2]=Y-U,o[A+68>>2]=J-y,o[(y=A- -64|0)>>2]=w-N,o[A+60>>2]=p-M,o[A+56>>2]=_-G,o[A+52>>2]=S-F,o[A+48>>2]=k-s,o[A+44>>2]=n-t,o[(t=A+40|0)>>2]=h-d,H(A+80|0,A,g+40|0),H(t,t,g),H(A+120|0,g+120|0,I+120|0),H(A,I+80|0,g+80|0),K=o[A+4>>2],Q=o[A+8>>2],i=o[A+12>>2],E=o[A+16>>2],a=o[A+20>>2],f=o[A+24>>2],c=o[A+28>>2],e=o[A+32>>2],r=o[A+36>>2],I=o[t>>2],g=o[A+80>>2],h=o[A+44>>2],n=o[A+84>>2],s=o[A+48>>2],k=o[A+88>>2],F=o[A+52>>2],S=o[A+92>>2],G=o[A+56>>2],_=o[A+96>>2],M=o[A+60>>2],p=o[A+100>>2],w=o[y>>2],N=o[A+104>>2],J=o[A+68>>2],U=o[A+108>>2],Y=o[A+72>>2],d=o[A+112>>2],D=o[A>>2],C=o[A+76>>2],B=o[A+116>>2],o[A+76>>2]=C+B,o[A+72>>2]=Y+d,o[A+68>>2]=J+U,o[y>>2]=w+N,o[A+60>>2]=M+p,o[A+56>>2]=G+_,o[A+52>>2]=F+S,o[A+48>>2]=s+k,o[A+44>>2]=h+n,o[t>>2]=I+g,o[A+36>>2]=B-C,o[A+32>>2]=d-Y,o[A+28>>2]=U-J,o[A+24>>2]=N-w,o[A+20>>2]=p-M,o[A+16>>2]=_-G,o[A+12>>2]=S-F,o[A+8>>2]=k-s,o[A+4>>2]=n-h,o[A>>2]=g-I,I=o[A+156>>2],g=r<<1,o[A+156>>2]=I+g,t=o[A+152>>2],y=e<<1,o[A+152>>2]=t+y,h=o[A+148>>2],n=c<<1,o[A+148>>2]=h+n,s=o[A+144>>2],k=f<<1,o[A+144>>2]=s+k,F=o[A+140>>2],S=a<<1,o[A+140>>2]=F+S,G=o[A+136>>2],_=E<<1,o[A+136>>2]=G+_,M=o[A+132>>2],p=i<<1,o[A+132>>2]=M+p,w=o[A+128>>2],N=Q<<1,o[A+128>>2]=w+N,J=o[A+124>>2],U=K<<1,o[A+124>>2]=J+U,Y=o[A+120>>2],d=D<<1,o[A+120>>2]=Y+d,o[A+112>>2]=y-t,o[A+108>>2]=n-h,o[A+104>>2]=k-s,o[A+100>>2]=S-F,o[A+96>>2]=_-G,o[A+92>>2]=p-M,o[A+88>>2]=N-w,o[A+84>>2]=U-J,o[A+80>>2]=d-Y,o[A+116>>2]=g-I}function v(A,I,g){var C,B,Q,i,E,a,f,c,e,r,D,t=0,y=0,w=0,h=0,n=0,s=0,k=0,F=0,S=0,G=0,_=0,M=0,p=0,N=0,J=0,U=0,Y=0,d=0,K=0;t=o[I+40>>2],y=o[I+4>>2],h=o[I+44>>2],n=o[I+8>>2],s=o[I+48>>2],k=o[I+12>>2],F=o[I+52>>2],S=o[I+16>>2],G=o[I+56>>2],_=o[I+20>>2],M=o[I+60>>2],p=o[I+24>>2],N=o[(w=I- -64|0)>>2],J=o[I+28>>2],U=o[I+68>>2],Y=o[I+32>>2],d=o[I+72>>2],K=o[I>>2],o[A+36>>2]=o[I+36>>2]+o[I+76>>2],o[A+32>>2]=Y+d,o[A+28>>2]=J+U,o[A+24>>2]=p+N,o[A+20>>2]=_+M,o[A+16>>2]=S+G,o[A+12>>2]=k+F,o[A+8>>2]=n+s,o[A+4>>2]=y+h,o[A>>2]=t+K,h=o[I+40>>2],t=o[I+4>>2],n=o[I+44>>2],s=o[I+8>>2],k=o[I+48>>2],F=o[I+12>>2],S=o[I+52>>2],G=o[I+16>>2],_=o[I+56>>2],M=o[I+20>>2],p=o[I+60>>2],N=o[I+24>>2],w=o[w>>2],y=o[I+28>>2],J=o[I+68>>2],U=o[I+32>>2],Y=o[I+72>>2],d=o[I>>2],o[A+76>>2]=o[I+76>>2]-o[I+36>>2],o[A+72>>2]=Y-U,o[A+68>>2]=J-y,o[(y=A- -64|0)>>2]=w-N,o[A+60>>2]=p-M,o[A+56>>2]=_-G,o[A+52>>2]=S-F,o[A+48>>2]=k-s,o[A+44>>2]=n-t,o[(t=A+40|0)>>2]=h-d,H(A+80|0,A,g),H(t,t,g+40|0),H(A+120|0,g+80|0,I+120|0),K=o[I+80>>2],Q=o[I+84>>2],i=o[I+88>>2],E=o[I+92>>2],a=o[I+96>>2],f=o[I+100>>2],c=o[I+104>>2],e=o[I+108>>2],r=o[I+112>>2],D=o[I+116>>2],I=o[t>>2],g=o[A+80>>2],h=o[A+44>>2],n=o[A+84>>2],s=o[A+48>>2],k=o[A+88>>2],F=o[A+52>>2],S=o[A+92>>2],G=o[A+56>>2],_=o[A+96>>2],M=o[A+60>>2],p=o[A+100>>2],w=o[y>>2],N=o[A+104>>2],J=o[A+68>>2],U=o[A+108>>2],Y=o[A+72>>2],d=o[A+112>>2],C=o[A+76>>2],B=o[A+116>>2],o[A+76>>2]=C+B,o[A+72>>2]=Y+d,o[A+68>>2]=J+U,o[y>>2]=w+N,o[A+60>>2]=M+p,o[A+56>>2]=G+_,o[A+52>>2]=F+S,o[A+48>>2]=s+k,o[A+44>>2]=h+n,o[t>>2]=I+g,o[A+36>>2]=B-C,o[A+32>>2]=d-Y,o[A+28>>2]=U-J,o[A+24>>2]=N-w,o[A+20>>2]=p-M,o[A+16>>2]=_-G,o[A+12>>2]=S-F,o[A+8>>2]=k-s,o[A+4>>2]=n-h,o[A>>2]=g-I,I=D<<1,g=o[A+156>>2],o[A+156>>2]=I-g,t=r<<1,y=o[A+152>>2],o[A+152>>2]=t-y,h=e<<1,n=o[A+148>>2],o[A+148>>2]=h-n,s=c<<1,k=o[A+144>>2],o[A+144>>2]=s-k,F=f<<1,S=o[A+140>>2],o[A+140>>2]=F-S,G=a<<1,_=o[A+136>>2],o[A+136>>2]=G-_,M=E<<1,p=o[A+132>>2],o[A+132>>2]=M-p,w=i<<1,N=o[A+128>>2],o[A+128>>2]=w-N,J=Q<<1,U=o[A+124>>2],o[A+124>>2]=J-U,Y=K<<1,d=o[A+120>>2],o[A+120>>2]=Y-d,o[A+112>>2]=t+y,o[A+108>>2]=h+n,o[A+104>>2]=s+k,o[A+100>>2]=F+S,o[A+96>>2]=G+_,o[A+92>>2]=M+p,o[A+88>>2]=w+N,o[A+84>>2]=J+U,o[A+80>>2]=Y+d,o[A+116>>2]=I+g}function L(A,I){var g,C,B,Q,i,E,f,c,e,r,D,t,y,w,n=0,s=0,k=0,F=0,S=0,H=0,G=0,_=0,M=0,p=0,N=0,J=0,U=0;y=a[I+31|0],g=a[I+30|0],C=a[I+29|0],B=a[I+6|0],Q=a[I+5|0],i=a[I+4|0],E=a[I+9|0],f=a[I+8|0],c=a[I+7|0],e=a[I+12|0],N=a[I+11|0],J=a[I+10|0],r=a[I+15|0],U=a[I+14|0],D=a[I+13|0],G=a[I+28|0],p=a[I+27|0],_=a[I+26|0],H=a[I+25|0],F=a[I+24|0],k=a[I+23|0],w=a[0|I]|a[I+1|0]<<8|a[I+2|0]<<16|a[I+3|0]<<24,S=(s=a[I+21|0])<<15,s=n=s>>>17|0,M=S,M|=(S=a[I+20|0])<<7,S=(n=S>>>25|0)|s,s=(n=a[I+22|0])>>>9|0,n=n<<23|M,s|=S,t=a[I+16|0]|a[I+17|0]<<8|a[I+18|0]<<16|a[I+19|0]<<24,I=0,S=n,n=(33554431&(I=(M=t+16777216|0)>>>0<16777216?1:I))<<7|M>>>25,I=(I>>>25|0)+s|0,n=(s=S=S+n|0)>>>0<n>>>0?I+1|0:I,I=(S=s+33554432|0)>>>0<33554432?n+1|0:n,o[A+24>>2]=s-(-67108864&S),n=(s=k>>>27|0)|F>>>19|H>>>11,s=k=(F=H<<21|(k=F<<13|k<<5))+(s=(67108863&(s=I))<<6|S>>>26)|0,I=n,n=(k=F+16777216|0)>>>0<16777216?I+1|0:I,o[A+28>>2]=s-(1040187392&k),s=(n=(I=n)>>>25|0)+(s=p>>>20|_>>>28|G>>>12)|0,I=s=(n=k=(I=(33554431&I)<<7|k>>>25)+(p<<12|_<<4|G<<20)|0)>>>0<I>>>0?s+1|0:s,k=(G=n+33554432|0)>>>0<33554432?I+1|0:I,o[A+32>>2]=n-(-67108864&G),s=e>>>13|(n=N>>>21|J>>>29),I=(s=(p=16777216+(N=N<<11|J<<3|e<<19)|0)>>>0<16777216?s+1|0:s)>>>25|0,s=(n=F=U<<10|D<<2|r<<18)+(F=(33554431&s)<<7|p>>>25)|0,n=I+(H=U>>>22|D>>>30|r>>>14)|0,I=n=s>>>0<F>>>0?n+1|0:n,F=((67108863&(I=(F=s+33554432|0)>>>0<33554432?I+1|0:I))<<6|(n=F)>>>26)+(_=t-(-33554432&M)|0)|0,o[A+20>>2]=F,o[A+16>>2]=s-(-67108864&n),n=Q>>>18|i>>>26|B>>>10,s=(n=(_=16777216+(J=Q<<14|i<<6|B<<22)|0)>>>0<16777216?n+1|0:n)>>>25|0,n=(I=F=f<<13|c<<5|E<<21)+(F=(33554431&n)<<7|_>>>25)|0,I=s+(H=f>>>19|c>>>27|E>>>11)|0,I=n>>>0<F>>>0?I+1|0:I,s=(H=n+33554432|0)>>>0<33554432?I+1|0:I,o[A+8>>2]=n-(-67108864&H),G=(k=(67108863&k)<<6|G>>>26)+(U=y<<18&33292288|g<<10|C<<2)|0,I=n=g>>>22|C>>>30,n=(k=U+16777216|0)>>>0<16777216?I+1|0:I,o[A+36>>2]=G-(33554432&k),s=N+((67108863&s)<<6|H>>>26)|0,o[A+12>>2]=s-(234881024&p),F=J-(2113929216&_)|0,s=kA((33554431&(I=n))<<7|k>>>25,n=I>>>25|0,19,0),I=h,s=(n=s+w|0)>>>0<s>>>0?I+1|0:I,k=((67108863&(s=(I=n+33554432|0)>>>0<33554432?s+1|0:s))<<6|I>>>26)+F|0,o[A+4>>2]=k,o[A>>2]=n-(-67108864&I)}function R(A,I,g,C){var B,Q=0,i=0,f=0,c=0,e=0,r=0,D=0,t=0,y=0,h=0,n=0,s=0;if(w=B=w-704|0,g|C)if(Q=(C<<3|g>>>29)+(i=f=o[A+76>>2])|0,e=(r=o[A+72>>2])+(c=g<<3)|0,o[A+72>>2]=e,Q=c>>>0>e>>>0?Q+1|0:Q,o[A+76>>2]=Q,f=o[4+(c=A- -64|0)>>2],f=(D=Q=(0|Q)==(0|i)&e>>>0<r>>>0|Q>>>0<i>>>0)>>>0>(Q=Q+o[c>>2]|0)>>>0?f+1|0:f,e=(D=C>>>29|0)+Q|0,Q=f,o[c>>2]=e,o[c+4>>2]=e>>>0<D>>>0?Q+1|0:Q,(0|C)==(0|(f=D=0-((Q=0)+((c=127&((7&i)<<29|r>>>3))>>>0>128)|0)|0))&g>>>0>=(e=128-c|0)>>>0|C>>>0>f>>>0){if(i=0,f=0,!Q&(127^c)>>>0>=3|Q)for(s=252&e,r=A+80|0;E[(Q=i+c|0)+r|0]=a[I+i|0],E[r+(c+(Q=1|i)|0)|0]=a[I+Q|0],E[r+(c+(Q=2|i)|0)|0]=a[I+Q|0],E[r+(c+(Q=3|i)|0)|0]=a[I+Q|0],Q=f,f=(i=i+4|0)>>>0<4?Q+1|0:Q,Q=y,y=Q=(h=h+4|0)>>>0<4?Q+1|0:Q,(0|h)!=(0|s)|(0|n)!=(0|Q););if(r=Q=0,Q|(y=3&e))for(;E[80+(A+(Q=i+c|0)|0)|0]=a[I+i|0],Q=f,f=(i=i+1|0)?Q:Q+1|0,Q=n,n=Q=(t=t+1|0)?Q:Q+1|0,(0|y)!=(0|t)|(0|r)!=(0|Q););if(k(A,A+80|0,B,i=B+640|0),I=I+e|0,!(C=C-((g>>>0<e>>>0)+D|0)|0)&(g=g-e|0)>>>0>127|C)for(;k(A,I,B,i),I=I+128|0,!(C=C-(g>>>0<128)|0)&(g=g-128|0)>>>0>127|C;);if(g|C){if(h=3&g,e=0,t=0,n=0,i=0,f=0,!C&g>>>0>=4|C)for(c=-4&g,r=C,y=A+80|0,g=0,C=0;E[i+y|0]=a[I+i|0],E[(Q=1|i)+y|0]=a[I+Q|0],E[(Q=2|i)+y|0]=a[I+Q|0],E[(Q=3|i)+y|0]=a[I+Q|0],Q=f,f=(i=i+4|0)>>>0<4?Q+1|0:Q,Q=C,C=Q=(g=g+4|0)>>>0<4?Q+1|0:Q,(0|g)!=(0|c)|(0|r)!=(0|Q););if(e|h)for(;E[80+(A+i|0)|0]=a[I+i|0],f=(i=i+1|0)?f:f+1|0,Q=n,n=Q=(t=t+1|0)?Q:Q+1|0,(0|t)!=(0|h)|(0|e)!=(0|Q););}iI(B,704)}else{if(i=0,f=0,!C&g>>>0>=4|C)for(e=-4&g,r=C,C=A+80|0;E[C+(Q=i+c|0)|0]=a[I+i|0],E[C+(D=c+(Q=1|i)|0)|0]=a[I+Q|0],E[C+(D=c+(Q=2|i)|0)|0]=a[I+Q|0],E[C+(D=c+(Q=3|i)|0)|0]=a[I+Q|0],Q=f,f=(i=i+4|0)>>>0<4?Q+1|0:Q,Q=y,y=Q=(h=h+4|0)>>>0<4?Q+1|0:Q,(0|e)!=(0|h)|(0|r)!=(0|Q););if((g&=3)|(C=0))for(;E[80+(A+(Q=i+c|0)|0)|0]=a[I+i|0],f=(i=i+1|0)?f:f+1|0,Q=n,n=Q=(t=t+1|0)?Q:Q+1|0,(0|g)!=(0|t)|(0|C)!=(0|Q););}return w=B+704|0,0}function u(A,I){var g,C,B,Q,i=0,f=0,c=0,e=0,r=0,D=0;for(w=g=w-480|0;c=(f=g+288|0)+(i<<1)|0,e=a[I+i|0],E[c+1|0]=e>>>4,E[0|c]=15&e,f=f+((c=1|i)<<1)|0,c=a[I+c|0],E[f+1|0]=c>>>4,E[0|f]=15&c,32!=(0|(i=i+2|0)););for(I=0;i=8+(f=(i=I)+a[0|(I=(g+288|0)+r|0)]|0)|0,E[0|I]=f-(240&i),i=8+(f=a[I+1|0]+(i<<24>>24>>4)|0)|0,E[I+1|0]=f-(240&i),i=8+(f=a[I+2|0]+(i<<24>>24>>4)|0)|0,E[I+2|0]=f-(240&i),I=i<<24>>24>>4,63!=(0|(r=r+3|0)););for(E[g+351|0]=a[g+351|0]+I,o[A+32>>2]=0,o[A+36>>2]=0,o[A+24>>2]=0,o[A+28>>2]=0,o[A+16>>2]=0,o[A+20>>2]=0,o[A+8>>2]=0,o[A+12>>2]=0,o[A>>2]=0,o[A+4>>2]=0,o[A+44>>2]=0,o[A+48>>2]=0,o[(I=A+40|0)>>2]=1,o[A+52>>2]=0,o[A+56>>2]=0,o[A+60>>2]=0,o[A+64>>2]=0,o[A+68>>2]=0,o[A+72>>2]=0,o[A+76>>2]=0,o[A+80>>2]=1,dA(A+84|0,0,76),B=A+120|0,r=A+80|0,f=g+208|0,C=g+168|0,c=g+248|0,i=1;V(D=g+8|0,i>>>1|0,E[(g+288|0)+i|0]),v(e=g+128|0,A,D),H(A,e,c),H(I,C,f),H(r,f,c),H(B,e,C),D=i>>>0<62,i=i+2|0,D;);for(i=o[A+36>>2],o[g+392>>2]=o[A+32>>2],o[g+396>>2]=i,i=o[A+28>>2],o[g+384>>2]=o[A+24>>2],o[g+388>>2]=i,i=o[A+20>>2],o[g+376>>2]=o[A+16>>2],o[g+380>>2]=i,i=o[A+12>>2],o[g+368>>2]=o[A+8>>2],o[g+372>>2]=i,i=o[A+4>>2],o[g+360>>2]=o[A>>2],o[g+364>>2]=i,i=o[I+12>>2],o[g+408>>2]=o[I+8>>2],o[g+412>>2]=i,i=o[I+20>>2],o[g+416>>2]=o[I+16>>2],o[g+420>>2]=i,i=o[I+28>>2],o[g+424>>2]=o[I+24>>2],o[g+428>>2]=i,i=o[I+36>>2],o[g+432>>2]=o[I+32>>2],o[g+436>>2]=i,i=o[I+4>>2],o[g+400>>2]=o[I>>2],o[g+404>>2]=i,i=o[r+12>>2],o[g+448>>2]=o[r+8>>2],o[g+452>>2]=i,i=o[r+20>>2],o[g+456>>2]=o[r+16>>2],o[g+460>>2]=i,i=o[r+28>>2],o[g+464>>2]=o[r+24>>2],o[g+468>>2]=i,i=o[r+36>>2],o[g+472>>2]=o[r+32>>2],o[g+476>>2]=i,i=o[r+4>>2],o[g+440>>2]=o[r>>2],o[g+444>>2]=i,G(e,i=g+360|0),H(i,e,c),H(D=g+400|0,C,f),H(Q=g+440|0,f,c),G(e,i),H(i,e,c),H(D,C,f),H(Q,f,c),G(e,i),H(i,e,c),H(D,C,f),H(Q,f,c),G(e,i),H(A,e,c),H(I,C,f),H(r,f,c),H(B,e,C),i=0;V(D=g+8|0,i>>>1|0,E[(g+288|0)+i|0]),v(e=g+128|0,A,D),H(A,e,c),H(I,C,f),H(r,f,c),H(B,e,C),e=i>>>0<62,i=i+2|0,e;);w=g+480|0}function x(A,I,g){var C=0,B=0,Q=0,i=0,o=0,f=0,c=0,e=0,r=0,D=0,t=0,y=0,w=0,h=0,n=0,s=0,k=0,F=0,S=0,H=0;for(B=2036477234,i=857760878,C=1634760805,f=1797285236,Q=a[I+12|0]|a[I+13|0]<<8|a[I+14|0]<<16|a[I+15|0]<<24,r=a[I+8|0]|a[I+9|0]<<8|a[I+10|0]<<16|a[I+11|0]<<24,o=a[I+4|0]|a[I+5|0]<<8|a[I+6|0]<<16|a[I+7|0]<<24,D=a[g+28|0]|a[g+29|0]<<8|a[g+30|0]<<16|a[g+31|0]<<24,c=a[g+24|0]|a[g+25|0]<<8|a[g+26|0]<<16|a[g+27|0]<<24,k=a[g+20|0]|a[g+21|0]<<8|a[g+22|0]<<16|a[g+23|0]<<24,t=a[g+16|0]|a[g+17|0]<<8|a[g+18|0]<<16|a[g+19|0]<<24,y=a[g+12|0]|a[g+13|0]<<8|a[g+14|0]<<16|a[g+15|0]<<24,w=a[g+8|0]|a[g+9|0]<<8|a[g+10|0]<<16|a[g+11|0]<<24,h=a[g+4|0]|a[g+5|0]<<8|a[g+6|0]<<16|a[g+7|0]<<24,I=a[0|I]|a[I+1|0]<<8|a[I+2|0]<<16|a[I+3|0]<<24,g=a[0|g]|a[g+1|0]<<8|a[g+2|0]<<16|a[g+3|0]<<24;e=g,g=RA((n=I)^(I=g+C|0),16),e=t=RA(e^(C=g+t|0),12),F=RA((n=I+t|0)^g,8),I=RA(e^(t=F+C|0),7),C=y,y=RA((g=f+y|0)^Q,16),C=RA(C^(D=y+D|0),12),Q=w,f=RA((B=B+w|0)^r,16),Q=RA(Q^(w=f+c|0),12),c=RA((B=Q+B|0)^f,8),g=RA(c^(f=I+(s=g+C|0)|0),16),r=RA((i=i+h|0)^o,16),h=RA((o=r+k|0)^h,12),e=I,I=RA((i=i+h|0)^r,8),e=RA(e^(o=g+(S=I+o|0)|0),12),r=RA(g^(f=e+f|0),8),g=RA((k=r+o|0)^e,7),e=B,B=C,s=RA(y^s,8),B=RA(B^(C=s+D|0),7),y=RA((o=e+B|0)^I,16),D=RA((I=y+t|0)^B,12),o=RA(y^(B=D+o|0),8),y=RA((t=I+o|0)^D,7),I=RA((I=Q)^(Q=c+w|0),7),w=RA((i=I+i|0)^F,16),c=RA(I^(C=w+C|0),12),I=RA(w^(i=c+i|0),8),w=RA((D=C+I|0)^c,7),e=Q,C=RA(h^S,7),c=RA((Q=C+n|0)^s,16),n=RA(C^(h=e+c|0),12),Q=RA(c^(C=n+Q|0),8),h=RA((c=h+Q|0)^n,7),10!=(0|(H=H+1|0)););E[0|A]=C,E[A+1|0]=C>>>8,E[A+2|0]=C>>>16,E[A+3|0]=C>>>24,E[A+28|0]=Q,E[A+29|0]=Q>>>8,E[A+30|0]=Q>>>16,E[A+31|0]=Q>>>24,E[A+24|0]=r,E[A+25|0]=r>>>8,E[A+26|0]=r>>>16,E[A+27|0]=r>>>24,E[A+20|0]=o,E[A+21|0]=o>>>8,E[A+22|0]=o>>>16,E[A+23|0]=o>>>24,E[A+16|0]=I,E[A+17|0]=I>>>8,E[A+18|0]=I>>>16,E[A+19|0]=I>>>24,E[A+12|0]=f,E[A+13|0]=f>>>8,E[A+14|0]=f>>>16,E[A+15|0]=f>>>24,E[A+8|0]=B,E[A+9|0]=B>>>8,E[A+10|0]=B>>>16,E[A+11|0]=B>>>24,E[A+4|0]=i,E[A+5|0]=i>>>8,E[A+6|0]=i>>>16,E[A+7|0]=i>>>24}function m(A,I,g){var C=0,B=0,Q=0,i=0,o=0,f=0,c=0,e=0,r=0,D=0,t=0,y=0,w=0,h=0,n=0,s=0,k=0,F=0,S=0,H=0;for(C=1797285236,c=2036477234,e=857760878,B=1634760805,Q=a[I+12|0]|a[I+13|0]<<8|a[I+14|0]<<16|a[I+15|0]<<24,o=a[I+8|0]|a[I+9|0]<<8|a[I+10|0]<<16|a[I+11|0]<<24,i=a[I+4|0]|a[I+5|0]<<8|a[I+6|0]<<16|a[I+7|0]<<24,n=a[g+28|0]|a[g+29|0]<<8|a[g+30|0]<<16|a[g+31|0]<<24,h=a[g+24|0]|a[g+25|0]<<8|a[g+26|0]<<16|a[g+27|0]<<24,s=20,y=a[g+20|0]|a[g+21|0]<<8|a[g+22|0]<<16|a[g+23|0]<<24,w=a[g+16|0]|a[g+17|0]<<8|a[g+18|0]<<16|a[g+19|0]<<24,r=a[g+12|0]|a[g+13|0]<<8|a[g+14|0]<<16|a[g+15|0]<<24,D=a[g+8|0]|a[g+9|0]<<8|a[g+10|0]<<16|a[g+11|0]<<24,t=a[g+4|0]|a[g+5|0]<<8|a[g+6|0]<<16|a[g+7|0]<<24,I=a[0|I]|a[I+1|0]<<8|a[I+2|0]<<16|a[I+3|0]<<24,g=a[0|g]|a[g+1|0]<<8|a[g+2|0]<<16|a[g+3|0]<<24;f=RA(g+e|0,7)^Q,k=RA(f+e|0,9)^h,r=RA(B+y|0,7)^r,F=RA(r+B|0,9)^o,S=RA(F+r|0,13)^y,D=RA(C+w|0,7)^D,i=RA(D+C|0,9)^i,o=RA(i+D|0,13)^w,C=RA(i+o|0,18)^C,Q=RA(I+c|0,7)^n,y=S^RA(C+Q|0,7),h=k^RA(y+C|0,9),n=RA(y+h|0,13)^Q,C=RA(h+n|0,18)^C,t=RA(Q+c|0,9)^t,H=RA(t+Q|0,13)^I,I=RA(H+t|0,18)^c,w=RA(I+f|0,7)^o,o=RA(w+I|0,9)^F,Q=RA(o+w|0,13)^f,c=RA(Q+o|0,18)^I,f=RA(f+k|0,13)^g,g=RA(f+k|0,18)^e,I=RA(g+r|0,7)^H,i=RA(I+g|0,9)^i,r=RA(I+i|0,13)^r,e=RA(i+r|0,18)^g,B=RA(F+S|0,18)^B,g=RA(B+D|0,7)^f,t=RA(g+B|0,9)^t,D=RA(g+t|0,13)^D,B=RA(t+D|0,18)^B,f=s>>>0>2,s=s-2|0,f;);return E[0|A]=B,E[A+1|0]=B>>>8,E[A+2|0]=B>>>16,E[A+3|0]=B>>>24,E[A+28|0]=Q,E[A+29|0]=Q>>>8,E[A+30|0]=Q>>>16,E[A+31|0]=Q>>>24,E[A+24|0]=o,E[A+25|0]=o>>>8,E[A+26|0]=o>>>16,E[A+27|0]=o>>>24,E[A+20|0]=i,E[A+21|0]=i>>>8,E[A+22|0]=i>>>16,E[A+23|0]=i>>>24,E[A+16|0]=I,E[A+17|0]=I>>>8,E[A+18|0]=I>>>16,E[A+19|0]=I>>>24,E[A+12|0]=C,E[A+13|0]=C>>>8,E[A+14|0]=C>>>16,E[A+15|0]=C>>>24,E[A+8|0]=c,E[A+9|0]=c>>>8,E[A+10|0]=c>>>16,E[A+11|0]=c>>>24,E[A+4|0]=e,E[A+5|0]=e>>>8,E[A+6|0]=e>>>16,E[A+7|0]=e>>>24,0}function l(A,I){var g,C,B=0,Q=0,i=0,a=0;w=g=w-288|0,Q=40+((B=o[A+32>>2]>>>3&63)+A|0)|0,B>>>0>=56?(YA(Q,34224,64-B|0),_(A,A+40|0,g,g+256|0),o[A+88>>2]=0,o[A+92>>2]=0,o[A+80>>2]=0,o[A+84>>2]=0,o[A+72>>2]=0,o[A+76>>2]=0,o[(B=A- -64|0)>>2]=0,o[B+4>>2]=0,o[A+56>>2]=0,o[A+60>>2]=0,o[A+48>>2]=0,o[A+52>>2]=0,o[A+40>>2]=0,o[A+44>>2]=0):YA(Q,34224,56-B|0),i=(B=16711680&(Q=o[A+32>>2]))>>>8|0,a=B<<24,C=(B=-16777216&Q)>>>24|0,B=(a|=B<<8)|-16777216&((255&(B=o[A+36>>2]))<<24|Q>>>8)|16711680&((16777215&B)<<8|Q>>>24)|B>>>8&65280|B>>>24,E[A+96|0]=B,E[A+97|0]=B>>>8,E[A+98|0]=B>>>16,E[A+99|0]=B>>>24,B=(B=i|C|Q<<24|(65280&Q)<<8)|(i=0)|i,E[A+100|0]=B,E[A+101|0]=B>>>8,E[A+102|0]=B>>>16,E[A+103|0]=B>>>24,_(A,A+40|0,g,g+256|0),B=(B=o[A>>2])<<24|(65280&B)<<8|B>>>8&65280|B>>>24,E[0|I]=B,E[I+1|0]=B>>>8,E[I+2|0]=B>>>16,E[I+3|0]=B>>>24,B=(B=o[A+4>>2])<<24|(65280&B)<<8|B>>>8&65280|B>>>24,E[I+4|0]=B,E[I+5|0]=B>>>8,E[I+6|0]=B>>>16,E[I+7|0]=B>>>24,B=(B=o[A+8>>2])<<24|(65280&B)<<8|B>>>8&65280|B>>>24,E[I+8|0]=B,E[I+9|0]=B>>>8,E[I+10|0]=B>>>16,E[I+11|0]=B>>>24,B=(B=o[A+12>>2])<<24|(65280&B)<<8|B>>>8&65280|B>>>24,E[I+12|0]=B,E[I+13|0]=B>>>8,E[I+14|0]=B>>>16,E[I+15|0]=B>>>24,B=(B=o[A+16>>2])<<24|(65280&B)<<8|B>>>8&65280|B>>>24,E[I+16|0]=B,E[I+17|0]=B>>>8,E[I+18|0]=B>>>16,E[I+19|0]=B>>>24,B=(B=o[A+20>>2])<<24|(65280&B)<<8|B>>>8&65280|B>>>24,E[I+20|0]=B,E[I+21|0]=B>>>8,E[I+22|0]=B>>>16,E[I+23|0]=B>>>24,B=(B=o[A+24>>2])<<24|(65280&B)<<8|B>>>8&65280|B>>>24,E[I+24|0]=B,E[I+25|0]=B>>>8,E[I+26|0]=B>>>16,E[I+27|0]=B>>>24,B=(B=o[A+28>>2])<<24|(65280&B)<<8|B>>>8&65280|B>>>24,E[I+28|0]=B,E[I+29|0]=B>>>8,E[I+30|0]=B>>>16,E[I+31|0]=B>>>24,iI(g,288),iI(A,104),w=g+288|0}function z(A,I,g){var C,B=0,Q=0,i=0,f=0,c=0,e=0,r=0,D=0,t=0,y=0,h=0,n=0;if(w=C=w-288|0,g)if(e=(B=o[A+36>>2])+(g>>>29|0)|0,t=(i=o[A+32>>2])+(f=g<<3)|0,o[A+32>>2]=t,o[A+36>>2]=f>>>0>t>>>0?e+1|0:e,!0&(f=64-(e=63&((7&B)<<29|i>>>3))|0)>>>0<=g>>>0){if(B=0,i=0,(63^e)>>>0>=3)for(n=124&f,t=A+40|0;E[(B+e|0)+t|0]=a[I+B|0],E[(e+(h=1|B)|0)+t|0]=a[I+h|0],E[(e+(h=2|B)|0)+t|0]=a[I+h|0],E[(e+(h=3|B)|0)+t|0]=a[I+h|0],i=(B=B+4|0)>>>0<4?i+1|0:i,(Q=(y=y+4|0)>>>0<4?Q+1|0:Q)|(0|y)!=(0|n););if(Q=3&f)for(;E[40+((B+e|0)+A|0)|0]=a[I+B|0],i=(B=B+1|0)?i:i+1|0,(r=(D=D+1|0)?r:r+1|0)|(0|Q)!=(0|D););if(_(A,A+40|0,C,r=C+256|0),I=I+f|0,!(Q=0-((g>>>0<f>>>0)+c|0)|0)&(g=g-f|0)>>>0>63|Q)for(;_(A,I,C,r),I=I- -64|0,Q=Q-1|0,!(Q=(g=g+-64|0)>>>0<4294967232?Q+1|0:Q)&g>>>0>63|Q;);if(g|Q){if(y=3&g,D=0,r=0,B=0,i=0,!Q&g>>>0>=4|Q)for(t=-4&g,e=Q,f=A+40|0,g=0,Q=0;E[B+f|0]=a[I+B|0],E[(c=1|B)+f|0]=a[I+c|0],E[(c=2|B)+f|0]=a[I+c|0],E[(c=3|B)+f|0]=a[I+c|0],i=(B=B+4|0)>>>0<4?i+1|0:i,(0|(g=g+4|0))!=(0|t)|(0|(Q=g>>>0<4?Q+1|0:Q))!=(0|e););if(y)for(;E[40+(A+B|0)|0]=a[I+B|0],i=(B=B+1|0)?i:i+1|0,(r=(D=D+1|0)?r:r+1|0)|(0|D)!=(0|y););}iI(C,288)}else{if(B=0,i=0,g>>>0>=4)for(t=-4&g,f=A+40|0;E[(B+e|0)+f|0]=a[I+B|0],E[(e+(c=1|B)|0)+f|0]=a[I+c|0],E[(e+(c=2|B)|0)+f|0]=a[I+c|0],E[(e+(c=3|B)|0)+f|0]=a[I+c|0],i=(B=B+4|0)>>>0<4?i+1|0:i,(Q=(y=y+4|0)>>>0<4?Q+1|0:Q)|(0|t)!=(0|y););if(g&=3)for(;E[40+((B+e|0)+A|0)|0]=a[I+B|0],i=(B=B+1|0)?i:i+1|0,(r=(D=D+1|0)?r:r+1|0)|(0|g)!=(0|D););}w=C+288|0}function q(A,I,g){var C,B=0,Q=0,i=0,f=0,c=0,e=0,r=0,D=0;if(w=C=w-96|0,g>>>0>=65&&(SA(A),z(A,I,g),l(A,C),g=32,I=C),SA(A),o[C+88>>2]=909522486,o[C+92>>2]=909522486,o[C+80>>2]=909522486,o[C+84>>2]=909522486,o[C+72>>2]=909522486,o[C+76>>2]=909522486,o[(i=r=C- -64|0)>>2]=909522486,o[i+4>>2]=909522486,o[C+56>>2]=909522486,o[C+60>>2]=909522486,o[C+48>>2]=909522486,o[C+52>>2]=909522486,o[C+40>>2]=909522486,o[C+44>>2]=909522486,o[C+32>>2]=909522486,o[C+36>>2]=909522486,g){if(g>>>0>=4)for(f=124&g;E[0|(Q=(i=C+32|0)+B|0)]=a[0|Q]^a[I+B|0],E[0|(D=(Q=1|B)+i|0)]=a[0|D]^a[I+Q|0],E[0|(D=(Q=2|B)+i|0)]=a[0|D]^a[I+Q|0],E[0|(Q=(Q=i)+(i=3|B)|0)]=a[0|Q]^a[I+i|0],B=B+4|0,(0|f)!=(0|(c=c+4|0)););if(c=3&g)for(;E[0|(i=(C+32|0)+B|0)]=a[0|i]^a[I+B|0],B=B+1|0,(0|c)!=(0|(e=e+1|0)););}if(z(A,C+32|0,64),SA(i=A+104|0),o[C+88>>2]=1549556828,o[C+92>>2]=1549556828,o[C+80>>2]=1549556828,o[C+84>>2]=1549556828,o[C+72>>2]=1549556828,o[C+76>>2]=1549556828,o[r>>2]=1549556828,o[r+4>>2]=1549556828,o[C+56>>2]=1549556828,o[C+60>>2]=1549556828,o[C+48>>2]=1549556828,o[C+52>>2]=1549556828,o[C+40>>2]=1549556828,o[C+44>>2]=1549556828,o[C+32>>2]=1549556828,o[C+36>>2]=1549556828,g){if(e=0,B=0,g>>>0>=4)for(r=124&g,c=0;E[0|(f=(A=C+32|0)+B|0)]=a[0|f]^a[I+B|0],E[0|(Q=(f=1|B)+A|0)]=a[0|Q]^a[I+f|0],E[0|(Q=(f=2|B)+A|0)]=a[0|Q]^a[I+f|0],E[0|(f=(Q=A)+(A=3|B)|0)]=a[0|f]^a[A+I|0],B=B+4|0,(0|r)!=(0|(c=c+4|0)););if(A=3&g)for(;E[0|(g=(C+32|0)+B|0)]=a[0|g]^a[I+B|0],B=B+1|0,(0|A)!=(0|(e=e+1|0)););}return z(i,A=C+32|0,64),iI(A,64),iI(C,32),w=C+96|0,0}function X(A,I,g,C,B,i,E){var a=0,f=0,c=0,e=0,r=0,D=0,t=0;if(I-65>>>0<4294967232|E>>>0>64)A=-1;else{D=a=w,w=a=a-512&-64;A:{I:if(!(!(!(C|B)|g)|!A|((f=255&I)-65&255)>>>0<=191|!(!(I=255&E)||i)|I>>>0>=65)){if(I){if(!i)break I;dA(a- -64|0,0,293),o[a+56>>2]=327033209,o[a+60>>2]=1541459225,o[a+48>>2]=-79577749,o[a+52>>2]=528734635,o[a+40>>2]=725511199,o[a+44>>2]=-1694144372,o[a+32>>2]=-1377402159,o[a+36>>2]=1359893119,o[a+24>>2]=1595750129,o[a+28>>2]=-1521486534,o[a+16>>2]=-23791573,o[a+20>>2]=1013904242,o[a+8>>2]=-2067093701,o[a+12>>2]=-1150833019,o[a>>2]=-222443256^(I<<8|f),o[a+4>>2]=I>>>24^1779033703,dA((E=a+384|0)+I|0,0,128-I|0),YA(E,i,I),YA(a+96|0,E,128),o[a+352>>2]=128,iI(E,128),I=128}else dA(a- -64|0,0,293),o[a+56>>2]=327033209,o[a+60>>2]=1541459225,o[a+48>>2]=-79577749,o[a+52>>2]=528734635,o[a+40>>2]=725511199,o[a+44>>2]=-1694144372,o[a+32>>2]=-1377402159,o[a+36>>2]=1359893119,o[a+24>>2]=1595750129,o[a+28>>2]=-1521486534,o[a+16>>2]=-23791573,o[a+20>>2]=1013904242,o[a+8>>2]=-2067093701,o[a+12>>2]=-1150833019,o[a>>2]=-222443256^f,o[a+4>>2]=1779033703,I=0;g:if(C|B)for(t=a+224|0,c=a+96|0;;){if(E=I+c|0,!B&C>>>0<=(i=256-I|0)>>>0){YA(E,g,C),o[a+352>>2]=C+o[a+352>>2];break g}if(YA(E,g,i),o[a+352>>2]=i+o[a+352>>2],e=I=o[a+68>>2],I=(r=(E=o[a+64>>2])+128|0)>>>0<128?I+1|0:I,o[a+64>>2]=r,o[a+68>>2]=I,I=o[a+76>>2],I=(e=E=-1==(0|e)&E>>>0>4294967167)>>>0>(E=E+o[a+72>>2]|0)>>>0?I+1|0:I,o[a+72>>2]=E,o[a+76>>2]=I,n(a,c),YA(c,t,128),I=o[a+352>>2]-128|0,o[a+352>>2]=I,g=g+i|0,!((B=B-(C>>>0<i>>>0)|0)|(C=C-i|0)))break}J(a,A,f),w=D;break A}zA(),Q()}A=0}return A}function j(A,I,g,C){var B=0,Q=0,i=0,f=0,c=0,e=0,r=0,D=0,t=0,y=0,w=0,h=0;A:{if((i=o[A+56>>2])|(B=o[A+60>>2])){if(t=Q=16-i|0,c=(Q=(0|(f=0-((i>>>0>16)+B|0)|0))==(0|C)&g>>>0>Q>>>0|C>>>0>f>>>0)?t:g,t=Q=Q?f:C,Q|c){if(Q=0,i=0,!t&c>>>0>=4|t)for(e=-4&c,f=A- -64|0;B=Q+o[A+56>>2]|0,E[B+f|0]=a[I+Q|0],B=(y=1|Q)+o[A+56>>2]|0,E[B+f|0]=a[I+y|0],B=(y=2|Q)+o[A+56>>2]|0,E[B+f|0]=a[I+y|0],B=(y=3|Q)+o[A+56>>2]|0,E[B+f|0]=a[I+y|0],B=i,i=(Q=Q+4|0)>>>0<4?B+1|0:B,B=r,r=B=(D=D+4|0)>>>0<4?B+1|0:B,(0|D)!=(0|e)|(0|t)!=(0|B););if(f=B=0,B|(r=3&c))for(;D=Q+o[A+56>>2]|0,E[(A+D|0)- -64|0]=a[I+Q|0],i=(Q=Q+1|0)?i:i+1|0,B=h,h=B=(w=w+1|0)?B:B+1|0,(0|r)!=(0|w)|(0|f)!=(0|B););i=o[A+56>>2],B=o[A+60>>2]}if(B=B+t|0,B=(i=i+c|0)>>>0<c>>>0?B+1|0:B,o[A+56>>2]=i,o[A+60>>2]=B,!B&i>>>0<16)break A;d(A,A- -64|0,16,0),o[A+56>>2]=0,o[A+60>>2]=0,g=(i=g)-c|0,C=C-((i>>>0<c>>>0)+t|0)|0,I=I+c|0}if(!C&g>>>0>=16|C&&(d(A,I,i=-16&g,C),g&=15,C=0,I=I+i|0),g|C){if(w=0,h=0,Q=0,i=0,!C&g>>>0>=4|C)for(c=12&g,t=0,f=A- -64|0,D=0,r=0;B=Q+o[A+56>>2]|0,E[B+f|0]=a[I+Q|0],B=(e=1|Q)+o[A+56>>2]|0,E[B+f|0]=a[I+e|0],B=(e=2|Q)+o[A+56>>2]|0,E[B+f|0]=a[I+e|0],B=(e=3|Q)+o[A+56>>2]|0,E[B+f|0]=a[I+e|0],i=(Q=Q+4|0)>>>0<4?i+1|0:i,B=r,r=B=(D=D+4|0)>>>0<4?B+1|0:B,(0|c)!=(0|D)|(0|t)!=(0|B););if(f=B=0,B|(r=3&g))for(;B=Q+o[A+56>>2]|0,E[(A+B|0)- -64|0]=a[I+Q|0],i=(Q=Q+1|0)?i:i+1|0,B=h,h=B=(w=w+1|0)?B:B+1|0,(0|r)!=(0|w)|(0|f)!=(0|B););i=C+o[A+60>>2]|0,i=(I=g+o[A+56>>2]|0)>>>0<g>>>0?i+1|0:i,o[A+56>>2]=I,o[A+60>>2]=i}}}function T(A,I,g){var C,B=0,Q=0,i=0,E=0,a=0,f=0,c=0,e=0,r=0,D=0,t=0,y=0,w=0,h=0,n=0,s=0,k=0,F=0,S=0;y=o[I+4>>2],B=o[A+4>>2],w=o[I+8>>2],Q=o[A+8>>2],h=o[I+12>>2],i=o[A+12>>2],n=o[I+16>>2],E=o[A+16>>2],s=o[I+20>>2],a=o[A+20>>2],k=o[I+24>>2],f=o[A+24>>2],D=o[I+28>>2],c=o[A+28>>2],F=o[I+32>>2],e=o[A+32>>2],S=o[I+36>>2],r=o[A+36>>2],g=0-g|0,t=o[A>>2],o[A>>2]=g&(t^o[I>>2])^t,o[A+36>>2]=r^g&(r^S),o[A+32>>2]=e^g&(e^F),o[A+28>>2]=c^g&(c^D),o[A+24>>2]=f^g&(f^k),o[A+20>>2]=a^g&(a^s),o[A+16>>2]=E^g&(E^n),o[A+12>>2]=i^g&(i^h),o[A+8>>2]=Q^g&(Q^w),o[A+4>>2]=B^g&(B^y),B=o[A+40>>2],y=o[I+40>>2],Q=o[A+44>>2],w=o[I+44>>2],i=o[A+48>>2],h=o[I+48>>2],E=o[A+52>>2],n=o[I+52>>2],a=o[A+56>>2],s=o[I+56>>2],f=o[A+60>>2],k=o[I+60>>2],c=o[(D=A- -64|0)>>2],F=o[I- -64>>2],e=o[A+68>>2],S=o[I+68>>2],r=o[A+72>>2],t=o[I+72>>2],C=o[A+76>>2],o[A+76>>2]=C^g&(o[I+76>>2]^C),o[A+72>>2]=r^g&(r^t),o[A+68>>2]=e^g&(e^S),o[D>>2]=c^g&(c^F),o[A+60>>2]=f^g&(f^k),o[A+56>>2]=a^g&(a^s),o[A+52>>2]=E^g&(E^n),o[A+48>>2]=i^g&(i^h),o[A+44>>2]=Q^g&(Q^w),o[A+40>>2]=B^g&(B^y),B=o[A+80>>2],y=o[I+80>>2],Q=o[A+84>>2],w=o[I+84>>2],i=o[A+88>>2],h=o[I+88>>2],E=o[A+92>>2],n=o[I+92>>2],a=o[A+96>>2],s=o[I+96>>2],f=o[A+100>>2],k=o[I+100>>2],c=o[A+104>>2],D=o[I+104>>2],e=o[A+108>>2],F=o[I+108>>2],r=o[A+112>>2],S=o[I+112>>2],t=o[I+116>>2],I=o[A+116>>2],o[A+116>>2]=g&(t^I)^I,o[A+112>>2]=r^g&(r^S),o[A+108>>2]=e^g&(e^F),o[A+104>>2]=c^g&(c^D),o[A+100>>2]=f^g&(f^k),o[A+96>>2]=a^g&(a^s),o[A+92>>2]=E^g&(E^n),o[A+88>>2]=i^g&(i^h),o[A+84>>2]=Q^g&(Q^w),o[A+80>>2]=B^g&(B^y)}function O(A,I){var g,C,B=0;for(w=g=w-192|0,M(C=g+144|0,I),M(B=g+96|0,C),M(B,B),H(B,I,B),H(C,C,B),M(I=g+48|0,C),H(B,B,I),M(I,B),M(I,I),M(I,I),M(I,I),M(I,I),H(B,I,B),M(I,B),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),H(I,I,B),M(g,I),M(g,g),M(g,g),M(g,g),M(g,g),M(g,g),M(g,g),M(g,g),M(g,g),M(g,g),M(g,g),M(g,g),M(g,g),M(g,g),M(g,g),M(g,g),M(g,g),M(g,g),M(g,g),M(g,g),H(I,g,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),H(B,I,B),M(I,B),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),H(I,I,B),M(g,I),I=1;M(g,g),100!=(0|(I=I+1|0)););H(I=g+48|0,g,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),M(I,I),H(B=g+96|0,I,B),M(B,B),M(B,B),M(B,B),M(B,B),M(B,B),H(A,B,g+144|0),w=g+192|0}function V(A,I,g){var C,B,Q,i,E,a,f,e,r=0;w=C=w-128|0,o[A>>2]=1,o[A+4>>2]=0,o[A+8>>2]=0,o[A+12>>2]=0,o[A+16>>2]=0,o[A+20>>2]=0,o[A+24>>2]=0,o[A+28>>2]=0,o[A+32>>2]=0,o[A+36>>2]=0,o[A+40>>2]=1,dA(A+44|0,0,76),T(A,I=c(I,960)+2704|0,(255&(1^(r=g-((g>>31&g)<<1)|0)))-1>>>31|0),T(A,I+120|0,(255&(2^r))-1>>>31|0),T(A,I+240|0,(255&(3^r))-1>>>31|0),T(A,I+360|0,(255&(4^r))-1>>>31|0),T(A,I+480|0,(255&(5^r))-1>>>31|0),T(A,I+600|0,(255&(6^r))-1>>>31|0),T(A,I+720|0,(255&(7^r))-1>>>31|0),T(A,I+840|0,(255&(8^r))-1>>>31|0),I=o[A+76>>2],o[C+40>>2]=o[A+72>>2],o[C+44>>2]=I,r=o[4+(I=A- -64|0)>>2],o[C+32>>2]=o[I>>2],o[C+36>>2]=r,I=o[A+60>>2],o[C+24>>2]=o[A+56>>2],o[C+28>>2]=I,I=o[A+52>>2],o[C+16>>2]=o[A+48>>2],o[C+20>>2]=I,I=o[A+44>>2],o[C+8>>2]=o[A+40>>2],o[C+12>>2]=I,I=o[A+12>>2],o[C+56>>2]=o[A+8>>2],o[C+60>>2]=I,r=o[A+20>>2],o[(I=C- -64|0)>>2]=o[A+16>>2],o[I+4>>2]=r,I=o[A+28>>2],o[C+72>>2]=o[A+24>>2],o[C+76>>2]=I,I=o[A+36>>2],o[C+80>>2]=o[A+32>>2],o[C+84>>2]=I,I=o[A+4>>2],o[C+48>>2]=o[A>>2],o[C+52>>2]=I,I=o[A+80>>2],r=o[A+84>>2],B=o[A+88>>2],Q=o[A+92>>2],i=o[A+96>>2],E=o[A+100>>2],a=o[A+104>>2],f=o[A+108>>2],e=o[A+112>>2],o[C+124>>2]=0-o[A+116>>2],o[C+120>>2]=0-e,o[C+116>>2]=0-f,o[C+112>>2]=0-a,o[C+108>>2]=0-E,o[C+104>>2]=0-i,o[C+100>>2]=0-Q,o[C+96>>2]=0-B,o[C+92>>2]=0-r,o[C+88>>2]=0-I,T(A,C+8|0,(128&g)>>>7|0),w=C+128|0}function Z(A,I,g,C){var B=0,Q=0,i=0,o=0,f=0,c=0,e=0;if(g|C)A:for(e=A+224|0,f=A+96|0,Q=a[A+352|0]|a[A+353|0]<<8|a[A+354|0]<<16|a[A+355|0]<<24;;){if(B=Q+f|0,!C&g>>>0<=(i=256-Q|0)>>>0){YA(B,I,g),I=g+(a[A+352|0]|a[A+353|0]<<8|a[A+354|0]<<16|a[A+355|0]<<24)|0,E[A+352|0]=I,E[A+353|0]=I>>>8,E[A+354|0]=I>>>16,E[A+355|0]=I>>>24;break A}if(YA(B,I,i),B=(a[A+352|0]|a[A+353|0]<<8|a[A+354|0]<<16|a[A+355|0]<<24)+i|0,E[A+352|0]=B,E[A+353|0]=B>>>8,E[A+354|0]=B>>>16,E[A+355|0]=B>>>24,c=Q=a[A+68|0]|a[A+69|0]<<8|a[A+70|0]<<16|a[A+71|0]<<24,Q=(o=128+(B=a[A+64|0]|a[A+65|0]<<8|a[A+66|0]<<16|a[A+67|0]<<24)|0)>>>0<128?Q+1|0:Q,E[A+64|0]=o,E[A+65|0]=o>>>8,E[A+66|0]=o>>>16,E[A+67|0]=o>>>24,E[A+68|0]=Q,E[A+69|0]=Q>>>8,E[A+70|0]=Q>>>16,E[A+71|0]=Q>>>24,Q=a[A+76|0]|a[A+77|0]<<8|a[A+78|0]<<16|a[A+79|0]<<24,Q=(c=B=-1==(0|c)&B>>>0>4294967167)>>>0>(B=B+(a[A+72|0]|a[A+73|0]<<8|a[A+74|0]<<16|a[A+75|0]<<24)|0)>>>0?Q+1|0:Q,E[A+72|0]=B,E[A+73|0]=B>>>8,E[A+74|0]=B>>>16,E[A+75|0]=B>>>24,E[A+76|0]=Q,E[A+77|0]=Q>>>8,E[A+78|0]=Q>>>16,E[A+79|0]=Q>>>24,n(A,f),YA(f,e,128),B=Q=(a[A+352|0]|a[A+353|0]<<8|a[A+354|0]<<16|a[A+355|0]<<24)-128|0,E[A+352|0]=B,E[A+353|0]=B>>>8,E[A+354|0]=B>>>16,E[A+355|0]=B>>>24,I=I+i|0,!((C=C-(g>>>0<i>>>0)|0)|(g=g-i|0)))break}return 0}function W(A,I){var g,C=0,B=0,Q=0,i=0,E=0,a=0,f=0,c=0,e=0,r=0,D=0,t=0,y=0,w=0,h=0,n=0,s=0,k=0;C=o[I+40>>2],Q=o[I+4>>2],i=o[I+44>>2],E=o[I+8>>2],a=o[I+48>>2],f=o[I+12>>2],c=o[I+52>>2],e=o[I+16>>2],r=o[I+56>>2],D=o[I+20>>2],t=o[I+60>>2],y=o[I+24>>2],w=o[(B=I- -64|0)>>2],h=o[I+28>>2],n=o[I+68>>2],s=o[I+32>>2],k=o[I+72>>2],g=o[I>>2],o[A+36>>2]=o[I+36>>2]+o[I+76>>2],o[A+32>>2]=s+k,o[A+28>>2]=h+n,o[A+24>>2]=y+w,o[A+20>>2]=D+t,o[A+16>>2]=e+r,o[A+12>>2]=f+c,o[A+8>>2]=E+a,o[A+4>>2]=Q+i,o[A>>2]=C+g,C=o[I+40>>2],Q=o[I+4>>2],i=o[I+44>>2],E=o[I+8>>2],a=o[I+48>>2],f=o[I+12>>2],c=o[I+52>>2],e=o[I+16>>2],r=o[I+56>>2],D=o[I+20>>2],t=o[I+60>>2],y=o[I+24>>2],B=o[B>>2],w=o[I+28>>2],h=o[I+68>>2],n=o[I+32>>2],s=o[I+72>>2],k=o[I>>2],o[A+76>>2]=o[I+76>>2]-o[I+36>>2],o[A+72>>2]=s-n,o[A+68>>2]=h-w,o[A- -64>>2]=B-y,o[A+60>>2]=t-D,o[A+56>>2]=r-e,o[A+52>>2]=c-f,o[A+48>>2]=a-E,o[A+44>>2]=i-Q,o[A+40>>2]=C-k,C=o[I+84>>2],o[A+80>>2]=o[I+80>>2],o[A+84>>2]=C,C=o[I+92>>2],o[A+88>>2]=o[I+88>>2],o[A+92>>2]=C,C=o[I+100>>2],o[A+96>>2]=o[I+96>>2],o[A+100>>2]=C,C=o[I+108>>2],o[A+104>>2]=o[I+104>>2],o[A+108>>2]=C,C=o[I+116>>2],o[A+112>>2]=o[I+112>>2],o[A+116>>2]=C,H(A+120|0,I+120|0,1440)}function $(A,I){var g,C,B,Q,i,a=0,f=0,e=0,r=0,D=0,t=0,y=0,w=0,h=0,n=0;(a=o[A+56>>2])|(f=o[A+60>>2])&&(E[(r=A- -64|0)+a|0]=1,!((n=a+1|0)?f:f+1|0)&n>>>0<=15&&dA(65+(A+a|0)|0,0,15-a|0),E[A+80|0]=1,d(A,r,16,0)),n=o[A+52>>2],w=o[A+48>>2],r=o[A+44>>2],a=o[A+24>>2],D=o[A+28>>2]+(a>>>26|0)|0,e=o[A+32>>2]+(D>>>26|0)|0,g=o[A+36>>2]+(e>>>26|0)|0,f=(y=(a=(a=(67108863&a)+((t=o[A+20>>2]+c(g>>>26|0,5)|0)>>>26|0)|0)&(D=(e=(i=(67108863&g)+((Q=(C=67108863&e)+((B=(h=67108863&D)+((t=a+((f=5+(y=67108863&t)|0)>>>26|0)|0)>>>26|0)|0)>>>26|0)|0)>>>26|0)|0)-67108864|0)>>31)|t&(e=67108863&(t=(e>>>31|0)-1|0)))<<26|f&e|D&y)+o[A+40>>2]|0,E[0|I]=f,E[I+1|0]=f>>>8,E[I+2|0]=f>>>16,E[I+3|0]=f>>>24,y=f>>>0<y>>>0,f=0,f=(a=(h=D&h|e&B)<<20|a>>>6)>>>0>(a=a+r|0)>>>0?1:f,f=(r=a)>>>0>(a=a+y|0)>>>0?f+1|0:f,E[I+4|0]=a,E[I+5|0]=a>>>8,E[I+6|0]=a>>>16,E[I+7|0]=a>>>24,a=0,r=(r=(e=D&C|e&Q)<<14|h>>>12)>>>0>(w=r+w|0)>>>0?1:a,a=w,w=f,a=a+f|0,f=r,f=a>>>0<w>>>0?f+1|0:f,E[I+8|0]=a,E[I+9|0]=a>>>8,E[I+10|0]=a>>>16,E[I+11|0]=a>>>24,f=(a=(a=(t&i|D&g)<<8|e>>>18)+n|0)+f|0,E[I+12|0]=f,E[I+13|0]=f>>>8,E[I+14|0]=f>>>16,E[I+15|0]=f>>>24,iI(A,88)}function AA(A,I,g){var C,B=0;return w=C=w-16|0,E[C+15|0]=0,B=-1,0|wI[o[8806]](A,I,g)||(E[C+15|0]=a[0|A]|a[C+15|0],E[C+15|0]=a[A+1|0]|a[C+15|0],E[C+15|0]=a[A+2|0]|a[C+15|0],E[C+15|0]=a[A+3|0]|a[C+15|0],E[C+15|0]=a[A+4|0]|a[C+15|0],E[C+15|0]=a[A+5|0]|a[C+15|0],E[C+15|0]=a[A+6|0]|a[C+15|0],E[C+15|0]=a[A+7|0]|a[C+15|0],E[C+15|0]=a[A+8|0]|a[C+15|0],E[C+15|0]=a[A+9|0]|a[C+15|0],E[C+15|0]=a[A+10|0]|a[C+15|0],E[C+15|0]=a[A+11|0]|a[C+15|0],E[C+15|0]=a[A+12|0]|a[C+15|0],E[C+15|0]=a[A+13|0]|a[C+15|0],E[C+15|0]=a[A+14|0]|a[C+15|0],E[C+15|0]=a[A+15|0]|a[C+15|0],E[C+15|0]=a[A+16|0]|a[C+15|0],E[C+15|0]=a[A+17|0]|a[C+15|0],E[C+15|0]=a[A+18|0]|a[C+15|0],E[C+15|0]=a[A+19|0]|a[C+15|0],E[C+15|0]=a[A+20|0]|a[C+15|0],E[C+15|0]=a[A+21|0]|a[C+15|0],E[C+15|0]=a[A+22|0]|a[C+15|0],E[C+15|0]=a[A+23|0]|a[C+15|0],E[C+15|0]=a[A+24|0]|a[C+15|0],E[C+15|0]=a[A+25|0]|a[C+15|0],E[C+15|0]=a[A+26|0]|a[C+15|0],E[C+15|0]=a[A+27|0]|a[C+15|0],E[C+15|0]=a[A+28|0]|a[C+15|0],E[C+15|0]=a[A+29|0]|a[C+15|0],E[C+15|0]=a[A+30|0]|a[C+15|0],E[C+15|0]=a[A+31|0]|a[C+15|0],B=(a[C+15|0]<<23)-8388608>>31),w=C+16|0,B}function IA(A,I){var g,C,B,Q,i,a,f,e=0,r=0;C=o[I+32>>2],B=o[I+28>>2],Q=o[I+24>>2],i=o[I+20>>2],a=o[I+16>>2],f=o[I+12>>2],e=o[I+4>>2],r=o[I>>2],g=o[I+36>>2],I=o[I+8>>2],r=c((C+(B+(Q+(i+(a+(f+((e+(r+(c(g,19)+16777216>>>25|0)>>26)>>25)+I>>26)>>25)>>26)>>25)>>26)>>25)>>26)+g>>25,19)+r|0,E[0|A]=r,E[A+2|0]=r>>>16,E[A+1|0]=r>>>8,e=e+(r>>26)|0,E[A+5|0]=e>>>14,E[A+4|0]=e>>>6,E[A+3|0]=r>>>24&3|e<<2,I=I+(e>>25)|0,E[A+8|0]=I>>>13,E[A+7|0]=I>>>5,E[A+6|0]=I<<3|(29360128&e)>>>22,r=(I>>26)+f|0,E[A+11|0]=r>>>11,E[A+10|0]=r>>>3,E[A+9|0]=r<<5|(65011712&I)>>>21,e=(r>>25)+a|0,E[A+15|0]=e>>>18,E[A+14|0]=e>>>10,E[A+13|0]=e>>>2,I=(e>>26)+i|0,E[A+16|0]=I,E[A+12|0]=e<<6|(33030144&r)>>>19,E[A+18|0]=I>>>16,E[A+17|0]=I>>>8,e=(I>>25)+Q|0,E[A+21|0]=e>>>15,E[A+20|0]=e>>>7,E[A+19|0]=I>>>24&1|e<<1,I=(e>>26)+B|0,E[A+24|0]=I>>>13,E[A+23|0]=I>>>5,E[A+22|0]=I<<3|(58720256&e)>>>23,e=(I>>25)+C|0,E[A+27|0]=e>>>12,E[A+26|0]=e>>>4,E[A+25|0]=e<<4|(31457280&I)>>>21,I=g+(e>>26)|0,E[A+30|0]=I>>>10,E[A+29|0]=I>>>2,E[A+31|0]=(33292288&I)>>>18,E[A+28|0]=I<<6|(66060288&e)>>>20}function gA(A,I,g){var C,B=0,Q=0,i=0,o=0,f=0,c=0,e=0;if(w=C=w-192|0,g>>>0>=129&&(cA(A),R(A,I,g,0),N(A,C),g=64,I=C),cA(A),dA(C- -64|0,54,128),g){if(g>>>0>=4)for(e=252&g;E[0|(B=(i=C- -64|0)+Q|0)]=a[0|B]^a[I+Q|0],E[0|(o=(B=1|Q)+i|0)]=a[0|o]^a[I+B|0],E[0|(o=(B=2|Q)+i|0)]=a[0|o]^a[I+B|0],E[0|(B=(B=i)+(i=3|Q)|0)]=a[0|B]^a[I+i|0],Q=Q+4|0,(0|e)!=(0|(f=f+4|0)););if(f=3&g)for(;E[0|(i=(C- -64|0)+Q|0)]=a[0|i]^a[I+Q|0],Q=Q+1|0,(0|f)!=(0|(c=c+1|0)););}if(R(A,Q=C- -64|0,128,0),cA(i=A+208|0),dA(Q,92,128),g){if(c=0,Q=0,g>>>0>=4)for(e=252&g,f=0;E[0|(B=(A=C- -64|0)+Q|0)]=a[0|B]^a[I+Q|0],E[0|(o=(B=1|Q)+A|0)]=a[0|o]^a[I+B|0],E[0|(o=(B=2|Q)+A|0)]=a[0|o]^a[I+B|0],E[0|(B=(B=A)+(A=3|Q)|0)]=a[0|B]^a[A+I|0],Q=Q+4|0,(0|e)!=(0|(f=f+4|0)););if(A=3&g)for(;E[0|(g=(C- -64|0)+Q|0)]=a[0|g]^a[I+Q|0],Q=Q+1|0,(0|A)!=(0|(c=c+1|0)););}return R(i,A=C- -64|0,128,0),iI(A,128),iI(C,64),w=C+192|0,0}function CA(A,I){var g;return o[12+(g=w-16|0)>>2]=A,o[g+8>>2]=I,o[g+4>>2]=0,o[g+4>>2]=o[g+4>>2]|a[o[g+12>>2]]^a[o[g+8>>2]],o[g+4>>2]=o[g+4>>2]|a[o[g+12>>2]+1|0]^a[o[g+8>>2]+1|0],o[g+4>>2]=o[g+4>>2]|a[o[g+12>>2]+2|0]^a[o[g+8>>2]+2|0],o[g+4>>2]=o[g+4>>2]|a[o[g+12>>2]+3|0]^a[o[g+8>>2]+3|0],o[g+4>>2]=o[g+4>>2]|a[o[g+12>>2]+4|0]^a[o[g+8>>2]+4|0],o[g+4>>2]=o[g+4>>2]|a[o[g+12>>2]+5|0]^a[o[g+8>>2]+5|0],o[g+4>>2]=o[g+4>>2]|a[o[g+12>>2]+6|0]^a[o[g+8>>2]+6|0],o[g+4>>2]=o[g+4>>2]|a[o[g+12>>2]+7|0]^a[o[g+8>>2]+7|0],o[g+4>>2]=o[g+4>>2]|a[o[g+12>>2]+8|0]^a[o[g+8>>2]+8|0],o[g+4>>2]=o[g+4>>2]|a[o[g+12>>2]+9|0]^a[o[g+8>>2]+9|0],o[g+4>>2]=o[g+4>>2]|a[o[g+12>>2]+10|0]^a[o[g+8>>2]+10|0],o[g+4>>2]=o[g+4>>2]|a[o[g+12>>2]+11|0]^a[o[g+8>>2]+11|0],o[g+4>>2]=o[g+4>>2]|a[o[g+12>>2]+12|0]^a[o[g+8>>2]+12|0],o[g+4>>2]=o[g+4>>2]|a[o[g+12>>2]+13|0]^a[o[g+8>>2]+13|0],o[g+4>>2]=o[g+4>>2]|a[o[g+12>>2]+14|0]^a[o[g+8>>2]+14|0],o[g+4>>2]=o[g+4>>2]|a[o[g+12>>2]+15|0]^a[o[g+8>>2]+15|0],(o[g+4>>2]-1>>>8&1)-1|0}function BA(A,I){var g,C=0,B=0;g=I;A:if(C=255&I){if(3&A)for(;;){if(!(I=a[0|A])|(0|I)==(255&g))break A;if(!(3&(A=A+1|0)))break}I:if(!((-1^(I=o[A>>2]))&I-16843009&-2139062144))for(C=c(C,16843009);;){if((-1^(I^=C))&I-16843009&-2139062144)break I;if(I=o[A+4>>2],A=A+4|0,I-16843009&(-1^I)&-2139062144)break}for(;I=A,(C=a[0|A])&&(A=A+1|0,(0|C)!=(255&g)););A=I}else{C=A;I:{g:{C:if(3&A){if(I=0,!a[0|A])break I;for(;;){if(!(3&(A=A+1|0)))break C;if(!a[0|A])break}break g}for(;I=A,A=A+4|0,!((-1^(B=o[I>>2]))&B-16843009&-2139062144););for(;I=(A=I)+1|0,a[0|A];);}I=A-C|0}A=I+C|0}return a[0|A]==(255&g)?A:0}function QA(A,I,g,C,B,Q,i){var E,a,f=0,c=0,e=0;w=E=w-96|0,m(E,Q,i),i=E+32|0,a=Q+16|0,wI[o[8808]](i,32,0,a,E),Q=-1;A:{if(!(0|wI[o[8802]](g,I,C,B,i))){if(Q=0,!A)break A;!((!B&C>>>0>I-A>>>0|0!=(0|B))&A>>>0<I>>>0)&(!B&C>>>0<=A-I>>>0|A>>>0<=I>>>0)||(I=pA(A,I,C)),c=i=(Q=!B&C>>>0>=32|0!=(0|B))?0:B,(g=Q?32:C)|i?(e=YA(E- -64|0,I,g),qA(Q=E+32|0,Q,f=g+32|0,i=f>>>0<32?i+1|0:i,a,E),YA(A,e,g)):qA(Q=E+32|0,Q,f=g+32|0,i=f>>>0<32?i+1|0:i,a,E),iI(E+32|0,64),Q=0,!B&C>>>0<33||jA(A+g|0,I+g|0,C-g|0,B-(c+(g>>>0>C>>>0)|0)|0,a,E)}iI(E,32)}return w=E+96|0,Q}function iA(A,I,g,C,B,Q,i){var E,a,f,c,e=0;return w=E=w-352|0,m(E,Q,i),!((!B&C>>>0>A-g>>>0|0!=(0|B))&A>>>0>g>>>0)&(!B&C>>>0<=g-A>>>0|A>>>0>=g>>>0)||(g=pA(A,g,C)),o[E+56>>2]=0,o[E+60>>2]=0,o[E+48>>2]=0,o[E+52>>2]=0,o[E+40>>2]=0,o[E+44>>2]=0,o[E+32>>2]=0,o[E+36>>2]=0,(f=!((i=(e=!B&C>>>0>=32|0!=(0|B))?32:C)|(e=e?0:B)))||YA(E- -64|0,g,i),qA(a=E+32|0,a,c=i+32|0,c>>>0<32?e+1|0:e,Q=Q+16|0,E),CI(E+96|0,a),f||YA(A,E- -64|0,i),iI(E+32|0,64),!B&C>>>0>=33|B&&jA(A+i|0,g+i|0,C-i|0,B-(e+(C>>>0<i>>>0)|0)|0,Q,E),iI(E,32),$A(g=E+96|0,A,C,B),BI(g,I),iI(g,256),w=E+352|0,0}function EA(A,I,g,C,B,Q,i,E,f,c){var e,r;return w=e=w-400|0,o[e+4>>2]=0,x(r=e+16|0,f,c),c=a[f+20|0]|a[f+21|0]<<8|a[f+22|0]<<16|a[f+23|0]<<24,o[e+8>>2]=a[f+16|0]|a[f+17|0]<<8|a[f+18|0]<<16|a[f+19|0]<<24,o[e+12>>2]=c,ZA(c=e+80|0,64,e+4|0,r),CI(f=e+144|0,c),iI(c,64),$A(f,Q,i,E),$A(f,33904,0-i&15,0),$A(f,I,g,C),$A(f,33904,0-g&15,0),o[e+72>>2]=i,o[e+76>>2]=E,$A(f,Q=e+72|0,8,0),o[e+72>>2]=g,o[e+76>>2]=C,$A(f,Q,8,0),BI(f,Q=e+48|0),iI(f,256),f=CA(Q,B),iI(Q,16),A&&(f?(dA(A,0,g),f=-1):(xA(A,I,g,C,e+4|0,e+16|0),f=0)),iI(e+16|0,32),w=e+400|0,f}function oA(A,I,g,C,B,Q,i,E,f,c,e){var r,D,t;return w=r=w-384|0,o[r+4>>2]=0,x(D=r+16|0,c,e),e=a[c+20|0]|a[c+21|0]<<8|a[c+22|0]<<16|a[c+23|0]<<24,o[r+8>>2]=a[c+16|0]|a[c+17|0]<<8|a[c+18|0]<<16|a[c+19|0]<<24,o[r+12>>2]=e,ZA(e=r- -64|0,64,t=r+4|0,D),CI(c=r+128|0,e),iI(e,64),$A(c,i,E,f),$A(c,33904,0-E&15,0),xA(A,C,B,Q,t,D),$A(c,A,B,Q),$A(c,33904,0-B&15,0),o[r+56>>2]=E,o[r+60>>2]=f,$A(c,A=r+56|0,8,0),o[r+56>>2]=B,o[r+60>>2]=Q,$A(c,A,8,0),BI(c,I),iI(c,256),g&&(o[g>>2]=16,o[g+4>>2]=0),iI(r+16|0,32),w=r+384|0,0}function aA(A,I,g,C){var B,Q=0;return w=B=w-208|0,o[B+72>>2]=0,o[B+76>>2]=0,Q=o[8579],o[B+8>>2]=o[8578],o[B+12>>2]=Q,Q=o[8581],o[B+16>>2]=o[8580],o[B+20>>2]=Q,Q=o[8583],o[B+24>>2]=o[8582],o[B+28>>2]=Q,Q=o[8585],o[B+32>>2]=o[8584],o[B+36>>2]=Q,Q=o[8587],o[B+40>>2]=o[8586],o[B+44>>2]=Q,Q=o[8589],o[B+48>>2]=o[8588],o[B+52>>2]=Q,Q=o[8591],o[B+56>>2]=o[8590],o[B+60>>2]=Q,o[B+64>>2]=0,o[B+68>>2]=0,Q=o[8577],o[B>>2]=o[8576],o[B+4>>2]=Q,R(B,I,g,C),N(B,A),w=B+208|0,0}function fA(A,I){var g,C=0,B=0,Q=0;if(E[15+(g=w-16|0)|0]=0,I){if(B=3&I,I>>>0>=4)for(Q=-4&I,I=0;E[g+15|0]=a[A+C|0]|a[g+15|0],E[g+15|0]=a[(1|C)+A|0]|a[g+15|0],E[g+15|0]=a[(2|C)+A|0]|a[g+15|0],E[g+15|0]=a[(3|C)+A|0]|a[g+15|0],C=C+4|0,(0|Q)!=(0|(I=I+4|0)););if(B)for(I=0;E[g+15|0]=a[A+C|0]|a[g+15|0],C=C+1|0,(0|B)!=(0|(I=I+1|0)););}return a[g+15|0]-1>>>8&1}function cA(A){var I=0;o[A+64>>2]=0,o[A+68>>2]=0,o[A+72>>2]=0,o[A+76>>2]=0,I=o[8577],o[A>>2]=o[8576],o[A+4>>2]=I,I=o[8579],o[A+8>>2]=o[8578],o[A+12>>2]=I,I=o[8581],o[A+16>>2]=o[8580],o[A+20>>2]=I,I=o[8583],o[A+24>>2]=o[8582],o[A+28>>2]=I,I=o[8585],o[A+32>>2]=o[8584],o[A+36>>2]=I,I=o[8587],o[A+40>>2]=o[8586],o[A+44>>2]=I,I=o[8589],o[A+48>>2]=o[8588],o[A+52>>2]=I,I=o[8591],o[A+56>>2]=o[8590],o[A+60>>2]=I}function eA(A,I,g){var C,B=0,Q=0;if(o[12+(C=w-16|0)>>2]=A,o[C+8>>2]=I,A=0,E[C+7|0]=0,g){if(I=1&g,1!=(0|g))for(Q=-2&g,g=0;E[C+7|0]=a[C+7|0]|a[o[C+12>>2]+A|0]^a[o[C+8>>2]+A|0],B=1|A,E[C+7|0]=a[C+7|0]|a[B+o[C+12>>2]|0]^a[o[C+8>>2]+B|0],A=A+2|0,(0|Q)!=(0|(g=g+2|0)););I&&(E[C+7|0]=a[C+7|0]|a[o[C+12>>2]+A|0]^a[o[C+8>>2]+A|0])}return(a[C+7|0]-1>>>8&1)-1|0}function rA(A){for(var I=0,g=0,C=0,B=0,Q=0,i=0,E=0,o=0,f=0,c=0;B=(g=a[A+C|0])^a[0|(I=C+2448|0)]|B,Q=g^a[I+192|0]|Q,i=g^a[I+160|0]|i,E=g^a[I+128|0]|E,o=g^a[I+96|0]|o,f=g^a[I- -64|0]|f,c=g^a[I+32|0]|c,31!=(0|(C=C+1|0)););return((255&((I=127^(A=127&a[A+31|0]))|Q))-1|(255&(I|i))-1|(255&(I|E))-1|(255&(122^A|o))-1|(255&(5^A|f))-1|(255&(A|c))-1|(255&(A|B))-1)>>>8&1}function DA(A,I,g){var C=0,B=0,Q=0,i=0;return B=31&(Q=i=63&g),Q=Q>>>0>=32?-1>>>B|0:(C=-1>>>B|0)|(1<<B)-1<<32-B,Q&=A,C&=I,B=31&i,i>>>0>=32?(C=Q<<B,i=0):(C=(1<<B)-1&Q>>>32-B|C<<B,i=Q<<B),Q=C,C=31&(B=0-g&63),B>>>0>=32?(C=-1<<C,g=0):C=(g=-1<<C)|(1<<C)-1&-1>>>32-C,A&=g,I&=C,C=31&B,B>>>0>=32?(g=0,A=I>>>C|0):(g=I>>>C|0,A=((1<<C)-1&I)<<32-C|A>>>C),h=g|Q,A|i}function tA(A,I,g,C,B,Q,i,E,a,f){var c,e,r;return w=c=w-352|0,ZA(r=c+32|0,64,a,f),CI(e=c+96|0,r),iI(r,64),$A(e,Q,i,E),$A(e,33920,0-i&15,0),$A(e,I,g,C),$A(e,33920,0-g&15,0),o[c+24>>2]=i,o[c+28>>2]=E,$A(e,Q=c+24|0,8,0),o[c+24>>2]=g,o[c+28>>2]=C,$A(e,Q,8,0),BI(e,c),iI(e,256),Q=CA(c,B),iI(c,16),A&&(Q?(dA(A,0,g),Q=-1):(FA(A,I,g,C,a,1,f),Q=0)),w=c+352|0,Q}function yA(A,I,g,C,B,Q,i,E,a,f,c){var e,r,D;return w=e=w-336|0,ZA(D=e+16|0,64,f,c),CI(r=e+80|0,D),iI(D,64),$A(r,i,E,a),$A(r,33920,0-E&15,0),FA(A,C,B,Q,f,1,c),$A(r,A,B,Q),$A(r,33920,0-B&15,0),o[e+8>>2]=E,o[e+12>>2]=a,$A(r,A=e+8|0,8,0),o[e+8>>2]=B,o[e+12>>2]=Q,$A(r,A,8,0),BI(r,I),iI(r,256),g&&(o[g>>2]=16,o[g+4>>2]=0),w=e+336|0,0}function wA(A,I,g,C,B,Q,i,E,a,f){var c,e,r;return w=c=w-352|0,WA(r=c+32|0,a,f),CI(e=c+96|0,r),iI(r,64),$A(e,Q,i,E),o[c+24>>2]=i,o[c+28>>2]=E,$A(e,Q=c+24|0,8,0),$A(e,I,g,C),o[c+24>>2]=g,o[c+28>>2]=C,$A(e,Q,8,0),BI(e,c),iI(e,256),Q=CA(c,B),iI(c,16),A&&(Q?(dA(A,0,g),Q=-1):(uA(A,I,g,C,a,f),Q=0)),w=c+352|0,Q}function hA(A,I,g,C,B,Q,i,E,a,f,c){var e,r,D;return w=e=w-336|0,WA(D=e+16|0,f,c),CI(r=e+80|0,D),iI(D,64),$A(r,i,E,a),o[e+8>>2]=E,o[e+12>>2]=a,$A(r,i=e+8|0,8,0),uA(A,C,B,Q,f,c),$A(r,A,B,Q),o[e+8>>2]=B,o[e+12>>2]=Q,$A(r,i,8,0),BI(r,I),iI(r,256),g&&(o[g>>2]=16,o[g+4>>2]=0),w=e+336|0,0}function nA(A,I){var g;for(o[12+(g=w-16|0)>>2]=A,o[g+8>>2]=I,A=0,o[g+4>>2]=0;o[g+4>>2]=o[g+4>>2]|a[o[g+12>>2]+A|0]^a[o[g+8>>2]+A|0],I=1|A,o[g+4>>2]=o[g+4>>2]|a[I+o[g+12>>2]|0]^a[I+o[g+8>>2]|0],32!=(0|(A=A+2|0)););return(o[g+4>>2]-1>>>8&1)-1|0}function sA(A){var I=0,g=0,C=0,B=0;for(I=1;I=a[0|(g=A+C|0)]+I|0,E[0|g]=I,I=a[0|(g=(1|C)+A|0)]+(I>>>8|0)|0,E[0|g]=I,I=a[0|(g=(2|C)+A|0)]+(I>>>8|0)|0,E[0|g]=I,I=a[0|(g=(3|C)+A|0)]+(I>>>8|0)|0,E[0|g]=I,I=I>>>8|0,C=C+4|0,4!=(0|(B=B+4|0)););}function kA(A,I,g,C){var B,Q,i,E,o=0,a=0;return E=c(o=g>>>16|0,a=A>>>16|0),o=(65535&(a=((i=c(B=65535&g,Q=65535&A))>>>16|0)+c(a,B)|0))+c(o,Q)|0,h=(c(I,g)+E|0)+c(A,C)+(a>>>16)+(o>>>16)|0,65535&i|o<<16}function FA(A,I,g,C,B,i,E){var a=0,f=0;a=C,1==(((a=(f=g+63|0)>>>0<63?a+1|0:a)>>>6|0)+(0!=(0|(a=(63&a)<<26|f>>>6)))|0)&i>>>0>(f=0-a|0)>>>0|1==(0|C)|C>>>0>1?(zA(),Q()):wI[o[8813]](A,I,g,C,B,i,E)}function SA(A){var I=0;o[A+32>>2]=0,o[A+36>>2]=0,I=o[8485],o[A>>2]=o[8484],o[A+4>>2]=I,I=o[8487],o[A+8>>2]=o[8486],o[A+12>>2]=I,I=o[8489],o[A+16>>2]=o[8488],o[A+20>>2]=I,I=o[8491],o[A+24>>2]=o[8490],o[A+28>>2]=I}function HA(A,I){A|=0;var g,C=0,B=0,Q=0;if(w=g=w-16|0,I|=0)for(;E[g+15|0]=0,B=A+C|0,Q=0|r(35256,g+15|0,0),E[0|B]=Q,(0|(C=C+1|0))!=(0|I););w=g+16|0}function GA(A,I,g,C,B,Q,i){var E,o,a=0;return w=E=w-32|0,a=-1,(o=g>>>0<16)&!C||UA(E,Q,i)||(a=QA(A,I+16|0,I,g-16|0,C-o|0,B,E),iI(E,32)),w=E+32|0,a}function _A(A){var I,g;return(A=(I=o[8800])+(g=A+7&-8)|0)>>>0<=I>>>0&&g||A>>>0>hI()<<16>>>0&&!(0|y(0|A))?(o[9005]=48,-1):(o[8800]=A,I)}function MA(A,I){var g,C,B;w=g=w-176|0,O(C=g+96|0,I+80|0),H(B=g+48|0,I,C),H(g,I+40|0,C),IA(A,g),IA(g+144|0,B),E[A+31|0]=a[A+31|0]^a[g+144|0]<<7,w=g+176|0}function pA(A,I,g){var C=0;if(A>>>0<I>>>0)return YA(A,I,g);if(g)for(C=A+g|0,I=I+g|0;I=I-1|0,E[0|(C=C-1|0)]=a[0|I],g=g-1|0;);return A}function NA(A,I,g,C,B,i,E){var o,a=0;if(w=o=w-32|0,!C&g>>>0<4294967280)return a=-1,UA(o,i,E)||(a=iA(A+16|0,A,I,g,C,B,o),iI(o,32)),w=o+32|0,a;zA(),Q()}function JA(A,I,g,C,B,Q){return I|=0,0|(!(C|=0)&(g|=0)>>>0>=16|C?QA(A|=0,I+16|0,I,g-16|0,C-(g>>>0<16)|0,B|=0,Q|=0):-1)}function UA(A,I,g){A|=0;var C,B=0;return w=C=w-32|0,B=-1,AA(C,g|=0,I|=0)||(B=m(A,35184,C)),w=C+32|0,0|B}function YA(A,I,g){var C=0;if(g)for(C=A;E[0|C]=a[0|I],C=C+1|0,I=I+1|0,g=g-1|0;);return A}function dA(A,I,g){var C=0;if(g)for(C=A;E[0|C]=I,C=C+1|0,g=g-1|0;);return A}function KA(A,I,g){return A|=0,I|=0,(g|=0)>>>0>=256&&(D(1260,1187,107,1067),Q()),0|J(A,I,255&g)}function bA(A,I){var g;w=g=w+-64|0,N(A,g),R(A=A+208|0,g,64,0),N(A,I),iI(g,64),w=g- -64|0}function PA(A,I,g,C,B,Q,i){return 0|iA(A|=0,I|=0,g|=0,C|=0,B|=0,Q|=0,i|=0)}function vA(A,I,g,C,B,Q,i){return 0|QA(A|=0,I|=0,g|=0,C|=0,B|=0,Q|=0,i|=0)}function LA(A,I){var g;w=g=w-32|0,l(A,g),z(A=A+104|0,g,32),l(A,I),iI(g,32),w=g+32|0}function RA(A,I){var g=0;return(-1>>>(g=31&I)&A)<<g|((g=A)&-1<<(A=0-I&31))>>>A}function uA(A,I,g,C,B,i){1==(0|C)|C>>>0>1&&(zA(),Q()),wI[o[8812]](A,I,g,C,B,1,0,i)}function xA(A,I,g,C,B,i){1==(0|C)|C>>>0>1&&(zA(),Q()),wI[o[8813]](A,I,g,C,B,1,i)}function mA(){var A;w=A=w-16|0,E[A+15|0]=0,r(35292,A+15|0,0),w=A+16|0}function lA(A,I,g){return 0|AA(A|=0,I|=0,g|=0)}function zA(){var A;(A=o[9137])&&wI[0|A](),t(),Q()}function qA(A,I,g,C,B,Q){wI[o[8809]](A,I,g,C,B,0,0,Q)}function XA(A,I){return A|=0,HA(I|=0,32),0|II(A,I)}function jA(A,I,g,C,B,Q){wI[o[8809]](A,I,g,C,B,1,0,Q)}function TA(A){return A?31-e(A-1^A)|0:32}function OA(A,I,g,C){wI[o[8813]](A,I,40,0,g,0,C)}function VA(A,I){return 0|II(A|=0,I|=0)}function ZA(A,I,g,C){wI[o[8811]](A,I,0,g,C)}function WA(A,I,g){wI[o[8810]](A,64,0,I,g)}function $A(A,I,g,C){wI[o[8804]](A,I,g,C)}function AI(A,I,g,C){return R(A,I,g,C),0}function II(A,I){return 0|wI[o[8807]](A,I)}function gI(A,I,g){return z(A,I,g),0}function CI(A,I){wI[o[8803]](A,I)}function BI(A,I){wI[o[8805]](A,I)}function QI(A){HA(A|=0,32)}function iI(A,I){dA(A,0,I)}function EI(){return 208}function oI(){return 16}function aI(){return 32}function fI(){return 24}function cI(){return-17}function eI(){return 64}function rI(){return 1}function DI(){return 8}function tI(){return 0}B(I=a,1024,"TGlic29kaXVtRFJHcmFuZG9tYnl0ZXMAYjY0X3BvcyA8PSBiNjRfbGVuAGNyeXB0b19nZW5lcmljaGFzaF9ibGFrZTJiX2ZpbmFsAHJhbmRvbWJ5dGVzL3JhbmRvbWJ5dGVzLmMAc29kaXVtL2NvZGVjcy5jAGNyeXB0b19nZW5lcmljaGFzaC9ibGFrZTJiL3JlZi9ibGFrZTJiLXJlZi5jAGNyeXB0b19nZW5lcmljaGFzaC9ibGFrZTJiL3JlZi9nZW5lcmljaGFzaF9ibGFrZTJiLmMAYnVmX2xlbiA8PSBTSVpFX01BWABvdXRsZW4gPD0gVUlOVDhfTUFYAFMtPmJ1ZmxlbiA8PSBCTEFLRTJCX0JMT0NLQllURVMAMS4wLjE5AHNvZGl1bV9iaW4yYmFzZTY0AAAAAAAAAAC2eFn/hXLTAL1uFf8PCmoAKcABAJjoef+8PKD/mXHO/wC34v60DUj/AAAAAAAAAACwoA7+08mG/54YjwB/aTUAYAy9AKfX+/+fTID+amXh/x78BACSDK4="),B(I,1440,"WfGy/grlpv973Sr+HhTUAFKAAwAw0fMAd3lA/zLjnP8AbsUBZxuQ"),B(I,1488,"hTuMAb3xJP/4JcMBYNw3ALdMPv/DQj0AMkykAeGkTP9MPaP/dT4fAFGRQP92QQ4AonPW/waKLgB85vT/CoqPADQawgC49EwAgY8pAb70E/97qnr/YoFEAHnVkwBWZR7/oWebAIxZQ//v5b4BQwu1AMbwif7uRbz/Q5fuABMqbP/lVXEBMkSH/xFqCQAyZwH/UAGoASOYHv8QqLkBOFno/2XS/AAp+kcAzKpP/w4u7/9QTe8AvdZL/xGN+QAmUEz/vlV1AFbkqgCc2NABw8+k/5ZCTP+v4RD/jVBiAUzb8gDGonIALtqYAJsr8f6boGj/M7ulAAIRrwBCVKAB9zoeACNBNf5F7L8ALYb1AaN73QAgbhT/NBelALrWRwDpsGAA8u82ATlZigBTAFT/iKBkAFyOeP5ofL4AtbE+//opVQCYgioBYPz2AJeXP/7vhT4AIDicAC2nvf+OhbMBg1bTALuzlv76qg7/0qNOACU0lwBjTRoA7pzV/9XA0QFJLlQAFEEpATbOTwDJg5L+qm8Y/7EhMv6rJsv/Tvd0ANHdmQCFgLIBOiwZAMknOwG9E/wAMeXSAXW7dQC1s7gBAHLbADBekwD1KTgAfQ3M/vStdwAs3SD+VOoUAPmgxgHsfur/L2Oo/qrimf9ms9gA4o16/3pCmf629YYA4+QZAdY56//YrTj/tefSAHeAnf+BX4j/bn4zAAKpt/8HgmL+RbBe/3QE4wHZ8pH/yq0fAWkBJ/8ur0UA5C86/9fgRf7POEX/EP6L/xfP1P/KFH7/X9Vg/wmwIQDIBc//8SqA/iMhwP/45cQBgRF4APtnl/8HNHD/jDhC/yji9f/ZRiX+rNYJ/0hDhgGSwNb/LCZwAES4S//OWvsAleuNALWqOgB09O8AXJ0CAGatYgDpiWABfzHLAAWblAAXlAn/03oMACKGGv/bzIgAhggp/+BTK/5VGfcAbX8A/qmIMADud9v/563VAM4S/v4Iugf/fgkHAW8qSABvNOz+YD+NAJO/f/7NTsD/DmrtAbvbTACv87v+aVmtAFUZWQGi85QAAnbR/iGeCQCLoy7/XUYoAGwqjv5v/I7/m9+QADPlp/9J/Jv/XnQM/5ig2v+c7iX/s+rP/8UAs/+apI0A4cRoAAojGf7R1PL/Yf3e/rhl5QDeEn8BpIiH/x7PjP6SYfMAgcAa/slUIf9vCk7/k1Gy/wQEGACh7tf/Bo0hADXXDv8ptdD/54udALPL3f//uXEAveKs/3FC1v/KPi3/ZkAI/06uEP6FdUT/"),B(I,2480,"AQ=="),B(I,2512,"JuiVj8KyJ7BFw/SJ8u+Y8NXfrAXTxjM5sTgCiG1T/AXHF2pwPU3YT7o8C3YNEGcPKiBT+iw5zMZOx/13kqwDeuz///////////////////////////////////////9/7f///////////////////////////////////////3/u////////////////////////////////////////f+3T9VwaYxJY1pz3ot753hQ="),B(I,2703,"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"),B(I,33676,"AQ=="),B(I,33712,"AQ=="),B(I,33744,"4Ot6fDtBuK4WVuP68Z/EatoJjeucMrH9hmIFFl9JuABfnJW8o1CMJLHQsVWcg+9bBERcxFgcjobYIk7d0J8RV+z///////////////////////////////////////9/7f///////////////////////////////////////3/u////////////////////////////////////////fw=="),B(I,33936,"Z+YJaoWuZ7ty8248OvVPpX9SDlGMaAWbq9mDHxnN4FuYL4pCkUQ3cc/7wLWl27XpW8JWOfER8Vmkgj+S1V4cq5iqB9gBW4MSvoUxJMN9DFV0Xb5y/rHegKcG3Jt08ZvBwWmb5IZHvu/GncEPzKEMJG8s6S2qhHRK3KmwXNqI+XZSUT6YbcYxqMgnA7DHf1m/8wvgxkeRp9VRY8oGZykpFIUKtyc4IRsu/G0sTRMNOFNUcwpluwpqdi7JwoGFLHKSoei/oktmGqhwi0vCo1FsxxnoktEkBpnWhTUO9HCgahAWwaQZCGw3Hkx3SCe1vLA0swwcOUqq2E5Pypxb828uaO6Cj3RvY6V4FHjIhAgCx4z6/76Q62xQpPej+b7yeHHGgA=="),B(I,34304,"CMm882fmCWo7p8qEha5nuyv4lP5y82488TYdXzr1T6XRguatf1IOUR9sPiuMaAWba71B+6vZgx95IX4TGc3gWyKuKNeYL4pCzWXvI5FEN3EvO03sz/vAtbzbiYGl27XpOLVI81vCVjkZ0AW28RHxWZtPGa+kgj+SGIFt2tVeHKtCAgOjmKoH2L5vcEUBW4MSjLLkTr6FMSTitP/Vw30MVW+Je/J0Xb5ysZYWO/6x3oA1Esclpwbcm5Qmac908ZvB0krxnsFpm+TjJU84hke+77XVjIvGncEPZZysd8yhDCR1AitZbyzpLYPkpm6qhHRK1PtBvdypsFy1UxGD2oj5dqvfZu5SUT6YEDK0LW3GMag/IfuYyCcDsOQO777Hf1m/wo+oPfML4MYlpwqTR5Gn1W+CA+BRY8oGcG4OCmcpKRT8L9JGhQq3JybJJlw4IRsu7SrEWvxtLE3fs5WdEw04U95jr4tUcwplqLJ3PLsKanbmru1HLsnCgTs1ghSFLHKSZAPxTKHov6IBMEK8S2YaqJGX+NBwi0vCML5UBqNRbMcYUu/WGeiS0RCpZVUkBpnWKiBxV4U1DvS40bsycKBqEMjQ0rgWwaQZU6tBUQhsNx6Z647fTHdIJ6hIm+G1vLA0Y1rJxbMMHDnLikHjSqrYTnPjY3dPypxbo7iy1vNvLmj8su9d7oKPdGAvF0NvY6V4cqvwoRR4yITsOWQaCALHjCgeYyP6/76Q6b2C3utsUKQVecay96P5vitTcuPyeHHGnGEm6s4+J8oHwsAhx7iG0R7r4M3WfdrqeNFu7n9PffW6bxdyqmfwBqaYyKLFfWMKrg35vgSYPxEbRxwTNQtxG4R9BCP1d9sokyTHQHuryjK8vskVCr6ePEwNEJzEZx1DtkI+y77UxUwqfmX8nCl/Wez61jqrb8tfF1hHSowZRGyA"),B(I,35136,"U2lnRWQyNTUxOSBubyBFZDI1NTE5IGNvbGxpc2lvbnMB"),B(I,35200,"0I4BAAEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0=");var yI,wI=(yI=[null,function(A,I,g,C,B){var Q,i,f;return A|=0,I|=0,g|=0,C|=0,B|=0,w=Q=(i=w)-128&-64,o[Q>>2]=67108863&(a[0|B]|a[B+1|0]<<8|a[B+2|0]<<16|a[B+3|0]<<24),o[Q+4>>2]=(a[B+3|0]|a[B+4|0]<<8|a[B+5|0]<<16|a[B+6|0]<<24)>>>2&67108611,o[Q+8>>2]=(a[B+6|0]|a[B+7|0]<<8|a[B+8|0]<<16|a[B+9|0]<<24)>>>4&67092735,o[Q+12>>2]=(a[B+9|0]|a[B+10|0]<<8|a[B+11|0]<<16|a[B+12|0]<<24)>>>6&66076671,f=a[B+12|0]|a[B+13|0]<<8|a[B+14|0]<<16|a[B+15|0]<<24,o[Q+20>>2]=0,o[Q+24>>2]=0,o[Q+28>>2]=0,o[Q+32>>2]=0,o[Q+36>>2]=0,o[Q+16>>2]=f>>>8&1048575,o[Q+40>>2]=a[B+16|0]|a[B+17|0]<<8|a[B+18|0]<<16|a[B+19|0]<<24,o[Q+44>>2]=a[B+20|0]|a[B+21|0]<<8|a[B+22|0]<<16|a[B+23|0]<<24,o[Q+48>>2]=a[B+24|0]|a[B+25|0]<<8|a[B+26|0]<<16|a[B+27|0]<<24,B=a[B+28|0]|a[B+29|0]<<8|a[B+30|0]<<16|a[B+31|0]<<24,E[Q+80|0]=0,o[Q+56>>2]=0,o[Q+60>>2]=0,o[Q+52>>2]=B,j(Q,I,g,C),$(Q,A),w=i,0},function(A,I,g,C,B){var Q,i,f;return A|=0,I|=0,g|=0,C|=0,B|=0,w=Q=(i=w)-192&-64,o[Q+64>>2]=67108863&(a[0|B]|a[B+1|0]<<8|a[B+2|0]<<16|a[B+3|0]<<24),o[Q+68>>2]=(a[B+3|0]|a[B+4|0]<<8|a[B+5|0]<<16|a[B+6|0]<<24)>>>2&67108611,o[Q+72>>2]=(a[B+6|0]|a[B+7|0]<<8|a[B+8|0]<<16|a[B+9|0]<<24)>>>4&67092735,o[Q+76>>2]=(a[B+9|0]|a[B+10|0]<<8|a[B+11|0]<<16|a[B+12|0]<<24)>>>6&66076671,f=a[B+12|0]|a[B+13|0]<<8|a[B+14|0]<<16|a[B+15|0]<<24,o[Q+84>>2]=0,o[Q+88>>2]=0,o[Q+92>>2]=0,o[Q+96>>2]=0,o[Q+100>>2]=0,o[Q+80>>2]=f>>>8&1048575,o[Q+104>>2]=a[B+16|0]|a[B+17|0]<<8|a[B+18|0]<<16|a[B+19|0]<<24,o[Q+108>>2]=a[B+20|0]|a[B+21|0]<<8|a[B+22|0]<<16|a[B+23|0]<<24,o[Q+112>>2]=a[B+24|0]|a[B+25|0]<<8|a[B+26|0]<<16|a[B+27|0]<<24,B=a[B+28|0]|a[B+29|0]<<8|a[B+30|0]<<16|a[B+31|0]<<24,E[Q+144|0]=0,o[Q+120>>2]=0,o[Q+124>>2]=0,o[Q+116>>2]=B,j(B=Q- -64|0,I,g,C),$(B,I=Q+48|0),A=CA(A,I),w=i,0|A},function(A,I){var g;return I|=0,o[(A|=0)>>2]=67108863&(a[0|I]|a[I+1|0]<<8|a[I+2|0]<<16|a[I+3|0]<<24),o[A+4>>2]=(a[I+3|0]|a[I+4|0]<<8|a[I+5|0]<<16|a[I+6|0]<<24)>>>2&67108611,o[A+8>>2]=(a[I+6|0]|a[I+7|0]<<8|a[I+8|0]<<16|a[I+9|0]<<24)>>>4&67092735,o[A+12>>2]=(a[I+9|0]|a[I+10|0]<<8|a[I+11|0]<<16|a[I+12|0]<<24)>>>6&66076671,g=a[I+12|0]|a[I+13|0]<<8|a[I+14|0]<<16|a[I+15|0]<<24,o[A+20>>2]=0,o[A+24>>2]=0,o[A+28>>2]=0,o[A+32>>2]=0,o[A+36>>2]=0,o[A+16>>2]=g>>>8&1048575,o[A+40>>2]=a[I+16|0]|a[I+17|0]<<8|a[I+18|0]<<16|a[I+19|0]<<24,o[A+44>>2]=a[I+20|0]|a[I+21|0]<<8|a[I+22|0]<<16|a[I+23|0]<<24,o[A+48>>2]=a[I+24|0]|a[I+25|0]<<8|a[I+26|0]<<16|a[I+27|0]<<24,I=a[I+28|0]|a[I+29|0]<<8|a[I+30|0]<<16|a[I+31|0]<<24,E[A+80|0]=0,o[A+56>>2]=0,o[A+60>>2]=0,o[A+52>>2]=I,0},function(A,I,g,C){return j(A|=0,I|=0,g|=0,C|=0),0},function(A,I){return $(A|=0,I|=0),0},function(A,I,g){A|=0,I|=0,g|=0;var C,B=0,Q=0,i=0,f=0,c=0,e=0,r=0,D=0,t=0,y=0,n=0,s=0,k=0,F=0,S=0,G=0,_=0,p=0,N=0,J=0,U=0,Y=0,d=0,K=0,b=0,P=0,v=0,R=0,u=0,x=0,m=0,l=0,z=0,q=0,X=0,j=0,T=0,V=0,Z=0,W=0,$=0,AA=0,gA=0,CA=0,BA=0,QA=0,iA=0,EA=0,oA=0,aA=0,fA=0,cA=0,eA=0,rA=0,DA=0,tA=0,yA=0,wA=0,hA=0,nA=0,sA=0,FA=0,SA=0,HA=0,GA=0,_A=0;for(w=C=w-368|0;n=(i=a[g+B|0])^a[0|(c=B+33680|0)]|n,y=i^a[c+192|0]|y,t=i^a[c+160|0]|t,D=i^a[c+128|0]|D,f=i^a[c+96|0]|f,e=i^a[c- -64|0]|e,Q=i^a[c+32|0]|Q,31!=(0|(B=B+1|0)););if(B=-1,!(256&((255&((i=127^(c=127&a[g+31|0]))|y))-1|(255&(i|t))-1|(255&(i|D))-1|(255&(87^c|f))-1|(255&(e|c))-1|(255&(Q|c))-1|(255&(c|n))-1))){for(B=I,I=a[I+28|0]|a[I+29|0]<<8|a[I+30|0]<<16|a[I+31|0]<<24,o[C+360>>2]=a[B+24|0]|a[B+25|0]<<8|a[B+26|0]<<16|a[B+27|0]<<24,o[C+364>>2]=I,I=a[B+20|0]|a[B+21|0]<<8|a[B+22|0]<<16|a[B+23|0]<<24,o[C+352>>2]=a[B+16|0]|a[B+17|0]<<8|a[B+18|0]<<16|a[B+19|0]<<24,o[C+356>>2]=I,Q=a[B+4|0]|a[B+5|0]<<8|a[B+6|0]<<16|a[B+7|0]<<24,I=a[0|B]|a[B+1|0]<<8|a[B+2|0]<<16|a[B+3|0]<<24,o[C+336>>2]=I,o[C+340>>2]=Q,Q=a[B+12|0]|a[B+13|0]<<8|a[B+14|0]<<16|a[B+15|0]<<24,o[C+344>>2]=a[B+8|0]|a[B+9|0]<<8|a[B+10|0]<<16|a[B+11|0]<<24,o[C+348>>2]=Q,E[C+336|0]=248&I,E[C+367|0]=63&a[C+367|0]|64,L(C+288|0,g),o[C+260>>2]=0,o[C+264>>2]=0,o[C+268>>2]=0,o[C+272>>2]=0,o[C+276>>2]=0,o[C+208>>2]=0,o[C+212>>2]=0,o[C+216>>2]=0,o[C+220>>2]=0,o[C+224>>2]=0,o[C+228>>2]=0,I=o[C+308>>2],o[C+160>>2]=o[C+304>>2],o[C+164>>2]=I,I=o[C+316>>2],o[C+168>>2]=o[C+312>>2],o[C+172>>2]=I,I=o[C+324>>2],o[C+176>>2]=o[C+320>>2],o[C+180>>2]=I,o[C+244>>2]=0,o[C+248>>2]=0,o[C+240>>2]=1,o[C+252>>2]=0,o[C+256>>2]=0,o[C+192>>2]=0,o[C+196>>2]=0,o[C+200>>2]=0,o[C+204>>2]=0,I=o[C+292>>2],o[C+144>>2]=o[C+288>>2],o[C+148>>2]=I,I=o[C+300>>2],o[C+152>>2]=o[C+296>>2],o[C+156>>2]=I,o[C+116>>2]=0,o[C+120>>2]=0,o[C+124>>2]=0,o[C+128>>2]=0,o[C+132>>2]=0,o[C+100>>2]=0,o[C+104>>2]=0,o[C+96>>2]=1,o[C+108>>2]=0,o[C+112>>2]=0,g=254;$=o[C+276>>2],i=o[C+180>>2],AA=o[C+96>>2],gA=o[C+192>>2],CA=o[C+144>>2],BA=o[C+240>>2],QA=o[C+100>>2],iA=o[C+196>>2],EA=o[C+148>>2],oA=o[C+244>>2],Y=o[C+104>>2],aA=o[C+200>>2],d=o[C+152>>2],fA=o[C+248>>2],P=o[C+108>>2],cA=o[C+204>>2],v=o[C+156>>2],eA=o[C+252>>2],K=o[C+112>>2],rA=o[C+208>>2],J=o[C+160>>2],DA=o[C+256>>2],n=o[C+116>>2],tA=o[C+212>>2],r=o[C+164>>2],yA=o[C+260>>2],y=o[C+120>>2],wA=o[C+216>>2],t=o[C+168>>2],hA=o[C+264>>2],D=o[C+124>>2],nA=o[C+220>>2],f=o[C+172>>2],sA=o[C+268>>2],e=o[C+128>>2],FA=o[C+224>>2],Q=o[C+176>>2],N=o[C+272>>2],SA=g,U=(G=(I=0-((I=W)^(W=a[(HA=C+336|0)+(g>>>3|0)|0]>>>(7&g)&1))|0)&((B=o[C+132>>2])^(j=o[C+228>>2])))^B,o[C+132>>2]=U,T=i^(_=I&(i^$)),o[C+84>>2]=T-U,b=e^(k=I&(e^FA)),o[C+128>>2]=b,V=(p=I&(Q^N))^Q,o[C+80>>2]=V-b,u=D^(F=I&(D^nA)),o[C+124>>2]=u,GA=f^(S=I&(f^sA)),o[C+76>>2]=GA-u,x=y^(s=I&(y^wA)),o[C+120>>2]=x,_A=t^(c=I&(t^hA)),o[C+72>>2]=_A-x,m=n^(i=I&(n^tA)),o[C+116>>2]=m,l=r^(n=I&(r^yA)),o[C+68>>2]=l-m,z=K^(y=I&(K^rA)),o[C+112>>2]=z,R=J^(t=I&(J^DA)),o[C+64>>2]=R-z,q=P^(D=I&(P^cA)),o[C+108>>2]=q,Z=v^(f=I&(v^eA)),o[C+60>>2]=Z-q,X=Y^(e=I&(Y^aA)),o[C+104>>2]=X,P=d^(Q=I&(d^fA)),o[C+56>>2]=P-X,Y=QA^(B=I&(QA^iA)),o[C+100>>2]=Y,v=EA^(g=I&(EA^oA)),o[C+52>>2]=v-Y,d=AA^(K=I&(AA^gA)),o[C+96>>2]=d,J=(I&=CA^BA)^CA,o[C+48>>2]=J-d,r=_^$,G^=j,o[C+36>>2]=r-G,_=p^N,k^=FA,o[C+32>>2]=_-k,p=S^sA,F^=nA,o[C+28>>2]=p-F,S=c^hA,s^=wA,o[C+24>>2]=S-s,c=n^yA,i^=tA,o[C+20>>2]=c-i,n=t^DA,y^=rA,o[C+16>>2]=n-y,t=f^eA,D^=cA,o[C+12>>2]=t-D,f=Q^fA,e^=aA,o[C+8>>2]=f-e,Q=g^oA,B^=iA,o[C+4>>2]=Q-B,g=I^BA,I=K^gA,o[C>>2]=g-I,o[C+276>>2]=r+G,o[C+272>>2]=_+k,o[C+268>>2]=F+p,o[C+264>>2]=s+S,o[C+260>>2]=i+c,o[C+256>>2]=y+n,o[C+248>>2]=f+e,o[C+244>>2]=B+Q,o[C+240>>2]=I+g,o[C+252>>2]=D+t,o[C+228>>2]=U+T,o[C+224>>2]=b+V,o[C+220>>2]=u+GA,o[C+216>>2]=x+_A,o[C+212>>2]=m+l,o[C+208>>2]=R+z,o[C+204>>2]=q+Z,o[C+200>>2]=P+X,o[C+196>>2]=Y+v,o[C+192>>2]=J+d,H(T=C+96|0,b=C+48|0,U=C+240|0),H(N=C+192|0,N,C),M(b,C),M(C,U),r=o[C+192>>2],G=o[C+96>>2],_=o[C+196>>2],k=o[C+100>>2],p=o[C+200>>2],F=o[C+104>>2],S=o[C+204>>2],s=o[C+108>>2],c=o[C+208>>2],i=o[C+112>>2],n=o[C+212>>2],y=o[C+116>>2],t=o[C+216>>2],D=o[C+120>>2],f=o[C+220>>2],e=o[C+124>>2],Q=o[C+224>>2],B=o[C+128>>2],g=o[C+228>>2],I=o[C+132>>2],o[C+180>>2]=g+I,o[C+176>>2]=B+Q,o[C+172>>2]=f+e,o[C+168>>2]=D+t,o[C+164>>2]=y+n,o[C+160>>2]=i+c,o[C+156>>2]=s+S,o[C+152>>2]=F+p,o[C+148>>2]=_+k,o[C+144>>2]=r+G,o[C+228>>2]=I-g,o[C+224>>2]=B-Q,o[C+220>>2]=e-f,o[C+216>>2]=D-t,o[C+212>>2]=y-n,o[C+208>>2]=i-c,o[C+204>>2]=s-S,o[C+200>>2]=F-p,o[C+196>>2]=k-_,o[C+192>>2]=G-r,H(U,C,b),u=o[C+52>>2],s=o[C+4>>2],x=o[C+56>>2],c=o[C+8>>2],m=o[C+64>>2],t=o[C+16>>2],z=o[C+60>>2],D=o[C+12>>2],q=o[C+72>>2],f=o[C+24>>2],X=o[C+68>>2],e=o[C+20>>2],Y=o[C+80>>2],Q=o[C+32>>2],d=o[C+76>>2],B=o[C+28>>2],j=o[C+84>>2],I=o[C+36>>2],V=o[C+48>>2],g=o[C>>2]-V|0,o[C>>2]=g,I=I-j|0,o[C+36>>2]=I,K=B-d|0,o[C+28>>2]=K,J=Q-Y|0,o[C+32>>2]=J,i=e-X|0,o[C+20>>2]=i,n=f-q|0,o[C+24>>2]=n,y=D-z|0,o[C+12>>2]=y,t=t-m|0,o[C+16>>2]=t,D=c-x|0,o[C+8>>2]=D,Q=s-u|0,o[C+4>>2]=Q,M(N,N),I=kA(I,I>>31,121666,0),B=h,Z=I,I=kA((33554431&(B=(r=I+16777216|0)>>>0<16777216?B+1|0:B))<<7|r>>>25,B>>25,19,0),e=h,B=I,I=kA(g,g>>31,121666,0),R=h+e|0,I=I>>>0>(B=B+I|0)>>>0?R+1|0:R,g=(f=B+33554432|0)>>>0<33554432?I+1|0:I,G=B-(-67108864&f)|0,o[C+96>>2]=G,e=kA(Q,Q>>31,121666,0),B=h,B=(Q=e+16777216|0)>>>0<16777216?B+1|0:B,_=(e-(-33554432&Q)|0)+((67108863&g)<<6|f>>>26)|0,o[C+100>>2]=_,R=(I=B)>>25,B=(33554431&I)<<7|Q>>>25,g=kA(D,D>>31,121666,0)+B|0,I=R+h|0,I=g>>>0<B>>>0?I+1|0:I,e=(k=g+33554432|0)>>>0<33554432?I+1|0:I,p=g-(-67108864&k)|0,o[C+104>>2]=p,B=kA(t,t>>31,121666,0),Q=h,g=kA(y,y>>31,121666,0),I=h,l=B,P=g,B=(33554431&(I=(F=g+16777216|0)>>>0<16777216?I+1|0:I))<<7|F>>>25,I=(I>>25)+Q|0,I=(g=l+B|0)>>>0<B>>>0?I+1|0:I,Q=(S=g+33554432|0)>>>0<33554432?I+1|0:I,s=g-(-67108864&S)|0,o[C+112>>2]=s,B=kA(n,n>>31,121666,0),f=h,g=kA(i,i>>31,121666,0),I=h,l=B,v=g,B=(33554431&(I=(c=g+16777216|0)>>>0<16777216?I+1|0:I))<<7|c>>>25,I=(I>>25)+f|0,I=(g=l+B|0)>>>0<B>>>0?I+1|0:I,B=(i=g+33554432|0)>>>0<33554432?I+1|0:I,n=g-(-67108864&i)|0,o[C+120>>2]=n,f=kA(J,J>>31,121666,0),D=h,g=kA(K,K>>31,121666,0),I=h,J=g,g=(33554431&(I=(y=g+16777216|0)>>>0<16777216?I+1|0:I))<<7|y>>>25,I=(I>>25)+D|0,I=g>>>0>(f=g+f|0)>>>0?I+1|0:I,g=(t=f+33554432|0)>>>0<33554432?I+1|0:I,D=f-(-67108864&t)|0,o[C+128>>2]=D,f=(e=P+((67108863&e)<<6|k>>>26)|0)-(-33554432&F)|0,o[C+108>>2]=f,e=(Q=v+((67108863&Q)<<6|S>>>26)|0)-(-33554432&c)|0,o[C+116>>2]=e,Q=(I=J+((67108863&B)<<6|i>>>26)|0)-(-33554432&y)|0,o[C+124>>2]=Q,g=(g=Z+((67108863&g)<<6|t>>>26)|0)-(-33554432&r)|0,o[C+132>>2]=g,M(I=C+144|0,I),o[C+84>>2]=g+j,o[C+80>>2]=D+Y,o[C+76>>2]=Q+d,o[C+72>>2]=n+q,o[C+68>>2]=e+X,o[C+64>>2]=s+m,o[C+60>>2]=f+z,o[C+56>>2]=p+x,o[C+52>>2]=_+u,o[C+48>>2]=G+V,g=SA-1|0,H(T,C+288|0,N),H(N,C,b),SA;);n=o[C+144>>2],G=o[C+240>>2],y=o[C+148>>2],_=o[C+244>>2],t=o[C+152>>2],k=o[C+248>>2],D=o[C+156>>2],p=o[C+252>>2],f=o[C+160>>2],F=o[C+256>>2],e=o[C+164>>2],S=o[C+260>>2],Q=o[C+168>>2],s=o[C+264>>2],B=o[C+172>>2],c=o[C+268>>2],g=o[C+176>>2],i=o[C+272>>2],r=0-W|0,I=o[C+276>>2],o[C+276>>2]=r&(I^o[C+180>>2])^I,o[C+272>>2]=i^r&(g^i),o[C+268>>2]=c^r&(B^c),o[C+264>>2]=s^r&(Q^s),o[C+260>>2]=S^r&(e^S),o[C+256>>2]=F^r&(f^F),o[C+252>>2]=p^r&(D^p),o[C+248>>2]=k^r&(t^k),o[C+244>>2]=_^r&(y^_),o[C+240>>2]=G^r&(n^G),G=o[C+192>>2],n=o[C+96>>2],_=o[C+196>>2],y=o[C+100>>2],k=o[C+200>>2],t=o[C+104>>2],p=o[C+204>>2],D=o[C+108>>2],F=o[C+208>>2],f=o[C+112>>2],S=o[C+212>>2],e=o[C+116>>2],s=o[C+216>>2],Q=o[C+120>>2],c=o[C+220>>2],B=o[C+124>>2],i=o[C+224>>2],g=o[C+128>>2],I=o[C+228>>2],o[C+228>>2]=r&(I^o[C+132>>2])^I,o[C+224>>2]=i^r&(g^i),o[C+220>>2]=c^r&(B^c),o[C+216>>2]=s^r&(Q^s),o[C+212>>2]=S^r&(e^S),o[C+208>>2]=F^r&(f^F),o[C+204>>2]=p^r&(D^p),o[C+200>>2]=k^r&(t^k),o[C+196>>2]=_^r&(y^_),o[C+192>>2]=G^r&(n^G),O(N,N),H(U,U,N),IA(A,U),iI(HA,32),B=0}return w=C+368|0,0|B},function(A,I){var g,C,B,Q,i,f,c,e,r,D,t,y,h,n,s,k,F,S,G,_;return I|=0,w=g=w-304|0,E[0|(A|=0)]=a[0|I],E[A+1|0]=a[I+1|0],E[A+2|0]=a[I+2|0],E[A+3|0]=a[I+3|0],E[A+4|0]=a[I+4|0],E[A+5|0]=a[I+5|0],E[A+6|0]=a[I+6|0],E[A+7|0]=a[I+7|0],E[A+8|0]=a[I+8|0],E[A+9|0]=a[I+9|0],E[A+10|0]=a[I+10|0],E[A+11|0]=a[I+11|0],E[A+12|0]=a[I+12|0],E[A+13|0]=a[I+13|0],E[A+14|0]=a[I+14|0],E[A+15|0]=a[I+15|0],E[A+16|0]=a[I+16|0],E[A+17|0]=a[I+17|0],E[A+18|0]=a[I+18|0],E[A+19|0]=a[I+19|0],E[A+20|0]=a[I+20|0],E[A+21|0]=a[I+21|0],E[A+22|0]=a[I+22|0],E[A+23|0]=a[I+23|0],E[A+24|0]=a[I+24|0],E[A+25|0]=a[I+25|0],E[A+26|0]=a[I+26|0],E[A+27|0]=a[I+27|0],E[A+28|0]=a[I+28|0],E[A+29|0]=a[I+29|0],E[A+30|0]=a[I+30|0],I=a[I+31|0],E[0|A]=248&a[0|A],E[A+31|0]=63&I|64,u(g+48|0,A),I=o[g+132>>2],C=o[g+92>>2],B=o[g+136>>2],Q=o[g+96>>2],i=o[g+140>>2],f=o[g+100>>2],c=o[g+144>>2],e=o[g+104>>2],r=o[g+148>>2],D=o[g+108>>2],t=o[g+152>>2],y=o[g+112>>2],h=o[g+156>>2],n=o[g+116>>2],s=o[g+160>>2],k=o[g+120>>2],F=o[g+128>>2],S=o[g+88>>2],G=o[g+124>>2],_=o[g+164>>2],o[g+292>>2]=G+_,o[g+288>>2]=s+k,o[g+284>>2]=h+n,o[g+280>>2]=t+y,o[g+276>>2]=r+D,o[g+272>>2]=c+e,o[g+268>>2]=i+f,o[g+264>>2]=B+Q,o[g+260>>2]=I+C,o[g+256>>2]=F+S,o[g+244>>2]=_-G,o[g+240>>2]=s-k,o[g+236>>2]=h-n,o[g+232>>2]=t-y,o[g+228>>2]=r-D,o[g+224>>2]=c-e,o[g+220>>2]=i-f,o[g+216>>2]=B-Q,o[g+212>>2]=I-C,o[g+208>>2]=F-S,O(I=g+208|0,I),H(g,g+256|0,I),IA(A,g),w=g+304|0,0},function(A,I,g,C,B){A|=0,C|=0,B|=0;var Q,i=0,f=0,c=0,e=0;if(w=Q=w-112|0,(I|=0)|(g|=0)){i=a[B+28|0]|a[B+29|0]<<8|a[B+30|0]<<16|a[B+31|0]<<24,o[Q+24>>2]=a[B+24|0]|a[B+25|0]<<8|a[B+26|0]<<16|a[B+27|0]<<24,o[Q+28>>2]=i,i=a[B+20|0]|a[B+21|0]<<8|a[B+22|0]<<16|a[B+23|0]<<24,o[Q+16>>2]=a[B+16|0]|a[B+17|0]<<8|a[B+18|0]<<16|a[B+19|0]<<24,o[Q+20>>2]=i,i=a[B+4|0]|a[B+5|0]<<8|a[B+6|0]<<16|a[B+7|0]<<24,o[Q>>2]=a[0|B]|a[B+1|0]<<8|a[B+2|0]<<16|a[B+3|0]<<24,o[Q+4>>2]=i,i=a[B+12|0]|a[B+13|0]<<8|a[B+14|0]<<16|a[B+15|0]<<24,o[Q+8>>2]=a[B+8|0]|a[B+9|0]<<8|a[B+10|0]<<16|a[B+11|0]<<24,o[Q+12>>2]=i,B=a[0|C]|a[C+1|0]<<8|a[C+2|0]<<16|a[C+3|0]<<24,C=a[C+4|0]|a[C+5|0]<<8|a[C+6|0]<<16|a[C+7|0]<<24,o[Q+104>>2]=0,o[Q+108>>2]=0,o[Q+96>>2]=B,o[Q+100>>2]=C;A:{if(!g&I>>>0>=64|g){for(;Y(A,Q+96|0,Q),C=a[Q+104|0]+1|0,E[Q+104|0]=C,C=a[Q+105|0]+(C>>>8|0)|0,E[Q+105|0]=C,C=a[Q+106|0]+(C>>>8|0)|0,E[Q+106|0]=C,C=a[Q+107|0]+(C>>>8|0)|0,E[Q+107|0]=C,C=a[Q+108|0]+(C>>>8|0)|0,E[Q+108|0]=C,C=a[Q+109|0]+(C>>>8|0)|0,E[Q+109|0]=C,C=a[Q+110|0]+(C>>>8|0)|0,E[Q+110|0]=C,E[Q+111|0]=a[Q+111|0]+(C>>>8|0),A=A- -64|0,g=g-1|0,!(g=(I=I+-64|0)>>>0<4294967232?g+1|0:g)&I>>>0>63|g;);if(!(I|g))break A}if(C=0,Y(Q+32|0,Q+96|0,Q),g=3&I,B=0,I-1>>>0>=3)for(i=-4&I,I=0;f=c=Q+32|0,E[A+B|0]=a[f+B|0],E[(e=1|B)+A|0]=a[f+e|0],E[(f=2|B)+A|0]=a[f+c|0],E[(f=3|B)+A|0]=a[f+(Q+32|0)|0],B=B+4|0,(0|i)!=(0|(I=I+4|0)););if(g)for(;E[A+B|0]=a[(Q+32|0)+B|0],B=B+1|0,(0|g)!=(0|(C=C+1|0)););}iI(Q+32|0,64),iI(Q,32)}return w=Q+112|0,0},function(A,I,g,C,B,Q,i,f){A|=0,I|=0,B|=0,Q|=0,i|=0,f|=0;var c,e=0;if(w=c=w-112|0,(g|=0)|(C|=0)){e=a[f+28|0]|a[f+29|0]<<8|a[f+30|0]<<16|a[f+31|0]<<24,o[c+24>>2]=a[f+24|0]|a[f+25|0]<<8|a[f+26|0]<<16|a[f+27|0]<<24,o[c+28>>2]=e,e=a[f+20|0]|a[f+21|0]<<8|a[f+22|0]<<16|a[f+23|0]<<24,o[c+16>>2]=a[f+16|0]|a[f+17|0]<<8|a[f+18|0]<<16|a[f+19|0]<<24,o[c+20>>2]=e,e=a[f+4|0]|a[f+5|0]<<8|a[f+6|0]<<16|a[f+7|0]<<24,o[c>>2]=a[0|f]|a[f+1|0]<<8|a[f+2|0]<<16|a[f+3|0]<<24,o[c+4>>2]=e,e=a[f+12|0]|a[f+13|0]<<8|a[f+14|0]<<16|a[f+15|0]<<24,o[c+8>>2]=a[f+8|0]|a[f+9|0]<<8|a[f+10|0]<<16|a[f+11|0]<<24,o[c+12>>2]=e,f=a[B+4|0]|a[B+5|0]<<8|a[B+6|0]<<16|a[B+7|0]<<24,o[c+96>>2]=a[0|B]|a[B+1|0]<<8|a[B+2|0]<<16|a[B+3|0]<<24,o[c+100>>2]=f,E[c+104|0]=Q,E[c+111|0]=i>>>24,E[c+110|0]=i>>>16,E[c+109|0]=i>>>8,E[c+108|0]=i,E[c+107|0]=(16777215&i)<<8|Q>>>24,E[c+106|0]=(65535&i)<<16|Q>>>16,E[c+105|0]=(255&i)<<24|Q>>>8;A:{if(!C&g>>>0>=64|C){for(;;){for(f=0,Y(c+32|0,c+96|0,c);Q=c+32|0,E[A+f|0]=a[Q+f|0]^a[I+f|0],E[(B=1|f)+A|0]=a[B+Q|0]^a[I+B|0],64!=(0|(f=f+2|0)););if(B=a[c+104|0]+1|0,E[c+104|0]=B,B=a[c+105|0]+(B>>>8|0)|0,E[c+105|0]=B,B=a[c+106|0]+(B>>>8|0)|0,E[c+106|0]=B,B=a[c+107|0]+(B>>>8|0)|0,E[c+107|0]=B,B=a[c+108|0]+(B>>>8|0)|0,E[c+108|0]=B,B=a[c+109|0]+(B>>>8|0)|0,E[c+109|0]=B,B=a[c+110|0]+(B>>>8|0)|0,E[c+110|0]=B,E[c+111|0]=a[c+111|0]+(B>>>8|0),I=I- -64|0,A=A- -64|0,C=C-1|0,!(!(C=(g=g+-64|0)>>>0<4294967232?C+1|0:C)&g>>>0>63|C))break}if(!(g|C))break A}if(f=0,Y(c+32|0,c+96|0,c),C=1&g,1!=(0|g))for(Q=-2&g,B=0;i=c+32|0,E[A+f|0]=a[i+f|0]^a[I+f|0],E[(g=1|f)+A|0]=a[g+i|0]^a[I+g|0],f=f+2|0,(0|Q)!=(0|(B=B+2|0)););C&&(E[A+f|0]=a[(c+32|0)+f|0]^a[I+f|0])}iI(c+32|0,64),iI(c,32)}return w=c+112|0,0},function(A,I,g,C,B){var Q;return A|=0,C|=0,B|=0,w=Q=w+-64|0,(I|=0)|(g|=0)&&(o[Q+8>>2]=2036477234,o[Q+12>>2]=1797285236,o[Q>>2]=1634760805,o[Q+4>>2]=857760878,o[Q+16>>2]=a[0|B]|a[B+1|0]<<8|a[B+2|0]<<16|a[B+3|0]<<24,o[Q+20>>2]=a[B+4|0]|a[B+5|0]<<8|a[B+6|0]<<16|a[B+7|0]<<24,o[Q+24>>2]=a[B+8|0]|a[B+9|0]<<8|a[B+10|0]<<16|a[B+11|0]<<24,o[Q+28>>2]=a[B+12|0]|a[B+13|0]<<8|a[B+14|0]<<16|a[B+15|0]<<24,o[Q+32>>2]=a[B+16|0]|a[B+17|0]<<8|a[B+18|0]<<16|a[B+19|0]<<24,o[Q+36>>2]=a[B+20|0]|a[B+21|0]<<8|a[B+22|0]<<16|a[B+23|0]<<24,o[Q+40>>2]=a[B+24|0]|a[B+25|0]<<8|a[B+26|0]<<16|a[B+27|0]<<24,B=a[B+28|0]|a[B+29|0]<<8|a[B+30|0]<<16|a[B+31|0]<<24,o[Q+48>>2]=0,o[Q+52>>2]=0,o[Q+44>>2]=B,o[Q+56>>2]=a[0|C]|a[C+1|0]<<8|a[C+2|0]<<16|a[C+3|0]<<24,o[Q+60>>2]=a[C+4|0]|a[C+5|0]<<8|a[C+6|0]<<16|a[C+7|0]<<24,p(Q,A=dA(A,0,I),A,I,g),iI(Q,64)),w=Q- -64|0,0},function(A,I,g,C,B){var Q;return A|=0,C|=0,B|=0,w=Q=w+-64|0,(I|=0)|(g|=0)&&(o[Q+8>>2]=2036477234,o[Q+12>>2]=1797285236,o[Q>>2]=1634760805,o[Q+4>>2]=857760878,o[Q+16>>2]=a[0|B]|a[B+1|0]<<8|a[B+2|0]<<16|a[B+3|0]<<24,o[Q+20>>2]=a[B+4|0]|a[B+5|0]<<8|a[B+6|0]<<16|a[B+7|0]<<24,o[Q+24>>2]=a[B+8|0]|a[B+9|0]<<8|a[B+10|0]<<16|a[B+11|0]<<24,o[Q+28>>2]=a[B+12|0]|a[B+13|0]<<8|a[B+14|0]<<16|a[B+15|0]<<24,o[Q+32>>2]=a[B+16|0]|a[B+17|0]<<8|a[B+18|0]<<16|a[B+19|0]<<24,o[Q+36>>2]=a[B+20|0]|a[B+21|0]<<8|a[B+22|0]<<16|a[B+23|0]<<24,o[Q+40>>2]=a[B+24|0]|a[B+25|0]<<8|a[B+26|0]<<16|a[B+27|0]<<24,B=a[B+28|0]|a[B+29|0]<<8|a[B+30|0]<<16|a[B+31|0]<<24,o[Q+48>>2]=0,o[Q+44>>2]=B,o[Q+52>>2]=a[0|C]|a[C+1|0]<<8|a[C+2|0]<<16|a[C+3|0]<<24,o[Q+56>>2]=a[C+4|0]|a[C+5|0]<<8|a[C+6|0]<<16|a[C+7|0]<<24,o[Q+60>>2]=a[C+8|0]|a[C+9|0]<<8|a[C+10|0]<<16|a[C+11|0]<<24,p(Q,A=dA(A,0,I),A,I,g),iI(Q,64)),w=Q- -64|0,0},function(A,I,g,C,B,Q,i,E){var f;return A|=0,I|=0,B|=0,Q|=0,i|=0,E|=0,w=f=w+-64|0,(g|=0)|(C|=0)&&(o[f+8>>2]=2036477234,o[f+12>>2]=1797285236,o[f>>2]=1634760805,o[f+4>>2]=857760878,o[f+16>>2]=a[0|E]|a[E+1|0]<<8|a[E+2|0]<<16|a[E+3|0]<<24,o[f+20>>2]=a[E+4|0]|a[E+5|0]<<8|a[E+6|0]<<16|a[E+7|0]<<24,o[f+24>>2]=a[E+8|0]|a[E+9|0]<<8|a[E+10|0]<<16|a[E+11|0]<<24,o[f+28>>2]=a[E+12|0]|a[E+13|0]<<8|a[E+14|0]<<16|a[E+15|0]<<24,o[f+32>>2]=a[E+16|0]|a[E+17|0]<<8|a[E+18|0]<<16|a[E+19|0]<<24,o[f+36>>2]=a[E+20|0]|a[E+21|0]<<8|a[E+22|0]<<16|a[E+23|0]<<24,o[f+40>>2]=a[E+24|0]|a[E+25|0]<<8|a[E+26|0]<<16|a[E+27|0]<<24,o[f+44>>2]=a[E+28|0]|a[E+29|0]<<8|a[E+30|0]<<16|a[E+31|0]<<24,o[f+48>>2]=Q,o[f+52>>2]=i,o[f+56>>2]=a[0|B]|a[B+1|0]<<8|a[B+2|0]<<16|a[B+3|0]<<24,o[f+60>>2]=a[B+4|0]|a[B+5|0]<<8|a[B+6|0]<<16|a[B+7|0]<<24,p(f,I,A,g,C),iI(f,64)),w=f- -64|0,0},function(A,I,g,C,B,Q,i){var E;return A|=0,I|=0,B|=0,Q|=0,i|=0,w=E=w+-64|0,(g|=0)|(C|=0)&&(o[E+8>>2]=2036477234,o[E+12>>2]=1797285236,o[E>>2]=1634760805,o[E+4>>2]=857760878,o[E+16>>2]=a[0|i]|a[i+1|0]<<8|a[i+2|0]<<16|a[i+3|0]<<24,o[E+20>>2]=a[i+4|0]|a[i+5|0]<<8|a[i+6|0]<<16|a[i+7|0]<<24,o[E+24>>2]=a[i+8|0]|a[i+9|0]<<8|a[i+10|0]<<16|a[i+11|0]<<24,o[E+28>>2]=a[i+12|0]|a[i+13|0]<<8|a[i+14|0]<<16|a[i+15|0]<<24,o[E+32>>2]=a[i+16|0]|a[i+17|0]<<8|a[i+18|0]<<16|a[i+19|0]<<24,o[E+36>>2]=a[i+20|0]|a[i+21|0]<<8|a[i+22|0]<<16|a[i+23|0]<<24,o[E+40>>2]=a[i+24|0]|a[i+25|0]<<8|a[i+26|0]<<16|a[i+27|0]<<24,i=a[i+28|0]|a[i+29|0]<<8|a[i+30|0]<<16|a[i+31|0]<<24,o[E+48>>2]=Q,o[E+44>>2]=i,o[E+52>>2]=a[0|B]|a[B+1|0]<<8|a[B+2|0]<<16|a[B+3|0]<<24,o[E+56>>2]=a[B+4|0]|a[B+5|0]<<8|a[B+6|0]<<16|a[B+7|0]<<24,o[E+60>>2]=a[B+8|0]|a[B+9|0]<<8|a[B+10|0]<<16|a[B+11|0]<<24,p(E,I,A,g,C),iI(E,64)),w=E- -64|0,0}],yI.grow=function(A){var I=this.length;return this.length=this.length+A,I},yI.set=function(A,I){this[A]=I},yI.get=function(A){return this[A]},yI);function hI(){return i.byteLength/65536|0}return{f:function(){},g:function(A,I,g,C,B,Q,i,E,o,a,f,c){return 0|hA(A|=0,I|=0,g|=0,C|=0,(A=0)|(B|=0),Q|=0,i|=0,A|(E|=0),o|=0,f|=0,c|=0)},h:function(A,I,g,C,B,i,E,a,f,c,e){return A|=0,I|=0,C|=0,E|=0,f|=0,E|=f=0,!(B|=0)&(C|=f)>>>0<4294967280?(hA(A,A+C|0,0,g|=0,C,B,i|=0,E,a|=0,c|=0,e|=0),I&&(B=(A=C+16|0)>>>0<16?B+1|0:B,o[I>>2]=A,o[I+4>>2]=B)):(zA(),Q()),0},i:function(A,I,g,C,B,Q,i,E,o,a,f,c){return 0|yA(A|=0,I|=0,g|=0,C|=0,(A=0)|(B|=0),Q|=0,i|=0,A|(E|=0),o|=0,f|=0,c|=0)},j:function(A,I,g,C,B,i,E,a,f,c,e){return A|=0,I|=0,C|=0,E|=0,f|=0,E|=f=0,!(B|=0)&(C|=f)>>>0<4294967280?(yA(A,A+C|0,0,g|=0,C,B,i|=0,E,a|=0,c|=0,e|=0),I&&(B=(A=C+16|0)>>>0<16?B+1|0:B,o[I>>2]=A,o[I+4>>2]=B)):(zA(),Q()),0},k:function(A,I,g,C,B,Q,i,E,o,a,f){return 0|wA(A|=0,g|=0,(A=0)|(C|=0),B|=0,Q|=0,i|=0,A|(E|=0),o|=0,a|=0,f|=0)},l:function(A,I,g,C,B,Q,i,E,a,f,c){return I|=0,g|=0,C|=0,B|=0,E|=0,E|=0,g=-1,!(Q|=0)&(B|=0)>>>0>=16|Q&&(g=wA(A|=0,C,B-16|0,Q-(B>>>0<16)|0,(C+B|0)-16|0,i|=0,E,a|=0,f|=0,c|=0)),I&&(o[I>>2]=g?0:B-16|0,o[I+4>>2]=g?0:Q-(B>>>0<16)|0),0|g},m:function(A,I,g,C,B,Q,i,E,o,a,f){return 0|tA(A|=0,g|=0,(A=0)|(C|=0),B|=0,Q|=0,i|=0,A|(E|=0),o|=0,a|=0,f|=0)},n:function(A,I,g,C,B,Q,i,E,a,f,c){return I|=0,g|=0,C|=0,B|=0,E|=0,E|=0,g=-1,!(Q|=0)&(B|=0)>>>0>=16|Q&&(g=tA(A|=0,C,B-16|0,Q-(B>>>0<16)|0,(C+B|0)-16|0,i|=0,E,a|=0,f|=0,c|=0)),I&&(o[I>>2]=g?0:B-16|0,o[I+4>>2]=g?0:Q-(B>>>0<16)|0),0|g},o:aI,p:function(){return 12},q:tI,r:oI,s:cI,t:QI,u:aI,v:DI,w:tI,x:oI,y:cI,z:QI,A:function(A,I,g,C,B,Q,i,E,o,a,f,c){return 0|oA(A|=0,I|=0,g|=0,C|=0,(A=0)|(B|=0),Q|=0,i|=0,A|(E|=0),o|=0,f|=0,c|=0)},B:function(A,I,g,C,B,i,E,a,f,c,e){return A|=0,I|=0,C|=0,E|=0,f|=0,E|=f=0,!(B|=0)&(C|=f)>>>0<4294967280?(oA(A,A+C|0,0,g|=0,C,B,i|=0,E,a|=0,c|=0,e|=0),I&&(B=(A=C+16|0)>>>0<16?B+1|0:B,o[I>>2]=A,o[I+4>>2]=B)):(zA(),Q()),0},C:function(A,I,g,C,B,Q,i,E,o,a,f){return 0|EA(A|=0,g|=0,(A=0)|(C|=0),B|=0,Q|=0,i|=0,A|(E|=0),o|=0,a|=0,f|=0)},D:function(A,I,g,C,B,Q,i,E,a,f,c){return I|=0,g|=0,C|=0,B|=0,E|=0,E|=0,g=-1,!(Q|=0)&(B|=0)>>>0>=16|Q&&(g=EA(A|=0,C,B-16|0,Q-(B>>>0<16)|0,(C+B|0)-16|0,i|=0,E,a|=0,f|=0,c|=0)),I&&(o[I>>2]=g?0:B-16|0,o[I+4>>2]=g?0:Q-(B>>>0<16)|0),0|g},E:aI,F:fI,G:tI,H:oI,I:cI,J:QI,K:aI,L:aI,M:function(A,I,g,C,B){var Q;return A|=0,I|=0,g|=0,C|=0,w=Q=w-480|0,gA(Q,B|=0,32),AI(Q,I,g,C),bA(Q,Q+416|0),I=o[Q+444>>2],g=o[Q+440>>2],E[A+24|0]=g,E[A+25|0]=g>>>8,E[A+26|0]=g>>>16,E[A+27|0]=g>>>24,E[A+28|0]=I,E[A+29|0]=I>>>8,E[A+30|0]=I>>>16,E[A+31|0]=I>>>24,I=o[Q+436>>2],g=o[Q+432>>2],E[A+16|0]=g,E[A+17|0]=g>>>8,E[A+18|0]=g>>>16,E[A+19|0]=g>>>24,E[A+20|0]=I,E[A+21|0]=I>>>8,E[A+22|0]=I>>>16,E[A+23|0]=I>>>24,I=o[Q+428>>2],g=o[Q+424>>2],E[A+8|0]=g,E[A+9|0]=g>>>8,E[A+10|0]=g>>>16,E[A+11|0]=g>>>24,E[A+12|0]=I,E[A+13|0]=I>>>8,E[A+14|0]=I>>>16,E[A+15|0]=I>>>24,I=o[Q+420>>2],g=o[Q+416>>2],E[0|A]=g,E[A+1|0]=g>>>8,E[A+2|0]=g>>>16,E[A+3|0]=g>>>24,E[A+4|0]=I,E[A+5|0]=I>>>8,E[A+6|0]=I>>>16,E[A+7|0]=I>>>24,w=Q+480|0,0},N:function(A,I,g,C,B){var Q,i;return A|=0,I|=0,g|=0,C|=0,w=Q=w-512|0,gA(i=Q+32|0,B|=0,32),AI(i,I,g,C),bA(i,Q+448|0),I=o[Q+476>>2],o[Q+24>>2]=o[Q+472>>2],o[Q+28>>2]=I,I=o[Q+468>>2],o[Q+16>>2]=o[Q+464>>2],o[Q+20>>2]=I,I=o[Q+460>>2],o[Q+8>>2]=o[Q+456>>2],o[Q+12>>2]=I,I=o[Q+452>>2],o[Q>>2]=o[Q+448>>2],o[Q+4>>2]=I,I=nA(A,Q),g=eA(Q,A,32),w=Q+512|0,((0|A)==(0|Q)?-1:I)|g},O:QI,P:aI,Q:aI,R:aI,S:aI,T:fI,U:oI,V:cI,W:function(A,I,g){A|=0,I|=0;var C,B=0;return w=C=w+-64|0,aA(C,g|=0,32,0),g=o[C+28>>2],B=o[C+24>>2],E[I+24|0]=B,E[I+25|0]=B>>>8,E[I+26|0]=B>>>16,E[I+27|0]=B>>>24,E[I+28|0]=g,E[I+29|0]=g>>>8,E[I+30|0]=g>>>16,E[I+31|0]=g>>>24,g=o[C+20>>2],B=o[C+16>>2],E[I+16|0]=B,E[I+17|0]=B>>>8,E[I+18|0]=B>>>16,E[I+19|0]=B>>>24,E[I+20|0]=g,E[I+21|0]=g>>>8,E[I+22|0]=g>>>16,E[I+23|0]=g>>>24,g=o[C+12>>2],B=o[C+8>>2],E[I+8|0]=B,E[I+9|0]=B>>>8,E[I+10|0]=B>>>16,E[I+11|0]=B>>>24,E[I+12|0]=g,E[I+13|0]=g>>>8,E[I+14|0]=g>>>16,E[I+15|0]=g>>>24,g=o[C+4>>2],B=o[C>>2],E[0|I]=B,E[I+1|0]=B>>>8,E[I+2|0]=B>>>16,E[I+3|0]=B>>>24,E[I+4|0]=g,E[I+5|0]=g>>>8,E[I+6|0]=g>>>16,E[I+7|0]=g>>>24,iI(C,64),A=II(A,I),w=C- -64|0,0|A},X:XA,Y:UA,Z:PA,_:function(A,I,g,C,B,Q,i,E){A|=0,I|=0,g|=0,Q|=0;var o,a=0;return a=C|=0,C=B|=0,o=0|a,w=a=w-32|0,B=-1,UA(a,i|=0,E|=0)||(B=iA(A,I,g,o,C,Q,a),iI(a,32)),w=a+32|0,0|B},$:function(A,I,g,C,B,i){return A|=0,I|=0,B|=0,i|=0,!(C|=0)&(g|=0)>>>0>=4294967280|C&&(zA(),Q()),0|iA(A+16|0,A,I,g,C,B,i)},aa:function(A,I,g,C,B,Q,i){return 0|NA(A|=0,I|=0,g|=0,C|=0,B|=0,Q|=0,i|=0)},ba:vA,ca:function(A,I,g,C,B,Q,i,E){A|=0,I|=0,g|=0,Q|=0;var o,a=0;return a=C|=0,C=B|=0,o=0|a,w=a=w-32|0,B=-1,UA(a,i|=0,E|=0)||(B=QA(A,I,g,o,C,Q,a),iI(a,32)),w=a+32|0,0|B},da:JA,ea:function(A,I,g,C,B,Q,i){return 0|GA(A|=0,I|=0,g|=0,C|=0,B|=0,Q|=0,i|=0)},fa:function(A,I,g,C,B){A|=0,I|=0,B|=0;var Q,i,a,f,c=0,e=0;return c=g|=0,g=C|=0,f=0|c,c=C=w,w=Q=C-512&-64,C=-1,XA(i=Q- -64|0,a=Q+32|0)||(K(C=Q+128|0,0,0,24),Z(C,i,32,0),Z(C,B,32,0),KA(C,e=Q+96|0,24),C=NA(A+32|0,I,f,g,e,B,a),I=o[Q+92>>2],g=o[Q+88>>2],E[A+24|0]=g,E[A+25|0]=g>>>8,E[A+26|0]=g>>>16,E[A+27|0]=g>>>24,E[A+28|0]=I,E[A+29|0]=I>>>8,E[A+30|0]=I>>>16,E[A+31|0]=I>>>24,I=o[Q+84>>2],g=o[Q+80>>2],E[A+16|0]=g,E[A+17|0]=g>>>8,E[A+18|0]=g>>>16,E[A+19|0]=g>>>24,E[A+20|0]=I,E[A+21|0]=I>>>8,E[A+22|0]=I>>>16,E[A+23|0]=I>>>24,I=o[Q+76>>2],g=o[Q+72>>2],E[A+8|0]=g,E[A+9|0]=g>>>8,E[A+10|0]=g>>>16,E[A+11|0]=g>>>24,E[A+12|0]=I,E[A+13|0]=I>>>8,E[A+14|0]=I>>>16,E[A+15|0]=I>>>24,I=o[Q+68>>2],g=o[Q+64>>2],E[0|A]=g,E[A+1|0]=g>>>8,E[A+2|0]=g>>>16,E[A+3|0]=g>>>24,E[A+4|0]=I,E[A+5|0]=I>>>8,E[A+6|0]=I>>>16,E[A+7|0]=I>>>24,iI(a,32),iI(i,32),iI(e,24)),w=c,0|C},ga:function(A,I,g,C,B,Q){A|=0,I|=0,B|=0,Q|=0;var i,E,o=0;return E=o=w,w=i=o-448&-64,o=-1,!(C|=0)&(g|=0)>>>0>=48|C&&(K(o=i- -64|0,0,0,24),Z(o,I,32,0),Z(o,B,32,0),KA(o,B=i+32|0,24),o=GA(A,I+32|0,g-32|0,C-(g>>>0<32)|0,B,I,Q)),w=E,0|o},ha:function(){return 48},ia:oI,ja:eI,ka:aI,la:oI,ma:eI,na:aI,oa:function(){return 384},pa:function(A,I,g,C,B,Q,i){return 0|X(A|=0,I|=0,g|=0,C|=0,B|=0,Q|=0,i|=0)},qa:K,ra:function(A,I,g,C){return 0|Z(A|=0,I|=0,g|=0,C|=0)},sa:KA,ta:QI,ua:eI,va:function(A,I,g,C){return 0|aA(A|=0,I|=0,g|=0,C|=0)},wa:oI,xa:eI,ya:DI,za:aI,Aa:function(A,I,g,C,B,i){A|=0,I|=0,g|=0,C|=0,i|=0;var E,f=0,c=0,e=0,r=0,D=0,t=0,y=0;return w=E=w-32|0,f=a[0|(B|=0)]|a[B+1|0]<<8|a[B+2|0]<<16|a[B+3|0]<<24,B=a[B+4|0]|a[B+5|0]<<8|a[B+6|0]<<16|a[B+7|0]<<24,o[E+24>>2]=0,o[E+28>>2]=0,o[E+16>>2]=f,o[E+20>>2]=B,o[E+8>>2]=0,o[E+12>>2]=0,o[(B=E)>>2]=g,o[B+4>>2]=C,I-65>>>0<=4294967246?(o[9005]=28,A=-1):I-65>>>0<4294967232?A=-1:(w=B=(e=w)-512&-64,!i|!A|((c=255&I)-65&255)>>>0<=191?(zA(),Q()):(C=E+16|0,E?(r=725511199^(a[E+8|0]|a[E+9|0]<<8|a[E+10|0]<<16|a[E+11|0]<<24),D=-1694144372^(a[E+12|0]|a[E+13|0]<<8|a[E+14|0]<<16|a[E+15|0]<<24),g=-1377402159^(a[0|E]|a[E+1|0]<<8|a[E+2|0]<<16|a[E+3|0]<<24),I=1359893119^(a[E+4|0]|a[E+5|0]<<8|a[E+6|0]<<16|a[E+7|0]<<24)):(r=725511199,D=-1694144372,g=-1377402159,I=1359893119),C?(t=327033209^(a[C+8|0]|a[C+9|0]<<8|a[C+10|0]<<16|a[C+11|0]<<24),y=1541459225^(a[C+12|0]|a[C+13|0]<<8|a[C+14|0]<<16|a[C+15|0]<<24),f=-79577749^(a[0|C]|a[C+1|0]<<8|a[C+2|0]<<16|a[C+3|0]<<24),C=528734635^(a[C+4|0]|a[C+5|0]<<8|a[C+6|0]<<16|a[C+7|0]<<24)):(t=327033209,y=1541459225,f=-79577749,C=528734635),dA(B- -64|0,0,293),o[B+56>>2]=t,o[B+60>>2]=y,o[B+48>>2]=f,o[B+52>>2]=C,o[B+40>>2]=r,o[B+44>>2]=D,o[B+32>>2]=g,o[B+36>>2]=I,o[B+24>>2]=1595750129,o[B+28>>2]=-1521486534,o[B+16>>2]=-23791573,o[B+20>>2]=1013904242,o[B+8>>2]=-2067093701,o[B+12>>2]=-1150833019,o[B>>2]=-222443256^(8192|c),o[B+4>>2]=1779033703,dA(32+(I=B+384|0)|0,0,96),YA(I,i,32),YA(B+96|0,I,128),o[B+352>>2]=128,iI(I,128),J(B,A,c),w=e),A=0),w=E+32|0,0|A},Ba:QI,Ca:function(A,I,g){return 0|q(A|=0,I|=0,g|=0)},Da:function(A,I,g){return 0|gI(A|=0,I|=0,g|=0)},Ea:function(A,I){return LA(A|=0,I|=0),iI(A,4),0},Fa:function(A,I,g,C,B){var Q;return A|=0,C|=0,B|=0,w=Q=w-208|0,q(Q,I|=0,g|=0),gI(Q,C,B),LA(Q,A),iI(Q,4),w=Q+208|0,0},Ga:QI,Ha:function(A,I,g,C,B){A|=0,I|=0,g|=0,C|=0,B|=0;var Q,i=0,f=0,c=0;if(w=Q=w-256|0,E[Q+15|0]=1,I>>>0<=8160){if(I>>>0>=32)for(i=32;c=i,q(i=Q+48|0,B,32),f&&gI(i,(A+f|0)-32|0,32),gI(i=Q+48|0,g,C),gI(i,Q+15|0,1),LA(i,A+f|0),E[Q+15|0]=a[Q+15|0]+1,(i=(f=c)+32|0)>>>0<=I>>>0;);(f=31&I)&&(q(I=Q+48|0,B,32),c&&gI(I,(A+c|0)-32|0,32),gI(I=Q+48|0,g,C),gI(I,Q+15|0,1),LA(g=I,I=Q+16|0),YA(A+c|0,I,f),iI(I,32)),iI(Q+48|0,208),A=0}else o[9005]=28,A=-1;return w=Q+256|0,0|A},Ia:aI,Ja:tI,Ka:function(){return 8160},La:EI,Ma:function(A,I,g){return 0|gA(A|=0,I|=0,g|=0)},Na:function(A,I,g){return 0|AI(A|=0,I|=0,g|=0,0)},Oa:function(A,I){return bA(A|=0,I|=0),iI(A,4),0},Pa:function(A,I,g,C,B){var Q;return A|=0,C|=0,B|=0,w=Q=w-416|0,gA(Q,I|=0,g|=0),AI(Q,C,B,0),bA(Q,A),iI(Q,4),w=Q+416|0,0},Qa:function(A){HA(A|=0,64)},Ra:function(A,I,g,C,B){A|=0,I|=0,g|=0,C|=0,B|=0;var Q,i=0,f=0,c=0;if(w=Q=w-496|0,E[Q+15|0]=1,I>>>0<=16320){if(I>>>0>=64)for(i=64;c=i,gA(i=Q+80|0,B,64),f&&AI(i,(A+f|0)-64|0,64,0),AI(i=Q+80|0,g,C,0),AI(i,Q+15|0,1,0),bA(i,A+f|0),E[Q+15|0]=a[Q+15|0]+1,(i=(f=c)- -64|0)>>>0<=I>>>0;);(f=63&I)&&(gA(I=Q+80|0,B,64),c&&AI(I,(A+c|0)-64|0,64,0),AI(I=Q+80|0,g,C,0),AI(I,Q+15|0,1,0),bA(g=I,I=Q+16|0),YA(A+c|0,I,f),iI(I,64)),iI(Q+80|0,416),A=0}else o[9005]=28,A=-1;return w=Q+496|0,0|A},Sa:eI,Ta:tI,Ua:function(){return 16320},Va:function(A,I,g){return A|=0,X(I|=0,32,g|=0,32,0,0,0),0|VA(A,I)},Wa:function(A,I){return A|=0,HA(I|=0,32),0|VA(A,I)},Xa:function(A,I,g,C,B){I|=0,g|=0,C|=0,B|=0;var i,o,f=0,c=0,e=0;if(o=f=w,w=f=f-512&-64,i=(A|=0)||I){if(e=-1,!lA(c=f+96|0,C,B)){for(C=I||A,A=0,K(I=f+128|0,0,0,64),Z(I,c,32,0),iI(c,32),Z(I,g,32,0),Z(I,B,32,0),KA(I,f+32|0,64),iI(I,384);g=(I=f+32|0)+A|0,E[A+i|0]=a[0|g],E[A+C|0]=a[g+32|0],E[(B=1|A)+i|0]=a[I+B|0],E[C+B|0]=a[g+33|0],32!=(0|(A=A+2|0)););iI(I,64),e=0}return w=o,0|e}zA(),Q()},Ya:function(A,I,g,C,B){I|=0,g|=0,C|=0,B|=0;var i,o,f=0,c=0,e=0;if(o=f=w,w=f=f-512&-64,i=(A|=0)||I){if(e=-1,!lA(c=f+96|0,C,B)){for(C=I||A,A=0,K(I=f+128|0,0,0,64),Z(I,c,32,0),iI(c,32),Z(I,B,32,0),Z(I,g,32,0),KA(I,f+32|0,64),iI(I,384);g=(I=f+32|0)+A|0,E[A+C|0]=a[0|g],E[A+i|0]=a[g+32|0],E[(B=1|A)+C|0]=a[I+B|0],E[B+i|0]=a[g+33|0],32!=(0|(A=A+2|0)););iI(I,64),e=0}return w=o,0|e}zA(),Q()},Za:aI,_a:aI,$a:aI,ab:aI,bb:VA,cb:lA,db:aI,eb:aI,fb:aI,gb:fI,hb:oI,ib:cI,jb:QI,kb:PA,lb:function(A,I,g,C,B,i){return A|=0,I|=0,B|=0,i|=0,!(C|=0)&(g|=0)>>>0>=4294967280|C&&(zA(),Q()),iA(A+16|0,A,I,g,C,B,i),0},mb:vA,nb:JA,ob:QI,pb:function(A,I,g){return A|=0,g|=0,HA(I|=0,24),x(A,I,g),E[A+32|0]=1,E[A+33|0]=0,E[A+34|0]=0,E[A+35|0]=0,g=a[I+16|0]|a[I+17|0]<<8|a[I+18|0]<<16|a[I+19|0]<<24,I=a[I+20|0]|a[I+21|0]<<8|a[I+22|0]<<16|a[I+23|0]<<24,E[A+44|0]=0,E[A+45|0]=0,E[A+46|0]=0,E[A+47|0]=0,E[A+48|0]=0,E[A+49|0]=0,E[A+50|0]=0,E[A+51|0]=0,E[A+36|0]=g,E[A+37|0]=g>>>8,E[A+38|0]=g>>>16,E[A+39|0]=g>>>24,E[A+40|0]=I,E[A+41|0]=I>>>8,E[A+42|0]=I>>>16,E[A+43|0]=I>>>24,0},qb:function(A,I,g){return x(A|=0,I|=0,g|=0),E[A+32|0]=1,E[A+33|0]=0,E[A+34|0]=0,E[A+35|0]=0,g=a[I+16|0]|a[I+17|0]<<8|a[I+18|0]<<16|a[I+19|0]<<24,I=a[I+20|0]|a[I+21|0]<<8|a[I+22|0]<<16|a[I+23|0]<<24,E[A+44|0]=0,E[A+45|0]=0,E[A+46|0]=0,E[A+47|0]=0,E[A+48|0]=0,E[A+49|0]=0,E[A+50|0]=0,E[A+51|0]=0,E[A+36|0]=g,E[A+37|0]=g>>>8,E[A+38|0]=g>>>16,E[A+39|0]=g>>>24,E[A+40|0]=I,E[A+41|0]=I>>>8,E[A+42|0]=I>>>16,E[A+43|0]=I>>>24,0},rb:function(A){var I,g=0,C=0;w=I=w-48|0,g=a[28+(A|=0)|0]|a[A+29|0]<<8|a[A+30|0]<<16|a[A+31|0]<<24,o[I+24>>2]=a[A+24|0]|a[A+25|0]<<8|a[A+26|0]<<16|a[A+27|0]<<24,o[I+28>>2]=g,g=a[A+20|0]|a[A+21|0]<<8|a[A+22|0]<<16|a[A+23|0]<<24,o[I+16>>2]=a[A+16|0]|a[A+17|0]<<8|a[A+18|0]<<16|a[A+19|0]<<24,o[I+20>>2]=g,g=a[A+4|0]|a[A+5|0]<<8|a[A+6|0]<<16|a[A+7|0]<<24,o[I>>2]=a[0|A]|a[A+1|0]<<8|a[A+2|0]<<16|a[A+3|0]<<24,o[I+4>>2]=g,g=a[A+12|0]|a[A+13|0]<<8|a[A+14|0]<<16|a[A+15|0]<<24,o[I+8>>2]=a[A+8|0]|a[A+9|0]<<8|a[A+10|0]<<16|a[A+11|0]<<24,o[I+12>>2]=g,g=a[A+40|0]|a[A+41|0]<<8|a[A+42|0]<<16|a[A+43|0]<<24,o[I+32>>2]=a[A+36|0]|a[A+37|0]<<8|a[A+38|0]<<16|a[A+39|0]<<24,o[I+36>>2]=g,OA(I,I,A+32|0,A),g=o[I+28>>2],C=o[I+24>>2],E[A+24|0]=C,E[A+25|0]=C>>>8,E[A+26|0]=C>>>16,E[A+27|0]=C>>>24,E[A+28|0]=g,E[A+29|0]=g>>>8,E[A+30|0]=g>>>16,E[A+31|0]=g>>>24,g=o[I+20>>2],C=o[I+16>>2],E[A+16|0]=C,E[A+17|0]=C>>>8,E[A+18|0]=C>>>16,E[A+19|0]=C>>>24,E[A+20|0]=g,E[A+21|0]=g>>>8,E[A+22|0]=g>>>16,E[A+23|0]=g>>>24,g=o[I+12>>2],C=o[I+8>>2],E[A+8|0]=C,E[A+9|0]=C>>>8,E[A+10|0]=C>>>16,E[A+11|0]=C>>>24,E[A+12|0]=g,E[A+13|0]=g>>>8,E[A+14|0]=g>>>16,E[A+15|0]=g>>>24,g=o[I+4>>2],C=o[I>>2],E[0|A]=C,E[A+1|0]=C>>>8,E[A+2|0]=C>>>16,E[A+3|0]=C>>>24,E[A+4|0]=g,E[A+5|0]=g>>>8,E[A+6|0]=g>>>16,E[A+7|0]=g>>>24,C=o[I+36>>2],g=o[I+32>>2],E[A+32|0]=1,E[A+33|0]=0,E[A+34|0]=0,E[A+35|0]=0,E[A+36|0]=g,E[A+37|0]=g>>>8,E[A+38|0]=g>>>16,E[A+39|0]=g>>>24,E[A+40|0]=C,E[A+41|0]=C>>>8,E[A+42|0]=C>>>16,E[A+43|0]=C>>>24,w=I+48|0},sb:function(A,I,g,C,B,i,f,c,e,r){A|=0,I|=0,C|=0,i|=0,f|=0,e|=0,r|=0;var D,t=0,y=0,h=0;return t=B|=0,t|=B=0,D=B|(c|=0),w=B=w-384|0,(g|=0)&&(o[g>>2]=0,o[g+4>>2]=0),!i&t>>>0<4294967279?(ZA(y=B+16|0,64,h=A+32|0,A),CI(c=B+80|0,y),iI(y,64),$A(c,f,D,e),$A(c,34288,0-D&15,0),o[B+72>>2]=0,o[B+76>>2]=0,o[(f=B- -64|0)>>2]=0,o[f+4>>2]=0,o[B+56>>2]=0,o[B+60>>2]=0,o[B+48>>2]=0,o[B+52>>2]=0,o[B+40>>2]=0,o[B+44>>2]=0,o[B+32>>2]=0,o[B+36>>2]=0,o[B+16>>2]=0,o[B+20>>2]=0,o[B+24>>2]=0,o[B+28>>2]=0,E[B+16|0]=r,FA(y,y,64,0,h,1,A),$A(c,y,64,0),E[0|I]=a[B+16|0],FA(I=I+1|0,C,t,i,h,2,A),$A(c,I,t,i),$A(c,34288,15&t,0),o[B+8>>2]=D,o[B+12>>2]=e,$A(c,C=B+8|0,8,0),o[B+8>>2]=t- -64,o[B+12>>2]=i-((t>>>0<4294967232)-1|0),$A(c,C,8,0),BI(c,I=I+t|0),iI(c,256),E[A+36|0]=a[A+36|0]^a[0|I],E[A+37|0]=a[A+37|0]^a[I+1|0],E[A+38|0]=a[A+38|0]^a[I+2|0],E[A+39|0]=a[A+39|0]^a[I+3|0],E[A+40|0]=a[A+40|0]^a[I+4|0],E[A+41|0]=a[A+41|0]^a[I+5|0],E[A+42|0]=a[A+42|0]^a[I+6|0],E[A+43|0]=a[A+43|0]^a[I+7|0],sA(h),(2&r||fA(h,4))&&(I=a[A+28|0]|a[A+29|0]<<8|a[A+30|0]<<16|a[A+31|0]<<24,o[B+360>>2]=a[A+24|0]|a[A+25|0]<<8|a[A+26|0]<<16|a[A+27|0]<<24,o[B+364>>2]=I,I=a[A+20|0]|a[A+21|0]<<8|a[A+22|0]<<16|a[A+23|0]<<24,o[B+352>>2]=a[A+16|0]|a[A+17|0]<<8|a[A+18|0]<<16|a[A+19|0]<<24,o[B+356>>2]=I,I=a[A+4|0]|a[A+5|0]<<8|a[A+6|0]<<16|a[A+7|0]<<24,o[B+336>>2]=a[0|A]|a[A+1|0]<<8|a[A+2|0]<<16|a[A+3|0]<<24,o[B+340>>2]=I,I=a[A+12|0]|a[A+13|0]<<8|a[A+14|0]<<16|a[A+15|0]<<24,o[B+344>>2]=a[A+8|0]|a[A+9|0]<<8|a[A+10|0]<<16|a[A+11|0]<<24,o[B+348>>2]=I,I=a[A+40|0]|a[A+41|0]<<8|a[A+42|0]<<16|a[A+43|0]<<24,o[B+368>>2]=a[A+36|0]|a[A+37|0]<<8|a[A+38|0]<<16|a[A+39|0]<<24,o[B+372>>2]=I,OA(I=B+336|0,I,h,A),I=o[B+364>>2],C=o[B+360>>2],E[A+24|0]=C,E[A+25|0]=C>>>8,E[A+26|0]=C>>>16,E[A+27|0]=C>>>24,E[A+28|0]=I,E[A+29|0]=I>>>8,E[A+30|0]=I>>>16,E[A+31|0]=I>>>24,I=o[B+356>>2],C=o[B+352>>2],E[A+16|0]=C,E[A+17|0]=C>>>8,E[A+18|0]=C>>>16,E[A+19|0]=C>>>24,E[A+20|0]=I,E[A+21|0]=I>>>8,E[A+22|0]=I>>>16,E[A+23|0]=I>>>24,I=o[B+348>>2],C=o[B+344>>2],E[A+8|0]=C,E[A+9|0]=C>>>8,E[A+10|0]=C>>>16,E[A+11|0]=C>>>24,E[A+12|0]=I,E[A+13|0]=I>>>8,E[A+14|0]=I>>>16,E[A+15|0]=I>>>24,I=o[B+340>>2],C=o[B+336>>2],E[0|A]=C,E[A+1|0]=C>>>8,E[A+2|0]=C>>>16,E[A+3|0]=C>>>24,E[A+4|0]=I,E[A+5|0]=I>>>8,E[A+6|0]=I>>>16,E[A+7|0]=I>>>24,I=o[B+368>>2],C=o[B+372>>2],E[A+32|0]=1,E[A+33|0]=0,E[A+34|0]=0,E[A+35|0]=0,E[A+36|0]=I,E[A+37|0]=I>>>8,E[A+38|0]=I>>>16,E[A+39|0]=I>>>24,E[A+40|0]=C,E[A+41|0]=C>>>8,E[A+42|0]=C>>>16,E[A+43|0]=C>>>24),g&&(i=(A=t+17|0)>>>0<17?i+1|0:i,o[g>>2]=A,o[g+4>>2]=i),w=B+384|0):(zA(),Q()),0},tb:function(A,I,g,C,B,i,f,c,e,r){A|=0,I|=0,C|=0,B|=0,c|=0,r|=0;var D,t=0,y=0,h=0,n=0,s=0,k=0;t=i|=0,i=f|=0,y=0|t,D=e|=0,w=f=w-400|0,(g|=0)&&(o[g>>2]=0,o[g+4>>2]=0),C&&(E[0|C]=255),k=-1;A:{I:{if(!((e=y>>>0<17)&!i)){if(s=t=i-e|0,!t&(e=y-17|0)>>>0>=4294967279|t)break I;ZA(h=f+32|0,64,n=A+32|0,A),CI(t=f+96|0,h),iI(h,64),$A(t,c,D,r),$A(t,34288,0-D&15,0),o[f+88>>2]=0,o[f+92>>2]=0,o[f+80>>2]=0,o[f+84>>2]=0,o[f+72>>2]=0,o[f+76>>2]=0,o[(c=f- -64|0)>>2]=0,o[c+4>>2]=0,o[f+56>>2]=0,o[f+60>>2]=0,o[f+48>>2]=0,o[f+52>>2]=0,o[f+40>>2]=0,o[f+44>>2]=0,o[f+32>>2]=0,o[f+36>>2]=0,E[f+32|0]=a[0|B],FA(h,h,64,0,n,1,A),c=a[f+32|0],E[f+32|0]=a[0|B],$A(t,h,64,0),$A(t,B=B+1|0,e,s),$A(t,34288,y-1&15,0),o[f+24>>2]=D,o[f+28>>2]=r,$A(t,r=f+24|0,8,0),i=(y=y+47|0)>>>0<47?i+1|0:i,o[f+24>>2]=y,o[f+28>>2]=i,$A(t,r,8,0),BI(t,f),iI(t,256),eA(f,B+e|0,16)?iI(f,16):(FA(I,B,e,s,n,2,A),E[A+36|0]=a[A+36|0]^a[0|f],E[A+37|0]=a[A+37|0]^a[f+1|0],E[A+38|0]=a[A+38|0]^a[f+2|0],E[A+39|0]=a[A+39|0]^a[f+3|0],E[A+40|0]=a[A+40|0]^a[f+4|0],E[A+41|0]=a[A+41|0]^a[f+5|0],E[A+42|0]=a[A+42|0]^a[f+6|0],E[A+43|0]=a[A+43|0]^a[f+7|0],sA(n),(2&c||fA(n,4))&&(I=a[A+28|0]|a[A+29|0]<<8|a[A+30|0]<<16|a[A+31|0]<<24,o[f+376>>2]=a[A+24|0]|a[A+25|0]<<8|a[A+26|0]<<16|a[A+27|0]<<24,o[f+380>>2]=I,I=a[A+20|0]|a[A+21|0]<<8|a[A+22|0]<<16|a[A+23|0]<<24,o[f+368>>2]=a[A+16|0]|a[A+17|0]<<8|a[A+18|0]<<16|a[A+19|0]<<24,o[f+372>>2]=I,I=a[A+4|0]|a[A+5|0]<<8|a[A+6|0]<<16|a[A+7|0]<<24,o[f+352>>2]=a[0|A]|a[A+1|0]<<8|a[A+2|0]<<16|a[A+3|0]<<24,o[f+356>>2]=I,I=a[A+12|0]|a[A+13|0]<<8|a[A+14|0]<<16|a[A+15|0]<<24,o[f+360>>2]=a[A+8|0]|a[A+9|0]<<8|a[A+10|0]<<16|a[A+11|0]<<24,o[f+364>>2]=I,I=a[A+40|0]|a[A+41|0]<<8|a[A+42|0]<<16|a[A+43|0]<<24,o[f+384>>2]=a[A+36|0]|a[A+37|0]<<8|a[A+38|0]<<16|a[A+39|0]<<24,o[f+388>>2]=I,OA(I=f+352|0,I,n,A),I=o[f+380>>2],B=o[f+376>>2],E[A+24|0]=B,E[A+25|0]=B>>>8,E[A+26|0]=B>>>16,E[A+27|0]=B>>>24,E[A+28|0]=I,E[A+29|0]=I>>>8,E[A+30|0]=I>>>16,E[A+31|0]=I>>>24,I=o[f+372>>2],B=o[f+368>>2],E[A+16|0]=B,E[A+17|0]=B>>>8,E[A+18|0]=B>>>16,E[A+19|0]=B>>>24,E[A+20|0]=I,E[A+21|0]=I>>>8,E[A+22|0]=I>>>16,E[A+23|0]=I>>>24,I=o[f+364>>2],B=o[f+360>>2],E[A+8|0]=B,E[A+9|0]=B>>>8,E[A+10|0]=B>>>16,E[A+11|0]=B>>>24,E[A+12|0]=I,E[A+13|0]=I>>>8,E[A+14|0]=I>>>16,E[A+15|0]=I>>>24,I=o[f+356>>2],B=o[f+352>>2],E[0|A]=B,E[A+1|0]=B>>>8,E[A+2|0]=B>>>16,E[A+3|0]=B>>>24,E[A+4|0]=I,E[A+5|0]=I>>>8,E[A+6|0]=I>>>16,E[A+7|0]=I>>>24,I=o[f+384>>2],B=o[f+388>>2],E[A+32|0]=1,E[A+33|0]=0,E[A+34|0]=0,E[A+35|0]=0,E[A+36|0]=I,E[A+37|0]=I>>>8,E[A+38|0]=I>>>16,E[A+39|0]=I>>>24,E[A+40|0]=B,E[A+41|0]=B>>>8,E[A+42|0]=B>>>16,E[A+43|0]=B>>>24),g&&(o[g>>2]=e,o[g+4>>2]=s),k=0,C&&(E[0|C]=c))}w=f+400|0;break A}zA(),Q()}return 0|k},ub:function(){return 52},vb:function(){return 17},wb:fI,xb:aI,yb:function(){return-18},zb:tI,Ab:rI,Bb:function(){return 2},Cb:function(){return 3},Db:DI,Eb:oI,Fb:function(A,I,g,C,B){A|=0,I|=0,g|=0,C|=0;var Q,i=0,o=0,f=0,c=0,e=0,r=0,D=0,t=0,y=0,w=0,n=0,s=0,k=0,F=0,S=0;if(k=1886610805^(i=a[0|(B|=0)]|a[B+1|0]<<8|a[B+2|0]<<16|a[B+3|0]<<24),t=1936682341^(o=a[B+4|0]|a[B+5|0]<<8|a[B+6|0]<<16|a[B+7|0]<<24),i^=1852142177,f=1819895653^o,F=1852075885^(o=a[B+8|0]|a[B+9|0]<<8|a[B+10|0]<<16|a[B+11|0]<<24),S=1685025377^(B=a[B+12|0]|a[B+13|0]<<8|a[B+14|0]<<16|a[B+15|0]<<24),D=2037671283^o,o=1952801890^B,n=g,(0|(w=(g+I|0)-(Q=7&g)|0))!=(0|I)){for(;g=(e=o^(s=a[I+4|0]|a[I+5|0]<<8|a[I+6|0]<<16|a[I+7|0]<<24))+f|0,D=C=i+(B=D^(y=a[0|I]|a[I+1|0]<<8|a[I+2|0]<<16|a[I+3|0]<<24))|0,r=g=C>>>0<B>>>0?g+1|0:g,i=C,C=g,g=t+S|0,g=(o=k+F|0)>>>0<F>>>0?g+1|0:g,c=(f=DA(F,S,13)^o)+i|0,C=(i=h^g)+C|0,i=DA(f,i,17)^c,k=DA(i,C=(f=f>>>0>c>>>0?C+1|0:C)^h,13),t=h,e=DA(B,e,16),B=r^h,e^=D,r=DA(o,g,32),g=h+B|0,g=(D=C)+(C=(o=e+r|0)>>>0<r>>>0?g+1|0:g)|0,r=g=(D=i+o|0)>>>0<o>>>0?g+1|0:g,k=DA(i=D^k,g^=t,17),t=h,e=DA(e,B,21),B=C^h,e^=o,o=DA(c,f,32),C=h+B|0,g=(o=o>>>0>(f=e+o|0)>>>0?C+1|0:C)+g|0,F=(i=i+f|0)^k,C=g=i>>>0<f>>>0?g+1|0:g,S=g^t,g=DA(e,B,16),e=o^=h,c=DA(g^=f,o,21),f=h,r=(o=DA(D,r,32))+g|0,g=h+e|0,D=c^r,o=(g=o>>>0>r>>>0?g+1|0:g)^f,i=DA(i,C,32),f=h,k=r^y,t=g^s,(0|w)!=(0|(I=I+8|0)););I=w}switch(s=0,c=n<<24,Q-1|0){case 6:c|=a[I+6|0]<<16;case 5:c|=a[I+5|0]<<8;case 4:c|=a[I+4|0];case 3:s|=(g=a[I+3|0])<<24,c|=C=g>>>8|0;case 2:s|=(C=a[I+2|0])<<16,c|=g=C>>>16|0;case 1:s|=(g=a[I+1|0])<<8,c|=C=g>>>24|0;case 0:s=a[0|I]|s}return I=A,C=DA(B=D^s,A=o^c,16),A=A+f|0,r=A=(D=B+i|0)>>>0<i>>>0?A+1|0:A,y=DA(B=C^D,A^=g=h,21),o=h,g=t+S|0,C=g=(i=k+F|0)>>>0<F>>>0?g+1|0:g,w=B,B=DA(i,g,32),g=h+A|0,A=o,o=g=B>>>0>(f=w+B|0)>>>0?g+1|0:g,e=DA(B=f^y,A^=g,16),y=h,n=DA(F,S,13)^i,C=(w=h^C)+r|0,r=B,B=DA(g=(i=n)+D|0,C=g>>>0<i>>>0?C+1|0:C,32),A=h+A|0,t=DA(i=e^(D=r+B|0),B=(r=B>>>0>D>>>0?A+1|0:A)^y,21),y=h,e=DA(n,w,17)^g,g=(n=h^C)+o|0,A=g=(C=f=(A=e)+f|0)>>>0<A>>>0?g+1|0:g,o=i,i=DA(C,g,32),g=h+B|0,w=g=(o=i>>>0>(f=o+i|0)>>>0?g+1|0:g)^y,y=DA(t^=f,g,16),i=h,e=DA(e,n,13)^C,A=(n=A^h)+r|0,C=A=(g=e)>>>0>(B=g+D|0)>>>0?A+1|0:A,A=DA(B,A,32),g=w+h|0,w=g=(r=i)^(i=(A=t+(255^A)|0)>>>0<t>>>0?g+1|0:g),D=A,y=DA(t=y^A,g,21),r=h,e=DA(e,n,17)^B,g=(n=C^h)+(o^c)|0,C=g=(A=f^s)>>>0>(B=e+A|0)>>>0?g+1|0:g,A=DA(B,g,32),g=w+h|0,w=g=(o=(A=A+t|0)>>>0<t>>>0?g+1|0:g)^r,r=A,y=DA(t=y^A,g,16),f=h,e=DA(e,n,13)^B,A=i+(c=h^C)|0,A=DA(B=D+e|0,g=A=B>>>0<D>>>0?A+1|0:A,32),C=w+h|0,n=C=(i=(A=A+t|0)>>>0<t>>>0?C+1|0:C)^f,f=A,w=DA(t=y^A,C,21),y=h,A=DA(e,c,17),g=o+(c=g^h)|0,C=g=(B=r+(D=A^B)|0)>>>0<r>>>0?g+1|0:g,A=DA(B,g,32),g=n+h|0,r=A=A+t|0,o=g=A>>>0<t>>>0?g+1|0:g,n=DA(e=w^A,g^=y,16),w=h,A=DA(D,c,13),C=i+(y=C^h)|0,A=DA(i=f+(c=A^B)|0,C=i>>>0<f>>>0?C+1|0:C,32),g=g+h|0,D=A=A+e|0,f=g=A>>>0<e>>>0?g+1|0:g,e=DA(B=n^A,A=g^w,21),n=h,c=DA(c,y,17),g=o+(w=C^h)|0,y=i^c,i=B,B=DA(C=r+y|0,g=C>>>0<r>>>0?g+1|0:g,32),A=h+A|0,n=DA(i=e^(r=i+B|0),B=(o=B>>>0>r>>>0?A+1|0:A)^n,16),c=h,A=DA(y,w,13),g=f+(w=g^h)|0,A=g=(C=D+(y=A^C)|0)>>>0<D>>>0?g+1|0:g,f=DA(C,g,32),g=h+B|0,c=DA(n^(B=i=f+i|0),(g=B>>>0<f>>>0?g+1|0:g)^c,21),D=h,i=DA(y,w,17)^C,f=DA(i,A^=h,13),A=A+o|0,C=A=h^((i=i+r|0)>>>0<r>>>0?A+1|0:A),i=DA(o=i^f,A,17)^c,A=h^D,C=g+C|0,g=DA(g=B+o|0,C=g>>>0<B>>>0?C+1|0:C,32)^i^g,E[0|I]=g,E[I+1|0]=g>>>8,E[I+2|0]=g>>>16,E[I+3|0]=g>>>24,A^=C^h,E[I+4|0]=A,E[I+5|0]=A>>>8,E[I+6|0]=A>>>16,E[I+7|0]=A>>>24,0},Gb:function(A){HA(A|=0,16)},Hb:EI,Ib:eI,Jb:aI,Kb:aI,Lb:eI,Mb:function(){return-65},Nb:function(A,I,g){A|=0;var C,B,Q,i,o=0,f=0,c=0,e=0,r=0;return w=Q=w-160|0,aA(I|=0,g|=0,32,0),E[0|I]=248&a[0|I],E[I+31|0]=63&a[I+31|0]|64,u(Q,I),MA(A,Q),f=a[(B=g)+8|0]|a[B+9|0]<<8|a[B+10|0]<<16|a[B+11|0]<<24,o=a[B+12|0]|a[B+13|0]<<8|a[B+14|0]<<16|a[B+15|0]<<24,c=a[B+16|0]|a[B+17|0]<<8|a[B+18|0]<<16|a[B+19|0]<<24,e=a[B+20|0]|a[B+21|0]<<8|a[B+22|0]<<16|a[B+23|0]<<24,r=a[0|B]|a[B+1|0]<<8|a[B+2|0]<<16|a[B+3|0]<<24,g=a[B+4|0]|a[B+5|0]<<8|a[B+6|0]<<16|a[B+7|0]<<24,i=a[B+28|0]|a[B+29|0]<<8|a[B+30|0]<<16|a[B+31|0]<<24,C=I,I=a[B+24|0]|a[B+25|0]<<8|a[B+26|0]<<16|a[B+27|0]<<24,E[C+24|0]=I,E[C+25|0]=I>>>8,E[C+26|0]=I>>>16,E[C+27|0]=I>>>24,E[C+28|0]=i,E[C+29|0]=i>>>8,E[C+30|0]=i>>>16,E[C+31|0]=i>>>24,E[C+16|0]=c,E[C+17|0]=c>>>8,E[C+18|0]=c>>>16,E[C+19|0]=c>>>24,E[C+20|0]=e,E[C+21|0]=e>>>8,E[C+22|0]=e>>>16,E[C+23|0]=e>>>24,E[C+8|0]=f,E[C+9|0]=f>>>8,E[C+10|0]=f>>>16,E[C+11|0]=f>>>24,E[C+12|0]=o,E[C+13|0]=o>>>8,E[C+14|0]=o>>>16,E[C+15|0]=o>>>24,E[0|C]=r,E[C+1|0]=r>>>8,E[C+2|0]=r>>>16,E[C+3|0]=r>>>24,E[C+4|0]=g,E[C+5|0]=g>>>8,E[C+6|0]=g>>>16,E[C+7|0]=g>>>24,c=a[(o=A)+8|0]|a[o+9|0]<<8|a[o+10|0]<<16|a[o+11|0]<<24,e=a[o+12|0]|a[o+13|0]<<8|a[o+14|0]<<16|a[o+15|0]<<24,r=a[o+16|0]|a[o+17|0]<<8|a[o+18|0]<<16|a[o+19|0]<<24,g=a[o+20|0]|a[o+21|0]<<8|a[o+22|0]<<16|a[o+23|0]<<24,I=a[0|o]|a[o+1|0]<<8|a[o+2|0]<<16|a[o+3|0]<<24,A=a[o+4|0]|a[o+5|0]<<8|a[o+6|0]<<16|a[o+7|0]<<24,f=a[o+28|0]|a[o+29|0]<<8|a[o+30|0]<<16|a[o+31|0]<<24,o=a[o+24|0]|a[o+25|0]<<8|a[o+26|0]<<16|a[o+27|0]<<24,E[C+56|0]=o,E[C+57|0]=o>>>8,E[C+58|0]=o>>>16,E[C+59|0]=o>>>24,E[C+60|0]=f,E[C+61|0]=f>>>8,E[C+62|0]=f>>>16,E[C+63|0]=f>>>24,E[C+48|0]=r,E[C+49|0]=r>>>8,E[C+50|0]=r>>>16,E[C+51|0]=r>>>24,E[C+52|0]=g,E[C+53|0]=g>>>8,E[C+54|0]=g>>>16,E[C+55|0]=g>>>24,E[C+40|0]=c,E[C+41|0]=c>>>8,E[C+42|0]=c>>>16,E[C+43|0]=c>>>24,E[C+44|0]=e,E[C+45|0]=e>>>8,E[C+46|0]=e>>>16,E[C+47|0]=e>>>24,E[C+32|0]=I,E[C+33|0]=I>>>8,E[C+34|0]=I>>>16,E[C+35|0]=I>>>24,E[C+36|0]=A,E[C+37|0]=A>>>8,E[C+38|0]=A>>>16,E[C+39|0]=A>>>24,w=Q+160|0,0},Ob:function(A,I){A|=0,I|=0;var g,C,B,Q,i,f=0,c=0,e=0;return w=c=w-192|0,HA(c,32),aA(I,c,32,0),E[0|I]=248&a[0|I],E[I+31|0]=63&a[I+31|0]|64,u(e=c+32|0,I),MA(A,e),g=c,e=o[c+28>>2],c=o[c+24>>2],E[I+24|0]=c,E[I+25|0]=c>>>8,E[I+26|0]=c>>>16,E[I+27|0]=c>>>24,E[I+28|0]=e,E[I+29|0]=e>>>8,E[I+30|0]=e>>>16,E[I+31|0]=e>>>24,e=o[g+20>>2],c=o[g+16>>2],E[I+16|0]=c,E[I+17|0]=c>>>8,E[I+18|0]=c>>>16,E[I+19|0]=c>>>24,E[I+20|0]=e,E[I+21|0]=e>>>8,E[I+22|0]=e>>>16,E[I+23|0]=e>>>24,e=o[g+12>>2],c=o[g+8>>2],E[I+8|0]=c,E[I+9|0]=c>>>8,E[I+10|0]=c>>>16,E[I+11|0]=c>>>24,E[I+12|0]=e,E[I+13|0]=e>>>8,E[I+14|0]=e>>>16,E[I+15|0]=e>>>24,e=o[g+4>>2],c=o[g>>2],E[0|I]=c,E[I+1|0]=c>>>8,E[I+2|0]=c>>>16,E[I+3|0]=c>>>24,E[I+4|0]=e,E[I+5|0]=e>>>8,E[I+6|0]=e>>>16,E[I+7|0]=e>>>24,C=a[(f=A)+8|0]|a[f+9|0]<<8|a[f+10|0]<<16|a[f+11|0]<<24,B=a[f+12|0]|a[f+13|0]<<8|a[f+14|0]<<16|a[f+15|0]<<24,Q=a[f+16|0]|a[f+17|0]<<8|a[f+18|0]<<16|a[f+19|0]<<24,e=a[f+20|0]|a[f+21|0]<<8|a[f+22|0]<<16|a[f+23|0]<<24,c=a[0|f]|a[f+1|0]<<8|a[f+2|0]<<16|a[f+3|0]<<24,A=a[f+4|0]|a[f+5|0]<<8|a[f+6|0]<<16|a[f+7|0]<<24,i=a[f+28|0]|a[f+29|0]<<8|a[f+30|0]<<16|a[f+31|0]<<24,f=a[f+24|0]|a[f+25|0]<<8|a[f+26|0]<<16|a[f+27|0]<<24,E[I+56|0]=f,E[I+57|0]=f>>>8,E[I+58|0]=f>>>16,E[I+59|0]=f>>>24,E[I+60|0]=i,E[I+61|0]=i>>>8,E[I+62|0]=i>>>16,E[I+63|0]=i>>>24,E[I+48|0]=Q,E[I+49|0]=Q>>>8,E[I+50|0]=Q>>>16,E[I+51|0]=Q>>>24,E[I+52|0]=e,E[I+53|0]=e>>>8,E[I+54|0]=e>>>16,E[I+55|0]=e>>>24,E[I+40|0]=C,E[I+41|0]=C>>>8,E[I+42|0]=C>>>16,E[I+43|0]=C>>>24,E[I+44|0]=B,E[I+45|0]=B>>>8,E[I+46|0]=B>>>16,E[I+47|0]=B>>>24,E[I+32|0]=c,E[I+33|0]=c>>>8,E[I+34|0]=c>>>16,E[I+35|0]=c>>>24,E[I+36|0]=A,E[I+37|0]=A>>>8,E[I+38|0]=A>>>16,E[I+39|0]=A>>>24,iI(g,32),w=g+192|0,0},Pb:function(A,I,g,C,B,Q){I|=0,B|=0,Q|=0;var i,E=0;return w=i=w-16|0,s(A|=0,i+8|0,pA(A- -64|0,g|=0,C|=0),C,B,Q,0),64!=o[i+8>>2]|o[i+12>>2]?(I&&(o[I>>2]=0,o[I+4>>2]=0),dA(A,0,C- -64|0),E=-1):I&&(o[I>>2]=C- -64,o[I+4>>2]=B-((C>>>0<4294967232)-1|0)),w=i+16|0,0|E},Qb:function(A,I,g,C,B,Q){A|=0,I|=0,g|=0;var i=0;A:{I:{if(i=C|=0,!(!(B|=0)&C>>>0<64||(C=B-1|0,!(C=(B=i+-64|0)>>>0<4294967232?C+1|0:C)&B>>>0>4294967231|C))){if(!S(g,i=g- -64|0,B,C,Q|=0,0))break I;A&&dA(A,0,B)}if(g=-1,!I)break A;o[I>>2]=0,o[I+4>>2]=0;break A}I&&(o[I>>2]=B,o[I+4>>2]=C),g=0,A&&pA(A,i,B)}return 0|g},Rb:function(A,I,g,C,B,Q){return s(A|=0,I|=0,g|=0,C|=0,B|=0,Q|=0,0),0},Sb:function(A,I,g,C,B){return 0|S(A|=0,I|=0,g|=0,C|=0,B|=0,0)},Tb:function(A){return cA(A|=0),0},Ub:function(A,I,g,C){return 0|R(A|=0,I|=0,g|=0,C|=0)},Vb:function(A,I,g,C){var B;return I|=0,g|=0,C|=0,w=B=w+-64|0,N(A|=0,B),A=s(I,g,B,64,0,C,1),w=B- -64|0,0|A},Wb:function(A,I,g){var C;return I|=0,g|=0,w=C=w+-64|0,N(A|=0,C),A=S(I,C,64,0,g,1),w=C- -64|0,0|A},Xb:function(A,I){A|=0;var g,C=0,B=0,Q=0,i=0,a=0,f=0,e=0,r=0,D=0,t=0,y=0,n=0,s=0,k=0,F=0,S=0,_=0,M=0,p=0,N=0,J=0,Y=0,d=0,K=0,v=0,L=0,R=0,u=0,x=0,m=0,l=0,z=0,q=0,X=0,j=0,T=0,V=0,Z=0,$=0,AA=0,gA=0,CA=0,BA=0,QA=0,iA=0,EA=0,oA=0,aA=0,cA=0,eA=0,DA=0,tA=0,yA=0,wA=0,hA=0,nA=0,sA=0,FA=0,SA=0,HA=0,GA=0,_A=0,MA=0,pA=0,NA=0,JA=0,UA=0,YA=0,KA=0,bA=0,PA=0,vA=0,LA=0,RA=0,uA=0,xA=0,mA=0,lA=0,zA=0,qA=0;if(w=g=w-256|0,vA=-1,!rA(I|=0)&&!U(C=g+96|0,I)){for(w=Q=w-2048|0,W(i=Q+640|0,C),C=o[(I=C)+36>>2],o[Q+352>>2]=o[I+32>>2],o[Q+356>>2]=C,C=o[I+28>>2],o[Q+344>>2]=o[I+24>>2],o[Q+348>>2]=C,C=o[I+20>>2],o[Q+336>>2]=o[I+16>>2],o[Q+340>>2]=C,C=o[I+12>>2],o[Q+328>>2]=o[I+8>>2],o[Q+332>>2]=C,C=o[I+4>>2],o[Q+320>>2]=o[I>>2],o[Q+324>>2]=C,C=o[I+52>>2],o[Q+368>>2]=o[I+48>>2],o[Q+372>>2]=C,C=o[I+60>>2],o[Q+376>>2]=o[I+56>>2],o[Q+380>>2]=C,B=o[4+(C=I- -64|0)>>2],o[Q+384>>2]=o[C>>2],o[Q+388>>2]=B,C=o[I+76>>2],o[Q+392>>2]=o[I+72>>2],o[Q+396>>2]=C,C=o[I+44>>2],o[Q+360>>2]=o[I+40>>2],o[Q+364>>2]=C,C=o[I+92>>2],o[Q+408>>2]=o[I+88>>2],o[Q+412>>2]=C,C=o[I+100>>2],o[Q+416>>2]=o[I+96>>2],o[Q+420>>2]=C,C=o[I+108>>2],o[Q+424>>2]=o[I+104>>2],o[Q+428>>2]=C,C=o[I+116>>2],o[Q+432>>2]=o[I+112>>2],o[Q+436>>2]=C,C=o[I+84>>2],o[Q+400>>2]=o[I+80>>2],o[Q+404>>2]=C,G(I=Q+480|0,C=Q+320|0),H(B=Q+160|0,I,f=Q+600|0),H(Q+200|0,r=Q+520|0,D=Q+560|0),H(Q+240|0,D,f),H(Q+280|0,I,r),b(I,B,i),H(C,I,f),H(F=Q+360|0,r,D),H(S=Q+400|0,D,f),H(n=Q+440|0,I,r),W(i=Q+800|0,C),b(I,B,i),H(C,I,f),H(F,r,D),H(S,D,f),H(n,I,r),W(i=Q+960|0,C),b(I,B,i),H(C,I,f),H(F,r,D),H(S,D,f),H(n,I,r),W(i=Q+1120|0,C),b(I,B,i),H(C,I,f),H(F,r,D),H(S,D,f),H(n,I,r),W(i=Q+1280|0,C),b(I,B,i),H(C,I,f),H(F,r,D),H(S,D,f),H(n,I,r),W(i=Q+1440|0,C),b(I,B,i),H(C,I,f),H(F,r,D),H(S,D,f),H(n,I,r),W(i=Q+1600|0,C),b(I,B,i),H(C,I,f),H(F,r,D),H(S,D,f),H(n,I,r),W(Q+1760|0,C),o[Q+32>>2]=0,o[Q+36>>2]=0,o[Q+24>>2]=0,o[Q+28>>2]=0,o[Q+16>>2]=0,o[Q+20>>2]=0,o[Q+8>>2]=0,o[Q+12>>2]=0,o[Q+44>>2]=0,o[Q+48>>2]=0,o[Q+52>>2]=0,o[Q+56>>2]=0,o[Q+60>>2]=0,o[Q+64>>2]=0,o[Q+68>>2]=0,o[Q+72>>2]=0,o[Q+76>>2]=0,o[Q+80>>2]=1,o[Q>>2]=0,o[Q+4>>2]=0,o[Q+40>>2]=1,dA(Q+84|0,0,76),t=Q+120|0,k=Q+2008|0,s=Q+1968|0,C=Q+80|0,B=Q+40|0,i=252;a=o[Q+36>>2],o[(I=Q+1960|0)>>2]=o[Q+32>>2],o[I+4>>2]=a,a=o[Q+28>>2],o[(I=Q+1952|0)>>2]=o[Q+24>>2],o[I+4>>2]=a,a=o[Q+20>>2],o[(I=Q+1944|0)>>2]=o[Q+16>>2],o[I+4>>2]=a,a=o[Q+12>>2],o[(I=Q+1936|0)>>2]=o[Q+8>>2],o[I+4>>2]=a,I=o[Q+4>>2],o[Q+1928>>2]=o[Q>>2],o[Q+1932>>2]=I,a=o[(I=B)+36>>2],o[s+32>>2]=o[I+32>>2],o[s+36>>2]=a,a=o[I+28>>2],o[s+24>>2]=o[I+24>>2],o[s+28>>2]=a,a=o[I+20>>2],o[s+16>>2]=o[I+16>>2],o[s+20>>2]=a,a=o[I+12>>2],o[s+8>>2]=o[I+8>>2],o[s+12>>2]=a,a=o[I+4>>2],o[s>>2]=o[I>>2],o[s+4>>2]=a,a=o[(I=C)+36>>2],o[k+32>>2]=o[I+32>>2],o[k+36>>2]=a,a=o[I+28>>2],o[k+24>>2]=o[I+24>>2],o[k+28>>2]=a,a=o[I+20>>2],o[k+16>>2]=o[I+16>>2],o[k+20>>2]=a,a=o[I+12>>2],o[k+8>>2]=o[I+8>>2],o[k+12>>2]=a,a=o[I+4>>2],o[k>>2]=o[I>>2],o[k+4>>2]=a,i=E[(I=i)+33424|0],G(a=Q+480|0,Q+1928|0),(0|i)>0?(H(M=Q+320|0,a,f),H(F,r,D),H(S,D,f),H(n,a,r),b(a,M,(Q+640|0)+c((254&i)>>>1|0,160)|0)):(0|i)>=0||(H(M=Q+320|0,a=Q+480|0,f),H(F,r,D),H(S,D,f),H(n,a,r),P(a,M,(Q+640|0)+c((0-i&254)>>>1|0,160)|0)),H(Q,i=Q+480|0,f),H(B,r,D),H(C,D,f),H(t,i,r),i=I-1|0,I;);IA(I=Q+640|0,Q),I=fA(I,32),w=Q+2048|0,I&&(Q=o[g+136>>2],o[g>>2]=1-Q,vA=0,z=o[g+172>>2],o[g+36>>2]=0-z,F=o[g+168>>2],o[g+32>>2]=0-F,q=o[g+164>>2],o[g+28>>2]=0-q,r=o[g+160>>2],o[g+24>>2]=0-r,X=o[g+156>>2],o[g+20>>2]=0-X,D=o[g+152>>2],o[g+16>>2]=0-D,j=o[g+148>>2],o[g+12>>2]=0-j,k=o[g+144>>2],o[g+8>>2]=0-k,T=o[g+140>>2],o[g+4>>2]=0-T,O(g,g),I=kA(S=o[g+4>>2],x=S>>31,Y=X<<1,cA=Y>>31),C=h,B=kA(f=o[g>>2],d=f>>31,r,K=r>>31),C=h+C|0,C=(I=B+I|0)>>>0<B>>>0?C+1|0:C,B=(i=kA(a=o[g+8>>2],V=a>>31,D,v=D>>31))+I|0,I=h+C|0,I=B>>>0<i>>>0?I+1|0:I,C=B,B=kA(m=o[g+12>>2],AA=m>>31,BA=j<<1,eA=BA>>31),I=h+I|0,I=(C=C+B|0)>>>0<B>>>0?I+1|0:I,B=kA(Z=o[g+16>>2],QA=Z>>31,k,L=k>>31),I=h+I|0,I=(C=B+C|0)>>>0<B>>>0?I+1|0:I,JA=i=o[g+20>>2],s=kA(i,DA=i>>31,iA=T<<1,tA=iA>>31),B=h+I|0,B=(C=s+C|0)>>>0<s>>>0?B+1|0:B,UA=p=o[g+24>>2],I=(Q=kA(p,MA=p>>31,s=Q+1|0,R=s>>31))+C|0,C=h+B|0,C=I>>>0<Q>>>0?C+1|0:C,yA=o[g+28>>2],B=(Q=kA(M=c(yA,19),gA=M>>31,EA=z<<1,wA=EA>>31))+I|0,I=h+C|0,I=B>>>0<Q>>>0?I+1|0:I,C=B,LA=o[g+32>>2],B=kA(t=c(LA,19),$=t>>31,F,u=F>>31),I=h+I|0,I=(C=C+B|0)>>>0<B>>>0?I+1|0:I,RA=o[g+36>>2],B=kA(n=c(RA,19),l=n>>31,oA=q<<1,hA=oA>>31),I=h+I|0,y=C=B+C|0,Q=C>>>0<B>>>0?I+1|0:I,I=kA(D,v,S,x),C=h,e=kA(f,d,X,nA=X>>31),B=h+C|0,B=(I=e+I|0)>>>0<e>>>0?B+1|0:B,e=kA(a,V,j,sA=j>>31),C=h+B|0,C=(I=e+I|0)>>>0<e>>>0?C+1|0:C,B=(e=kA(k,L,m,AA))+I|0,I=h+C|0,I=B>>>0<e>>>0?I+1|0:I,C=B,B=kA(Z,QA,T,FA=T>>31),I=h+I|0,I=(C=C+B|0)>>>0<B>>>0?I+1|0:I,B=kA(s,R,i,DA),I=h+I|0,I=(C=B+C|0)>>>0<B>>>0?I+1|0:I,e=kA(p=c(p,19),aA=p>>31,z,SA=z>>31),B=h+I|0,B=(C=e+C|0)>>>0<e>>>0?B+1|0:B,I=(e=kA(F,u,M,gA))+C|0,C=h+B|0,C=I>>>0<e>>>0?C+1|0:C,B=(e=kA(t,$,q,HA=q>>31))+I|0,I=h+C|0,I=B>>>0<e>>>0?I+1|0:I,C=B,B=kA(r,K,n,l),I=h+I|0,YA=C=C+B|0,CA=C>>>0<B>>>0?I+1|0:I,I=kA(S,x,BA,eA),B=h,C=(e=kA(f,d,D,v))+I|0,I=h+B|0,I=C>>>0<e>>>0?I+1|0:I,e=kA(k,L,a,V),B=h+I|0,B=(C=e+C|0)>>>0<e>>>0?B+1|0:B,I=(e=kA(m,AA,iA,tA))+C|0,C=h+B|0,C=I>>>0<e>>>0?C+1|0:C,B=(e=kA(s,R,Z,QA))+I|0,I=h+C|0,I=B>>>0<e>>>0?I+1|0:I,C=B,B=kA(e=c(i,19),GA=e>>31,EA,wA),I=h+I|0,I=(C=C+B|0)>>>0<B>>>0?I+1|0:I,B=kA(F,u,p,aA),I=h+I|0,I=(C=B+C|0)>>>0<B>>>0?I+1|0:I,i=kA(M,gA,oA,hA),B=h+I|0,B=(C=i+C|0)>>>0<i>>>0?B+1|0:B,I=(i=kA(r,K,t,$))+C|0,C=h+B|0,C=I>>>0<i>>>0?C+1|0:C,B=(i=kA(n,l,Y,cA))+I|0,I=h+C|0,uA=B,xA=I=B>>>0<i>>>0?I+1|0:I,mA=B=B+33554432|0,lA=I=B>>>0<33554432?I+1|0:I,B=(67108863&I)<<6|B>>>26,I=(I>>26)+CA|0,YA=i=B+YA|0,I=B>>>0>i>>>0?I+1|0:I,zA=i=i+16777216|0,I=(C=(B=i>>>0<16777216?I+1|0:I)>>25)+Q|0,I=(B=(i=(33554431&B)<<7|i>>>25)+y|0)>>>0<i>>>0?I+1|0:I,J=C=B+33554432|0,i=I=C>>>0<33554432?I+1|0:I,o[g+72>>2]=B-(-67108864&C),I=kA(S,x,iA,tA),C=h,Q=kA(f,d,k,L),B=h+C|0,B=(I=Q+I|0)>>>0<Q>>>0?B+1|0:B,C=(Q=kA(s,R,a,V))+I|0,I=h+B|0,I=C>>>0<Q>>>0?I+1|0:I,B=kA(Q=c(m,19),_A=Q>>31,EA,wA),I=h+I|0,I=(C=B+C|0)>>>0<B>>>0?I+1|0:I,B=(y=kA(CA=c(Z,19),pA=CA>>31,F,u))+C|0,C=h+I|0,C=B>>>0<y>>>0?C+1|0:C,y=kA(oA,hA,e,GA),I=h+C|0,I=(B=y+B|0)>>>0<y>>>0?I+1|0:I,C=(y=kA(r,K,p,aA))+B|0,B=h+I|0,B=C>>>0<y>>>0?B+1|0:B,y=kA(M,gA,Y,cA),I=h+B|0,I=(C=y+C|0)>>>0<y>>>0?I+1|0:I,B=kA(D,v,t,$),I=h+I|0,I=(C=B+C|0)>>>0<B>>>0?I+1|0:I,B=(y=kA(n,l,BA,eA))+C|0,C=h+I|0,N=B,KA=B>>>0<y>>>0?C+1|0:C,I=kA(s,R,S,x),C=h,B=(y=kA(f,d,T,FA))+I|0,I=h+C|0,I=B>>>0<y>>>0?I+1|0:I,y=C=c(a,19),C=(_=kA(C,NA=C>>31,z,SA))+B|0,B=h+I|0,B=C>>>0<_>>>0?B+1|0:B,_=kA(Q,_A,F,u),I=h+B|0,I=(C=_+C|0)>>>0<_>>>0?I+1|0:I,B=kA(CA,pA,q,HA),I=h+I|0,I=(C=B+C|0)>>>0<B>>>0?I+1|0:I,B=(_=kA(r,K,e,GA))+C|0,C=h+I|0,C=B>>>0<_>>>0?C+1|0:C,_=kA(p,aA,X,nA),I=h+C|0,I=(B=_+B|0)>>>0<_>>>0?I+1|0:I,C=(_=kA(D,v,M,gA))+B|0,B=h+I|0,B=C>>>0<_>>>0?B+1|0:B,_=kA(t,$,j,sA),I=h+B|0,I=(C=_+C|0)>>>0<_>>>0?I+1|0:I,B=kA(k,L,n,l),I=h+I|0,bA=C=B+C|0,_=C>>>0<B>>>0?I+1|0:I,I=kA(I=c(S,19),I>>31,EA,wA),C=h,B=kA(f,d,s,R),C=h+C|0,C=(I=B+I|0)>>>0<B>>>0?C+1|0:C,B=(y=kA(y,NA,F,u))+I|0,I=h+C|0,C=(Q=kA(Q,_A,oA,hA))+B|0,B=h+(B>>>0<y>>>0?I+1|0:I)|0,B=C>>>0<Q>>>0?B+1|0:B,Q=kA(r,K,CA,pA),I=h+B|0,I=(C=Q+C|0)>>>0<Q>>>0?I+1|0:I,B=kA(Y,cA,e,GA),I=h+I|0,I=(C=B+C|0)>>>0<B>>>0?I+1|0:I,B=(Q=kA(D,v,p,aA))+C|0,C=h+I|0,C=B>>>0<Q>>>0?C+1|0:C,Q=kA(M,gA,BA,eA),I=h+C|0,I=(B=Q+B|0)>>>0<Q>>>0?I+1|0:I,C=(Q=kA(k,L,t,$))+B|0,B=h+I|0,B=C>>>0<Q>>>0?B+1|0:B,Q=kA(n,l,iA,tA),I=h+B|0,y=C=Q+C|0,_A=I=C>>>0<Q>>>0?I+1|0:I,NA=C=C+33554432|0,qA=I=C>>>0<33554432?I+1|0:I,B=I>>26,I=(67108863&I)<<6|C>>>26,C=B+_|0,_=Q=I+bA|0,I=C=I>>>0>Q>>>0?C+1|0:C,bA=Q=Q+16777216|0,Q=(33554431&(I=Q>>>0<16777216?I+1|0:I))<<7|Q>>>25,I=(I>>25)+KA|0,I=(C=Q+N|0)>>>0<Q>>>0?I+1|0:I,B=C,KA=C=C+33554432|0,Q=I=C>>>0<33554432?I+1|0:I,o[g+56>>2]=B-(-67108864&C),I=kA(r,K,S,x),B=h,C=(N=kA(f,d,q,HA))+I|0,I=h+B|0,I=C>>>0<N>>>0?I+1|0:I,B=kA(a,V,X,nA),I=h+I|0,I=(C=B+C|0)>>>0<B>>>0?I+1|0:I,B=kA(D,v,m,AA),I=h+I|0,I=(C=B+C|0)>>>0<B>>>0?I+1|0:I,N=kA(Z,QA,j,sA),B=h+I|0,B=(C=N+C|0)>>>0<N>>>0?B+1|0:B,I=(N=kA(k,L,JA,DA))+C|0,C=h+B|0,C=I>>>0<N>>>0?C+1|0:C,B=(N=kA(T,FA,UA,MA))+I|0,I=h+C|0,I=B>>>0<N>>>0?I+1|0:I,C=B,B=kA(yA,PA=yA>>31,s,R),I=h+I|0,I=(C=C+B|0)>>>0<B>>>0?I+1|0:I,B=kA(t,$,z,SA),I=h+I|0,I=(C=B+C|0)>>>0<B>>>0?I+1|0:I,N=(B=C)+(C=kA(F,u,n,l))|0,B=h+I|0,C=(I=i>>26)+(C=C>>>0>N>>>0?B+1|0:B)|0,J=B=(i=(67108863&i)<<6|J>>>26)+N|0,I=C=B>>>0<i>>>0?C+1|0:C,N=B=B+16777216|0,i=I=B>>>0<16777216?I+1|0:I,o[g+76>>2]=J-(-33554432&B),I=kA(k,L,S,x),C=h,J=kA(f,d,j,sA),B=h+C|0,B=(I=J+I|0)>>>0<J>>>0?B+1|0:B,J=kA(a,V,T,FA),C=h+B|0,C=(I=J+I|0)>>>0<J>>>0?C+1|0:C,B=(J=kA(s,R,m,AA))+I|0,I=h+C|0,I=B>>>0<J>>>0?I+1|0:I,C=B,B=kA(CA,pA,z,SA),I=h+I|0,I=(C=C+B|0)>>>0<B>>>0?I+1|0:I,B=kA(F,u,e,GA),I=h+I|0,I=(C=B+C|0)>>>0<B>>>0?I+1|0:I,C=(p=kA(p,aA,q,HA))+C|0,B=h+I|0,I=(M=kA(r,K,M,gA))+C|0,C=h+(C>>>0<p>>>0?B+1|0:B)|0,B=(t=kA(t,$,X,nA))+I|0,I=h+(I>>>0<M>>>0?C+1|0:C)|0,I=B>>>0<t>>>0?I+1|0:I,C=B,B=kA(D,v,n,l),I=h+I|0,J=C=C+B|0,I=(I=C>>>0<B>>>0?I+1|0:I)+(C=Q>>26)|0,t=Q=J+(B=(67108863&Q)<<6|KA>>>26)|0,I=B>>>0>Q>>>0?I+1|0:I,M=C=Q+16777216|0,Q=B=C>>>0<16777216?I+1|0:I,o[g+60>>2]=t-(-33554432&C),I=kA(S,x,oA,hA),B=h,C=(t=kA(f,d,F,u))+I|0,I=h+B|0,I=C>>>0<t>>>0?I+1|0:I,B=kA(r,K,a,V),I=h+I|0,I=(C=B+C|0)>>>0<B>>>0?I+1|0:I,t=kA(m,AA,Y,cA),B=h+I|0,B=(C=t+C|0)>>>0<t>>>0?B+1|0:B,I=(t=kA(D,v,Z,QA))+C|0,C=h+B|0,C=I>>>0<t>>>0?C+1|0:C,B=(t=kA(BA,eA,JA,DA))+I|0,I=h+C|0,I=B>>>0<t>>>0?I+1|0:I,C=B,B=kA(k,L,UA,MA),I=h+I|0,I=(C=C+B|0)>>>0<B>>>0?I+1|0:I,B=C,C=kA(iA,tA,yA,PA),I=h+I|0,I=C>>>0>(B=B+C|0)>>>0?I+1|0:I,t=C=LA,C=(Y=kA(C,p=C>>31,s,R))+B|0,B=h+I|0,I=(n=kA(n,l,EA,wA))+C|0,C=h+(C>>>0<Y>>>0?B+1|0:B)|0,B=I>>>0<n>>>0?C+1|0:C,C=I,I=(I=i>>25)+B|0,I=(C=C+(i=(33554431&i)<<7|N>>>25)|0)>>>0<i>>>0?I+1|0:I,B=C,n=C=C+33554432|0,i=I=C>>>0<33554432?I+1|0:I,o[g+80>>2]=B-(-67108864&C),C=Q>>25,B=(Q=(33554431&Q)<<7|M>>>25)+(uA-(I=-67108864&mA)|0)|0,I=C+(xA-((I>>>0>uA>>>0)+lA|0)|0)|0,I=B>>>0<Q>>>0?I+1|0:I,I=((67108863&(I=(C=B+33554432|0)>>>0<33554432?I+1|0:I))<<6|C>>>26)+(Y=YA-(-33554432&zA)|0)|0,o[g+68>>2]=I,o[g+64>>2]=B-(-67108864&C),I=kA(F,u,S,x),B=h,C=(Q=kA(f,d,z,SA))+I|0,I=h+B|0,I=C>>>0<Q>>>0?I+1|0:I,B=(Q=kA(a,V,q,HA))+C|0,C=h+I|0,C=B>>>0<Q>>>0?C+1|0:C,I=(Q=kA(r,K,m,AA))+B|0,B=h+C|0,B=I>>>0<Q>>>0?B+1|0:B,C=(Q=kA(Z,QA,X,nA))+I|0,I=h+B|0,I=C>>>0<Q>>>0?I+1|0:I,B=kA(D,v,JA,DA),I=h+I|0,I=(C=B+C|0)>>>0<B>>>0?I+1|0:I,B=kA(j,sA,UA,MA),I=h+I|0,I=(C=B+C|0)>>>0<B>>>0?I+1|0:I,B=(Q=kA(k,L,yA,PA))+C|0,C=h+I|0,C=B>>>0<Q>>>0?C+1|0:C,Q=(I=kA(t,p,T,FA))+B|0,B=h+C|0,B=I>>>0>Q>>>0?B+1|0:B,C=Q,Q=kA(I=RA,I>>31,s,R),I=h+B|0,B=C=C+Q|0,I=(I=C>>>0<Q>>>0?I+1|0:I)+(C=i>>26)|0,I=(B=B+(i=(67108863&i)<<6|n>>>26)|0)>>>0<i>>>0?I+1|0:I,I=(C=B+16777216|0)>>>0<16777216?I+1|0:I,o[g+84>>2]=B-(-33554432&C),i=_-(-33554432&bA)|0,Q=y-(B=-67108864&NA)|0,f=_A-((B>>>0>y>>>0)+qA|0)|0,I=kA((33554431&(B=I))<<7|C>>>25,I>>=25,19,0),C=h+f|0,I=I>>>0>(B=I+Q|0)>>>0?C+1|0:C,I=((67108863&(I=(C=B+33554432|0)>>>0<33554432?I+1|0:I))<<6|C>>>26)+i|0,o[g+52>>2]=I,o[g+48>>2]=B-(-67108864&C),IA(A,g+48|0))}return w=g+256|0,0|vA},Yb:function(A,I){A|=0;var g,C=0;return w=g=w+-64|0,aA(g,I|=0,32,0),E[0|g]=248&a[0|g],E[g+31|0]=63&a[g+31|0]|64,I=o[g+20>>2],C=o[g+16>>2],E[A+16|0]=C,E[A+17|0]=C>>>8,E[A+18|0]=C>>>16,E[A+19|0]=C>>>24,E[A+20|0]=I,E[A+21|0]=I>>>8,E[A+22|0]=I>>>16,E[A+23|0]=I>>>24,I=o[g+12>>2],C=o[g+8>>2],E[A+8|0]=C,E[A+9|0]=C>>>8,E[A+10|0]=C>>>16,E[A+11|0]=C>>>24,E[A+12|0]=I,E[A+13|0]=I>>>8,E[A+14|0]=I>>>16,E[A+15|0]=I>>>24,I=o[g+4>>2],C=o[g>>2],E[0|A]=C,E[A+1|0]=C>>>8,E[A+2|0]=C>>>16,E[A+3|0]=C>>>24,E[A+4|0]=I,E[A+5|0]=I>>>8,E[A+6|0]=I>>>16,E[A+7|0]=I>>>24,I=o[g+28>>2],C=o[g+24>>2],E[A+24|0]=C,E[A+25|0]=C>>>8,E[A+26|0]=C>>>16,E[A+27|0]=C>>>24,E[A+28|0]=I,E[A+29|0]=I>>>8,E[A+30|0]=I>>>16,E[A+31|0]=I>>>24,iI(g,64),w=g- -64|0,0},Zb:function(){var A,I;return w=A=w-16|0,E[A+15|0]=0,I=0|r(35256,A+15|0,0),w=A+16|0,0|I},_b:mA,$b:function(A){var I,g=0,C=0;if(w=I=w-16|0,(A|=0)>>>0>=2){for(g=(0-A>>>0)%(A>>>0)|0;E[I+15|0]=0,g>>>0>(C=0|r(35256,I+15|0,0))>>>0;);g=(C>>>0)%(A>>>0)|0}return w=I+16|0,0|g},ac:HA,bc:function(A,I,g){ZA(A|=0,I|=0,1024,g|=0)},cc:aI,dc:function(){var A=0,I=0;return(A=o[9004])&&(A=o[A+20>>2])&&(I=0|wI[0|A]()),0|I},ec:function(A,I,g){A|=0,I|=0;var C,B=0,i=0,o=0;if(w=C=w-16|0,g|=0)D(1240,1100,197,1036),Q();else{if(I)for(;E[C+15|0]=0,i=A+B|0,o=0|r(35256,C+15|0,0),E[0|i]=o,(0|I)!=(0|(B=B+1|0)););w=C+16|0}},fc:function(A,I,g,C){A|=0,g|=0;var B=0,i=0,o=0;if(!((C|=0)>>>0>2147483646|C<<1>>>0>=(I|=0)>>>0)){if(I=0,C){for(;B=(I<<1)+A|0,i=15&(o=a[I+g|0]),E[B+1|0]=22272+((i<<8)+(i+65526&55552)|0)>>>8,i=B,B=o>>>4|0,E[0|i]=87+((B+65526>>>8&217)+B|0),(0|C)!=(0|(I=I+1|0)););I=C<<1}else I=0;return E[I+A|0]=0,0|A}zA(),Q()},gc:function(A,I,g,C,B,Q,i){A|=0,I|=0,g|=0,B|=0,Q|=0,i|=0;var f=0,c=0,e=0,r=0,D=0,t=0,y=0,w=0,h=0,n=0;A:if(C|=0){I:{g:{C:{B:{if(!B){for(c=1,B=0;;){if(!(255&((y=(65526+(e=(223&(D=a[g+f|0]))-55&255)^e+65520)>>>8|0)|(w=65526+(D^=48)>>>8|0))))break C;if(I>>>0<=t>>>0)break B;if(e=e&y|D&w,255&r?(E[A+t|0]=B|e,t=t+1|0):B=e<<4,r^=-1,(0|(f=f+1|0))==(0|C))break}f=C;break C}for(;;){Q:{i:{E:{o:{a:{if(!(255&((D=(65526+(e=(223&(c=a[g+f|0]))-55&255)^e+65520)>>>8|0)|(w=65526+(y=48^c)>>>8|0)))){if(255&r)break g;if(!BA(B,c))break A;if((f=r=f+1|0)>>>0<C>>>0)break a;break A}if(I>>>0<=t>>>0)break B;if(c=e&D|y&w,!(255&r))break o;E[A+t|0]=c|n,t=t+1|0;break Q}for(;;){if(!(255&((D=(65526+(e=(223&(c=a[g+f|0]))-55&255)^e+65520)>>>8|0)|(w=65526+(y=48^c)>>>8|0)))){if(!BA(B,c))break A;if((f=f+1|0)>>>0<C>>>0)continue;break E}break}if(I>>>0<=t>>>0)break i;c=e&D|y&w}n=c<<4,r=0;break Q}f=C>>>0>r>>>0?C:r;break A}r=0;break B}if(r^=-1,c=1,!((f=f+1|0)>>>0<C>>>0))break}break C}o[9005]=68,c=0}if(!(255&r))break I}o[9005]=28,h=-1,f=f-1|0,t=0;break A}c||(t=0,h=-1)}return i?o[i>>2]=g+f:(0|C)!=(0|f)&&(o[9005]=28,h=-1),Q&&(o[Q>>2]=t),0|h},hc:function(A,I){A|=0;var g=0;return 1!=(-7&(I|=0))&&(zA(),Q()),1+((3&(g=(g=A)+c(A=(A>>>0)/3|0,-3)|0)?2&I?g+1|0:4:0)+(A<<2)|0)|0},ic:function(A,I,g,C,B){A|=0,I|=0,g|=0,C|=0;var i=0,o=0,f=0,e=0,r=0,t=0,y=0,w=0,h=0,n=0;A:{I:{g:{C:{B:{Q:{i:{if(1==(-7&(B|=0))&&(r=(o=(C>>>0)/3|0)<<2,(o=c(o,-3)+C|0)&&(r=2&B?(2|r)+(o>>>1|0)|0:r+4|0),!(I>>>0<=r>>>0))){if(!(4&B)){if(!C){B=0;break C}B=0;break i}if(!C){B=0;break C}for(B=0;;){for(y=(w=a[g+t|0])|y<<8,o=B,B=1+((((e|=8)-6>>>0)/6|0)+B|0)|0;h=65510+(f=y>>>(e=(i=e)-6|0)&63)>>>8|0,n=f+65484>>>8|0,E[A+o|0]=(1+(16321^f)^-1)>>>8&45|f+252&f+65474>>>8&(-1^n)|(f+32705^-1)>>>8&95|h&f+65|n&f+71&(-1^h),(0|(o=o+1|0))!=(0|B););if((0|(t=t+1|0))==(0|C))break}if(!e)break B;o=(C=65510+(i=w<<12-i&63)>>>8|0)&i+65,e=i+252&i+65474>>>8&(-1^(g=i+65484>>>8|0)),C=g&i+71&(-1^C),t=i+32705|0,y=95,g=(1+(16321^i)^-1)>>>8&45;break Q}zA(),Q()}for(;;){for(y=(w=a[g+t|0])|y<<8,o=B,B=1+((((e|=8)-6>>>0)/6|0)+B|0)|0;h=65510+(f=y>>>(e=(i=e)-6|0)&63)>>>8|0,n=f+65484>>>8|0,E[A+o|0]=(1+(16321^f)^-1)>>>8&43|f+252&f+65474>>>8&(-1^n)|(f+16321^-1)>>>8&47|h&f+65|n&f+71&(-1^h),(0|(o=o+1|0))!=(0|B););if((0|(t=t+1|0))==(0|C))break}if(!e)break B;o=(C=65510+(i=w<<12-i&63)>>>8|0)&i+65,e=i+252&i+65474>>>8&(-1^(g=i+65484>>>8|0)),C=g&i+71&(-1^C),t=i+16321|0,y=47,g=(1+(16321^i)^-1)>>>8&43}E[A+B|0]=g|(-1^t)>>>8&y|o|e|C,B=B+1|0}if(B>>>0>r>>>0)break g}if(B>>>0<r>>>0)break I;r=B;break A}D(1048,1126,231,1319),Q()}dA(A+B|0,61,r-B|0)}return dA(A+r|0,0,(I>>>0>(g=r+1|0)>>>0?I:g)-r|0),0|A},jc:function(A,I,g,C,B,i,f,c){A|=0,I|=0,g|=0,C|=0,B|=0,i|=0,f|=0;var e=0,r=0,D=0,t=0,y=0,w=0,h=0,n=0;A:{I:{g:{C:{B:{Q:{i:{E:{o:{a:{f:{if(1==(-7&(c|=0))){if(D=0,!C)break E;if(4&c)break f;for(;;){D=r;c:{e:{r:{D:{for(;;){if(e=(e=(t=E[g+D|0])-65|0)&((90-t^-1)&(-1^e))>>>8&255|t+4&((t+65488^-1)&(57-t^-1))>>>8&255|t+185&((t+65439^-1)&(122-t^-1))>>>8&255|(1+(16336^t)^-1)>>>8&63|(1+(16340^t)^-1)>>>8&62,255!=(0|(e|=(e-1&1+(65470^t))>>>8&255)))break D;if(e=0,!B)break o;if(!BA(B,t))break;if((D=D+1|0)>>>0>=C>>>0)break r}r=D;break o}if(h=e+(h<<6)|0,y>>>0>1)break e;y=y+6|0;break c}r=(A=r+1|0)>>>0<C>>>0?C:A;break o}if(y=y-2|0,I>>>0<=w>>>0)break a;E[A+w|0]=h>>>y,w=w+1|0}if(e=0,!((r=D+1|0)>>>0<C>>>0))break}break o}zA(),Q()}f:for(;;){for(D=r;;){c:{if(e=(e=(t=E[g+D|0])-65|0)&((90-t^-1)&(-1^e))>>>8&255|t+4&((t+65488^-1)&(57-t^-1))>>>8&255|t+185&((t+65439^-1)&(122-t^-1))>>>8&255|(1+(16288^t)^-1)>>>8&63|(1+(16338^t)^-1)>>>8&62,255==(0|(e|=(e-1&1+(65470^t))>>>8&255))){if(e=0,!B)break o;if(BA(B,t))break c;r=D;break o}if(h=e+(h<<6)|0,y>>>0<2)y=y+6|0;else{if(y=y-2|0,I>>>0<=w>>>0)break a;E[A+w|0]=h>>>y,w=w+1|0}if(e=0,(r=D+1|0)>>>0<C>>>0)continue f;break o}if(!((D=D+1|0)>>>0<C>>>0))break}break}r=(A=r+1|0)>>>0<C>>>0?C:A;break o}r=D,o[9005]=68,e=1}if(y>>>0>4)break i;D=r}if(A=D,I=-1,e){r=A;break A}if((-1<<y^-1)&h){r=A;break A}if(2&c){c=A;break B}if(y>>>0<2){c=A;break B}if(r=A>>>0>C>>>0?A:C,D=y>>>1|0,!B)break Q;for(c=A;;){if((0|c)==(0|r)){e=68;break C}if(61!=(0|(A=E[g+c|0]))){if(!BA(B,A)){e=28,r=c;break C}}else D=D-1|0;if(c=c+1|0,!D)break}break B}I=-1;break A}if(e=68,A>>>0>=C>>>0)break C;if(61!=a[A+g|0]){r=A,e=28;break C}if(c=A+D|0,1!=(0|D)){if((0|(y=A+1|0))==(0|r))break C;if(61!=a[g+y|0]){r=y,e=28;break C}if(2!=(0|D)){if((0|(A=A+2|0))==(0|r))break C;if(e=28,r=A,61!=a[A+g|0])break C}}}if(I=0,B)break g;break I}o[9005]=e;break A}if(!(C>>>0<=c>>>0)){for(;;){if(!BA(B,E[g+c|0]))break I;if((0|(c=c+1|0))==(0|C))break}c=C}}r=c,n=w}return f?o[f>>2]=g+r:(0|C)!=(0|r)&&(o[9005]=28,I=-1),i&&(o[i>>2]=n),0|I},kc:function(){var A=0;return o[9136]?A=1:(mA(),HA(36528,16),o[9136]=1,A=0),0|A},lc:function(A,I,g,C,B){A|=0,I|=0,g|=0,B|=0;var i,f=0,c=0,e=0;w=i=w-16|0;A:{if(C|=0){if((f=C-1|0)&C?(c=-1^g,f=f-((g>>>0)%(C>>>0)|0)|0):f&=c=-1^g,c>>>0<=f>>>0)break A;if(c=-1,!((g=g+f|0)>>>0>=B>>>0))for(A&&(o[A>>2]=g+1),A=I+g|0,c=0,E[i+15|0]=0,g=0;B=I=A-g|0,e=a[0|I]&a[i+15|0],I=(g^f)-1>>>24|0,E[0|B]=e|128&I,E[i+15|0]=I|a[i+15|0],(0|C)!=(0|(g=g+1|0)););}else c=-1;return w=i+16|0,0|c}zA(),Q()},mc:function(A,I,g,C){A|=0,I|=0,g|=0,C|=0;var B,Q=0,i=0,E=0,f=0,c=0;if(o[12+(B=w-16|0)>>2]=0,C-1>>>0<g>>>0){for(c=(Q=g-1|0)+I|0,g=0,I=0;f=((128^(i=a[c-g|0]))-1&o[B+12>>2]-1&E-1)>>>8&1,o[B+12>>2]=o[B+12>>2]|0-f&g,I|=f,E|=i,(0|C)!=(0|(g=g+1|0)););o[A>>2]=Q-o[B+12>>2],A=(255&I)-1|0}else A=-1;return 0|A},nc:function(){return 1312},oc:function(){return 26},pc:rI,qc:rI,rc:function(A){var I,g=0,C=0,B=0,Q=0,i=0,E=0,c=0,r=0,D=0,t=0,y=0,h=0;w=I=w-16|0;A:{I:{g:{C:{B:{Q:{i:{E:{o:{a:{f:{c:{e:{r:{if((A|=0)>>>0<=244){if(3&(g=(E=o[9006])>>>(C=(c=A>>>0<11?16:A+11&-8)>>>3|0)|0)){g=36064+(A=(C=C+(1&(-1^g))|0)<<3)|0,B=o[A+36072>>2],(0|g)!=(0|(A=o[B+8>>2]))?(o[A+12>>2]=g,o[g+8>>2]=A):(y=36024,h=RA(-2,C)&E,o[y>>2]=h),A=B+8|0,g=C<<3,o[B+4>>2]=3|g,o[4+(g=g+B|0)>>2]=1|o[g+4>>2];break A}if((t=o[9008])>>>0>=c>>>0)break r;if(g){g=36064+(A=(B=TA((0-(A=2<<C)|A)&g<<C))<<3)|0,Q=o[A+36072>>2],(0|g)!=(0|(A=o[Q+8>>2]))?(o[A+12>>2]=g,o[g+8>>2]=A):(E=RA(-2,B)&E,o[9006]=E),o[Q+4>>2]=3|c,B=(A=B<<3)-c|0,o[4+(C=Q+c|0)>>2]=1|B,o[A+Q>>2]=B,t&&(g=36064+(-8&t)|0,i=o[9011],(A=1<<(t>>>3))&E?A=o[g+8>>2]:(o[9006]=A|E,A=g),o[g+8>>2]=i,o[A+12>>2]=i,o[i+12>>2]=g,o[i+8>>2]=A),A=Q+8|0,o[9011]=C,o[9008]=B;break A}if(!(D=o[9007]))break r;for(C=o[36328+(TA(D)<<2)>>2],i=(-8&o[C+4>>2])-c|0,g=C;(A=o[g+16>>2])||(A=o[g+20>>2]);)i=(B=(g=(-8&o[A+4>>2])-c|0)>>>0<i>>>0)?g:i,C=B?A:C,g=A;if(r=o[C+24>>2],(0|(B=o[C+12>>2]))!=(0|C)){A=o[C+8>>2],o[A+12>>2]=B,o[B+8>>2]=A;break I}if(!(A=o[(g=C+20|0)>>2])){if(!(A=o[C+16>>2]))break e;g=C+16|0}for(;Q=g,B=A,(A=o[(g=A+20|0)>>2])||(g=B+16|0,A=o[B+16>>2]););o[Q>>2]=0;break I}if(c=-1,!(A>>>0>4294967231)&&(c=-8&(A=A+11|0),D=o[9007])){i=0-c|0,E=0,c>>>0<256||(E=31,c>>>0>16777215||(E=62+((c>>>38-(A=e(A>>>8|0))&1)-(A<<1)|0)|0));D:{t:{if(g=o[36328+(E<<2)>>2])for(A=0,C=c<<(31!=(0|E)?25-(E>>>1|0)|0:0);;){if(!((Q=(-8&o[g+4>>2])-c|0)>>>0>=i>>>0||(B=g,i=Q,Q))){i=0,A=g;break t}if(Q=o[g+20>>2],g=o[16+((C>>>29&4)+g|0)>>2],A=Q?(0|Q)==(0|g)?A:Q:A,C<<=1,!g)break}else A=0;if(!(A|B)){if(B=0,!(A=(0-(A=2<<E)|A)&D))break r;A=o[36328+(TA(A)<<2)>>2]}if(!A)break D}for(;i=(C=(g=(-8&o[A+4>>2])-c|0)>>>0<i>>>0)?g:i,B=C?A:B,A=(g=o[A+16>>2])||o[A+20>>2];);}if(!(!B|o[9008]-c>>>0<=i>>>0)){if(E=o[B+24>>2],(0|B)!=(0|(C=o[B+12>>2]))){A=o[B+8>>2],o[A+12>>2]=C,o[C+8>>2]=A;break g}if(!(A=o[(g=B+20|0)>>2])){if(!(A=o[B+16>>2]))break c;g=B+16|0}for(;Q=g,C=A,(A=o[(g=A+20|0)>>2])||(g=C+16|0,A=o[C+16>>2]););o[Q>>2]=0;break g}}}if((A=o[9008])>>>0>=c>>>0){B=o[9011],(g=A-c|0)>>>0>=16?(o[4+(C=B+c|0)>>2]=1|g,o[A+B>>2]=g,o[B+4>>2]=3|c):(o[B+4>>2]=3|A,o[4+(A=A+B|0)>>2]=1|o[A+4>>2],C=0,g=0),o[9008]=g,o[9011]=C,A=B+8|0;break A}if((r=o[9009])>>>0>c>>>0){g=r-c|0,o[9009]=g,A=(C=o[9012])+c|0,o[9012]=A,o[A+4>>2]=1|g,o[C+4>>2]=3|c,A=C+8|0;break A}if(A=0,D=c+47|0,o[9124]?C=o[9126]:(o[9127]=-1,o[9128]=-1,o[9125]=4096,o[9126]=4096,o[9124]=I+12&-16^1431655768,o[9129]=0,o[9117]=0,C=4096),(g=(Q=D+C|0)&(i=0-C|0))>>>0<=c>>>0)break A;if((B=o[9116])&&B>>>0<(E=(C=o[9114])+g|0)>>>0|C>>>0>=E>>>0)break A;r:{if(!(4&a[36468])){D:{t:{y:{w:{if(B=o[9012])for(A=36472;;){if((C=o[A>>2])>>>0<=B>>>0&B>>>0<C+o[A+4>>2]>>>0)break w;if(!(A=o[A+8>>2]))break}if(-1==(0|(C=_A(0))))break D;if(E=g,(A=(B=o[9125])-1|0)&C&&(E=(g-C|0)+(A+C&0-B)|0),E>>>0<=c>>>0)break D;if((B=o[9116])&&B>>>0<(i=(A=o[9114])+E|0)>>>0|A>>>0>=i>>>0)break D;if((0|C)!=(0|(A=_A(E))))break y;break r}if((0|(C=_A(E=i&Q-r)))==(o[A>>2]+o[A+4>>2]|0))break t;A=C}if(-1==(0|A))break D;if(c+48>>>0<=E>>>0){C=A;break r}if(-1==(0|_A(C=(C=o[9126])+(D-E|0)&0-C)))break D;E=C+E|0,C=A;break r}if(-1!=(0|C))break r}o[9117]=4|o[9117]}if(-1==(0|(C=_A(g)))|-1==(0|(A=_A(0)))|A>>>0<=C>>>0)break o;if((E=A-C|0)>>>0<=c+40>>>0)break o}A=o[9114]+E|0,o[9114]=A,A>>>0>f[9115]&&(o[9115]=A);r:{if(Q=o[9012]){for(A=36472;;){if(((B=o[A>>2])+(g=o[A+4>>2])|0)==(0|C))break r;if(!(A=o[A+8>>2]))break}break f}for((A=o[9010])>>>0<=C>>>0&&A||(o[9010]=C),A=0,o[9119]=E,o[9118]=C,o[9014]=-1,o[9015]=o[9124],o[9121]=0;g=36064+(B=A<<3)|0,o[B+36072>>2]=g,o[B+36076>>2]=g,32!=(0|(A=A+1|0)););g=(B=E-40|0)-(A=-8-C&7)|0,o[9009]=g,A=A+C|0,o[9012]=A,o[A+4>>2]=1|g,o[4+(C+B|0)>>2]=40,o[9013]=o[9128];break a}if(8&o[A+12>>2]|C>>>0<=Q>>>0|B>>>0>Q>>>0)break f;o[A+4>>2]=g+E,C=(A=-8-Q&7)+Q|0,o[9012]=C,A=(g=o[9009]+E|0)-A|0,o[9009]=A,o[C+4>>2]=1|A,o[4+(g+Q|0)>>2]=40,o[9013]=o[9128];break a}B=0;break I}C=0;break g}f[9010]>C>>>0&&(o[9010]=C),g=C+E|0,A=36472;f:{c:{e:{for(;;){if((0|g)!=o[A>>2]){if(A=o[A+8>>2])continue;break e}break}if(!(8&a[A+12|0]))break c}for(A=36472;;){if((g=o[A>>2])>>>0<=Q>>>0&&(i=g+o[A+4>>2]|0)>>>0>Q>>>0)break f;A=o[A+8>>2]}}if(o[A>>2]=C,o[A+4>>2]=o[A+4>>2]+E,o[4+(D=(-8-C&7)+C|0)>>2]=3|c,A=(E=g+(-8-g&7)|0)-(r=c+D|0)|0,(0|Q)==(0|E)){o[9012]=r,A=o[9009]+A|0,o[9009]=A,o[r+4>>2]=1|A;break C}if(o[9011]==(0|E)){o[9011]=r,A=o[9008]+A|0,o[9008]=A,o[r+4>>2]=1|A,o[A+r>>2]=A;break C}if(1!=(3&(i=o[E+4>>2])))break B;if(Q=-8&i,i>>>0<=255){if((0|(C=o[E+12>>2]))==(0|(g=o[E+8>>2]))){y=36024,h=o[9006]&RA(-2,i>>>3|0),o[y>>2]=h;break Q}o[g+12>>2]=C,o[C+8>>2]=g;break Q}if(c=o[E+24>>2],(0|E)!=(0|(C=o[E+12>>2]))){g=o[E+8>>2],o[g+12>>2]=C,o[C+8>>2]=g;break i}if(!(i=o[(g=E+20|0)>>2])){if(!(i=o[E+16>>2]))break E;g=E+16|0}for(;B=g,(i=o[(g=(C=i)+20|0)>>2])||(g=C+16|0,i=o[C+16>>2]););o[B>>2]=0;break i}for(g=(B=E-40|0)-(A=-8-C&7)|0,o[9009]=g,A=A+C|0,o[9012]=A,o[A+4>>2]=1|g,o[4+(C+B|0)>>2]=40,o[9013]=o[9128],o[(B=(A=(i+(39-i&7)|0)-47|0)>>>0<Q+16>>>0?Q:A)+4>>2]=27,A=o[9121],o[B+16>>2]=o[9120],o[B+20>>2]=A,A=o[9119],o[B+8>>2]=o[9118],o[B+12>>2]=A,o[9120]=B+8,o[9119]=E,o[9118]=C,o[9121]=0,A=B+24|0;o[A+4>>2]=7,g=A+8|0,A=A+4|0,g>>>0<i>>>0;);if((0|B)!=(0|Q))if(o[B+4>>2]=-2&o[B+4>>2],i=B-Q|0,o[Q+4>>2]=1|i,o[B>>2]=i,i>>>0<=255)g=36064+(-8&i)|0,(C=o[9006])&(A=1<<(i>>>3))?A=o[g+8>>2]:(o[9006]=A|C,A=g),o[g+8>>2]=Q,o[A+12>>2]=Q,o[Q+12>>2]=g,o[Q+8>>2]=A;else{A=31,i>>>0<=16777215&&(A=62+((i>>>38-(A=e(i>>>8|0))&1)-(A<<1)|0)|0),o[Q+28>>2]=A,o[Q+16>>2]=0,o[Q+20>>2]=0,g=36328+(A<<2)|0;f:{if((B=o[9007])&(C=1<<A)){for(A=i<<(31!=(0|A)?25-(A>>>1|0)|0:0),B=o[g>>2];;){if((0|i)==(-8&o[(g=B)+4>>2]))break f;if(C=A>>>29|0,A<<=1,!(B=o[16+(C=(4&C)+g|0)>>2]))break}o[C+16>>2]=Q}else o[9007]=C|B,o[g>>2]=Q;o[Q+24>>2]=g,o[Q+12>>2]=Q,o[Q+8>>2]=Q;break a}A=o[g+8>>2],o[A+12>>2]=Q,o[g+8>>2]=Q,o[Q+24>>2]=0,o[Q+12>>2]=g,o[Q+8>>2]=A}}if(!((A=o[9009])>>>0<=c>>>0)){g=A-c|0,o[9009]=g,A=(C=o[9012])+c|0,o[9012]=A,o[A+4>>2]=1|g,o[C+4>>2]=3|c,A=C+8|0;break A}}o[9005]=48,A=0;break A}C=0}if(c){B=o[E+28>>2];i:{if(o[(g=36328+(B<<2)|0)>>2]==(0|E)){if(o[g>>2]=C,C)break i;y=36028,h=o[9007]&RA(-2,B),o[y>>2]=h;break Q}if(o[c+(o[c+16>>2]==(0|E)?16:20)>>2]=C,!C)break Q}o[C+24>>2]=c,(g=o[E+16>>2])&&(o[C+16>>2]=g,o[g+24>>2]=C),(g=o[E+20>>2])&&(o[C+20>>2]=g,o[g+24>>2]=C)}}A=A+Q|0,i=o[4+(E=Q+E|0)>>2]}if(o[E+4>>2]=-2&i,o[r+4>>2]=1|A,o[A+r>>2]=A,A>>>0<=255)g=36064+(-8&A)|0,(C=o[9006])&(A=1<<(A>>>3))?A=o[g+8>>2]:(o[9006]=A|C,A=g),o[g+8>>2]=r,o[A+12>>2]=r,o[r+12>>2]=g,o[r+8>>2]=A;else{i=31,A>>>0<=16777215&&(i=62+((A>>>38-(g=e(A>>>8|0))&1)-(g<<1)|0)|0),o[r+28>>2]=i,o[r+16>>2]=0,o[r+20>>2]=0,g=36328+(i<<2)|0;B:{if((B=o[9007])&(C=1<<i)){for(i=A<<(31!=(0|i)?25-(i>>>1|0)|0:0),C=o[g>>2];;){if(g=C,(-8&o[C+4>>2])==(0|A))break B;if(B=i>>>29|0,i<<=1,!(C=o[16+(B=(4&B)+C|0)>>2]))break}o[B+16>>2]=r}else o[9007]=C|B,o[g>>2]=r;o[r+24>>2]=g,o[r+12>>2]=r,o[r+8>>2]=r;break C}A=o[g+8>>2],o[A+12>>2]=r,o[g+8>>2]=r,o[r+24>>2]=0,o[r+12>>2]=g,o[r+8>>2]=A}}A=D+8|0;break A}g:if(E){g=o[B+28>>2];C:{if(o[(A=36328+(g<<2)|0)>>2]==(0|B)){if(o[A>>2]=C,C)break C;D=RA(-2,g)&D,o[9007]=D;break g}if(o[E+(o[E+16>>2]==(0|B)?16:20)>>2]=C,!C)break g}o[C+24>>2]=E,(A=o[B+16>>2])&&(o[C+16>>2]=A,o[A+24>>2]=C),(A=o[B+20>>2])&&(o[C+20>>2]=A,o[A+24>>2]=C)}g:if(i>>>0<=15)A=i+c|0,o[B+4>>2]=3|A,o[4+(A=A+B|0)>>2]=1|o[A+4>>2];else if(o[B+4>>2]=3|c,o[4+(Q=B+c|0)>>2]=1|i,o[Q+i>>2]=i,i>>>0<=255)g=36064+(-8&i)|0,(C=o[9006])&(A=1<<(i>>>3))?A=o[g+8>>2]:(o[9006]=A|C,A=g),o[g+8>>2]=Q,o[A+12>>2]=Q,o[Q+12>>2]=g,o[Q+8>>2]=A;else{A=31,i>>>0<=16777215&&(A=62+((i>>>38-(A=e(i>>>8|0))&1)-(A<<1)|0)|0),o[Q+28>>2]=A,o[Q+16>>2]=0,o[Q+20>>2]=0,g=36328+(A<<2)|0;C:{if((C=1<<A)&D){for(A=i<<(31!=(0|A)?25-(A>>>1|0)|0:0),c=o[g>>2];;){if((-8&o[(g=c)+4>>2])==(0|i))break C;if(C=A>>>29|0,A<<=1,!(c=o[16+(C=(4&C)+g|0)>>2]))break}o[C+16>>2]=Q}else o[9007]=C|D,o[g>>2]=Q;o[Q+24>>2]=g,o[Q+12>>2]=Q,o[Q+8>>2]=Q;break g}A=o[g+8>>2],o[A+12>>2]=Q,o[g+8>>2]=Q,o[Q+24>>2]=0,o[Q+12>>2]=g,o[Q+8>>2]=A}A=B+8|0;break A}I:if(r){g=o[C+28>>2];g:{if(o[(A=36328+(g<<2)|0)>>2]==(0|C)){if(o[A>>2]=B,B)break g;y=36028,h=RA(-2,g)&D,o[y>>2]=h;break I}if(o[r+(o[r+16>>2]==(0|C)?16:20)>>2]=B,!B)break I}o[B+24>>2]=r,(A=o[C+16>>2])&&(o[B+16>>2]=A,o[A+24>>2]=B),(A=o[C+20>>2])&&(o[B+20>>2]=A,o[A+24>>2]=B)}i>>>0<=15?(A=i+c|0,o[C+4>>2]=3|A,o[4+(A=A+C|0)>>2]=1|o[A+4>>2]):(o[C+4>>2]=3|c,o[4+(B=C+c|0)>>2]=1|i,o[B+i>>2]=i,t&&(g=36064+(-8&t)|0,Q=o[9011],(A=1<<(t>>>3))&E?A=o[g+8>>2]:(o[9006]=A|E,A=g),o[g+8>>2]=Q,o[A+12>>2]=Q,o[Q+12>>2]=g,o[Q+8>>2]=A),o[9011]=B,o[9008]=i),A=C+8|0}return w=I+16|0,0|A},sc:function(A){var I=0,g=0,C=0,B=0,Q=0,i=0,E=0,a=0,c=0;A:if(A|=0){Q=(C=A-8|0)+(A=-8&(I=o[A-4>>2]))|0;I:if(!(1&I)){if(!(3&I))break A;if((C=C-(I=o[C>>2])|0)>>>0<f[9010])break A;A=A+I|0;g:{C:{if(o[9011]!=(0|C)){if(I>>>0<=255){if(B=I>>>3|0,(0|(I=o[C+12>>2]))==(0|(g=o[C+8>>2]))){a=36024,c=o[9006]&RA(-2,B),o[a>>2]=c;break I}o[g+12>>2]=I,o[I+8>>2]=g;break I}if(E=o[C+24>>2],(0|C)!=(0|(I=o[C+12>>2]))){g=o[C+8>>2],o[g+12>>2]=I,o[I+8>>2]=g;break g}if(!(g=o[(B=C+20|0)>>2])){if(!(g=o[C+16>>2]))break C;B=C+16|0}for(;i=B,(g=o[(B=(I=g)+20|0)>>2])||(B=I+16|0,g=o[I+16>>2]););o[i>>2]=0;break g}if(3!=(3&(I=o[Q+4>>2])))break I;return o[9008]=A,o[Q+4>>2]=-2&I,o[C+4>>2]=1|A,void(o[Q>>2]=A)}I=0}if(E){g=o[C+28>>2];g:{if(o[(B=36328+(g<<2)|0)>>2]==(0|C)){if(o[B>>2]=I,I)break g;a=36028,c=o[9007]&RA(-2,g),o[a>>2]=c;break I}if(o[E+(o[E+16>>2]==(0|C)?16:20)>>2]=I,!I)break I}o[I+24>>2]=E,(g=o[C+16>>2])&&(o[I+16>>2]=g,o[g+24>>2]=I),(g=o[C+20>>2])&&(o[I+20>>2]=g,o[g+24>>2]=I)}}if(!(C>>>0>=Q>>>0)&&1&(I=o[Q+4>>2])){I:{g:{C:{B:{if(!(2&I)){if(o[9012]==(0|Q)){if(o[9012]=C,A=o[9009]+A|0,o[9009]=A,o[C+4>>2]=1|A,o[9011]!=(0|C))break A;return o[9008]=0,void(o[9011]=0)}if(o[9011]==(0|Q))return o[9011]=C,A=o[9008]+A|0,o[9008]=A,o[C+4>>2]=1|A,void(o[A+C>>2]=A);if(A=(-8&I)+A|0,I>>>0<=255){if(B=I>>>3|0,(0|(I=o[Q+12>>2]))==(0|(g=o[Q+8>>2]))){a=36024,c=o[9006]&RA(-2,B),o[a>>2]=c;break g}o[g+12>>2]=I,o[I+8>>2]=g;break g}if(E=o[Q+24>>2],(0|Q)!=(0|(I=o[Q+12>>2]))){g=o[Q+8>>2],o[g+12>>2]=I,o[I+8>>2]=g;break C}if(!(g=o[(B=Q+20|0)>>2])){if(!(g=o[Q+16>>2]))break B;B=Q+16|0}for(;i=B,(g=o[(B=(I=g)+20|0)>>2])||(B=I+16|0,g=o[I+16>>2]););o[i>>2]=0;break C}o[Q+4>>2]=-2&I,o[C+4>>2]=1|A,o[A+C>>2]=A;break I}I=0}if(E){g=o[Q+28>>2];C:{if(o[(B=36328+(g<<2)|0)>>2]==(0|Q)){if(o[B>>2]=I,I)break C;a=36028,c=o[9007]&RA(-2,g),o[a>>2]=c;break g}if(o[E+(o[E+16>>2]==(0|Q)?16:20)>>2]=I,!I)break g}o[I+24>>2]=E,(g=o[Q+16>>2])&&(o[I+16>>2]=g,o[g+24>>2]=I),(g=o[Q+20>>2])&&(o[I+20>>2]=g,o[g+24>>2]=I)}}if(o[C+4>>2]=1|A,o[A+C>>2]=A,o[9011]==(0|C))return void(o[9008]=A)}if(A>>>0<=255)return I=36064+(-8&A)|0,(g=o[9006])&(A=1<<(A>>>3))?A=o[I+8>>2]:(o[9006]=A|g,A=I),o[I+8>>2]=C,o[A+12>>2]=C,o[C+12>>2]=I,void(o[C+8>>2]=A);g=31,A>>>0<=16777215&&(g=62+((A>>>38-(I=e(A>>>8|0))&1)-(I<<1)|0)|0),o[C+28>>2]=g,o[C+16>>2]=0,o[C+20>>2]=0,I=36328+(g<<2)|0;I:{g:{if((B=o[9007])&(i=1<<g)){for(g=A<<(31!=(0|g)?25-(g>>>1|0)|0:0),I=o[I>>2];;){if(B=I,(-8&o[I+4>>2])==(0|A))break g;if(i=g>>>29|0,g<<=1,!(I=o[16+(i=I+(4&i)|0)>>2]))break}o[i+16>>2]=C,o[C+24>>2]=B}else o[9007]=B|i,o[I>>2]=C,o[C+24>>2]=I;o[C+12>>2]=C,o[C+8>>2]=C;break I}A=o[B+8>>2],o[A+12>>2]=C,o[B+8>>2]=C,o[C+24>>2]=0,o[C+12>>2]=B,o[C+8>>2]=A}A=o[9014]-1|0,o[9014]=A||-1}}},tc:wI}}(A)}(I)},instantiate:function(A,I){return{then:function(g){var C=new y.Module(A);g({instance:new y.Instance(C,I)})}}},RuntimeError:Error};r=[],"object"!=typeof y&&d("no native wasm support detected");var w,h,n,s,k,F,S,H=!1;function G(){var A=t.buffer;Q.HEAP8=w=new Int8Array(A),Q.HEAP16=n=new Int16Array(A),Q.HEAPU8=h=new Uint8Array(A),Q.HEAPU16=new Uint16Array(A),Q.HEAP32=s=new Int32Array(A),Q.HEAPU32=k=new Uint32Array(A),Q.HEAPF32=F=new Float32Array(A),Q.HEAPF64=S=new Float64Array(A)}var _=Q.INITIAL_MEMORY||16777216;_>=65536||d("INITIAL_MEMORY should be larger than STACK_SIZE, was "+_+"! (STACK_SIZE=65536)"),t=Q.wasmMemory?Q.wasmMemory:new y.Memory({initial:_/65536,maximum:32768}),G(),_=t.buffer.byteLength;var M=[],p=[],N=[],J=0,U=null,Y=null;function d(A){throw Q.onAbort&&Q.onAbort(A),D(A="Aborted("+A+")"),H=!0,A+=". Build with -sASSERTIONS for more info.",new y.RuntimeError(A)}var K,b,P="data:application/octet-stream;base64,";function v(A){return A.startsWith(P)}v(K="<<< WASM_BINARY_FILE >>>")||(b=K,K=Q.locateFile?Q.locateFile(b,f):f+b);var L,R={35256:()=>Q.getRandomValue(),35292:()=>{if(void 0===Q.getRandomValue)try{var A="object"==typeof window?window:self,I=void 0!==A.crypto?A.crypto:A.msCrypto,g=function(){var A=new Uint32Array(1);return I.getRandomValues(A),A[0]>>>0};g(),Q.getRandomValue=g}catch(A){try{var C=__nccwpck_require__(6113),B=function(){var A=C.randomBytes(4);return(A[0]<<24|A[1]<<16|A[2]<<8|A[3])>>>0};B(),Q.getRandomValue=B}catch(A){throw"No secure random number generator found"}}}},u=A=>{for(;A.length>0;)A.shift()(Q)},x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,m=(A,I)=>A?((A,I,g)=>{for(var C=I+g,B=I;A[B]&&!(B>=C);)++B;if(B-I>16&&A.buffer&&x)return x.decode(A.subarray(I,B));for(var Q="";I<B;){var i=A[I++];if(128&i){var E=63&A[I++];if(192!=(224&i)){var o=63&A[I++];if((i=224==(240&i)?(15&i)<<12|E<<6|o:(7&i)<<18|E<<12|o<<6|63&A[I++])<65536)Q+=String.fromCharCode(i);else{var a=i-65536;Q+=String.fromCharCode(55296|a>>10,56320|1023&a)}}else Q+=String.fromCharCode((31&i)<<6|E)}else Q+=String.fromCharCode(i)}return Q})(h,A,I):"",l=[],z=A=>{var I=(A-t.buffer.byteLength+65535)/65536;try{return t.grow(I),G(),1}catch(A){}},q={c:(A,I,g,C)=>{d(`Assertion failed: ${m(A)}, at: `+[I?m(I):"unknown filename",g,C?m(C):"unknown function"])},d:()=>{d("")},b:(A,I,g)=>((A,I,g)=>{var C=((A,I)=>{var g;for(l.length=0;g=h[A++];)I+=105!=g&&I%8?4:0,l.push(105==g?s[I>>2]:S[I>>3]),I+=105==g?4:8;return l})(I,g);return R[A].apply(null,C)})(A,I,g),e:A=>{var I=h.length,g=2147483648;if((A>>>=0)>g)return!1;for(var C,B=1;B<=4;B*=2){var Q=I*(1+.2/B);Q=Math.min(Q,A+100663296);var i=Math.min(g,(C=Math.max(A,Q))+(65536-C%65536)%65536);if(z(i))return!0}return!1},a:t},X=function(){var A,I,g={a:q};function C(A,I){var g,C=A.exports;return(X=C).tc,g=X.f,p.unshift(g),function(A){if(J--,Q.monitorRunDependencies&&Q.monitorRunDependencies(J),0==J&&(null!==U&&(clearInterval(U),U=null),Y)){var I=Y;Y=null,I()}}(),C}if(J++,Q.monitorRunDependencies&&Q.monitorRunDependencies(J),Q.instantiateWasm)try{return Q.instantiateWasm(g,C)}catch(A){return D(`Module.instantiateWasm callback failed with error: ${A}`),!1}return A=g,I=function(A){C(A.instance)},function(A){return Promise.resolve().then((()=>function(A){if(A==K&&r)return new Uint8Array(r);var I=function(A){if(v(A))return function(A){if(void 0!==a&&a){var I=Buffer.from(A,"base64");return new Uint8Array(I.buffer,I.byteOffset,I.length)}try{for(var g=atob(A),C=new Uint8Array(g.length),B=0;B<g.length;++B)C[B]=g.charCodeAt(B);return C}catch(A){throw new Error("Converting base64 string to bytes failed.")}}(A.slice(P.length))}(A);if(I)return I;if(B)return B(A);throw"both async and sync fetching of the wasm failed"}(A)))}(K).then((I=>y.instantiate(I,A))).then((A=>A)).then(I,(A=>{D(`failed to asynchronously prepare wasm: ${A}`),d(A)})),{}}();function j(){function A(){L||(L=!0,Q.calledRun=!0,H||(u(p),Q.onRuntimeInitialized&&Q.onRuntimeInitialized(),function(){if(Q.postRun)for("function"==typeof Q.postRun&&(Q.postRun=[Q.postRun]);Q.postRun.length;)A=Q.postRun.shift(),N.unshift(A);var A;u(N)}()))}J>0||(function(){if(Q.preRun)for("function"==typeof Q.preRun&&(Q.preRun=[Q.preRun]);Q.preRun.length;)A=Q.preRun.shift(),M.unshift(A);var A;u(M)}(),J>0||(Q.setStatus?(Q.setStatus("Running..."),setTimeout((function(){setTimeout((function(){Q.setStatus("")}),1),A()}),1)):A()))}if(Q._crypto_aead_chacha20poly1305_encrypt_detached=(A,I,g,C,B,i,E,o,a,f,c,e)=>(Q._crypto_aead_chacha20poly1305_encrypt_detached=X.g)(A,I,g,C,B,i,E,o,a,f,c,e),Q._crypto_aead_chacha20poly1305_encrypt=(A,I,g,C,B,i,E,o,a,f,c)=>(Q._crypto_aead_chacha20poly1305_encrypt=X.h)(A,I,g,C,B,i,E,o,a,f,c),Q._crypto_aead_chacha20poly1305_ietf_encrypt_detached=(A,I,g,C,B,i,E,o,a,f,c,e)=>(Q._crypto_aead_chacha20poly1305_ietf_encrypt_detached=X.i)(A,I,g,C,B,i,E,o,a,f,c,e),Q._crypto_aead_chacha20poly1305_ietf_encrypt=(A,I,g,C,B,i,E,o,a,f,c)=>(Q._crypto_aead_chacha20poly1305_ietf_encrypt=X.j)(A,I,g,C,B,i,E,o,a,f,c),Q._crypto_aead_chacha20poly1305_decrypt_detached=(A,I,g,C,B,i,E,o,a,f,c)=>(Q._crypto_aead_chacha20poly1305_decrypt_detached=X.k)(A,I,g,C,B,i,E,o,a,f,c),Q._crypto_aead_chacha20poly1305_decrypt=(A,I,g,C,B,i,E,o,a,f,c)=>(Q._crypto_aead_chacha20poly1305_decrypt=X.l)(A,I,g,C,B,i,E,o,a,f,c),Q._crypto_aead_chacha20poly1305_ietf_decrypt_detached=(A,I,g,C,B,i,E,o,a,f,c)=>(Q._crypto_aead_chacha20poly1305_ietf_decrypt_detached=X.m)(A,I,g,C,B,i,E,o,a,f,c),Q._crypto_aead_chacha20poly1305_ietf_decrypt=(A,I,g,C,B,i,E,o,a,f,c)=>(Q._crypto_aead_chacha20poly1305_ietf_decrypt=X.n)(A,I,g,C,B,i,E,o,a,f,c),Q._crypto_aead_chacha20poly1305_ietf_keybytes=()=>(Q._crypto_aead_chacha20poly1305_ietf_keybytes=X.o)(),Q._crypto_aead_chacha20poly1305_ietf_npubbytes=()=>(Q._crypto_aead_chacha20poly1305_ietf_npubbytes=X.p)(),Q._crypto_aead_chacha20poly1305_ietf_nsecbytes=()=>(Q._crypto_aead_chacha20poly1305_ietf_nsecbytes=X.q)(),Q._crypto_aead_chacha20poly1305_ietf_abytes=()=>(Q._crypto_aead_chacha20poly1305_ietf_abytes=X.r)(),Q._crypto_aead_chacha20poly1305_ietf_messagebytes_max=()=>(Q._crypto_aead_chacha20poly1305_ietf_messagebytes_max=X.s)(),Q._crypto_aead_chacha20poly1305_ietf_keygen=A=>(Q._crypto_aead_chacha20poly1305_ietf_keygen=X.t)(A),Q._crypto_aead_chacha20poly1305_keybytes=()=>(Q._crypto_aead_chacha20poly1305_keybytes=X.u)(),Q._crypto_aead_chacha20poly1305_npubbytes=()=>(Q._crypto_aead_chacha20poly1305_npubbytes=X.v)(),Q._crypto_aead_chacha20poly1305_nsecbytes=()=>(Q._crypto_aead_chacha20poly1305_nsecbytes=X.w)(),Q._crypto_aead_chacha20poly1305_abytes=()=>(Q._crypto_aead_chacha20poly1305_abytes=X.x)(),Q._crypto_aead_chacha20poly1305_messagebytes_max=()=>(Q._crypto_aead_chacha20poly1305_messagebytes_max=X.y)(),Q._crypto_aead_chacha20poly1305_keygen=A=>(Q._crypto_aead_chacha20poly1305_keygen=X.z)(A),Q._crypto_aead_xchacha20poly1305_ietf_encrypt_detached=(A,I,g,C,B,i,E,o,a,f,c,e)=>(Q._crypto_aead_xchacha20poly1305_ietf_encrypt_detached=X.A)(A,I,g,C,B,i,E,o,a,f,c,e),Q._crypto_aead_xchacha20poly1305_ietf_encrypt=(A,I,g,C,B,i,E,o,a,f,c)=>(Q._crypto_aead_xchacha20poly1305_ietf_encrypt=X.B)(A,I,g,C,B,i,E,o,a,f,c),Q._crypto_aead_xchacha20poly1305_ietf_decrypt_detached=(A,I,g,C,B,i,E,o,a,f,c)=>(Q._crypto_aead_xchacha20poly1305_ietf_decrypt_detached=X.C)(A,I,g,C,B,i,E,o,a,f,c),Q._crypto_aead_xchacha20poly1305_ietf_decrypt=(A,I,g,C,B,i,E,o,a,f,c)=>(Q._crypto_aead_xchacha20poly1305_ietf_decrypt=X.D)(A,I,g,C,B,i,E,o,a,f,c),Q._crypto_aead_xchacha20poly1305_ietf_keybytes=()=>(Q._crypto_aead_xchacha20poly1305_ietf_keybytes=X.E)(),Q._crypto_aead_xchacha20poly1305_ietf_npubbytes=()=>(Q._crypto_aead_xchacha20poly1305_ietf_npubbytes=X.F)(),Q._crypto_aead_xchacha20poly1305_ietf_nsecbytes=()=>(Q._crypto_aead_xchacha20poly1305_ietf_nsecbytes=X.G)(),Q._crypto_aead_xchacha20poly1305_ietf_abytes=()=>(Q._crypto_aead_xchacha20poly1305_ietf_abytes=X.H)(),Q._crypto_aead_xchacha20poly1305_ietf_messagebytes_max=()=>(Q._crypto_aead_xchacha20poly1305_ietf_messagebytes_max=X.I)(),Q._crypto_aead_xchacha20poly1305_ietf_keygen=A=>(Q._crypto_aead_xchacha20poly1305_ietf_keygen=X.J)(A),Q._crypto_auth_bytes=()=>(Q._crypto_auth_bytes=X.K)(),Q._crypto_auth_keybytes=()=>(Q._crypto_auth_keybytes=X.L)(),Q._crypto_auth=(A,I,g,C,B)=>(Q._crypto_auth=X.M)(A,I,g,C,B),Q._crypto_auth_verify=(A,I,g,C,B)=>(Q._crypto_auth_verify=X.N)(A,I,g,C,B),Q._crypto_auth_keygen=A=>(Q._crypto_auth_keygen=X.O)(A),Q._crypto_box_seedbytes=()=>(Q._crypto_box_seedbytes=X.P)(),Q._crypto_box_publickeybytes=()=>(Q._crypto_box_publickeybytes=X.Q)(),Q._crypto_box_secretkeybytes=()=>(Q._crypto_box_secretkeybytes=X.R)(),Q._crypto_box_beforenmbytes=()=>(Q._crypto_box_beforenmbytes=X.S)(),Q._crypto_box_noncebytes=()=>(Q._crypto_box_noncebytes=X.T)(),Q._crypto_box_macbytes=()=>(Q._crypto_box_macbytes=X.U)(),Q._crypto_box_messagebytes_max=()=>(Q._crypto_box_messagebytes_max=X.V)(),Q._crypto_box_seed_keypair=(A,I,g)=>(Q._crypto_box_seed_keypair=X.W)(A,I,g),Q._crypto_box_keypair=(A,I)=>(Q._crypto_box_keypair=X.X)(A,I),Q._crypto_box_beforenm=(A,I,g)=>(Q._crypto_box_beforenm=X.Y)(A,I,g),Q._crypto_box_detached_afternm=(A,I,g,C,B,i,E)=>(Q._crypto_box_detached_afternm=X.Z)(A,I,g,C,B,i,E),Q._crypto_box_detached=(A,I,g,C,B,i,E,o)=>(Q._crypto_box_detached=X._)(A,I,g,C,B,i,E,o),Q._crypto_box_easy_afternm=(A,I,g,C,B,i)=>(Q._crypto_box_easy_afternm=X.$)(A,I,g,C,B,i),Q._crypto_box_easy=(A,I,g,C,B,i,E)=>(Q._crypto_box_easy=X.aa)(A,I,g,C,B,i,E),Q._crypto_box_open_detached_afternm=(A,I,g,C,B,i,E)=>(Q._crypto_box_open_detached_afternm=X.ba)(A,I,g,C,B,i,E),Q._crypto_box_open_detached=(A,I,g,C,B,i,E,o)=>(Q._crypto_box_open_detached=X.ca)(A,I,g,C,B,i,E,o),Q._crypto_box_open_easy_afternm=(A,I,g,C,B,i)=>(Q._crypto_box_open_easy_afternm=X.da)(A,I,g,C,B,i),Q._crypto_box_open_easy=(A,I,g,C,B,i,E)=>(Q._crypto_box_open_easy=X.ea)(A,I,g,C,B,i,E),Q._crypto_box_seal=(A,I,g,C,B)=>(Q._crypto_box_seal=X.fa)(A,I,g,C,B),Q._crypto_box_seal_open=(A,I,g,C,B,i)=>(Q._crypto_box_seal_open=X.ga)(A,I,g,C,B,i),Q._crypto_box_sealbytes=()=>(Q._crypto_box_sealbytes=X.ha)(),Q._crypto_generichash_bytes_min=()=>(Q._crypto_generichash_bytes_min=X.ia)(),Q._crypto_generichash_bytes_max=()=>(Q._crypto_generichash_bytes_max=X.ja)(),Q._crypto_generichash_bytes=()=>(Q._crypto_generichash_bytes=X.ka)(),Q._crypto_generichash_keybytes_min=()=>(Q._crypto_generichash_keybytes_min=X.la)(),Q._crypto_generichash_keybytes_max=()=>(Q._crypto_generichash_keybytes_max=X.ma)(),Q._crypto_generichash_keybytes=()=>(Q._crypto_generichash_keybytes=X.na)(),Q._crypto_generichash_statebytes=()=>(Q._crypto_generichash_statebytes=X.oa)(),Q._crypto_generichash=(A,I,g,C,B,i,E)=>(Q._crypto_generichash=X.pa)(A,I,g,C,B,i,E),Q._crypto_generichash_init=(A,I,g,C)=>(Q._crypto_generichash_init=X.qa)(A,I,g,C),Q._crypto_generichash_update=(A,I,g,C)=>(Q._crypto_generichash_update=X.ra)(A,I,g,C),Q._crypto_generichash_final=(A,I,g)=>(Q._crypto_generichash_final=X.sa)(A,I,g),Q._crypto_generichash_keygen=A=>(Q._crypto_generichash_keygen=X.ta)(A),Q._crypto_hash_bytes=()=>(Q._crypto_hash_bytes=X.ua)(),Q._crypto_hash=(A,I,g,C)=>(Q._crypto_hash=X.va)(A,I,g,C),Q._crypto_kdf_bytes_min=()=>(Q._crypto_kdf_bytes_min=X.wa)(),Q._crypto_kdf_bytes_max=()=>(Q._crypto_kdf_bytes_max=X.xa)(),Q._crypto_kdf_contextbytes=()=>(Q._crypto_kdf_contextbytes=X.ya)(),Q._crypto_kdf_keybytes=()=>(Q._crypto_kdf_keybytes=X.za)(),Q._crypto_kdf_derive_from_key=(A,I,g,C,B,i)=>(Q._crypto_kdf_derive_from_key=X.Aa)(A,I,g,C,B,i),Q._crypto_kdf_keygen=A=>(Q._crypto_kdf_keygen=X.Ba)(A),Q._crypto_kdf_hkdf_sha256_extract_init=(A,I,g)=>(Q._crypto_kdf_hkdf_sha256_extract_init=X.Ca)(A,I,g),Q._crypto_kdf_hkdf_sha256_extract_update=(A,I,g)=>(Q._crypto_kdf_hkdf_sha256_extract_update=X.Da)(A,I,g),Q._crypto_kdf_hkdf_sha256_extract_final=(A,I)=>(Q._crypto_kdf_hkdf_sha256_extract_final=X.Ea)(A,I),Q._crypto_kdf_hkdf_sha256_extract=(A,I,g,C,B)=>(Q._crypto_kdf_hkdf_sha256_extract=X.Fa)(A,I,g,C,B),Q._crypto_kdf_hkdf_sha256_keygen=A=>(Q._crypto_kdf_hkdf_sha256_keygen=X.Ga)(A),Q._crypto_kdf_hkdf_sha256_expand=(A,I,g,C,B)=>(Q._crypto_kdf_hkdf_sha256_expand=X.Ha)(A,I,g,C,B),Q._crypto_kdf_hkdf_sha256_keybytes=()=>(Q._crypto_kdf_hkdf_sha256_keybytes=X.Ia)(),Q._crypto_kdf_hkdf_sha256_bytes_min=()=>(Q._crypto_kdf_hkdf_sha256_bytes_min=X.Ja)(),Q._crypto_kdf_hkdf_sha256_bytes_max=()=>(Q._crypto_kdf_hkdf_sha256_bytes_max=X.Ka)(),Q._crypto_kdf_hkdf_sha256_statebytes=()=>(Q._crypto_kdf_hkdf_sha256_statebytes=X.La)(),Q._crypto_kdf_hkdf_sha512_extract_init=(A,I,g)=>(Q._crypto_kdf_hkdf_sha512_extract_init=X.Ma)(A,I,g),Q._crypto_kdf_hkdf_sha512_extract_update=(A,I,g)=>(Q._crypto_kdf_hkdf_sha512_extract_update=X.Na)(A,I,g),Q._crypto_kdf_hkdf_sha512_extract_final=(A,I)=>(Q._crypto_kdf_hkdf_sha512_extract_final=X.Oa)(A,I),Q._crypto_kdf_hkdf_sha512_extract=(A,I,g,C,B)=>(Q._crypto_kdf_hkdf_sha512_extract=X.Pa)(A,I,g,C,B),Q._crypto_kdf_hkdf_sha512_keygen=A=>(Q._crypto_kdf_hkdf_sha512_keygen=X.Qa)(A),Q._crypto_kdf_hkdf_sha512_expand=(A,I,g,C,B)=>(Q._crypto_kdf_hkdf_sha512_expand=X.Ra)(A,I,g,C,B),Q._crypto_kdf_hkdf_sha512_keybytes=()=>(Q._crypto_kdf_hkdf_sha512_keybytes=X.Sa)(),Q._crypto_kdf_hkdf_sha512_bytes_min=()=>(Q._crypto_kdf_hkdf_sha512_bytes_min=X.Ta)(),Q._crypto_kdf_hkdf_sha512_bytes_max=()=>(Q._crypto_kdf_hkdf_sha512_bytes_max=X.Ua)(),Q._crypto_kx_seed_keypair=(A,I,g)=>(Q._crypto_kx_seed_keypair=X.Va)(A,I,g),Q._crypto_kx_keypair=(A,I)=>(Q._crypto_kx_keypair=X.Wa)(A,I),Q._crypto_kx_client_session_keys=(A,I,g,C,B)=>(Q._crypto_kx_client_session_keys=X.Xa)(A,I,g,C,B),Q._crypto_kx_server_session_keys=(A,I,g,C,B)=>(Q._crypto_kx_server_session_keys=X.Ya)(A,I,g,C,B),Q._crypto_kx_publickeybytes=()=>(Q._crypto_kx_publickeybytes=X.Za)(),Q._crypto_kx_secretkeybytes=()=>(Q._crypto_kx_secretkeybytes=X._a)(),Q._crypto_kx_seedbytes=()=>(Q._crypto_kx_seedbytes=X.$a)(),Q._crypto_kx_sessionkeybytes=()=>(Q._crypto_kx_sessionkeybytes=X.ab)(),Q._crypto_scalarmult_base=(A,I)=>(Q._crypto_scalarmult_base=X.bb)(A,I),Q._crypto_scalarmult=(A,I,g)=>(Q._crypto_scalarmult=X.cb)(A,I,g),Q._crypto_scalarmult_bytes=()=>(Q._crypto_scalarmult_bytes=X.db)(),Q._crypto_scalarmult_scalarbytes=()=>(Q._crypto_scalarmult_scalarbytes=X.eb)(),Q._crypto_secretbox_keybytes=()=>(Q._crypto_secretbox_keybytes=X.fb)(),Q._crypto_secretbox_noncebytes=()=>(Q._crypto_secretbox_noncebytes=X.gb)(),Q._crypto_secretbox_macbytes=()=>(Q._crypto_secretbox_macbytes=X.hb)(),Q._crypto_secretbox_messagebytes_max=()=>(Q._crypto_secretbox_messagebytes_max=X.ib)(),Q._crypto_secretbox_keygen=A=>(Q._crypto_secretbox_keygen=X.jb)(A),Q._crypto_secretbox_detached=(A,I,g,C,B,i,E)=>(Q._crypto_secretbox_detached=X.kb)(A,I,g,C,B,i,E),Q._crypto_secretbox_easy=(A,I,g,C,B,i)=>(Q._crypto_secretbox_easy=X.lb)(A,I,g,C,B,i),Q._crypto_secretbox_open_detached=(A,I,g,C,B,i,E)=>(Q._crypto_secretbox_open_detached=X.mb)(A,I,g,C,B,i,E),Q._crypto_secretbox_open_easy=(A,I,g,C,B,i)=>(Q._crypto_secretbox_open_easy=X.nb)(A,I,g,C,B,i),Q._crypto_secretstream_xchacha20poly1305_keygen=A=>(Q._crypto_secretstream_xchacha20poly1305_keygen=X.ob)(A),Q._crypto_secretstream_xchacha20poly1305_init_push=(A,I,g)=>(Q._crypto_secretstream_xchacha20poly1305_init_push=X.pb)(A,I,g),Q._crypto_secretstream_xchacha20poly1305_init_pull=(A,I,g)=>(Q._crypto_secretstream_xchacha20poly1305_init_pull=X.qb)(A,I,g),Q._crypto_secretstream_xchacha20poly1305_rekey=A=>(Q._crypto_secretstream_xchacha20poly1305_rekey=X.rb)(A),Q._crypto_secretstream_xchacha20poly1305_push=(A,I,g,C,B,i,E,o,a,f)=>(Q._crypto_secretstream_xchacha20poly1305_push=X.sb)(A,I,g,C,B,i,E,o,a,f),Q._crypto_secretstream_xchacha20poly1305_pull=(A,I,g,C,B,i,E,o,a,f)=>(Q._crypto_secretstream_xchacha20poly1305_pull=X.tb)(A,I,g,C,B,i,E,o,a,f),Q._crypto_secretstream_xchacha20poly1305_statebytes=()=>(Q._crypto_secretstream_xchacha20poly1305_statebytes=X.ub)(),Q._crypto_secretstream_xchacha20poly1305_abytes=()=>(Q._crypto_secretstream_xchacha20poly1305_abytes=X.vb)(),Q._crypto_secretstream_xchacha20poly1305_headerbytes=()=>(Q._crypto_secretstream_xchacha20poly1305_headerbytes=X.wb)(),Q._crypto_secretstream_xchacha20poly1305_keybytes=()=>(Q._crypto_secretstream_xchacha20poly1305_keybytes=X.xb)(),Q._crypto_secretstream_xchacha20poly1305_messagebytes_max=()=>(Q._crypto_secretstream_xchacha20poly1305_messagebytes_max=X.yb)(),Q._crypto_secretstream_xchacha20poly1305_tag_message=()=>(Q._crypto_secretstream_xchacha20poly1305_tag_message=X.zb)(),Q._crypto_secretstream_xchacha20poly1305_tag_push=()=>(Q._crypto_secretstream_xchacha20poly1305_tag_push=X.Ab)(),Q._crypto_secretstream_xchacha20poly1305_tag_rekey=()=>(Q._crypto_secretstream_xchacha20poly1305_tag_rekey=X.Bb)(),Q._crypto_secretstream_xchacha20poly1305_tag_final=()=>(Q._crypto_secretstream_xchacha20poly1305_tag_final=X.Cb)(),Q._crypto_shorthash_bytes=()=>(Q._crypto_shorthash_bytes=X.Db)(),Q._crypto_shorthash_keybytes=()=>(Q._crypto_shorthash_keybytes=X.Eb)(),Q._crypto_shorthash=(A,I,g,C,B)=>(Q._crypto_shorthash=X.Fb)(A,I,g,C,B),Q._crypto_shorthash_keygen=A=>(Q._crypto_shorthash_keygen=X.Gb)(A),Q._crypto_sign_statebytes=()=>(Q._crypto_sign_statebytes=X.Hb)(),Q._crypto_sign_bytes=()=>(Q._crypto_sign_bytes=X.Ib)(),Q._crypto_sign_seedbytes=()=>(Q._crypto_sign_seedbytes=X.Jb)(),Q._crypto_sign_publickeybytes=()=>(Q._crypto_sign_publickeybytes=X.Kb)(),Q._crypto_sign_secretkeybytes=()=>(Q._crypto_sign_secretkeybytes=X.Lb)(),Q._crypto_sign_messagebytes_max=()=>(Q._crypto_sign_messagebytes_max=X.Mb)(),Q._crypto_sign_seed_keypair=(A,I,g)=>(Q._crypto_sign_seed_keypair=X.Nb)(A,I,g),Q._crypto_sign_keypair=(A,I)=>(Q._crypto_sign_keypair=X.Ob)(A,I),Q._crypto_sign=(A,I,g,C,B,i)=>(Q._crypto_sign=X.Pb)(A,I,g,C,B,i),Q._crypto_sign_open=(A,I,g,C,B,i)=>(Q._crypto_sign_open=X.Qb)(A,I,g,C,B,i),Q._crypto_sign_detached=(A,I,g,C,B,i)=>(Q._crypto_sign_detached=X.Rb)(A,I,g,C,B,i),Q._crypto_sign_verify_detached=(A,I,g,C,B)=>(Q._crypto_sign_verify_detached=X.Sb)(A,I,g,C,B),Q._crypto_sign_init=A=>(Q._crypto_sign_init=X.Tb)(A),Q._crypto_sign_update=(A,I,g,C)=>(Q._crypto_sign_update=X.Ub)(A,I,g,C),Q._crypto_sign_final_create=(A,I,g,C)=>(Q._crypto_sign_final_create=X.Vb)(A,I,g,C),Q._crypto_sign_final_verify=(A,I,g)=>(Q._crypto_sign_final_verify=X.Wb)(A,I,g),Q._crypto_sign_ed25519_pk_to_curve25519=(A,I)=>(Q._crypto_sign_ed25519_pk_to_curve25519=X.Xb)(A,I),Q._crypto_sign_ed25519_sk_to_curve25519=(A,I)=>(Q._crypto_sign_ed25519_sk_to_curve25519=X.Yb)(A,I),Q._randombytes_random=()=>(Q._randombytes_random=X.Zb)(),Q._randombytes_stir=()=>(Q._randombytes_stir=X._b)(),Q._randombytes_uniform=A=>(Q._randombytes_uniform=X.$b)(A),Q._randombytes_buf=(A,I)=>(Q._randombytes_buf=X.ac)(A,I),Q._randombytes_buf_deterministic=(A,I,g)=>(Q._randombytes_buf_deterministic=X.bc)(A,I,g),Q._randombytes_seedbytes=()=>(Q._randombytes_seedbytes=X.cc)(),Q._randombytes_close=()=>(Q._randombytes_close=X.dc)(),Q._randombytes=(A,I,g)=>(Q._randombytes=X.ec)(A,I,g),Q._sodium_bin2hex=(A,I,g,C)=>(Q._sodium_bin2hex=X.fc)(A,I,g,C),Q._sodium_hex2bin=(A,I,g,C,B,i,E)=>(Q._sodium_hex2bin=X.gc)(A,I,g,C,B,i,E),Q._sodium_base64_encoded_len=(A,I)=>(Q._sodium_base64_encoded_len=X.hc)(A,I),Q._sodium_bin2base64=(A,I,g,C,B)=>(Q._sodium_bin2base64=X.ic)(A,I,g,C,B),Q._sodium_base642bin=(A,I,g,C,B,i,E,o)=>(Q._sodium_base642bin=X.jc)(A,I,g,C,B,i,E,o),Q._sodium_init=()=>(Q._sodium_init=X.kc)(),Q._sodium_pad=(A,I,g,C,B)=>(Q._sodium_pad=X.lc)(A,I,g,C,B),Q._sodium_unpad=(A,I,g,C)=>(Q._sodium_unpad=X.mc)(A,I,g,C),Q._sodium_version_string=()=>(Q._sodium_version_string=X.nc)(),Q._sodium_library_version_major=()=>(Q._sodium_library_version_major=X.oc)(),Q._sodium_library_version_minor=()=>(Q._sodium_library_version_minor=X.pc)(),Q._sodium_library_minimal=()=>(Q._sodium_library_minimal=X.qc)(),Q._malloc=A=>(Q._malloc=X.rc)(A),Q._free=A=>(Q._free=X.sc)(A),Q.setValue=function(A,I,g="i8"){switch(g.endsWith("*")&&(g="*"),g){case"i1":case"i8":w[A>>0]=I;break;case"i16":n[A>>1]=I;break;case"i32":s[A>>2]=I;break;case"i64":d("to do setValue(i64) use WASM_BIGINT");case"float":F[A>>2]=I;break;case"double":S[A>>3]=I;break;case"*":k[A>>2]=I;break;default:d(`invalid type for setValue: ${g}`)}},Q.getValue=function(A,I="i8"){switch(I.endsWith("*")&&(I="*"),I){case"i1":case"i8":return w[A>>0];case"i16":return n[A>>1];case"i32":return s[A>>2];case"i64":d("to do getValue(i64) use WASM_BIGINT");case"float":return F[A>>2];case"double":return S[A>>3];case"*":return k[A>>2];default:d(`invalid type for getValue: ${I}`)}},Q.UTF8ToString=m,Y=function A(){L||j(),L||(Y=A)},Q.preInit)for("function"==typeof Q.preInit&&(Q.preInit=[Q.preInit]);Q.preInit.length>0;)Q.preInit.pop()();j()}))};var g,B,Q=void 0!==Q?Q:{},i=Object.assign({},Q),E="object"==typeof window,o="function"==typeof importScripts,a="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,f="";if(a){var c=__nccwpck_require__(7147),e=__nccwpck_require__(1017);f=o?e.dirname(f)+"/":__dirname+"/",g=(A,I)=>(A=function(A){return A.startsWith("file://")}(A)?new URL(A):e.normalize(A),c.readFileSync(A,I?void 0:"utf8")),B=A=>{var I=g(A,!0);return I.buffer||(I=new Uint8Array(I)),I},!Q.thisProgram&&process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2), true&&(module.exports=Q),Q.inspect=()=>"[Emscripten Module object]"}else(E||o)&&(o?f=self.location.href:"undefined"!=typeof document&&document.currentScript&&(f=document.currentScript.src),f=0!==f.indexOf("blob:")?f.substr(0,f.replace(/[?#].*/,"").lastIndexOf("/")+1):"",g=A=>{var I=new XMLHttpRequest;return I.open("GET",A,!1),I.send(null),I.responseText},o&&(B=A=>{var I=new XMLHttpRequest;return I.open("GET",A,!1),I.responseType="arraybuffer",I.send(null),new Uint8Array(I.response)}));Q.print;var r,D,t=Q.printErr||void 0;Object.assign(Q,i),i=null,Q.arguments&&Q.arguments,Q.thisProgram&&Q.thisProgram,Q.quit&&Q.quit,Q.wasmBinary&&(r=Q.wasmBinary),Q.noExitRuntime,"object"!=typeof WebAssembly&&U("no native wasm support detected");var y,w,h,n,s,k,F,S=!1;function H(){var A=D.buffer;Q.HEAP8=y=new Int8Array(A),Q.HEAP16=h=new Int16Array(A),Q.HEAPU8=w=new Uint8Array(A),Q.HEAPU16=new Uint16Array(A),Q.HEAP32=n=new Int32Array(A),Q.HEAPU32=s=new Uint32Array(A),Q.HEAPF32=k=new Float32Array(A),Q.HEAPF64=F=new Float64Array(A)}var G=[],_=[],M=[],p=0,N=null,J=null;function U(A){throw Q.onAbort&&Q.onAbort(A),t(A="Aborted("+A+")"),S=!0,A+=". Build with -sASSERTIONS for more info.",new WebAssembly.RuntimeError(A)}var Y,d,K="data:application/octet-stream;base64,";function b(A){return A.startsWith(K)}b(Y="data:application/octet-stream;base64,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gAEgA0IDiEL/AIMiBH0iCCACWARAQgAhAyAEQv8AhUIDWgRAIAhC/AGDIQcgAEHQAGohCgNAIAogAyAEfKdqIAEgA6dqLQAAOgAAIAogA0IBhCIJIAR8p2ogASAJp2otAAA6AAAgCiADQgKEIgkgBHynaiABIAmnai0AADoAACAKIANCA4QiCSAEfKdqIAEgCadqLQAAOgAAIANCBHwhAyAFQgR8IgUgB1INAAsLIAhCA4MiBUIAUgRAA0AgACADIAR8p2ogASADp2otAAA6AFAgA0IBfCEDIAZCAXwiBiAFUg0ACwsgACAAQdAAaiAMIAxBgAVqIgoQNiABIAinaiEBIAIgCH0iAkL/AFYEQANAIAAgASAMIAoQNiABQYABaiEBIAJCgAF9IgJC/wBWDQALCwJAIAJQDQAgAkIDgyEEQgAhBkIAIQMgAkIEWgRAIAJCfIMhBSAAQdAAaiEKQgAhAgNAIAogA6ciC2ogASALai0AADoAACAKIAtBAXIiDWogASANai0AADoAACAKIAtBAnIiDWogASANai0AADoAACAKIAtBA3IiC2ogASALai0AADoAACADQgR8IQMgAkIEfCICIAVSDQALCyAEUA0AA0AgACADpyIKaiABIApqLQAAOgBQIANCAXwhAyAGQgF8IgYgBFINAAsLIAxBwAUQBwwBC0IAIQMgAkIEWgRAIAJCfIMhCCAAQdAAaiEKA0AgCiADIAR8p2ogASADp2otAAA6AAAgCiADQgGEIgcgBHynaiABIAenai0AADoAACAKIANCAoQiByAEfKdqIAEgB6dqLQAAOgAAIAogA0IDhCIHIAR8p2ogASAHp2otAAA6AAAgA0IEfCEDIAVCBHwiBSAIUg0ACwsgAkIDgyICUA0AA0AgACADIAR8p2ogASADp2otAAA6AFAgA0IBfCEDIAZCAXwiBiACUg0ACwsgDEHABWokAEEAC58EARN/IAEoAighAiABKAIEIQMgASgCLCEEIAEoAgghBSABKAIwIQYgASgCDCEHIAEoAjQhCCABKAIQIQkgASgCOCEKIAEoAhQhCyABKAI8IQwgASgCGCENIAFBQGsiDigCACEPIAEoAhwhECABKAJEIREgASgCICESIAEoAkghEyABKAIAIRQgACABKAIkIAEoAkxqNgIkIAAgEiATajYCICAAIBAgEWo2AhwgACANIA9qNgIYIAAgCyAMajYCFCAAIAkgCmo2AhAgACAHIAhqNgIMIAAgBSAGajYCCCAAIAMgBGo2AgQgACACIBRqNgIAIAEoAighAiABKAIEIQMgASgCLCEEIAEoAgghBSABKAIwIQYgASgCDCEHIAEoAjQhCCABKAIQIQkgASgCOCEKIAEoAhQhCyABKAI8IQwgASgCGCENIA4oAgAhDiABKAIcIQ8gASgCRCEQIAEoAiAhESABKAJIIRIgASgCACETIAAgASgCTCABKAIkazYCTCAAIBIgEWs2AkggACAQIA9rNgJEIABBQGsgDiANazYCACAAIAwgC2s2AjwgACAKIAlrNgI4IAAgCCAHazYCNCAAIAYgBWs2AjAgACAEIANrNgIsIAAgAiATazYCKCAAIAEpAlA3AlAgACABKQJYNwJYIAAgASkCYDcCYCAAIAEpAmg3AmggACABKQJwNwJwIABB+ABqIAFB+ABqQaALEAYL8AkBHn8gASgCKCEDIAEoAgQhBCABKAIsIQUgASgCCCEGIAEoAjAhByABKAIMIQggASgCNCEJIAEoAhAhCiABKAI4IQsgASgCFCEMIAEoAjwhDSABKAIYIQ4gAUFAayIPKAIAIRAgASgCHCERIAEoAkQhEiABKAIgIRMgASgCSCEUIAEoAgAhFSAAIAEoAiQgASgCTGo2AiQgACATIBRqNgIgIAAgESASajYCHCAAIA4gEGo2AhggACAMIA1qNgIUIAAgCiALajYCECAAIAggCWo2AgwgACAGIAdqNgIIIAAgBCAFajYCBCAAIAMgFWo2AgAgASgCKCEFIAEoAgQhAyABKAIsIQYgASgCCCEHIAEoAjAhCCABKAIMIQkgASgCNCEKIAEoAhAhCyABKAI4IQwgASgCFCENIAEoAjwhDiABKAIYIRAgDygCACEPIAEoAhwhBCABKAJEIREgASgCICESIAEoAkghEyABKAIAIRQgACABKAJMIAEoAiRrNgJMIAAgEyASazYCSCAAIBEgBGs2AkQgAEFAayIEIA8gEGs2AgAgACAOIA1rNgI8IAAgDCALazYCOCAAIAogCWs2AjQgACAIIAdrNgIwIAAgBiADazYCLCAAQShqIgMgBSAUazYCACAAQdAAaiAAIAIQBiADIAMgAkEoahAGIABB+ABqIAJB+ABqIAFB+ABq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BUKAgIDgD4N9PgJ4IAEoAighHyABKAIsISAgASgCBCEhIAEoAjAhIiABKAIIISMgASgCNCEkIAEoAgwhJSABKAI4ISYgASgCECEnIAEoAjwhKCABKAIUISkgAUFAaygCACEqIAEoAhghKyABKAJEISwgASgCHCEtIAEoAkghLiABKAIgIS8gASgCACEwIAAgASgCTCABKAIkajYCTCAAIC4gL2o2AkggACAsIC1qNgJEIABBQGsiMiAqICtqNgIAIAAgKCApajYCPCAAICYgJ2o2AjggACAkICVqNgI0IAAgIiAjajYCMCAAICAgIWo2AiwgAEEoaiIBIB8gMGo2AgAgHiABEAUgACgCUCEfIAAoAgQhICAAKAJUISEgACgCCCEiIAAoAlghIyAAKAIMISQgACgCXCElIAAoAhAhJiAAKAJgIScgACgCFCEoIAAoAmQhKSAAKAIYISogACgCaCErIAAoAhwhLCAAKAJsIS0gACgCICEuIAAoAnAhLyAAKAIAITAgACAAKAJ0IjEgACgCJCIzayI0NgJ0IAAgLyAuayI1NgJwIAAgLSAsayI2NgJsIAAgKyAqayI3NgJoIAAgKSAoayI4NgJkIAAgJyAmayI5NgJgIAAgJSAkayI6NgJcIAAgIyAiayI7NgJYIAAgISAgayI8NgJUIAAgHyAwayI9NgJQIAAgMSAzaiIxNgJMIAAgLiAvaiIuNgJIIAAgLCAtaiIsNgJEIDIgKiAraiIqNgIAIAAgKCApaiIoNgI8IAAgJiAnaiImNgI4IAAgJCAlaiIkNgI0IAAgIiAjaiIiNgIwIAAgICAhaiIgNgIsIAEgHyAwaiIBNgIAIB4oAgAhHyAeKAIEISEgHigCCCEjIB4oAgwhJSAeKAIQIScgHigCFCEpIB4oAhghKyAeKAIcIS0gHigCICEvIAAgHigCJCAxazYCJCAAIC8gLms2AiAgACAtICxrNgIcIAAgKyAqazYCGCAAICkgKGs2AhQgACAnICZrNgIQIAAgJSAkazYCDCAAICMgIms2AgggACAhICBrNgIEIAAgHyABazYCACAAKAJ4IQEgACgCfCEfIAAoAoABISAgACgChAEhISAAKAKIASEiIAAoAowBISMgACgCkAEhJCAAKAKUASElIAAoApgBISYgACAAKAKcASA0azYCnAEgACAmIDVrNgKYASAAICUgNms2ApQBIAAgJCA3azYCkAEgACAjIDhrNgKMASAAICIgOWs2AogBIAAgISA6azYChAEgACAgIDtrNgKAASAAIB8gPGs2AnwgACABID1rNgJ4IB5BMGokAAtEAQJ/IwBBEGsiAiQAIAEEQANAIAJBADoADyAAIANqQbiTAiACQQ9qQQAQADoAACADQQFqIgMgAUcNAAsLIAJBEGokAAsFAEHAAAskACABQoCAgIAQWgRAEAsACyAAIAEgAiADQayTAigCABEMABoLcAAgAEIANwNAIABCADcDSCAAQYCMAikDADcDACAAQYiMAikDADcDCCAAQZCMAikDADcDECAAQZiMAikDADcDGCAAQaCMAikDADcDICAAQaiMAikDADcDKCAAQbCMAikDADcDMCAAQbiMAikDADcDOAvmAgEDfwJ/AkAgASIDQf8BcSICBEAgAEEDcQRAA0AgAC0AACIBRQ0DIAEgA0H/AXFGDQMgAEEBaiIAQQNxDQALCwJAIAAoAgAiAUF/cyABQYGChAhrcUGAgYKEeHENACACQYGChAhsIQIDQCABIAJzIgFBf3MgAUGBgoQIa3FBgIGChHhxDQEgACgCBCEBIABBBGohACABQYGChAhrIAFBf3NxQYCBgoR4cUUNAAsLA0AgACIBLQAAIgIEQCAAQQFqIQAgAiADQf8BcUcNAQsLIAEMAgsCfwJAAkAgACICQQNxRQ0AQQAgAC0AAEUNAhoDQCAAQQFqIgBBA3FFDQEgAC0AAA0ACwwBCwNAIAAiAUEEaiEAIAEoAgAiBEF/cyAEQYGChAhrcUGAgYKEeHFFDQALA0AgASIAQQFqIQEgAC0AAA0ACwsgACACawsgAmoMAQsgAAsiAEEAIAAtAAAgA0H/AXFGGwtAAAJAIAStQoCAgIAQIAJCP3xCBoh9Vg0AIAJCgICAgBBaDQAgACABIAIgAyAEIAVBtJMCKAIAEQkAGg8LEAsACwQAQQALNwEBfyMAQUBqIgIkACAAIAIQFSAAQdABaiIAIAJCwAAQDBogACABEBUgAkHAABAHIAJBQGskAAvWBAEIfyMAQcABayIFJAAgAkGBAU8EQCAAEBsgACABIAKtEAwaIAAgBRAVQcAAIQIgBSEBCyAAEBsgBUFAa0E2QYABEAgaAkAgAkUNACACQQRPBEAgAkH8AXEhCgNAIAVBQGsiCCADaiIEIAQtAAAgASADai0AAHM6AAAgCCADQQFyIgRqIgYgBi0AACABIARqLQAAczoAACAIIANBAnIiBGoiBiAGLQAAIAEgBGotAABzOgAAIAggA0EDciIEaiIGIAYtAAAgASAEai0AAHM6AAAgA0EEaiEDIAdBBGoiByAKRw0ACwsgAkEDcSIHRQ0AA0AgBUFAayADaiIKIAotAAAgASADai0AAHM6AAAgA0EBaiEDIAlBAWoiCSAHRw0ACwsgACAFQUBrIgNCgAEQDBogAEHQAWoiABAbIANB3ABBgAEQCBoCQCACRQ0AQQAhCUEAIQMgAkEETwRAIAJB/AFxIQpBACEHA0AgBUFAayIIIANqIgQgBC0AACABIANqLQAAczoAACAIIANBAXIiBGoiBiAGLQAAIAEgBGotAABzOgAAIAggA0ECciIEaiIGIAYtAAAgASAEai0AAHM6AAAgCCADQQNyIgRqIgYgBi0AACABIARqLQAAczoAACADQQRqIQMgB0EEaiIHIApHDQALCyACQQNxIgJFDQADQCAFQUBrIANqIgcgBy0AACABIANqLQAAczoAACADQQFqIQMgCUEBaiIJIAJHDQALCyAAIAVBQGsiAEKAARAMGiAAQYABEAcgBUHAABAHIAVBwAFqJABBAAuVAQEBfyMAQdABayIDJAAgA0IANwNIIANBiIwCKQMANwMIIANBkIwCKQMANwMQIANBmIwCKQMANwMYIANBoIwCKQMANwMgIANBqIwCKQMANwMoIANBsIwCKQMANwMwIANBuIwCKQMANwM4IANCADcDQCADQYCMAikDADcDACADIAEgAhAMGiADIAAQFSADQdABaiQAQQALUgECf0GAkwIoAgAiASAAQQdqQXhxIgJqIQACQCACQQAgACABTRsNACAAPwBBEHRLBEAgABAERQ0BC0GAkwIgADYCACABDwtBtJkCQTA2AgBBfwvnBAESf0Gy2ojLByEDQe7IgZkDIQRB5fDBiwYhBUH0yoHZBiEOIAEoAAwhBiABKAAIIQ8gASgABCEHIAIoABwhCyACKAAYIQwgAigAFCEQIAIoABAhDSACKAAMIQggAigACCEJIAIoAAQhCiABKAAAIQEgAigAACECA0AgAiABIAIgBWoiBXNBEHciASANaiINc0EMdyICIAVqIgUgAXNB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IgIkACACQZABaiIEIAEQBSACQeAAaiIDIAQQBSADIAMQBSADIAEgAxAGIAQgBCADEAYgAkEwaiIBIAQQBSADIAMgARAGIAEgAxAFIAEgARAFIAEgARAFIAEgARAFIAEgARAFIAMgASADEAYgASADEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABIAMQBiACIAEQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSABIAIgARAGIAEgARAFIAEgARAFIAEgARAFIAEgARAFIAEgARAFIAEgARAFIAEgARAFIAEgARAFIAEgARAFIAEgARAFIAMgASADEAYgASADEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABIAMQBiACIAEQBUEBIQEDQCACIAIQBSABQQFqIgFB5ABHDQALIAJBMGoiASACIAEQBiABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSACQeAAaiIDIAEgAxAGIAMgAxAFIAMgAxAFIAMgAxAFIAMgAxAFIAMgAxAFIAAgAyACQZABahAGIAJBwAFqJAAL7wMBAX8jAEEQayICIAA2AgwgAiABNgIIIAJBADYCBCACIAIoAgQgAigCDC0AACACKAIILQAAc3I2AgQgAiACKAIEIAIoAgwtAAEgAigCCC0AAXNyNgIEIAIgAigCBCACKAIMLQACIAIoAggtAAJzcjYCBCACIAIoAgQgAigCDC0AAyACKAIILQADc3I2AgQgAiACKAIEIAIoAgwtAAQgAigCCC0ABHNyNgIEIAIgAigCBCACKAIMLQAFIAIoAggtAAVzcjYCBCACIAIoAgQgAigCDC0ABiACKAIILQAGc3I2AgQgAiACKAIEIAIoAgwtAAcgAigCCC0AB3NyNgIEIAIgAigCBCACKAIMLQAIIAIoAggtAAhzcjYCBCACIAIoAgQgAigCDC0ACSACKAIILQAJc3I2AgQgAiACKAIEIAIoAgwtAAogAigCCC0ACnNyNgIEIAIgAigCBCACKAIMLQALIAIoAggtAAtzcjYCBCACIAIoAgQgAigCDC0ADCACKAIILQAMc3I2AgQgAiACKAIEIAIoAgwtAA0gAigCCC0ADXNyNgIEIAIgAigCBCACKAIMLQAOIAIoAggtAA5zcjYCBCACIAIoAgQgAigCDC0ADyACKAIILQAPc3I2AgQgAigCBEEBa0EIdkEBcUEBawuLLgElfiAAIAEpACgiICABKQBoIhggASkAQCIaIAEpACAiGSAYIAEpAHgiHCABKQBYIiEgASkAUCIbICAgACkAECAZIAApADAiHXx8IhV8IB0gACkAUCAVhULr+obav7X2wR+FQiCJIhVCq/DT9K/uvLc8fCIehUIoiSIdfCIWIBWFQjCJIgYgHnwiBCAdhUIBiSIXIAEpABgiHSAAKQAIIiUgASkAECIVIAApACgiHnx8IiJ8IAApAEggIoVCn9j52cKR2oKbf4VCIIkiA0LFsdXZp6+U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Qv////8Pg3wiB0IaiKdBBWwgA6dB////H3FqIhFBGnYgBKdB////H3FqIRUgBadB////H3EhFCAGp0H///8fcSETIAenQf///x9xIRIgEUH///8fcSERIAFBEGohASACQhB9IgJCD1YNAAsLIAAgETYCFCAAIBI2AiQgACATNgIgIAAgFDYCHCAAIBU2AhgLrQMCDH8DfiAAKQM4Ig5CAFIEQCAAQUBrIgIgDqciA2pBAToAACAOQgF8Qg9YBEAgACADakHBAGpBAEEPIANrEAgaCyAAQQE6AFAgACACQhAQPgsgADUCNCEOIAA1AjAhDyAANQIsIRAgASAAKAIUIAAoAiQgACgCICAAKAIcIAAoAhgiA0EadmoiAkEadmoiBkEadmoiCUEadkEFbGoiBEH///8fcSIFQQVqIgdBGnYgA0H///8fcSAEQRp2aiIEaiIIQRp2IAJB////H3EiCmoiC0EadiAGQf///x9xIgZqIgxBGnYgCUH///8fcWoiDUGAgIAgayICQR91IgMgBHEgAkEfdkEBayIEQf///x9xIgIgCHFyIghBGnQgAiAHcSADIAVxcnIiBSAAKAIoaiIHNgAAIAEgBSAHS60gECADIApxIAIgC3FyIgVBFHQgCEEGdnKtfHwiED4ABCABIA8gAyAGcSACIAxxciICQQ50IAVBDHZyrXwgEEIgiHwiDz4ACCABIA4gBCANcSADIAlxckEIdCACQRJ2cq18IA9CIIh8PgAMIABB2AAQBwvfBAIGfgF/AkAgACkDOCIDQgBSBEAgAEIQIAN9IgQgAiACIARWGyIEQgBSBH5CACEDIARCBFoEQCAEQnyDIQUgAEFAayEJA0AgCSAAKQM4IAN8p2ogASADp2otAAA6AAAgCSADQgGEIgggACkDOHynaiABIAinai0AADoAACAJIANCAoQiCCAAKQM4fKdqIAEgCKdqLQAAOgAAIAkgA0IDhCIIIAApAzh8p2ogASAIp2otAAA6AAAgA0IEfCEDIAZCBHwiBiAFUg0ACwsgBEIDgyIGQgBSBEADQCAAIAApAzggA3ynakFAayABIAOnai0AADoAACADQgF8IQMgB0IBfCIHIAZSDQALCyAAKQM4BSADCyAEfCIDNwM4IANCEFQNASAAIABBQGtCEBA+IABCADcDOCACIAR9IQIgASAEp2ohAQsg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IhIgPygAFyICQQV2Qf///wBxrSITfnwgADMAFSAAMQAXQhCGQoCA/ACDhCIUID8oABxBB3atIhV+fCACQRh2rSA/MQAbQgiGhCA/MQAcQhCGhEICiEL///8AgyIWIAVBBXZB////AHGtIhd+fCATIBd+ID8oAA8iBUEYdq0gPzEAE0IIhoQgPzEAFEIQhoRCA4giGCARfnwgECASfnwgACgADyICQRh2rSAAMQATQgiGhCAAMQAUQhCGhEIDiCIZIBV+fCAUIBZ+fCIJQoCAQH0iCEIViHwiB0KAgEB9IgZCFYggFSAXfiARIBN+fCASIBZ+fCIDIANCgIBAfSIDQoCAgP////8Ag318IixCmNocfiARIBZ+IBIgFX58IANCFYh8IgMgA0KAgEB9IipCgICA/////wCDfSItQpPYKH58IAcgBkKAgIB/g30iLkLn9id+fCAJIAhCgICAf4N9IBIgGH4gBUEGdkH///8Aca0iGiARfnwgEyAUfnwgECAXfnwgFSACQQZ2Qf///wBxrSIbfnwgFiAZfnwgPygACiJCQRh2rSA/MQAOQgiGhCA/MQAPQhCGhEIBiEL///8AgyIcIBF+IBIgGn58IBcgGH58IBMgGX58IBAgFH58IAAoAAoiQUEYdq0gADEADkIIhoQgADEAD0IQhoRCAYhC////AIMiHSAVfnwgFiAbfnwiDEKAgEB9IgpCFYh8IglCgIBAfSIIQhWIfCIvQtOMQ358IEBB4AFqIj4oABciBUEFdkH///8Aca0gPzMAACA/MQACQhCGQoCA/ACDhCIeIBd+IBQgPygAAiICQQV2Qf///wBxrSIffnwgPzUAB0IHiEL///8AgyIgIBt+fCAdIEJBBHZB////AHGtIiF+fCACQRh2rSA/MQAGQgiGhCA/MQAHQhCGhEICiEL///8AgyIiIBl+fCAaIAA1AAdCB4hC////AIMiI358IBwgQUEEdkH///8Aca0iJH58IBggACgAAiICQRh2rSAAMQAGQgiGhCAAMQAHQhCGhEICiEL///8AgyIlfnwgADMAACAAMQACQhCGQoCA/ACDhCImIBN+fCAQIAJBBXZB////AHGtIid+fHwgPjMAFSAUIB5+IBkgH358IB0gIH58ICEgJH58IBsgIn58IBogJX58IBwgI358IBggJ358IBAgJn58fCA+MQAX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ACgCcCELIANBACAAKAJ0azYCfCADQQAgC2s2AnggA0EAIAprNgJ0IANBACAJazYCcCADQQAgCGs2AmwgA0EAIAdrNgJoIANBACAGazYCZCADQQAgBWs2AmAgA0EAIARrNgJcIANBACABazYCWCAAIANBCGogAkGAAXFBB3YQEyADQYABaiQAC/AJAR5/IAEoAighAyABKAIEIQQgASgCLCEFIAEoAgghBiABKAIwIQcgASgCDCEIIAEoAjQhCSABKAIQIQogASgCOCELIAEoAhQhDCABKAI8IQ0gASgCGCEOIAFBQGsiDygCACEQIAEoAhwhESABKAJEIRIgASgCICETIAEoAkghFCABKAIAIRUgACABKAIkIAEoAkxqNgIkIAAgEyAUajYCICAAIBEgEmo2AhwgACAOIBBqNgIYIAAgDCANajYCFCAAIAogC2o2AhAgACAIIAlqNgIMIAAgBiAHajYCCCAAIAQgBWo2AgQgACADIBVqNgIAIAEoAighBSABKAIEIQMgASgCLCEGIAEoAgghByABKAIwIQggASgCDCEJIAEoAjQhCiABKAIQIQsgASgCOCEMIAEoAhQhDSABKAI8IQ4gASgCGCEQIA8oAgAhDyABKAIcIQQgASgCRCERIAEoAiAhEiABKAJIIRMgASgCACEUIAAgASgCTCABKAIkazYCTCAAIBMgEms2AkggACARIARrNgJEIABBQGsiBCAPIBBrNgIAIAAgDiANazYCPCAAIAwgC2s2AjggACAKIAlrNgI0IAAgCCAHazYCMCAAIAYgA2s2AiwgAEEoaiIDIAUgFGs2AgAgAEHQAGogACACQShqEAYgAyADIAIQBiAAQfgAaiACQfgAaiABQfgAahAGIAAgAUHQAGogAkHQAGoQBiAAKAIEIRUgACgCCCEWIAAoAgwhFyAAKAIQIRggACgCFCEZIAAoAhghGiAAKAIcIRsgACgCICEcIAAoAiQhHSADKAIAIQEgACgCUCECIAAoAiwhBSAAKAJUIQYgACgCMCEHIAAoAlghCCAAKAI0IQkgACgCXCEKIAAoAjghCyAAKAJgIQwgACgCPCENIAAoAmQhDiAEKAIAIQ8gACgCaCEQIAAoAkQhESAAKAJsIRIgACgCSCETIAAoAnAhFCAAKAIAIR4gACAAKAJMIh8gACgCdCIgajYCTCAAIBMgFGo2AkggACARIBJqNgJEIAQgDyAQajYCACAAIA0gDmo2AjwgACALIAxqNgI4IAAgCSAKajYCNCAAIAcgCGo2AjAgACAFIAZqNgIsIAMgASACajYCACAAICAgH2s2AiQgACAUIBNrNgIgIAAgEiARazYCHCAAIBAgD2s2AhggACAOIA1rNgIUIAAgDCALazYCECAAIAogCWs2AgwgACAIIAdrNgIIIAAgBiAFazYCBCAAIAIgAWs2AgAgACAAKAKcASIBIB1BAXQiAmo2ApwBIAAgACgCmAEiAyAcQQF0IgRqNgKYASAAIAAoApQBIgUgG0EBdCIGajYClAEgACAAKAKQASIHIBpBAXQiCGo2ApABIAAgACgCjAEiCSAZQQF0IgpqNgKMASAAIAAoAogBIgsgGEEBdCIMajYCiAEgACAAKAKEASINIBdBAXQiDmo2AoQBIAAgACgCgAEiDyAWQQF0IhBqNgKAASAAIAAoAnwiESAVQQF0IhJqNgJ8IAAgACgCeCITIB5BAXQiFGo2AnggACAEIANrNgJwIAAgBiAFazYCbCAAIAggB2s2AmggACAKIAlrNgJkIAAgDCALazYCYCAAIA4gDWs2AlwgACAQIA9rNgJYIAAgEiARazYCVCAAIBQgE2s2AlAgACACIAFrNgJ0C60OARd/IwBBwAJrIgMkACAAQShqIgkgARBWIABCADcCVCAAQQE2AlAgAEIANwJcIABCADcCZCAAQgA3AmwgAEEANgJ0IANB8AFqIgggCRAFIANBwAFqIgYgCEHAChAGQX8hCiADIAMoAvABQQFrIgs2AvABIAMgAygCwAFBAWo2AsABIAMoAvQBIQwgAygC+AEhDSADKAL8ASEOIAMoAoACIQ8gAygChAIhECADKAKIAiERIAMoAowCIRIgAygCkAIhEyADKAKUAiEUIANBkAFqIgcgBhAFIAcgByAGEAYgACAHEAUgACAAIAYQBiAAIAAgCBAGIwBBkAFrIgQkACAEQeAAaiIFIAAQBSAEQTBqIgIgBRAFIAIgAhAFIAIgACACEAYgBSAFIAIQBiAFIAUQBSAFIAIgBRAGIAIgBRAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAUgAiAFEAYgAiAFEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACIAUQBiAEIAIQBSAEIAQQBSAEIAQQBSAEIAQQBSAEIAQQBSAEIAQQBSAEIAQQBSAEIAQQBSAEIAQQBSAEIAQQBSAEIAQQBSAEIAQQBSAEIAQQBSAEIAQQBSAEIAQQBSAEIAQQBSAEIAQQBSAEIAQQBSAEIAQQBSAEIAQQBSACIAQgAhAGIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAUgAiAFEAYgAiAFEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACIAUQBiAEIAIQBUEBIQIDQCAEIAQQBSACQQFqIgJB5ABHDQALIARBMGoiAiAEIAIQBiACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSAEQeAAaiIFIAIgBRAGIAUgBRAFIAUgBRAFIAAg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IgQkACABQgBSBEAgBCADKQAYNwMYIAQgAykAEDcDECAEIAMpAAA3AwAgBCADKQAINwMIIAIpAAAhCiAEQgA3A2ggBCAKNwNgAkAgAULAAFoEQANAIAAgBEHgAGogBBAwIAQgBC0AaEEBaiICOgBoIAQgBC0AaSACQQh2aiICOgBpIAQgBC0AaiACQQh2aiICOgBqIAQgBC0AayACQQh2aiICOgBrIAQgBC0AbCACQQh2aiICOgBsIAQgBC0AbSACQQh2aiICOgBtIAQgBC0AbiACQQh2aiICOgBuIAQgBC0AbyACQQh2ajoAbyAAQUBrIQAgAUJAfCIBQj9WDQALIAFQDQELQQAhAiAEQSBqIARB4ABqIAQQMCABpyIFQQNxIQdBACEDIAVBAWtBA08EQCAFQXxxIQhBACEFA0AgACADaiAEQSBqIgkgA2otAAA6AAAgACADQQFyIgZqIAYgCWotAAA6AAAgACADQQJyIgZqIARBIGogBmotAAA6AAAgACADQQNyIgZqIARBIGogBmotAAA6AAAgA0EEaiEDIAVBBGoiBSAIRw0ACwsgB0UNAANAIAAgA2ogBEEgaiADai0AADoAACADQQFqIQMgAkEBaiICIAdHDQALCyAEQSBqQcAAEAcgBEEgEAcLIARB8ABqJABBAAuGBgEUfyMAQbACayICJAAgACABLQAAOgAAIAAgAS0AAToAASAAIAEtAAI6AAIgACABLQADOgADIAAgAS0ABDoABCAAIAEtAAU6AAUgACABLQAGOgAGIAAgAS0ABzoAByAAIAEtAAg6AAggACABLQAJOgAJIAAgAS0ACjoACiAAIAEtAAs6AAsgACABLQAMOgAMIAAgAS0ADToADSAAIAEtAA46AA4gACABLQAPOgAPIAAgAS0AEDoAECAAIAEtABE6ABEgACABLQASOgASIAAgAS0AEzoAEyAAIAEtABQ6ABQgACABLQAVOgAVIAAgAS0AFjoAFiAAIAEtABc6ABcgACABLQAYOgAYIAAgAS0AGToAGSAAIAEtABo6ABogACABLQAbOgAbIAAgAS0AHDoAHCAAIAEtAB06AB0gACABLQAeOgAeIAEtAB8hASAAIAAtAABB+AFxOgAAIAAgAUE/cUHAAHI6AB8gAkEwaiAAEDEgAigChAEhASACKAJcIQMgAigCiAEhBCACKAJg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IDZzIh9rNgIUIAMgHiA5cyIeIBwgOHMiHGs2AhAgAyAXIDtzIhcgFCA6cyIUazYCDCADIBMgPXMiEyARIDxzIhFrNgIIIAMgECA/cyIQIAwgPnMiDGs2AgQgAyACIA1zIgIgCiBAcyIKazYCACADIAkgK2o2ApQCIAMgFiAoajYCkAIgAyAlICdqNgKMAiADICIgJGo2AogCIAMgHyAhajYChAIgAyAcIB5qNgKAAiADIBEgE2o2AvgBIAMgDCAQajYC9AEgAyACIApqNgLwASADIBQgF2o2AvwBIAMgKiAwajYC5AEgAyAGIClqNgLgASADIBsgJmo2AtwBIAMgGiAjajYC2AEgAyAZICBqNgLUASADIBggHWo2AtABIAMgDyAVajYCzAEgAyAOIBJqNgLIASADIAUgCGo2AsQBIAMgByALajYCwAEgA0HgAGoiGyADQTBqIhogA0HwAWoiGRAGIANBwAFqIhYgFiADEAYgGiADEAUgAyAZEAUgAygCwAEhAiADKAJgIQkgAygCxAEhBiADKAJkIQcgAygCyAEhCiADKAJoIQsgAygCzAEhDSADKAJsIQggAygC0AEhDCADKAJwIQUgAygC1AEhECADKAJ0IQ4gAygC2AEhESADKAJ4IRIgAygC3AEhEyADKAJ8IQ8gAygC4AEhFCADKAKAASEVIAMgAygC5AEiFyADKAKEASIYajYCtAEgAyAUIBVqNgKwASADIA8gE2o2AqwBIAMgESASajYCqAEgAyAOIBBqNgKkASADIAUgDGo2AqABIAMgCCANajYCnAEgAyAKIAtqNgKYASADIAYgB2o2ApQBIAMgAiAJajYCkAEgAyAYIBdrNgLkASADIBUgFGs2AuABIAMgDyATazYC3AEgAyASIBFrNgLYASADIA4gEGs2AtQBIAMgBSAMazYC0AEgAyAIIA1rNgLMASADIAsgCms2AsgBIAMgByAGazYCxAEgAyAJIAJrNgLAASAZIAMgGhAGIAMoAjQhAiADKAIEIQUgAygCOCEJIAMoAgghECADKAJAIQYgAygCECEOIAMoAjwhByADKAIMIREgAygCSCEKIAMoAhghEiADKAJEIQsgAygCFCETIAMoAlAhDSADKAIgIQ8gAygCTCEIIAMoAhwhFCADKAJUIQwgAygCJCEVIAMgAygCACADKAIwIhdrIhg2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AykDCDcACCABIAMpAwA3AAAgA0HAABAHIAAgAUGckwIoAgARAQAhBCADQUBrJAAgBAsGAEHA/wALswICBX8BfiMAQfADayIFJAAgBUEBOgAPAn8gAUHA/wBNBEAgAUHAAE8EQCADrSEKQcAAIQYDQCAGIQcgBUHQAGoiBiAEQcAAECAaIAgEQCAGIAAgCGpBQGpCwAAQEBoLIAVB0ABqIgYgAiAKEBAaIAYgBUEPakIBEBAaIAYgACAIahAfIAUgBS0AD0EBajoADyAHIQggB0FAayIGIAFNDQALCyABQT9xIggEQCAFQdAAaiIBIARBwAAQIBogBwRAIAEgACAHakFAakLAABAQGgsgBUHQAGoiASACIAOtEBAaIAEgBUEPakIBEBAaIAEgBUEQaiIBEB8gACAHaiABIAgQCRogAUHAABAHCyAFQdAAakGgAxAHQQAMAQtBtJkCQRw2AgBBfwshCSAFQfADaiQAIAkLCQAgAEHAABAYCzcBAX8jAEGgA2siBSQAIAUgASACECAaIAUgAyAErRAQGiAFIAAQHyAFQQQQByAFQaADaiQAQQALEAAgACABEB8gAEEEEAdBAAsLACAAIAEgAq0QEAsKACAAIAEgAhAgCysBAn8jAEFAaiIDJAAgACADEBUgASADQsAAIAJBARBFIQQgA0FAayQAIAQLLQECfyMAQUBqIgQkACAAIAQQFSABIAIgBELAACADQQEQRiEFIARBQGskACAFCwgAIAAQG0EAC7sBAgJ/A34jAEHAAWsiAiQAIAJBIBAYIAEgAkIgECEaIAEgAS0AAEH4AXE6AAAgASABLQAfQT9xQcAAcjoAHyACQSBqIgMgARAxIAAgAxAyIAEgAikDGDcAGCABIAIpAxA3ABAgASACKQMINwAIIAEgAikDADcAACAAKQAIIQQgACkAECEFIAApAAAhBiABIAApABg3ADggASAFNwAwIAEgBDcAKCABIAY3ACAgAkEgEAcgAkHAAWokAEEAC7YBAgF/A34jAEGgAWsiAyQAIAEgAkIgECEaIAEgAS0AAEH4AXE6AAAgASABLQAfQT9xQcAAcjoAHyADIAEQMSAAIAMQMiACKQAIIQQgAikAECEFIAIpAAAhBiABIAIpABg3ABggASAFNwAQIAEgBDcACCABIAY3AAAgACkACCEEIAApABAhBSAAKQAA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////////////////////////////////f+3///////////////////////////////////////9/7v///////////////////////////////////////3/t0/VcGmMSWNac96Le+d4UAEGPFQv88AEQhTuMAb3xJP/4JcMBYNw3ALdMPv/DQj0AMkykAeGkTP9MPaP/dT4fAFGRQP92QQ4AonPW/waKLgB85vT/CoqPADQawgC49EwAgY8pAb70E/97qnr/YoFEAHnVkwBWZR7/oWebAIxZQ//v5b4BQwu1AMbwif7uRbz/6nE8/yX/Of9Fsrb+gNCzAHYaff4DB9b/8TJN/1XLxf/Th/r/GTBk/7vVtP4RWGkAU9GeAQVzYgAErjz+qzdu/9m1Ef8UvKoAkpxm/lfWrv9yepsB6SyqAH8I7wHW7OoArwXbADFqPf8GQtD/Ampu/1HqE//Xa8D/Q5fuABMqbP/lVXEBMkSH/xFqCQAyZwH/UAGoASOYHv8QqLkBOFno/2XS/AAp+kcAzKpP/w4u7/9QTe8AvdZL/xGN+QAmUEz/vlV1AFbkqgCc2NABw8+k/5ZCTP+v4RD/jVBiAUzb8gDGonIALtqYAJsr8f6boGj/sgn8/mRu1AAOBacA6e+j/xyXnQFlkgr//p5G/kf55ABYHjIARDqg/78YaAGBQoH/wDJV/wiziv8m+skAc1CgAIPmcQB9WJMAWkTHAP1MngAc/3YAcfr+AEJLLgDm2isA5Xi6AZREKwCIfO4Bu2vF/1Q19v8zdP7/M7ulAAIRrwBCVKAB9zoeACNBNf5F7L8ALYb1AaN73QAgbhT/NBelALrWRwDpsGAA8u82ATlZigBTAFT/iKBkAFyOeP5ofL4AtbE+//opVQCYgioBYPz2AJeXP/7vhT4AIDicAC2nvf+OhbMBg1bTALuzlv76qg7/RHEV/966O/9CB/EBRQZIAFacbP43p1kAbTTb/g2wF//ELGr/75VH/6SMff+frQEAMynnAJE+IQCKb10BuVNFAJBzLgBhlxD/GOQaADHZ4gBxS+r+wZkM/7YwYP8ODRoAgMP5/kXBOwCEJVH+fWo8ANbwqQGk40IA0qNOACU0lwBjTRoA7pzV/9XA0QFJLlQAFEEpATbOTwDJg5L+qm8Y/7EhMv6rJsv/Tvd0ANHdmQCFgLIBOiwZAMkn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qwBNJVX/IXiH/47C4wEf1joA1bt9/+guPP++dCr+l7IT/zM+7f7M7MEAwug8AKwinf+9ELj+ZwNf/43pJP4pGQv/FcOmAHb1LQBD1ZX/nwwS/7uk4wGgGQUADE7DASvF4QAwjin+xJs8/9/HEgGRiJwA/HWp/pHi7gDvF2sAbbW8/+ZwMf5Jqu3/57fj/1DcFADCa38Bf81lAC40xQHSqyT/WANa/ziXjQBgu///Kk7IAP5GRgH0fagAzESKAXzXRgBmQsj+ETTkAHXcj/7L+HsAOBKu/7qXpP8z6NABoOQr//kdGQFEvj8ADQAAAAD/AAAAAPUAAAAAAAD7AAAAAAAA/QAAAADzAAAAAAcAAAAAAAMAAAAA8wAAAAAFAAAAAAAAAAALAAAAAAALAAAAAPMAAAAAAAD9AAAAAAD/AAAAAAMAAAAA9QAAAAAAAAAPAAAAAAD/AAAAAP8AAAAABwAAAAAFAEGMhwILAQEAQbCHAgsBAQBB0IcCC6AB4Ot6fDtBuK4WVuP68Z/EatoJjeucMrH9hmIFFl9JuABfnJW8o1CMJLHQsVWcg+9bBERcxFgcjobYIk7d0J8RV+z///////////////////////////////////////9/7f///////////////////////////////////////3/u////////////////////////////////////////fwBBkIkCC6ECZ+YJaoWuZ7ty8248OvVPpX9SDlGMaAWbq9mDHxnN4FuYL4pCkUQ3cc/7wLWl27XpW8JWOfER8Vmkgj+S1V4cq5iqB9gBW4MSvoUxJMN9DFV0Xb5y/rHegKcG3Jt08ZvBwWmb5IZHvu/GncEPzKEMJG8s6S2qhHRK3KmwXNqI+XZSUT6YbcYxqMgnA7DHf1m/8wvgxkeRp9VRY8oGZykpFIUKtyc4IRsu/G0sTRMNOFNUcwpluwpqdi7JwoGFLHKSoei/oktmGqhwi0vCo1FsxxnoktEkBpnWhTUO9HCgahAWwaQZCGw3Hkx3SCe1vLA0swwcOUqq2E5Pypxb828uaO6Cj3RvY6V4FHjIhAgCx4z6/76Q62xQpPej+b7yeHHGgABBgIwCC8EFCMm882fmCWo7p8qEha5nuyv4lP5y82488TYdXzr1T6XRguatf1IOUR9sPiuMaAWba71B+6vZgx95IX4TGc3gWyKuKNeYL4pCzWXvI5FEN3EvO03sz/vAtbzbiYGl27XpOLVI81vCVjkZ0AW28RHxWZtPGa+kgj+SGIFt2tVeHKtCAgOjmKoH2L5vcEUBW4MSjLLkTr6FMSTitP/Vw30MVW+Je/J0Xb5ysZYWO/6x3oA1Esclpwbcm5Qmac908ZvB0krxnsFpm+TjJU84hke+77XVjIvGncEPZZysd8yhDCR1AitZbyzpLYPkpm6qhHRK1PtBvdypsFy1UxGD2oj5dqvfZu5SUT6YEDK0LW3GMag/IfuYyCcDsOQO777Hf1m/wo+oPfML4MYlpwqTR5Gn1W+CA+BRY8oGcG4OCmcpKRT8L9JGhQq3JybJJlw4IRsu7SrEWvxtLE3fs5WdEw04U95jr4tUcwplqLJ3PLsKanbmru1HLsnCgTs1ghSFLHKSZAPxTKHov6IBMEK8S2YaqJGX+NBwi0vCML5UBqNRbMcYUu/WGeiS0RCpZVUkBpnWKiBxV4U1DvS40bsycKBqEMjQ0rgWwaQZU6tBUQhsNx6Z647fTHdIJ6hIm+G1vLA0Y1rJxbMMHDnLikHjSqrYTnPjY3dPypxbo7iy1vNvLmj8su9d7oKPdGAvF0NvY6V4cqvwoRR4yITsOWQaCALHjCgeYyP6/76Q6b2C3utsUKQVecay96P5vitTcuPyeHHGnGEm6s4+J8oHwsAhx7iG0R7r4M3WfdrqeNFu7n9PffW6bxdyqmfwBqaYyKLFfWMKrg35vgSYPxEbRxwTNQtxG4R9BCP1d9sokyTHQHuryjK8vskVCr6ePEwNEJzEZx1DtkI+y77UxUwqfmX8nCl/Wez61jqrb8tfF1hHSowZRGyAAEHAkgILIVNpZ0VkMjU1MTkgbm8gRWQyNTUxOSBjb2xsaXNpb25zAQBBgJMCCzXQjgEAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQ==")||(d=Y,Y=Q.locateFile?Q.locateFile(d,f):f+d);var P,v={35256:()=>Q.getRandomValue(),35292:()=>{if(void 0===Q.getRandomValue)try{var A="object"==typeof window?window:self,I=void 0!==A.crypto?A.crypto:A.msCrypto,g=function(){var A=new Uint32Array(1);return I.getRandomValues(A),A[0]>>>0};g(),Q.getRandomValue=g}catch(A){try{var C=__nccwpck_require__(6113),B=function(){var A=C.randomBytes(4);return(A[0]<<24|A[1]<<16|A[2]<<8|A[3])>>>0};B(),Q.getRandomValue=B}catch(A){throw"No secure random number generator found"}}}},L=A=>{for(;A.length>0;)A.shift()(Q)},R="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,u=(A,I)=>A?((A,I,g)=>{for(var C=I+g,B=I;A[B]&&!(B>=C);)++B;if(B-I>16&&A.buffer&&R)return R.decode(A.subarray(I,B));for(var Q="";I<B;){var i=A[I++];if(128&i){var E=63&A[I++];if(192!=(224&i)){var o=63&A[I++];if((i=224==(240&i)?(15&i)<<12|E<<6|o:(7&i)<<18|E<<12|o<<6|63&A[I++])<65536)Q+=String.fromCharCode(i);else{var a=i-65536;Q+=String.fromCharCode(55296|a>>10,56320|1023&a)}}else Q+=String.fromCharCode((31&i)<<6|E)}else Q+=String.fromCharCode(i)}return Q})(w,A,I):"",x=[],m=A=>{var I=(A-D.buffer.byteLength+65535)/65536;try{return D.grow(I),H(),1}catch(A){}},l={b:(A,I,g,C)=>{U(`Assertion failed: ${u(A)}, at: `+[I?u(I):"unknown filename",g,C?u(C):"unknown function"])},c:()=>{U("")},a:(A,I,g)=>((A,I,g)=>{var C=((A,I)=>{var g;for(x.length=0;g=w[A++];)I+=105!=g&&I%8?4:0,x.push(105==g?n[I>>2]:F[I>>3]),I+=105==g?4:8;return x})(I,g);return v[A].apply(null,C)})(A,I,g),d:(A,I,g)=>w.copyWithin(A,I,I+g),e:A=>{var I=w.length,g=2147483648;if((A>>>=0)>g)return!1;for(var C,B=1;B<=4;B*=2){var Q=I*(1+.2/B);Q=Math.min(Q,A+100663296);var i=Math.min(g,(C=Math.max(A,Q))+(65536-C%65536)%65536);if(m(i))return!0}return!1}},z=function(){var A,I,g={a:l};function C(A,I){var g=A.exports;return D=(z=g).f,H(),z.tc,function(A){if(p--,Q.monitorRunDependencies&&Q.monitorRunDependencies(p),0==p&&(null!==N&&(clearInterval(N),N=null),J)){var I=J;J=null,I()}}(),g}if(p++,Q.monitorRunDependencies&&Q.monitorRunDependencies(p),Q.instantiateWasm)try{return Q.instantiateWasm(g,C)}catch(A){return t(`Module.instantiateWasm callback failed with error: ${A}`),!1}return A=g,I=function(A){C(A.instance)},function(A){return Promise.resolve().then((()=>function(A){if(A==Y&&r)return new Uint8Array(r);var I=function(A){if(b(A))return function(A){if(void 0!==a&&a){var I=Buffer.from(A,"base64");return new Uint8Array(I.buffer,I.byteOffset,I.length)}try{for(var g=atob(A),C=new Uint8Array(g.length),B=0;B<g.length;++B)C[B]=g.charCodeAt(B);return C}catch(A){throw new Error("Converting base64 string to bytes failed.")}}(A.slice(K.length))}(A);if(I)return I;if(B)return B(A);throw"both async and sync fetching of the wasm failed"}(A)))}(Y).then((I=>WebAssembly.instantiate(I,A))).then((A=>A)).then(I,(A=>{t(`failed to asynchronously prepare wasm: ${A}`),U(A)})),{}}();function q(){function A(){P||(P=!0,Q.calledRun=!0,S||(L(_),Q.onRuntimeInitialized&&Q.onRuntimeInitialized(),function(){if(Q.postRun)for("function"==typeof Q.postRun&&(Q.postRun=[Q.postRun]);Q.postRun.length;)A=Q.postRun.shift(),M.unshift(A);var A;L(M)}()))}p>0||(function(){if(Q.preRun)for("function"==typeof Q.preRun&&(Q.preRun=[Q.preRun]);Q.preRun.length;)A=Q.preRun.shift(),G.unshift(A);var A;L(G)}(),p>0||(Q.setStatus?(Q.setStatus("Running..."),setTimeout((function(){setTimeout((function(){Q.setStatus("")}),1),A()}),1)):A()))}if(Q._crypto_aead_chacha20poly1305_encrypt_detached=(A,I,g,C,B,i,E,o,a,f,c,e)=>(Q._crypto_aead_chacha20poly1305_encrypt_detached=z.g)(A,I,g,C,B,i,E,o,a,f,c,e),Q._crypto_aead_chacha20poly1305_encrypt=(A,I,g,C,B,i,E,o,a,f,c)=>(Q._crypto_aead_chacha20poly1305_encrypt=z.h)(A,I,g,C,B,i,E,o,a,f,c),Q._crypto_aead_chacha20poly1305_ietf_encrypt_detached=(A,I,g,C,B,i,E,o,a,f,c,e)=>(Q._crypto_aead_chacha20poly1305_ietf_encrypt_detached=z.i)(A,I,g,C,B,i,E,o,a,f,c,e),Q._crypto_aead_chacha20poly1305_ietf_encrypt=(A,I,g,C,B,i,E,o,a,f,c)=>(Q._crypto_aead_chacha20poly1305_ietf_encrypt=z.j)(A,I,g,C,B,i,E,o,a,f,c),Q._crypto_aead_chacha20poly1305_decrypt_detached=(A,I,g,C,B,i,E,o,a,f,c)=>(Q._crypto_aead_chacha20poly1305_decrypt_detached=z.k)(A,I,g,C,B,i,E,o,a,f,c),Q._crypto_aead_chacha20poly1305_decrypt=(A,I,g,C,B,i,E,o,a,f,c)=>(Q._crypto_aead_chacha20poly1305_decrypt=z.l)(A,I,g,C,B,i,E,o,a,f,c),Q._crypto_aead_chacha20poly1305_ietf_decrypt_detached=(A,I,g,C,B,i,E,o,a,f,c)=>(Q._crypto_aead_chacha20poly1305_ietf_decrypt_detached=z.m)(A,I,g,C,B,i,E,o,a,f,c),Q._crypto_aead_chacha20poly1305_ietf_decrypt=(A,I,g,C,B,i,E,o,a,f,c)=>(Q._crypto_aead_chacha20poly1305_ietf_decrypt=z.n)(A,I,g,C,B,i,E,o,a,f,c),Q._crypto_aead_chacha20poly1305_ietf_keybytes=()=>(Q._crypto_aead_chacha20poly1305_ietf_keybytes=z.o)(),Q._crypto_aead_chacha20poly1305_ietf_npubbytes=()=>(Q._crypto_aead_chacha20poly1305_ietf_npubbytes=z.p)(),Q._crypto_aead_chacha20poly1305_ietf_nsecbytes=()=>(Q._crypto_aead_chacha20poly1305_ietf_nsecbytes=z.q)(),Q._crypto_aead_chacha20poly1305_ietf_abytes=()=>(Q._crypto_aead_chacha20poly1305_ietf_abytes=z.r)(),Q._crypto_aead_chacha20poly1305_ietf_messagebytes_max=()=>(Q._crypto_aead_chacha20poly1305_ietf_messagebytes_max=z.s)(),Q._crypto_aead_chacha20poly1305_ietf_keygen=A=>(Q._crypto_aead_chacha20poly1305_ietf_keygen=z.t)(A),Q._crypto_aead_chacha20poly1305_keybytes=()=>(Q._crypto_aead_chacha20poly1305_keybytes=z.u)(),Q._crypto_aead_chacha20poly1305_npubbytes=()=>(Q._crypto_aead_chacha20poly1305_npubbytes=z.v)(),Q._crypto_aead_chacha20poly1305_nsecbytes=()=>(Q._crypto_aead_chacha20poly1305_nsecbytes=z.w)(),Q._crypto_aead_chacha20poly1305_abytes=()=>(Q._crypto_aead_chacha20poly1305_abytes=z.x)(),Q._crypto_aead_chacha20poly1305_messagebytes_max=()=>(Q._crypto_aead_chacha20poly1305_messagebytes_max=z.y)(),Q._crypto_aead_chacha20poly1305_keygen=A=>(Q._crypto_aead_chacha20poly1305_keygen=z.z)(A),Q._crypto_aead_xchacha20poly1305_ietf_encrypt_detached=(A,I,g,C,B,i,E,o,a,f,c,e)=>(Q._crypto_aead_xchacha20poly1305_ietf_encrypt_detached=z.A)(A,I,g,C,B,i,E,o,a,f,c,e),Q._crypto_aead_xchacha20poly1305_ietf_encrypt=(A,I,g,C,B,i,E,o,a,f,c)=>(Q._crypto_aead_xchacha20poly1305_ietf_encrypt=z.B)(A,I,g,C,B,i,E,o,a,f,c),Q._crypto_aead_xchacha20poly1305_ietf_decrypt_detached=(A,I,g,C,B,i,E,o,a,f,c)=>(Q._crypto_aead_xchacha20poly1305_ietf_decrypt_detached=z.C)(A,I,g,C,B,i,E,o,a,f,c),Q._crypto_aead_xchacha20poly1305_ietf_decrypt=(A,I,g,C,B,i,E,o,a,f,c)=>(Q._crypto_aead_xchacha20poly1305_ietf_decrypt=z.D)(A,I,g,C,B,i,E,o,a,f,c),Q._crypto_aead_xchacha20poly1305_ietf_keybytes=()=>(Q._crypto_aead_xchacha20poly1305_ietf_keybytes=z.E)(),Q._crypto_aead_xchacha20poly1305_ietf_npubbytes=()=>(Q._crypto_aead_xchacha20poly1305_ietf_npubbytes=z.F)(),Q._crypto_aead_xchacha20poly1305_ietf_nsecbytes=()=>(Q._crypto_aead_xchacha20poly1305_ietf_nsecbytes=z.G)(),Q._crypto_aead_xchacha20poly1305_ietf_abytes=()=>(Q._crypto_aead_xchacha20poly1305_ietf_abytes=z.H)(),Q._crypto_aead_xchacha20poly1305_ietf_messagebytes_max=()=>(Q._crypto_aead_xchacha20poly1305_ietf_messagebytes_max=z.I)(),Q._crypto_aead_xchacha20poly1305_ietf_keygen=A=>(Q._crypto_aead_xchacha20poly1305_ietf_keygen=z.J)(A),Q._crypto_auth_bytes=()=>(Q._crypto_auth_bytes=z.K)(),Q._crypto_auth_keybytes=()=>(Q._crypto_auth_keybytes=z.L)(),Q._crypto_auth=(A,I,g,C,B)=>(Q._crypto_auth=z.M)(A,I,g,C,B),Q._crypto_auth_verify=(A,I,g,C,B)=>(Q._crypto_auth_verify=z.N)(A,I,g,C,B),Q._crypto_auth_keygen=A=>(Q._crypto_auth_keygen=z.O)(A),Q._crypto_box_seedbytes=()=>(Q._crypto_box_seedbytes=z.P)(),Q._crypto_box_publickeybytes=()=>(Q._crypto_box_publickeybytes=z.Q)(),Q._crypto_box_secretkeybytes=()=>(Q._crypto_box_secretkeybytes=z.R)(),Q._crypto_box_beforenmbytes=()=>(Q._crypto_box_beforenmbytes=z.S)(),Q._crypto_box_noncebytes=()=>(Q._crypto_box_noncebytes=z.T)(),Q._crypto_box_macbytes=()=>(Q._crypto_box_macbytes=z.U)(),Q._crypto_box_messagebytes_max=()=>(Q._crypto_box_messagebytes_max=z.V)(),Q._crypto_box_seed_keypair=(A,I,g)=>(Q._crypto_box_seed_keypair=z.W)(A,I,g),Q._crypto_box_keypair=(A,I)=>(Q._crypto_box_keypair=z.X)(A,I),Q._crypto_box_beforenm=(A,I,g)=>(Q._crypto_box_beforenm=z.Y)(A,I,g),Q._crypto_box_detached_afternm=(A,I,g,C,B,i,E)=>(Q._crypto_box_detached_afternm=z.Z)(A,I,g,C,B,i,E),Q._crypto_box_detached=(A,I,g,C,B,i,E,o)=>(Q._crypto_box_detached=z._)(A,I,g,C,B,i,E,o),Q._crypto_box_easy_afternm=(A,I,g,C,B,i)=>(Q._crypto_box_easy_afternm=z.$)(A,I,g,C,B,i),Q._crypto_box_easy=(A,I,g,C,B,i,E)=>(Q._crypto_box_easy=z.aa)(A,I,g,C,B,i,E),Q._crypto_box_open_detached_afternm=(A,I,g,C,B,i,E)=>(Q._crypto_box_open_detached_afternm=z.ba)(A,I,g,C,B,i,E),Q._crypto_box_open_detached=(A,I,g,C,B,i,E,o)=>(Q._crypto_box_open_detached=z.ca)(A,I,g,C,B,i,E,o),Q._crypto_box_open_easy_afternm=(A,I,g,C,B,i)=>(Q._crypto_box_open_easy_afternm=z.da)(A,I,g,C,B,i),Q._crypto_box_open_easy=(A,I,g,C,B,i,E)=>(Q._crypto_box_open_easy=z.ea)(A,I,g,C,B,i,E),Q._crypto_box_seal=(A,I,g,C,B)=>(Q._crypto_box_seal=z.fa)(A,I,g,C,B),Q._crypto_box_seal_open=(A,I,g,C,B,i)=>(Q._crypto_box_seal_open=z.ga)(A,I,g,C,B,i),Q._crypto_box_sealbytes=()=>(Q._crypto_box_sealbytes=z.ha)(),Q._crypto_generichash_bytes_min=()=>(Q._crypto_generichash_bytes_min=z.ia)(),Q._crypto_generichash_bytes_max=()=>(Q._crypto_generichash_bytes_max=z.ja)(),Q._crypto_generichash_bytes=()=>(Q._crypto_generichash_bytes=z.ka)(),Q._crypto_generichash_keybytes_min=()=>(Q._crypto_generichash_keybytes_min=z.la)(),Q._crypto_generichash_keybytes_max=()=>(Q._crypto_generichash_keybytes_max=z.ma)(),Q._crypto_generichash_keybytes=()=>(Q._crypto_generichash_keybytes=z.na)(),Q._crypto_generichash_statebytes=()=>(Q._crypto_generichash_statebytes=z.oa)(),Q._crypto_generichash=(A,I,g,C,B,i,E)=>(Q._crypto_generichash=z.pa)(A,I,g,C,B,i,E),Q._crypto_generichash_init=(A,I,g,C)=>(Q._crypto_generichash_init=z.qa)(A,I,g,C),Q._crypto_generichash_update=(A,I,g,C)=>(Q._crypto_generichash_update=z.ra)(A,I,g,C),Q._crypto_generichash_final=(A,I,g)=>(Q._crypto_generichash_final=z.sa)(A,I,g),Q._crypto_generichash_keygen=A=>(Q._crypto_generichash_keygen=z.ta)(A),Q._crypto_hash_bytes=()=>(Q._crypto_hash_bytes=z.ua)(),Q._crypto_hash=(A,I,g,C)=>(Q._crypto_hash=z.va)(A,I,g,C),Q._crypto_kdf_bytes_min=()=>(Q._crypto_kdf_bytes_min=z.wa)(),Q._crypto_kdf_bytes_max=()=>(Q._crypto_kdf_bytes_max=z.xa)(),Q._crypto_kdf_contextbytes=()=>(Q._crypto_kdf_contextbytes=z.ya)(),Q._crypto_kdf_keybytes=()=>(Q._crypto_kdf_keybytes=z.za)(),Q._crypto_kdf_derive_from_key=(A,I,g,C,B,i)=>(Q._crypto_kdf_derive_from_key=z.Aa)(A,I,g,C,B,i),Q._crypto_kdf_keygen=A=>(Q._crypto_kdf_keygen=z.Ba)(A),Q._crypto_kdf_hkdf_sha256_extract_init=(A,I,g)=>(Q._crypto_kdf_hkdf_sha256_extract_init=z.Ca)(A,I,g),Q._crypto_kdf_hkdf_sha256_extract_update=(A,I,g)=>(Q._crypto_kdf_hkdf_sha256_extract_update=z.Da)(A,I,g),Q._crypto_kdf_hkdf_sha256_extract_final=(A,I)=>(Q._crypto_kdf_hkdf_sha256_extract_final=z.Ea)(A,I),Q._crypto_kdf_hkdf_sha256_extract=(A,I,g,C,B)=>(Q._crypto_kdf_hkdf_sha256_extract=z.Fa)(A,I,g,C,B),Q._crypto_kdf_hkdf_sha256_keygen=A=>(Q._crypto_kdf_hkdf_sha256_keygen=z.Ga)(A),Q._crypto_kdf_hkdf_sha256_expand=(A,I,g,C,B)=>(Q._crypto_kdf_hkdf_sha256_expand=z.Ha)(A,I,g,C,B),Q._crypto_kdf_hkdf_sha256_keybytes=()=>(Q._crypto_kdf_hkdf_sha256_keybytes=z.Ia)(),Q._crypto_kdf_hkdf_sha256_bytes_min=()=>(Q._crypto_kdf_hkdf_sha256_bytes_min=z.Ja)(),Q._crypto_kdf_hkdf_sha256_bytes_max=()=>(Q._crypto_kdf_hkdf_sha256_bytes_max=z.Ka)(),Q._crypto_kdf_hkdf_sha256_statebytes=()=>(Q._crypto_kdf_hkdf_sha256_statebytes=z.La)(),Q._crypto_kdf_hkdf_sha512_extract_init=(A,I,g)=>(Q._crypto_kdf_hkdf_sha512_extract_init=z.Ma)(A,I,g),Q._crypto_kdf_hkdf_sha512_extract_update=(A,I,g)=>(Q._crypto_kdf_hkdf_sha512_extract_update=z.Na)(A,I,g),Q._crypto_kdf_hkdf_sha512_extract_final=(A,I)=>(Q._crypto_kdf_hkdf_sha512_extract_final=z.Oa)(A,I),Q._crypto_kdf_hkdf_sha512_extract=(A,I,g,C,B)=>(Q._crypto_kdf_hkdf_sha512_extract=z.Pa)(A,I,g,C,B),Q._crypto_kdf_hkdf_sha512_keygen=A=>(Q._crypto_kdf_hkdf_sha512_keygen=z.Qa)(A),Q._crypto_kdf_hkdf_sha512_expand=(A,I,g,C,B)=>(Q._crypto_kdf_hkdf_sha512_expand=z.Ra)(A,I,g,C,B),Q._crypto_kdf_hkdf_sha512_keybytes=()=>(Q._crypto_kdf_hkdf_sha512_keybytes=z.Sa)(),Q._crypto_kdf_hkdf_sha512_bytes_min=()=>(Q._crypto_kdf_hkdf_sha512_bytes_min=z.Ta)(),Q._crypto_kdf_hkdf_sha512_bytes_max=()=>(Q._crypto_kdf_hkdf_sha512_bytes_max=z.Ua)(),Q._crypto_kx_seed_keypair=(A,I,g)=>(Q._crypto_kx_seed_keypair=z.Va)(A,I,g),Q._crypto_kx_keypair=(A,I)=>(Q._crypto_kx_keypair=z.Wa)(A,I),Q._crypto_kx_client_session_keys=(A,I,g,C,B)=>(Q._crypto_kx_client_session_keys=z.Xa)(A,I,g,C,B),Q._crypto_kx_server_session_keys=(A,I,g,C,B)=>(Q._crypto_kx_server_session_keys=z.Ya)(A,I,g,C,B),Q._crypto_kx_publickeybytes=()=>(Q._crypto_kx_publickeybytes=z.Za)(),Q._crypto_kx_secretkeybytes=()=>(Q._crypto_kx_secretkeybytes=z._a)(),Q._crypto_kx_seedbytes=()=>(Q._crypto_kx_seedbytes=z.$a)(),Q._crypto_kx_sessionkeybytes=()=>(Q._crypto_kx_sessionkeybytes=z.ab)(),Q._crypto_scalarmult_base=(A,I)=>(Q._crypto_scalarmult_base=z.bb)(A,I),Q._crypto_scalarmult=(A,I,g)=>(Q._crypto_scalarmult=z.cb)(A,I,g),Q._crypto_scalarmult_bytes=()=>(Q._crypto_scalarmult_bytes=z.db)(),Q._crypto_scalarmult_scalarbytes=()=>(Q._crypto_scalarmult_scalarbytes=z.eb)(),Q._crypto_secretbox_keybytes=()=>(Q._crypto_secretbox_keybytes=z.fb)(),Q._crypto_secretbox_noncebytes=()=>(Q._crypto_secretbox_noncebytes=z.gb)(),Q._crypto_secretbox_macbytes=()=>(Q._crypto_secretbox_macbytes=z.hb)(),Q._crypto_secretbox_messagebytes_max=()=>(Q._crypto_secretbox_messagebytes_max=z.ib)(),Q._crypto_secretbox_keygen=A=>(Q._crypto_secretbox_keygen=z.jb)(A),Q._crypto_secretbox_detached=(A,I,g,C,B,i,E)=>(Q._crypto_secretbox_detached=z.kb)(A,I,g,C,B,i,E),Q._crypto_secretbox_easy=(A,I,g,C,B,i)=>(Q._crypto_secretbox_easy=z.lb)(A,I,g,C,B,i),Q._crypto_secretbox_open_detached=(A,I,g,C,B,i,E)=>(Q._crypto_secretbox_open_detached=z.mb)(A,I,g,C,B,i,E),Q._crypto_secretbox_open_easy=(A,I,g,C,B,i)=>(Q._crypto_secretbox_open_easy=z.nb)(A,I,g,C,B,i),Q._crypto_secretstream_xchacha20poly1305_keygen=A=>(Q._crypto_secretstream_xchacha20poly1305_keygen=z.ob)(A),Q._crypto_secretstream_xchacha20poly1305_init_push=(A,I,g)=>(Q._crypto_secretstream_xchacha20poly1305_init_push=z.pb)(A,I,g),Q._crypto_secretstream_xchacha20poly1305_init_pull=(A,I,g)=>(Q._crypto_secretstream_xchacha20poly1305_init_pull=z.qb)(A,I,g),Q._crypto_secretstream_xchacha20poly1305_rekey=A=>(Q._crypto_secretstream_xchacha20poly1305_rekey=z.rb)(A),Q._crypto_secretstream_xchacha20poly1305_push=(A,I,g,C,B,i,E,o,a,f)=>(Q._crypto_secretstream_xchacha20poly1305_push=z.sb)(A,I,g,C,B,i,E,o,a,f),Q._crypto_secretstream_xchacha20poly1305_pull=(A,I,g,C,B,i,E,o,a,f)=>(Q._crypto_secretstream_xchacha20poly1305_pull=z.tb)(A,I,g,C,B,i,E,o,a,f),Q._crypto_secretstream_xchacha20poly1305_statebytes=()=>(Q._crypto_secretstream_xchacha20poly1305_statebytes=z.ub)(),Q._crypto_secretstream_xchacha20poly1305_abytes=()=>(Q._crypto_secretstream_xchacha20poly1305_abytes=z.vb)(),Q._crypto_secretstream_xchacha20poly1305_headerbytes=()=>(Q._crypto_secretstream_xchacha20poly1305_headerbytes=z.wb)(),Q._crypto_secretstream_xchacha20poly1305_keybytes=()=>(Q._crypto_secretstream_xchacha20poly1305_keybytes=z.xb)(),Q._crypto_secretstream_xchacha20poly1305_messagebytes_max=()=>(Q._crypto_secretstream_xchacha20poly1305_messagebytes_max=z.yb)(),Q._crypto_secretstream_xchacha20poly1305_tag_message=()=>(Q._crypto_secretstream_xchacha20poly1305_tag_message=z.zb)(),Q._crypto_secretstream_xchacha20poly1305_tag_push=()=>(Q._crypto_secretstream_xchacha20poly1305_tag_push=z.Ab)(),Q._crypto_secretstream_xchacha20poly1305_tag_rekey=()=>(Q._crypto_secretstream_xchacha20poly1305_tag_rekey=z.Bb)(),Q._crypto_secretstream_xchacha20poly1305_tag_final=()=>(Q._crypto_secretstream_xchacha20poly1305_tag_final=z.Cb)(),Q._crypto_shorthash_bytes=()=>(Q._crypto_shorthash_bytes=z.Db)(),Q._crypto_shorthash_keybytes=()=>(Q._crypto_shorthash_keybytes=z.Eb)(),Q._crypto_shorthash=(A,I,g,C,B)=>(Q._crypto_shorthash=z.Fb)(A,I,g,C,B),Q._crypto_shorthash_keygen=A=>(Q._crypto_shorthash_keygen=z.Gb)(A),Q._crypto_sign_statebytes=()=>(Q._crypto_sign_statebytes=z.Hb)(),Q._crypto_sign_bytes=()=>(Q._crypto_sign_bytes=z.Ib)(),Q._crypto_sign_seedbytes=()=>(Q._crypto_sign_seedbytes=z.Jb)(),Q._crypto_sign_publickeybytes=()=>(Q._crypto_sign_publickeybytes=z.Kb)(),Q._crypto_sign_secretkeybytes=()=>(Q._crypto_sign_secretkeybytes=z.Lb)(),Q._crypto_sign_messagebytes_max=()=>(Q._crypto_sign_messagebytes_max=z.Mb)(),Q._crypto_sign_seed_keypair=(A,I,g)=>(Q._crypto_sign_seed_keypair=z.Nb)(A,I,g),Q._crypto_sign_keypair=(A,I)=>(Q._crypto_sign_keypair=z.Ob)(A,I),Q._crypto_sign=(A,I,g,C,B,i)=>(Q._crypto_sign=z.Pb)(A,I,g,C,B,i),Q._crypto_sign_open=(A,I,g,C,B,i)=>(Q._crypto_sign_open=z.Qb)(A,I,g,C,B,i),Q._crypto_sign_detached=(A,I,g,C,B,i)=>(Q._crypto_sign_detached=z.Rb)(A,I,g,C,B,i),Q._crypto_sign_verify_detached=(A,I,g,C,B)=>(Q._crypto_sign_verify_detached=z.Sb)(A,I,g,C,B),Q._crypto_sign_init=A=>(Q._crypto_sign_init=z.Tb)(A),Q._crypto_sign_update=(A,I,g,C)=>(Q._crypto_sign_update=z.Ub)(A,I,g,C),Q._crypto_sign_final_create=(A,I,g,C)=>(Q._crypto_sign_final_create=z.Vb)(A,I,g,C),Q._crypto_sign_final_verify=(A,I,g)=>(Q._crypto_sign_final_verify=z.Wb)(A,I,g),Q._crypto_sign_ed25519_pk_to_curve25519=(A,I)=>(Q._crypto_sign_ed25519_pk_to_curve25519=z.Xb)(A,I),Q._crypto_sign_ed25519_sk_to_curve25519=(A,I)=>(Q._crypto_sign_ed25519_sk_to_curve25519=z.Yb)(A,I),Q._randombytes_random=()=>(Q._randombytes_random=z.Zb)(),Q._randombytes_stir=()=>(Q._randombytes_stir=z._b)(),Q._randombytes_uniform=A=>(Q._randombytes_uniform=z.$b)(A),Q._randombytes_buf=(A,I)=>(Q._randombytes_buf=z.ac)(A,I),Q._randombytes_buf_deterministic=(A,I,g)=>(Q._randombytes_buf_deterministic=z.bc)(A,I,g),Q._randombytes_seedbytes=()=>(Q._randombytes_seedbytes=z.cc)(),Q._randombytes_close=()=>(Q._randombytes_close=z.dc)(),Q._randombytes=(A,I,g)=>(Q._randombytes=z.ec)(A,I,g),Q._sodium_bin2hex=(A,I,g,C)=>(Q._sodium_bin2hex=z.fc)(A,I,g,C),Q._sodium_hex2bin=(A,I,g,C,B,i,E)=>(Q._sodium_hex2bin=z.gc)(A,I,g,C,B,i,E),Q._sodium_base64_encoded_len=(A,I)=>(Q._sodium_base64_encoded_len=z.hc)(A,I),Q._sodium_bin2base64=(A,I,g,C,B)=>(Q._sodium_bin2base64=z.ic)(A,I,g,C,B),Q._sodium_base642bin=(A,I,g,C,B,i,E,o)=>(Q._sodium_base642bin=z.jc)(A,I,g,C,B,i,E,o),Q._sodium_init=()=>(Q._sodium_init=z.kc)(),Q._sodium_pad=(A,I,g,C,B)=>(Q._sodium_pad=z.lc)(A,I,g,C,B),Q._sodium_unpad=(A,I,g,C)=>(Q._sodium_unpad=z.mc)(A,I,g,C),Q._sodium_version_string=()=>(Q._sodium_version_string=z.nc)(),Q._sodium_library_version_major=()=>(Q._sodium_library_version_major=z.oc)(),Q._sodium_library_version_minor=()=>(Q._sodium_library_version_minor=z.pc)(),Q._sodium_library_minimal=()=>(Q._sodium_library_minimal=z.qc)(),Q._malloc=A=>(Q._malloc=z.rc)(A),Q._free=A=>(Q._free=z.sc)(A),Q.setValue=function(A,I,g="i8"){switch(g.endsWith("*")&&(g="*"),g){case"i1":case"i8":y[A>>0]=I;break;case"i16":h[A>>1]=I;break;case"i32":n[A>>2]=I;break;case"i64":U("to do setValue(i64) use WASM_BIGINT");case"float":k[A>>2]=I;break;case"double":F[A>>3]=I;break;case"*":s[A>>2]=I;break;default:U(`invalid type for setValue: ${g}`)}},Q.getValue=function(A,I="i8"){switch(I.endsWith("*")&&(I="*"),I){case"i1":case"i8":return y[A>>0];case"i16":return h[A>>1];case"i32":return n[A>>2];case"i64":U("to do getValue(i64) use WASM_BIGINT");case"float":return k[A>>2];case"double":return F[A>>3];case"*":return s[A>>2];default:U(`invalid type for getValue: ${I}`)}},Q.UTF8ToString=u,J=function A(){P||q(),P||(J=A)},Q.preInit)for("function"==typeof Q.preInit&&(Q.preInit=[Q.preInit]);Q.preInit.length>0;)Q.preInit.pop()();q()})).catch((function(){return C.useBackupModule()})),I}"function"==typeof define&&define.amd?define(["exports"],I): true&&"string"!=typeof exports.nodeName?I(exports):A.libsodium=I(A.libsodium_mod||(A.commonJsStrict={}))}(this);


/***/ }),

/***/ 2219:
/***/ (function(module, exports, __nccwpck_require__) {

/* module decorator */ module = __nccwpck_require__.nmd(module);
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.21';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
      FUNC_ERROR_TEXT = 'Expected a function',
      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295,
      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]',
      weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);

  /** Used to match leading whitespace. */
  var reTrimStart = /^\s+/;

  /** Used to match a single whitespace character. */
  var reWhitespace = /\s/;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /**
   * Used to validate the `validate` option in `_.template` variable.
   *
   * Forbids characters which could potentially change the meaning of the function argument definition:
   * - "()," (modification of function parameters)
   * - "=" (default value)
   * - "[]{}" (destructuring of function parameters)
   * - "/" (beginning of a comment)
   * - whitespace
   */
  var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat,
      freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports =  true && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection) {
      if (predicate(value, key, collection)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  /**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */
  function baseTrim(string) {
    return string
      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
      : string;
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedEndIndex(string) {
    var index = string.length;

    while (index-- && reWhitespace.test(string.charAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  var runInContext = (function runInContext(context) {
    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

    /** Built-in constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = context['__core-js_shared__'];

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /** Mocked built-ins. */
    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse;

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack);
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            }
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }

      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
          return object;
        }

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      var low = 0,
          high = array == null ? 0 : array.length;
      if (high === 0) {
        return 0;
      }

      value = iteratee(value);
      var valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
    var clearTimeout = ctxClearTimeout || function(id) {
      return root.clearTimeout(id);
    };

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = getIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG,
          isBind = bitmask & WRAP_BIND_FLAG,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
          isFlip = bitmask & WRAP_FLIP_FLAG,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision && nativeIsFinite(number)) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set(values);
    };

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Check that cyclic values are equal.
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      // Check that cyclic values are equal.
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }

    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return new Ctor;

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return new Ctor;

        case symbolTag:
          return cloneSymbol(object);
      }
    }

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      if (key === 'constructor' && typeof object[key] === 'function') {
        return;
      }

      if (key == '__proto__') {
        return;
      }

      return object[key];
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    var setTimeout = ctxSetTimeout || function(func, wait) {
      return root.setTimeout(func, wait);
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index);
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax(length + index, 0)
          : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, getIteratee(iteratee, 2))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, getIteratee(iteratee, 2))
        : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(getIteratee(predicate, 3)));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = ctxNow || function() {
      return root.Date.now();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(getIteratee()))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start == null ? 0 : nativeMax(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value),
          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

      return func(value);
    }

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
    }

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      result[value] = key;
    }, constant(identity));

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(getIteratee(predicate)));
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = getIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor(mid), chars) +
        string +
        createPadding(nativeCeil(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      // The sourceURL gets injected into the source that's eval-ed, so be careful
      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
      // and escape the comment, thus injecting code that gets evaled.
      var sourceURL = '//# sourceURL=' +
        (hasOwnProperty.call(options, 'sourceURL')
          ? (options.sourceURL + '').replace(/\s/g, ' ')
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Throw an error if a forbidden character was found in `variable`, to prevent
      // potential command injection attacks.
      else if (reForbiddenIdentifierChars.test(variable)) {
        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
      }

      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return baseTrim(string);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.slice(0, trimmedEndIndex(string) + 1);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
      });
      return object;
    });

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = getIteratee();

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      if (options == null &&
          !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     *
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
     */
    var overSome = createOver(arraySome);

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH,
          length = nativeMin(n, MAX_ARRAY_LENGTH);

      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
        : undefined;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee, 2));
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
        : undefined;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, getIteratee(iteratee, 2))
        : 0;
    }

    /*------------------------------------------------------------------------*/

    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.conformsTo = conformsTo;
    lodash.deburr = deburr;
    lodash.defaultTo = defaultTo;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.stubArray = stubArray;
    lodash.stubFalse = stubFalse;
    lodash.stubObject = stubObject;
    lodash.stubString = stubString;
    lodash.stubTrue = stubTrue;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;

    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(getIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name + '';
        if (!hasOwnProperty.call(realNames, key)) {
          realNames[key] = [];
        }
        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = wrapperToIterator;
    }
    return lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else if (freeModule) {
    // Export for Node.js.
    (freeModule.exports = _)._ = _;
    // Export for CommonJS support.
    freeExports._ = _;
  }
  else {
    // Export to the global object.
    root._ = _;
  }
}.call(this));


/***/ }),

/***/ 4795:
/***/ ((module) => {

module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};


/***/ }),

/***/ 3756:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};


/***/ }),

/***/ 5150:
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ 5406:
/***/ (function(module) {

/*! bignumber.js v5.0.0 https://github.com/MikeMcl/bignumber.js/LICENCE */

;(function (globalObj) {
    'use strict';

    /*
      bignumber.js v5.0.0
      A JavaScript library for arbitrary-precision arithmetic.
      https://github.com/MikeMcl/bignumber.js
      Copyright (c) 2017 Michael Mclaughlin <M8ch88l@gmail.com>
      MIT Expat Licence
    */


    var BigNumber,
        isNumeric = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
        mathceil = Math.ceil,
        mathfloor = Math.floor,
        notBool = ' not a boolean or binary digit',
        roundingMode = 'rounding mode',
        tooManyDigits = 'number type has more than 15 significant digits',
        ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_',
        BASE = 1e14,
        LOG_BASE = 14,
        MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
        // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
        POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
        SQRT_BASE = 1e7,

        /*
         * The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
         * the arguments to toExponential, toFixed, toFormat, and toPrecision, beyond which an
         * exception is thrown (if ERRORS is true).
         */
        MAX = 1E9;                                   // 0 to MAX_INT32


    /*
     * Create and return a BigNumber constructor.
     */
    function constructorFactory(config) {
        var div, parseNumeric,

            // id tracks the caller function, so its name can be included in error messages.
            id = 0,
            P = BigNumber.prototype,
            ONE = new BigNumber(1),


            /********************************* EDITABLE DEFAULTS **********************************/


            /*
             * The default values below must be integers within the inclusive ranges stated.
             * The values can also be changed at run-time using BigNumber.config.
             */

            // The maximum number of decimal places for operations involving division.
            DECIMAL_PLACES = 20,                     // 0 to MAX

            /*
             * The rounding mode used when rounding to the above decimal places, and when using
             * toExponential, toFixed, toFormat and toPrecision, and round (default value).
             * UP         0 Away from zero.
             * DOWN       1 Towards zero.
             * CEIL       2 Towards +Infinity.
             * FLOOR      3 Towards -Infinity.
             * HALF_UP    4 Towards nearest neighbour. If equidistant, up.
             * HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
             * HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
             * HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
             * HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
             */
            ROUNDING_MODE = 4,                       // 0 to 8

            // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

            // The exponent value at and beneath which toString returns exponential notation.
            // Number type: -7
            TO_EXP_NEG = -7,                         // 0 to -MAX

            // The exponent value at and above which toString returns exponential notation.
            // Number type: 21
            TO_EXP_POS = 21,                         // 0 to MAX

            // RANGE : [MIN_EXP, MAX_EXP]

            // The minimum exponent value, beneath which underflow to zero occurs.
            // Number type: -324  (5e-324)
            MIN_EXP = -1e7,                          // -1 to -MAX

            // The maximum exponent value, above which overflow to Infinity occurs.
            // Number type:  308  (1.7976931348623157e+308)
            // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
            MAX_EXP = 1e7,                           // 1 to MAX

            // Whether BigNumber Errors are ever thrown.
            ERRORS = true,                           // true or false

            // Change to intValidatorNoErrors if ERRORS is false.
            isValidInt = intValidatorWithErrors,     // intValidatorWithErrors/intValidatorNoErrors

            // Whether to use cryptographically-secure random number generation, if available.
            CRYPTO = false,                          // true or false

            /*
             * The modulo mode used when calculating the modulus: a mod n.
             * The quotient (q = a / n) is calculated according to the corresponding rounding mode.
             * The remainder (r) is calculated as: r = a - n * q.
             *
             * UP        0 The remainder is positive if the dividend is negative, else is negative.
             * DOWN      1 The remainder has the same sign as the dividend.
             *             This modulo mode is commonly known as 'truncated division' and is
             *             equivalent to (a % n) in JavaScript.
             * FLOOR     3 The remainder has the same sign as the divisor (Python %).
             * HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
             * EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
             *             The remainder is always positive.
             *
             * The truncated division, floored division, Euclidian division and IEEE 754 remainder
             * modes are commonly used for the modulus operation.
             * Although the other rounding modes can also be used, they may not give useful results.
             */
            MODULO_MODE = 1,                         // 0 to 9

            // The maximum number of significant digits of the result of the toPower operation.
            // If POW_PRECISION is 0, there will be unlimited significant digits.
            POW_PRECISION = 0,                       // 0 to MAX

            // The format specification used by the BigNumber.prototype.toFormat method.
            FORMAT = {
                decimalSeparator: '.',
                groupSeparator: ',',
                groupSize: 3,
                secondaryGroupSize: 0,
                fractionGroupSeparator: '\xA0',      // non-breaking space
                fractionGroupSize: 0
            };


        /******************************************************************************************/


        // CONSTRUCTOR


        /*
         * The BigNumber constructor and exported function.
         * Create and return a new instance of a BigNumber object.
         *
         * n {number|string|BigNumber} A numeric value.
         * [b] {number} The base of n. Integer, 2 to 64 inclusive.
         */
        function BigNumber( n, b ) {
            var c, e, i, num, len, str,
                x = this;

            // Enable constructor usage without new.
            if ( !( x instanceof BigNumber ) ) {

                // 'BigNumber() constructor call without new: {n}'
                // See GitHub issue: #81.
                //if (ERRORS) raise( 26, 'constructor call without new', n );
                return new BigNumber( n, b );
            }

            // 'new BigNumber() base not an integer: {b}'
            // 'new BigNumber() base out of range: {b}'
            if ( b == null || !isValidInt( b, 2, 64, id, 'base' ) ) {

                // Duplicate.
                if ( n instanceof BigNumber ) {
                    x.s = n.s;
                    x.e = n.e;
                    x.c = ( n = n.c ) ? n.slice() : n;
                    id = 0;
                    return;
                }

                if ( ( num = typeof n == 'number' ) && n * 0 == 0 ) {
                    x.s = 1 / n < 0 ? ( n = -n, -1 ) : 1;

                    // Fast path for integers.
                    if ( n === ~~n ) {
                        for ( e = 0, i = n; i >= 10; i /= 10, e++ );
                        x.e = e;
                        x.c = [n];
                        id = 0;
                        return;
                    }

                    str = n + '';
                } else {
                    if ( !isNumeric.test( str = n + '' ) ) return parseNumeric( x, str, num );
                    x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
                }
            } else {
                b = b | 0;
                str = n + '';

                // Ensure return value is rounded to DECIMAL_PLACES as with other bases.
                // Allow exponential notation to be used with base 10 argument.
                if ( b == 10 ) {
                    x = new BigNumber( n instanceof BigNumber ? n : str );
                    return round( x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE );
                }

                // Avoid potential interpretation of Infinity and NaN as base 44+ values.
                // Any number in exponential form will fail due to the [Ee][+-].
                if ( ( num = typeof n == 'number' ) && n * 0 != 0 ||
                  !( new RegExp( '^-?' + ( c = '[' + ALPHABET.slice( 0, b ) + ']+' ) +
                    '(?:\\.' + c + ')?$',b < 37 ? 'i' : '' ) ).test(str) ) {
                    return parseNumeric( x, str, num, b );
                }

                if (num) {
                    x.s = 1 / n < 0 ? ( str = str.slice(1), -1 ) : 1;

                    if ( ERRORS && str.replace( /^0\.0*|\./, '' ).length > 15 ) {

                        // 'new BigNumber() number type has more than 15 significant digits: {n}'
                        raise( id, tooManyDigits, n );
                    }

                    // Prevent later check for length on converted number.
                    num = false;
                } else {
                    x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
                }

                str = convertBase( str, 10, b, x.s );
            }

            // Decimal point?
            if ( ( e = str.indexOf('.') ) > -1 ) str = str.replace( '.', '' );

            // Exponential form?
            if ( ( i = str.search( /e/i ) ) > 0 ) {

                // Determine exponent.
                if ( e < 0 ) e = i;
                e += +str.slice( i + 1 );
                str = str.substring( 0, i );
            } else if ( e < 0 ) {

                // Integer.
                e = str.length;
            }

            // Determine leading zeros.
            for ( i = 0; str.charCodeAt(i) === 48; i++ );

            // Determine trailing zeros.
            for ( len = str.length; str.charCodeAt(--len) === 48; );
            str = str.slice( i, len + 1 );

            if (str) {
                len = str.length;

                // Disallow numbers with over 15 significant digits if number type.
                // 'new BigNumber() number type has more than 15 significant digits: {n}'
                if ( num && ERRORS && len > 15 && ( n > MAX_SAFE_INTEGER || n !== mathfloor(n) ) ) {
                    raise( id, tooManyDigits, x.s * n );
                }

                e = e - i - 1;

                 // Overflow?
                if ( e > MAX_EXP ) {

                    // Infinity.
                    x.c = x.e = null;

                // Underflow?
                } else if ( e < MIN_EXP ) {

                    // Zero.
                    x.c = [ x.e = 0 ];
                } else {
                    x.e = e;
                    x.c = [];

                    // Transform base

                    // e is the base 10 exponent.
                    // i is where to slice str to get the first element of the coefficient array.
                    i = ( e + 1 ) % LOG_BASE;
                    if ( e < 0 ) i += LOG_BASE;

                    if ( i < len ) {
                        if (i) x.c.push( +str.slice( 0, i ) );

                        for ( len -= LOG_BASE; i < len; ) {
                            x.c.push( +str.slice( i, i += LOG_BASE ) );
                        }

                        str = str.slice(i);
                        i = LOG_BASE - str.length;
                    } else {
                        i -= len;
                    }

                    for ( ; i--; str += '0' );
                    x.c.push( +str );
                }
            } else {

                // Zero.
                x.c = [ x.e = 0 ];
            }

            id = 0;
        }


        // CONSTRUCTOR PROPERTIES


        BigNumber.another = constructorFactory;

        BigNumber.ROUND_UP = 0;
        BigNumber.ROUND_DOWN = 1;
        BigNumber.ROUND_CEIL = 2;
        BigNumber.ROUND_FLOOR = 3;
        BigNumber.ROUND_HALF_UP = 4;
        BigNumber.ROUND_HALF_DOWN = 5;
        BigNumber.ROUND_HALF_EVEN = 6;
        BigNumber.ROUND_HALF_CEIL = 7;
        BigNumber.ROUND_HALF_FLOOR = 8;
        BigNumber.EUCLID = 9;


        /*
         * Configure infrequently-changing library-wide settings.
         *
         * Accept an object or an argument list, with one or many of the following properties or
         * parameters respectively:
         *
         *   DECIMAL_PLACES  {number}  Integer, 0 to MAX inclusive
         *   ROUNDING_MODE   {number}  Integer, 0 to 8 inclusive
         *   EXPONENTIAL_AT  {number|number[]}  Integer, -MAX to MAX inclusive or
         *                                      [integer -MAX to 0 incl., 0 to MAX incl.]
         *   RANGE           {number|number[]}  Non-zero integer, -MAX to MAX inclusive or
         *                                      [integer -MAX to -1 incl., integer 1 to MAX incl.]
         *   ERRORS          {boolean|number}   true, false, 1 or 0
         *   CRYPTO          {boolean|number}   true, false, 1 or 0
         *   MODULO_MODE     {number}           0 to 9 inclusive
         *   POW_PRECISION   {number}           0 to MAX inclusive
         *   FORMAT          {object}           See BigNumber.prototype.toFormat
         *      decimalSeparator       {string}
         *      groupSeparator         {string}
         *      groupSize              {number}
         *      secondaryGroupSize     {number}
         *      fractionGroupSeparator {string}
         *      fractionGroupSize      {number}
         *
         * (The values assigned to the above FORMAT object properties are not checked for validity.)
         *
         * E.g.
         * BigNumber.config(20, 4) is equivalent to
         * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
         *
         * Ignore properties/parameters set to null or undefined.
         * Return an object with the properties current values.
         */
        BigNumber.config = BigNumber.set = function () {
            var v, p,
                i = 0,
                r = {},
                a = arguments,
                o = a[0],
                has = o && typeof o == 'object'
                  ? function () { if ( o.hasOwnProperty(p) ) return ( v = o[p] ) != null; }
                  : function () { if ( a.length > i ) return ( v = a[i++] ) != null; };

            // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
            // 'config() DECIMAL_PLACES not an integer: {v}'
            // 'config() DECIMAL_PLACES out of range: {v}'
            if ( has( p = 'DECIMAL_PLACES' ) && isValidInt( v, 0, MAX, 2, p ) ) {
                DECIMAL_PLACES = v | 0;
            }
            r[p] = DECIMAL_PLACES;

            // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
            // 'config() ROUNDING_MODE not an integer: {v}'
            // 'config() ROUNDING_MODE out of range: {v}'
            if ( has( p = 'ROUNDING_MODE' ) && isValidInt( v, 0, 8, 2, p ) ) {
                ROUNDING_MODE = v | 0;
            }
            r[p] = ROUNDING_MODE;

            // EXPONENTIAL_AT {number|number[]}
            // Integer, -MAX to MAX inclusive or [integer -MAX to 0 inclusive, 0 to MAX inclusive].
            // 'config() EXPONENTIAL_AT not an integer: {v}'
            // 'config() EXPONENTIAL_AT out of range: {v}'
            if ( has( p = 'EXPONENTIAL_AT' ) ) {

                if ( isArray(v) ) {
                    if ( isValidInt( v[0], -MAX, 0, 2, p ) && isValidInt( v[1], 0, MAX, 2, p ) ) {
                        TO_EXP_NEG = v[0] | 0;
                        TO_EXP_POS = v[1] | 0;
                    }
                } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
                    TO_EXP_NEG = -( TO_EXP_POS = ( v < 0 ? -v : v ) | 0 );
                }
            }
            r[p] = [ TO_EXP_NEG, TO_EXP_POS ];

            // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
            // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
            // 'config() RANGE not an integer: {v}'
            // 'config() RANGE cannot be zero: {v}'
            // 'config() RANGE out of range: {v}'
            if ( has( p = 'RANGE' ) ) {

                if ( isArray(v) ) {
                    if ( isValidInt( v[0], -MAX, -1, 2, p ) && isValidInt( v[1], 1, MAX, 2, p ) ) {
                        MIN_EXP = v[0] | 0;
                        MAX_EXP = v[1] | 0;
                    }
                } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
                    if ( v | 0 ) MIN_EXP = -( MAX_EXP = ( v < 0 ? -v : v ) | 0 );
                    else if (ERRORS) raise( 2, p + ' cannot be zero', v );
                }
            }
            r[p] = [ MIN_EXP, MAX_EXP ];

            // ERRORS {boolean|number} true, false, 1 or 0.
            // 'config() ERRORS not a boolean or binary digit: {v}'
            if ( has( p = 'ERRORS' ) ) {

                if ( v === !!v || v === 1 || v === 0 ) {
                    id = 0;
                    isValidInt = ( ERRORS = !!v ) ? intValidatorWithErrors : intValidatorNoErrors;
                } else if (ERRORS) {
                    raise( 2, p + notBool, v );
                }
            }
            r[p] = ERRORS;

            // CRYPTO {boolean|number} true, false, 1 or 0.
            // 'config() CRYPTO not a boolean or binary digit: {v}'
            // 'config() crypto unavailable: {crypto}'
            if ( has( p = 'CRYPTO' ) ) {

                if ( v === true || v === false || v === 1 || v === 0 ) {
                    if (v) {
                        v = typeof crypto == 'undefined';
                        if ( !v && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                            CRYPTO = true;
                        } else if (ERRORS) {
                            raise( 2, 'crypto unavailable', v ? void 0 : crypto );
                        } else {
                            CRYPTO = false;
                        }
                    } else {
                        CRYPTO = false;
                    }
                } else if (ERRORS) {
                    raise( 2, p + notBool, v );
                }
            }
            r[p] = CRYPTO;

            // MODULO_MODE {number} Integer, 0 to 9 inclusive.
            // 'config() MODULO_MODE not an integer: {v}'
            // 'config() MODULO_MODE out of range: {v}'
            if ( has( p = 'MODULO_MODE' ) && isValidInt( v, 0, 9, 2, p ) ) {
                MODULO_MODE = v | 0;
            }
            r[p] = MODULO_MODE;

            // POW_PRECISION {number} Integer, 0 to MAX inclusive.
            // 'config() POW_PRECISION not an integer: {v}'
            // 'config() POW_PRECISION out of range: {v}'
            if ( has( p = 'POW_PRECISION' ) && isValidInt( v, 0, MAX, 2, p ) ) {
                POW_PRECISION = v | 0;
            }
            r[p] = POW_PRECISION;

            // FORMAT {object}
            // 'config() FORMAT not an object: {v}'
            if ( has( p = 'FORMAT' ) ) {

                if ( typeof v == 'object' ) {
                    FORMAT = v;
                } else if (ERRORS) {
                    raise( 2, p + ' not an object', v );
                }
            }
            r[p] = FORMAT;

            return r;
        };


        /*
         * Return a new BigNumber whose value is the maximum of the arguments.
         *
         * arguments {number|string|BigNumber}
         */
        BigNumber.max = function () { return maxOrMin( arguments, P.lt ); };


        /*
         * Return a new BigNumber whose value is the minimum of the arguments.
         *
         * arguments {number|string|BigNumber}
         */
        BigNumber.min = function () { return maxOrMin( arguments, P.gt ); };


        /*
         * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
         * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
         * zeros are produced).
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         *
         * 'random() decimal places not an integer: {dp}'
         * 'random() decimal places out of range: {dp}'
         * 'random() crypto unavailable: {crypto}'
         */
        BigNumber.random = (function () {
            var pow2_53 = 0x20000000000000;

            // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
            // Check if Math.random() produces more than 32 bits of randomness.
            // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
            // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
            var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
              ? function () { return mathfloor( Math.random() * pow2_53 ); }
              : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
                  (Math.random() * 0x800000 | 0); };

            return function (dp) {
                var a, b, e, k, v,
                    i = 0,
                    c = [],
                    rand = new BigNumber(ONE);

                dp = dp == null || !isValidInt( dp, 0, MAX, 14 ) ? DECIMAL_PLACES : dp | 0;
                k = mathceil( dp / LOG_BASE );

                if (CRYPTO) {

                    // Browsers supporting crypto.getRandomValues.
                    if (crypto.getRandomValues) {

                        a = crypto.getRandomValues( new Uint32Array( k *= 2 ) );

                        for ( ; i < k; ) {

                            // 53 bits:
                            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
                            // 11111 11111111 11111111 11111111 11100000 00000000 00000000
                            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
                            //                                     11111 11111111 11111111
                            // 0x20000 is 2^21.
                            v = a[i] * 0x20000 + (a[i + 1] >>> 11);

                            // Rejection sampling:
                            // 0 <= v < 9007199254740992
                            // Probability that v >= 9e15, is
                            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
                            if ( v >= 9e15 ) {
                                b = crypto.getRandomValues( new Uint32Array(2) );
                                a[i] = b[0];
                                a[i + 1] = b[1];
                            } else {

                                // 0 <= v <= 8999999999999999
                                // 0 <= (v % 1e14) <= 99999999999999
                                c.push( v % 1e14 );
                                i += 2;
                            }
                        }
                        i = k / 2;

                    // Node.js supporting crypto.randomBytes.
                    } else if (crypto.randomBytes) {

                        // buffer
                        a = crypto.randomBytes( k *= 7 );

                        for ( ; i < k; ) {

                            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
                            // 0x100000000 is 2^32, 0x1000000 is 2^24
                            // 11111 11111111 11111111 11111111 11111111 11111111 11111111
                            // 0 <= v < 9007199254740992
                            v = ( ( a[i] & 31 ) * 0x1000000000000 ) + ( a[i + 1] * 0x10000000000 ) +
                                  ( a[i + 2] * 0x100000000 ) + ( a[i + 3] * 0x1000000 ) +
                                  ( a[i + 4] << 16 ) + ( a[i + 5] << 8 ) + a[i + 6];

                            if ( v >= 9e15 ) {
                                crypto.randomBytes(7).copy( a, i );
                            } else {

                                // 0 <= (v % 1e14) <= 99999999999999
                                c.push( v % 1e14 );
                                i += 7;
                            }
                        }
                        i = k / 7;
                    } else {
                        CRYPTO = false;
                        if (ERRORS) raise( 14, 'crypto unavailable', crypto );
                    }
                }

                // Use Math.random.
                if (!CRYPTO) {

                    for ( ; i < k; ) {
                        v = random53bitInt();
                        if ( v < 9e15 ) c[i++] = v % 1e14;
                    }
                }

                k = c[--i];
                dp %= LOG_BASE;

                // Convert trailing digits to zeros according to dp.
                if ( k && dp ) {
                    v = POWS_TEN[LOG_BASE - dp];
                    c[i] = mathfloor( k / v ) * v;
                }

                // Remove trailing elements which are zero.
                for ( ; c[i] === 0; c.pop(), i-- );

                // Zero?
                if ( i < 0 ) {
                    c = [ e = 0 ];
                } else {

                    // Remove leading elements which are zero and adjust exponent accordingly.
                    for ( e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

                    // Count the digits of the first element of c to determine leading zeros, and...
                    for ( i = 1, v = c[0]; v >= 10; v /= 10, i++);

                    // adjust the exponent accordingly.
                    if ( i < LOG_BASE ) e -= LOG_BASE - i;
                }

                rand.e = e;
                rand.c = c;
                return rand;
            };
        })();


        // PRIVATE FUNCTIONS


        // Convert a numeric string of baseIn to a numeric string of baseOut.
        function convertBase( str, baseOut, baseIn, sign ) {
            var d, e, k, r, x, xc, y,
                i = str.indexOf( '.' ),
                dp = DECIMAL_PLACES,
                rm = ROUNDING_MODE;

            if ( baseIn < 37 ) str = str.toLowerCase();

            // Non-integer.
            if ( i >= 0 ) {
                k = POW_PRECISION;

                // Unlimited precision.
                POW_PRECISION = 0;
                str = str.replace( '.', '' );
                y = new BigNumber(baseIn);
                x = y.pow( str.length - i );
                POW_PRECISION = k;

                // Convert str as if an integer, then restore the fraction part by dividing the
                // result by its base raised to a power.
                y.c = toBaseOut( toFixedPoint( coeffToString( x.c ), x.e ), 10, baseOut );
                y.e = y.c.length;
            }

            // Convert the number as integer.
            xc = toBaseOut( str, baseIn, baseOut );
            e = k = xc.length;

            // Remove trailing zeros.
            for ( ; xc[--k] == 0; xc.pop() );
            if ( !xc[0] ) return '0';

            if ( i < 0 ) {
                --e;
            } else {
                x.c = xc;
                x.e = e;

                // sign is needed for correct rounding.
                x.s = sign;
                x = div( x, y, dp, rm, baseOut );
                xc = x.c;
                r = x.r;
                e = x.e;
            }

            d = e + dp + 1;

            // The rounding digit, i.e. the digit to the right of the digit that may be rounded up.
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;

            r = rm < 4 ? ( i != null || r ) && ( rm == 0 || rm == ( x.s < 0 ? 3 : 2 ) )
                       : i > k || i == k &&( rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
                         rm == ( x.s < 0 ? 8 : 7 ) );

            if ( d < 1 || !xc[0] ) {

                // 1^-dp or 0.
                str = r ? toFixedPoint( '1', -dp ) : '0';
            } else {
                xc.length = d;

                if (r) {

                    // Rounding up may mean the previous digit has to be rounded up and so on.
                    for ( --baseOut; ++xc[--d] > baseOut; ) {
                        xc[d] = 0;

                        if ( !d ) {
                            ++e;
                            xc = [1].concat(xc);
                        }
                    }
                }

                // Determine trailing zeros.
                for ( k = xc.length; !xc[--k]; );

                // E.g. [4, 11, 15] becomes 4bf.
                for ( i = 0, str = ''; i <= k; str += ALPHABET.charAt( xc[i++] ) );
                str = toFixedPoint( str, e );
            }

            // The caller will add the sign.
            return str;
        }


        // Perform division in the specified base. Called by div and convertBase.
        div = (function () {

            // Assume non-zero x and k.
            function multiply( x, k, base ) {
                var m, temp, xlo, xhi,
                    carry = 0,
                    i = x.length,
                    klo = k % SQRT_BASE,
                    khi = k / SQRT_BASE | 0;

                for ( x = x.slice(); i--; ) {
                    xlo = x[i] % SQRT_BASE;
                    xhi = x[i] / SQRT_BASE | 0;
                    m = khi * xlo + xhi * klo;
                    temp = klo * xlo + ( ( m % SQRT_BASE ) * SQRT_BASE ) + carry;
                    carry = ( temp / base | 0 ) + ( m / SQRT_BASE | 0 ) + khi * xhi;
                    x[i] = temp % base;
                }

                if (carry) x = [carry].concat(x);

                return x;
            }

            function compare( a, b, aL, bL ) {
                var i, cmp;

                if ( aL != bL ) {
                    cmp = aL > bL ? 1 : -1;
                } else {

                    for ( i = cmp = 0; i < aL; i++ ) {

                        if ( a[i] != b[i] ) {
                            cmp = a[i] > b[i] ? 1 : -1;
                            break;
                        }
                    }
                }
                return cmp;
            }

            function subtract( a, b, aL, base ) {
                var i = 0;

                // Subtract b from a.
                for ( ; aL--; ) {
                    a[aL] -= i;
                    i = a[aL] < b[aL] ? 1 : 0;
                    a[aL] = i * base + a[aL] - b[aL];
                }

                // Remove leading zeros.
                for ( ; !a[0] && a.length > 1; a.splice(0, 1) );
            }

            // x: dividend, y: divisor.
            return function ( x, y, dp, rm, base ) {
                var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
                    yL, yz,
                    s = x.s == y.s ? 1 : -1,
                    xc = x.c,
                    yc = y.c;

                // Either NaN, Infinity or 0?
                if ( !xc || !xc[0] || !yc || !yc[0] ) {

                    return new BigNumber(

                      // Return NaN if either NaN, or both Infinity or 0.
                      !x.s || !y.s || ( xc ? yc && xc[0] == yc[0] : !yc ) ? NaN :

                        // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                        xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                    );
                }

                q = new BigNumber(s);
                qc = q.c = [];
                e = x.e - y.e;
                s = dp + e + 1;

                if ( !base ) {
                    base = BASE;
                    e = bitFloor( x.e / LOG_BASE ) - bitFloor( y.e / LOG_BASE );
                    s = s / LOG_BASE | 0;
                }

                // Result exponent may be one less then the current value of e.
                // The coefficients of the BigNumbers from convertBase may have trailing zeros.
                for ( i = 0; yc[i] == ( xc[i] || 0 ); i++ );
                if ( yc[i] > ( xc[i] || 0 ) ) e--;

                if ( s < 0 ) {
                    qc.push(1);
                    more = true;
                } else {
                    xL = xc.length;
                    yL = yc.length;
                    i = 0;
                    s += 2;

                    // Normalise xc and yc so highest order digit of yc is >= base / 2.

                    n = mathfloor( base / ( yc[0] + 1 ) );

                    // Not necessary, but to handle odd bases where yc[0] == ( base / 2 ) - 1.
                    // if ( n > 1 || n++ == 1 && yc[0] < base / 2 ) {
                    if ( n > 1 ) {
                        yc = multiply( yc, n, base );
                        xc = multiply( xc, n, base );
                        yL = yc.length;
                        xL = xc.length;
                    }

                    xi = yL;
                    rem = xc.slice( 0, yL );
                    remL = rem.length;

                    // Add zeros to make remainder as long as divisor.
                    for ( ; remL < yL; rem[remL++] = 0 );
                    yz = yc.slice();
                    yz = [0].concat(yz);
                    yc0 = yc[0];
                    if ( yc[1] >= base / 2 ) yc0++;
                    // Not necessary, but to prevent trial digit n > base, when using base 3.
                    // else if ( base == 3 && yc0 == 1 ) yc0 = 1 + 1e-15;

                    do {
                        n = 0;

                        // Compare divisor and remainder.
                        cmp = compare( yc, rem, yL, remL );

                        // If divisor < remainder.
                        if ( cmp < 0 ) {

                            // Calculate trial digit, n.

                            rem0 = rem[0];
                            if ( yL != remL ) rem0 = rem0 * base + ( rem[1] || 0 );

                            // n is how many times the divisor goes into the current remainder.
                            n = mathfloor( rem0 / yc0 );

                            //  Algorithm:
                            //  1. product = divisor * trial digit (n)
                            //  2. if product > remainder: product -= divisor, n--
                            //  3. remainder -= product
                            //  4. if product was < remainder at 2:
                            //    5. compare new remainder and divisor
                            //    6. If remainder > divisor: remainder -= divisor, n++

                            if ( n > 1 ) {

                                // n may be > base only when base is 3.
                                if (n >= base) n = base - 1;

                                // product = divisor * trial digit.
                                prod = multiply( yc, n, base );
                                prodL = prod.length;
                                remL = rem.length;

                                // Compare product and remainder.
                                // If product > remainder.
                                // Trial digit n too high.
                                // n is 1 too high about 5% of the time, and is not known to have
                                // ever been more than 1 too high.
                                while ( compare( prod, rem, prodL, remL ) == 1 ) {
                                    n--;

                                    // Subtract divisor from product.
                                    subtract( prod, yL < prodL ? yz : yc, prodL, base );
                                    prodL = prod.length;
                                    cmp = 1;
                                }
                            } else {

                                // n is 0 or 1, cmp is -1.
                                // If n is 0, there is no need to compare yc and rem again below,
                                // so change cmp to 1 to avoid it.
                                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                                if ( n == 0 ) {

                                    // divisor < remainder, so n must be at least 1.
                                    cmp = n = 1;
                                }

                                // product = divisor
                                prod = yc.slice();
                                prodL = prod.length;
                            }

                            if ( prodL < remL ) prod = [0].concat(prod);

                            // Subtract product from remainder.
                            subtract( rem, prod, remL, base );
                            remL = rem.length;

                             // If product was < remainder.
                            if ( cmp == -1 ) {

                                // Compare divisor and new remainder.
                                // If divisor < new remainder, subtract divisor from remainder.
                                // Trial digit n too low.
                                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                                while ( compare( yc, rem, yL, remL ) < 1 ) {
                                    n++;

                                    // Subtract divisor from remainder.
                                    subtract( rem, yL < remL ? yz : yc, remL, base );
                                    remL = rem.length;
                                }
                            }
                        } else if ( cmp === 0 ) {
                            n++;
                            rem = [0];
                        } // else cmp === 1 and n will be 0

                        // Add the next digit, n, to the result array.
                        qc[i++] = n;

                        // Update the remainder.
                        if ( rem[0] ) {
                            rem[remL++] = xc[xi] || 0;
                        } else {
                            rem = [ xc[xi] ];
                            remL = 1;
                        }
                    } while ( ( xi++ < xL || rem[0] != null ) && s-- );

                    more = rem[0] != null;

                    // Leading zero?
                    if ( !qc[0] ) qc.splice(0, 1);
                }

                if ( base == BASE ) {

                    // To calculate q.e, first get the number of digits of qc[0].
                    for ( i = 1, s = qc[0]; s >= 10; s /= 10, i++ );
                    round( q, dp + ( q.e = i + e * LOG_BASE - 1 ) + 1, rm, more );

                // Caller is convertBase.
                } else {
                    q.e = e;
                    q.r = +more;
                }

                return q;
            };
        })();


        /*
         * Return a string representing the value of BigNumber n in fixed-point or exponential
         * notation rounded to the specified decimal places or significant digits.
         *
         * n is a BigNumber.
         * i is the index of the last digit required (i.e. the digit that may be rounded up).
         * rm is the rounding mode.
         * caller is caller id: toExponential 19, toFixed 20, toFormat 21, toPrecision 24.
         */
        function format( n, i, rm, caller ) {
            var c0, e, ne, len, str;

            rm = rm != null && isValidInt( rm, 0, 8, caller, roundingMode )
              ? rm | 0 : ROUNDING_MODE;

            if ( !n.c ) return n.toString();
            c0 = n.c[0];
            ne = n.e;

            if ( i == null ) {
                str = coeffToString( n.c );
                str = caller == 19 || caller == 24 && ne <= TO_EXP_NEG
                  ? toExponential( str, ne )
                  : toFixedPoint( str, ne );
            } else {
                n = round( new BigNumber(n), i, rm );

                // n.e may have changed if the value was rounded up.
                e = n.e;

                str = coeffToString( n.c );
                len = str.length;

                // toPrecision returns exponential notation if the number of significant digits
                // specified is less than the number of digits necessary to represent the integer
                // part of the value in fixed-point notation.

                // Exponential notation.
                if ( caller == 19 || caller == 24 && ( i <= e || e <= TO_EXP_NEG ) ) {

                    // Append zeros?
                    for ( ; len < i; str += '0', len++ );
                    str = toExponential( str, e );

                // Fixed-point notation.
                } else {
                    i -= ne;
                    str = toFixedPoint( str, e );

                    // Append zeros?
                    if ( e + 1 > len ) {
                        if ( --i > 0 ) for ( str += '.'; i--; str += '0' );
                    } else {
                        i += e - len;
                        if ( i > 0 ) {
                            if ( e + 1 == len ) str += '.';
                            for ( ; i--; str += '0' );
                        }
                    }
                }
            }

            return n.s < 0 && c0 ? '-' + str : str;
        }


        // Handle BigNumber.max and BigNumber.min.
        function maxOrMin( args, method ) {
            var m, n,
                i = 0;

            if ( isArray( args[0] ) ) args = args[0];
            m = new BigNumber( args[0] );

            for ( ; ++i < args.length; ) {
                n = new BigNumber( args[i] );

                // If any number is NaN, return NaN.
                if ( !n.s ) {
                    m = n;
                    break;
                } else if ( method.call( m, n ) ) {
                    m = n;
                }
            }

            return m;
        }


        /*
         * Return true if n is an integer in range, otherwise throw.
         * Use for argument validation when ERRORS is true.
         */
        function intValidatorWithErrors( n, min, max, caller, name ) {
            if ( n < min || n > max || n != truncate(n) ) {
                raise( caller, ( name || 'decimal places' ) +
                  ( n < min || n > max ? ' out of range' : ' not an integer' ), n );
            }

            return true;
        }


        /*
         * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
         * Called by minus, plus and times.
         */
        function normalise( n, c, e ) {
            var i = 1,
                j = c.length;

             // Remove trailing zeros.
            for ( ; !c[--j]; c.pop() );

            // Calculate the base 10 exponent. First get the number of digits of c[0].
            for ( j = c[0]; j >= 10; j /= 10, i++ );

            // Overflow?
            if ( ( e = i + e * LOG_BASE - 1 ) > MAX_EXP ) {

                // Infinity.
                n.c = n.e = null;

            // Underflow?
            } else if ( e < MIN_EXP ) {

                // Zero.
                n.c = [ n.e = 0 ];
            } else {
                n.e = e;
                n.c = c;
            }

            return n;
        }


        // Handle values that fail the validity test in BigNumber.
        parseNumeric = (function () {
            var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
                dotAfter = /^([^.]+)\.$/,
                dotBefore = /^\.([^.]+)$/,
                isInfinityOrNaN = /^-?(Infinity|NaN)$/,
                whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

            return function ( x, str, num, b ) {
                var base,
                    s = num ? str : str.replace( whitespaceOrPlus, '' );

                // No exception on ±Infinity or NaN.
                if ( isInfinityOrNaN.test(s) ) {
                    x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
                } else {
                    if ( !num ) {

                        // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
                        s = s.replace( basePrefix, function ( m, p1, p2 ) {
                            base = ( p2 = p2.toLowerCase() ) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
                            return !b || b == base ? p1 : m;
                        });

                        if (b) {
                            base = b;

                            // E.g. '1.' to '1', '.1' to '0.1'
                            s = s.replace( dotAfter, '$1' ).replace( dotBefore, '0.$1' );
                        }

                        if ( str != s ) return new BigNumber( s, base );
                    }

                    // 'new BigNumber() not a number: {n}'
                    // 'new BigNumber() not a base {b} number: {n}'
                    if (ERRORS) raise( id, 'not a' + ( b ? ' base ' + b : '' ) + ' number', str );
                    x.s = null;
                }

                x.c = x.e = null;
                id = 0;
            }
        })();


        // Throw a BigNumber Error.
        function raise( caller, msg, val ) {
            var error = new Error( [
                'new BigNumber',     // 0
                'cmp',               // 1
                'config',            // 2
                'div',               // 3
                'divToInt',          // 4
                'eq',                // 5
                'gt',                // 6
                'gte',               // 7
                'lt',                // 8
                'lte',               // 9
                'minus',             // 10
                'mod',               // 11
                'plus',              // 12
                'precision',         // 13
                'random',            // 14
                'round',             // 15
                'shift',             // 16
                'times',             // 17
                'toDigits',          // 18
                'toExponential',     // 19
                'toFixed',           // 20
                'toFormat',          // 21
                'toFraction',        // 22
                'pow',               // 23
                'toPrecision',       // 24
                'toString',          // 25
                'BigNumber'          // 26
            ][caller] + '() ' + msg + ': ' + val );

            error.name = 'BigNumber Error';
            id = 0;
            throw error;
        }


        /*
         * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
         * If r is truthy, it is known that there are more digits after the rounding digit.
         */
        function round( x, sd, rm, r ) {
            var d, i, j, k, n, ni, rd,
                xc = x.c,
                pows10 = POWS_TEN;

            // if x is not Infinity or NaN...
            if (xc) {

                // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
                // n is a base 1e14 number, the value of the element of array x.c containing rd.
                // ni is the index of n within x.c.
                // d is the number of digits of n.
                // i is the index of rd within n including leading zeros.
                // j is the actual index of rd within n (if < 0, rd is a leading zero).
                out: {

                    // Get the number of digits of the first element of xc.
                    for ( d = 1, k = xc[0]; k >= 10; k /= 10, d++ );
                    i = sd - d;

                    // If the rounding digit is in the first element of xc...
                    if ( i < 0 ) {
                        i += LOG_BASE;
                        j = sd;
                        n = xc[ ni = 0 ];

                        // Get the rounding digit at index j of n.
                        rd = n / pows10[ d - j - 1 ] % 10 | 0;
                    } else {
                        ni = mathceil( ( i + 1 ) / LOG_BASE );

                        if ( ni >= xc.length ) {

                            if (r) {

                                // Needed by sqrt.
                                for ( ; xc.length <= ni; xc.push(0) );
                                n = rd = 0;
                                d = 1;
                                i %= LOG_BASE;
                                j = i - LOG_BASE + 1;
                            } else {
                                break out;
                            }
                        } else {
                            n = k = xc[ni];

                            // Get the number of digits of n.
                            for ( d = 1; k >= 10; k /= 10, d++ );

                            // Get the index of rd within n.
                            i %= LOG_BASE;

                            // Get the index of rd within n, adjusted for leading zeros.
                            // The number of leading zeros of n is given by LOG_BASE - d.
                            j = i - LOG_BASE + d;

                            // Get the rounding digit at index j of n.
                            rd = j < 0 ? 0 : n / pows10[ d - j - 1 ] % 10 | 0;
                        }
                    }

                    r = r || sd < 0 ||

                    // Are there any non-zero digits after the rounding digit?
                    // The expression  n % pows10[ d - j - 1 ]  returns all digits of n to the right
                    // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                      xc[ni + 1] != null || ( j < 0 ? n : n % pows10[ d - j - 1 ] );

                    r = rm < 4
                      ? ( rd || r ) && ( rm == 0 || rm == ( x.s < 0 ? 3 : 2 ) )
                      : rd > 5 || rd == 5 && ( rm == 4 || r || rm == 6 &&

                        // Check whether the digit to the left of the rounding digit is odd.
                        ( ( i > 0 ? j > 0 ? n / pows10[ d - j ] : 0 : xc[ni - 1] ) % 10 ) & 1 ||
                          rm == ( x.s < 0 ? 8 : 7 ) );

                    if ( sd < 1 || !xc[0] ) {
                        xc.length = 0;

                        if (r) {

                            // Convert sd to decimal places.
                            sd -= x.e + 1;

                            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
                            xc[0] = pows10[ ( LOG_BASE - sd % LOG_BASE ) % LOG_BASE ];
                            x.e = -sd || 0;
                        } else {

                            // Zero.
                            xc[0] = x.e = 0;
                        }

                        return x;
                    }

                    // Remove excess digits.
                    if ( i == 0 ) {
                        xc.length = ni;
                        k = 1;
                        ni--;
                    } else {
                        xc.length = ni + 1;
                        k = pows10[ LOG_BASE - i ];

                        // E.g. 56700 becomes 56000 if 7 is the rounding digit.
                        // j > 0 means i > number of leading zeros of n.
                        xc[ni] = j > 0 ? mathfloor( n / pows10[ d - j ] % pows10[j] ) * k : 0;
                    }

                    // Round up?
                    if (r) {

                        for ( ; ; ) {

                            // If the digit to be rounded up is in the first element of xc...
                            if ( ni == 0 ) {

                                // i will be the length of xc[0] before k is added.
                                for ( i = 1, j = xc[0]; j >= 10; j /= 10, i++ );
                                j = xc[0] += k;
                                for ( k = 1; j >= 10; j /= 10, k++ );

                                // if i != k the length has increased.
                                if ( i != k ) {
                                    x.e++;
                                    if ( xc[0] == BASE ) xc[0] = 1;
                                }

                                break;
                            } else {
                                xc[ni] += k;
                                if ( xc[ni] != BASE ) break;
                                xc[ni--] = 0;
                                k = 1;
                            }
                        }
                    }

                    // Remove trailing zeros.
                    for ( i = xc.length; xc[--i] === 0; xc.pop() );
                }

                // Overflow? Infinity.
                if ( x.e > MAX_EXP ) {
                    x.c = x.e = null;

                // Underflow? Zero.
                } else if ( x.e < MIN_EXP ) {
                    x.c = [ x.e = 0 ];
                }
            }

            return x;
        }


        // PROTOTYPE/INSTANCE METHODS


        /*
         * Return a new BigNumber whose value is the absolute value of this BigNumber.
         */
        P.absoluteValue = P.abs = function () {
            var x = new BigNumber(this);
            if ( x.s < 0 ) x.s = 1;
            return x;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole
         * number in the direction of Infinity.
         */
        P.ceil = function () {
            return round( new BigNumber(this), this.e + 1, 2 );
        };


        /*
         * Return
         * 1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
         * -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
         * 0 if they have the same value,
         * or null if the value of either is NaN.
         */
        P.comparedTo = P.cmp = function ( y, b ) {
            id = 1;
            return compare( this, new BigNumber( y, b ) );
        };


        /*
         * Return the number of decimal places of the value of this BigNumber, or null if the value
         * of this BigNumber is ±Infinity or NaN.
         */
        P.decimalPlaces = P.dp = function () {
            var n, v,
                c = this.c;

            if ( !c ) return null;
            n = ( ( v = c.length - 1 ) - bitFloor( this.e / LOG_BASE ) ) * LOG_BASE;

            // Subtract the number of trailing zeros of the last number.
            if ( v = c[v] ) for ( ; v % 10 == 0; v /= 10, n-- );
            if ( n < 0 ) n = 0;

            return n;
        };


        /*
         *  n / 0 = I
         *  n / N = N
         *  n / I = 0
         *  0 / n = 0
         *  0 / 0 = N
         *  0 / N = N
         *  0 / I = 0
         *  N / n = N
         *  N / 0 = N
         *  N / N = N
         *  N / I = N
         *  I / n = I
         *  I / 0 = I
         *  I / N = N
         *  I / I = N
         *
         * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
         * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
         */
        P.dividedBy = P.div = function ( y, b ) {
            id = 3;
            return div( this, new BigNumber( y, b ), DECIMAL_PLACES, ROUNDING_MODE );
        };


        /*
         * Return a new BigNumber whose value is the integer part of dividing the value of this
         * BigNumber by the value of BigNumber(y, b).
         */
        P.dividedToIntegerBy = P.divToInt = function ( y, b ) {
            id = 4;
            return div( this, new BigNumber( y, b ), 0, 1 );
        };


        /*
         * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
         * otherwise returns false.
         */
        P.equals = P.eq = function ( y, b ) {
            id = 5;
            return compare( this, new BigNumber( y, b ) ) === 0;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole
         * number in the direction of -Infinity.
         */
        P.floor = function () {
            return round( new BigNumber(this), this.e + 1, 3 );
        };


        /*
         * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
         * otherwise returns false.
         */
        P.greaterThan = P.gt = function ( y, b ) {
            id = 6;
            return compare( this, new BigNumber( y, b ) ) > 0;
        };


        /*
         * Return true if the value of this BigNumber is greater than or equal to the value of
         * BigNumber(y, b), otherwise returns false.
         */
        P.greaterThanOrEqualTo = P.gte = function ( y, b ) {
            id = 7;
            return ( b = compare( this, new BigNumber( y, b ) ) ) === 1 || b === 0;

        };


        /*
         * Return true if the value of this BigNumber is a finite number, otherwise returns false.
         */
        P.isFinite = function () {
            return !!this.c;
        };


        /*
         * Return true if the value of this BigNumber is an integer, otherwise return false.
         */
        P.isInteger = P.isInt = function () {
            return !!this.c && bitFloor( this.e / LOG_BASE ) > this.c.length - 2;
        };


        /*
         * Return true if the value of this BigNumber is NaN, otherwise returns false.
         */
        P.isNaN = function () {
            return !this.s;
        };


        /*
         * Return true if the value of this BigNumber is negative, otherwise returns false.
         */
        P.isNegative = P.isNeg = function () {
            return this.s < 0;
        };


        /*
         * Return true if the value of this BigNumber is 0 or -0, otherwise returns false.
         */
        P.isZero = function () {
            return !!this.c && this.c[0] == 0;
        };


        /*
         * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
         * otherwise returns false.
         */
        P.lessThan = P.lt = function ( y, b ) {
            id = 8;
            return compare( this, new BigNumber( y, b ) ) < 0;
        };


        /*
         * Return true if the value of this BigNumber is less than or equal to the value of
         * BigNumber(y, b), otherwise returns false.
         */
        P.lessThanOrEqualTo = P.lte = function ( y, b ) {
            id = 9;
            return ( b = compare( this, new BigNumber( y, b ) ) ) === -1 || b === 0;
        };


        /*
         *  n - 0 = n
         *  n - N = N
         *  n - I = -I
         *  0 - n = -n
         *  0 - 0 = 0
         *  0 - N = N
         *  0 - I = -I
         *  N - n = N
         *  N - 0 = N
         *  N - N = N
         *  N - I = N
         *  I - n = I
         *  I - 0 = I
         *  I - N = N
         *  I - I = N
         *
         * Return a new BigNumber whose value is the value of this BigNumber minus the value of
         * BigNumber(y, b).
         */
        P.minus = P.sub = function ( y, b ) {
            var i, j, t, xLTy,
                x = this,
                a = x.s;

            id = 10;
            y = new BigNumber( y, b );
            b = y.s;

            // Either NaN?
            if ( !a || !b ) return new BigNumber(NaN);

            // Signs differ?
            if ( a != b ) {
                y.s = -b;
                return x.plus(y);
            }

            var xe = x.e / LOG_BASE,
                ye = y.e / LOG_BASE,
                xc = x.c,
                yc = y.c;

            if ( !xe || !ye ) {

                // Either Infinity?
                if ( !xc || !yc ) return xc ? ( y.s = -b, y ) : new BigNumber( yc ? x : NaN );

                // Either zero?
                if ( !xc[0] || !yc[0] ) {

                    // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                    return yc[0] ? ( y.s = -b, y ) : new BigNumber( xc[0] ? x :

                      // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                      ROUNDING_MODE == 3 ? -0 : 0 );
                }
            }

            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();

            // Determine which is the bigger number.
            if ( a = xe - ye ) {

                if ( xLTy = a < 0 ) {
                    a = -a;
                    t = xc;
                } else {
                    ye = xe;
                    t = yc;
                }

                t.reverse();

                // Prepend zeros to equalise exponents.
                for ( b = a; b--; t.push(0) );
                t.reverse();
            } else {

                // Exponents equal. Check digit by digit.
                j = ( xLTy = ( a = xc.length ) < ( b = yc.length ) ) ? a : b;

                for ( a = b = 0; b < j; b++ ) {

                    if ( xc[b] != yc[b] ) {
                        xLTy = xc[b] < yc[b];
                        break;
                    }
                }
            }

            // x < y? Point xc to the array of the bigger number.
            if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

            b = ( j = yc.length ) - ( i = xc.length );

            // Append zeros to xc if shorter.
            // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
            if ( b > 0 ) for ( ; b--; xc[i++] = 0 );
            b = BASE - 1;

            // Subtract yc from xc.
            for ( ; j > a; ) {

                if ( xc[--j] < yc[j] ) {
                    for ( i = j; i && !xc[--i]; xc[i] = b );
                    --xc[i];
                    xc[j] += BASE;
                }

                xc[j] -= yc[j];
            }

            // Remove leading zeros and adjust exponent accordingly.
            for ( ; xc[0] == 0; xc.splice(0, 1), --ye );

            // Zero?
            if ( !xc[0] ) {

                // Following IEEE 754 (2008) 6.3,
                // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
                y.s = ROUNDING_MODE == 3 ? -1 : 1;
                y.c = [ y.e = 0 ];
                return y;
            }

            // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
            // for finite x and y.
            return normalise( y, xc, ye );
        };


        /*
         *   n % 0 =  N
         *   n % N =  N
         *   n % I =  n
         *   0 % n =  0
         *  -0 % n = -0
         *   0 % 0 =  N
         *   0 % N =  N
         *   0 % I =  0
         *   N % n =  N
         *   N % 0 =  N
         *   N % N =  N
         *   N % I =  N
         *   I % n =  N
         *   I % 0 =  N
         *   I % N =  N
         *   I % I =  N
         *
         * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
         * BigNumber(y, b). The result depends on the value of MODULO_MODE.
         */
        P.modulo = P.mod = function ( y, b ) {
            var q, s,
                x = this;

            id = 11;
            y = new BigNumber( y, b );

            // Return NaN if x is Infinity or NaN, or y is NaN or zero.
            if ( !x.c || !y.s || y.c && !y.c[0] ) {
                return new BigNumber(NaN);

            // Return x if y is Infinity or x is zero.
            } else if ( !y.c || x.c && !x.c[0] ) {
                return new BigNumber(x);
            }

            if ( MODULO_MODE == 9 ) {

                // Euclidian division: q = sign(y) * floor(x / abs(y))
                // r = x - qy    where  0 <= r < abs(y)
                s = y.s;
                y.s = 1;
                q = div( x, y, 0, 3 );
                y.s = s;
                q.s *= s;
            } else {
                q = div( x, y, 0, MODULO_MODE );
            }

            return x.minus( q.times(y) );
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber negated,
         * i.e. multiplied by -1.
         */
        P.negated = P.neg = function () {
            var x = new BigNumber(this);
            x.s = -x.s || null;
            return x;
        };


        /*
         *  n + 0 = n
         *  n + N = N
         *  n + I = I
         *  0 + n = n
         *  0 + 0 = 0
         *  0 + N = N
         *  0 + I = I
         *  N + n = N
         *  N + 0 = N
         *  N + N = N
         *  N + I = N
         *  I + n = I
         *  I + 0 = I
         *  I + N = N
         *  I + I = I
         *
         * Return a new BigNumber whose value is the value of this BigNumber plus the value of
         * BigNumber(y, b).
         */
        P.plus = P.add = function ( y, b ) {
            var t,
                x = this,
                a = x.s;

            id = 12;
            y = new BigNumber( y, b );
            b = y.s;

            // Either NaN?
            if ( !a || !b ) return new BigNumber(NaN);

            // Signs differ?
             if ( a != b ) {
                y.s = -b;
                return x.minus(y);
            }

            var xe = x.e / LOG_BASE,
                ye = y.e / LOG_BASE,
                xc = x.c,
                yc = y.c;

            if ( !xe || !ye ) {

                // Return ±Infinity if either ±Infinity.
                if ( !xc || !yc ) return new BigNumber( a / 0 );

                // Either zero?
                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                if ( !xc[0] || !yc[0] ) return yc[0] ? y : new BigNumber( xc[0] ? x : a * 0 );
            }

            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();

            // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
            if ( a = xe - ye ) {
                if ( a > 0 ) {
                    ye = xe;
                    t = yc;
                } else {
                    a = -a;
                    t = xc;
                }

                t.reverse();
                for ( ; a--; t.push(0) );
                t.reverse();
            }

            a = xc.length;
            b = yc.length;

            // Point xc to the longer array, and b to the shorter length.
            if ( a - b < 0 ) t = yc, yc = xc, xc = t, b = a;

            // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
            for ( a = 0; b; ) {
                a = ( xc[--b] = xc[b] + yc[b] + a ) / BASE | 0;
                xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
            }

            if (a) {
                xc = [a].concat(xc);
                ++ye;
            }

            // No need to check for zero, as +x + +y != 0 && -x + -y != 0
            // ye = MAX_EXP + 1 possible
            return normalise( y, xc, ye );
        };


        /*
         * Return the number of significant digits of the value of this BigNumber.
         *
         * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
         */
        P.precision = P.sd = function (z) {
            var n, v,
                x = this,
                c = x.c;

            // 'precision() argument not a boolean or binary digit: {z}'
            if ( z != null && z !== !!z && z !== 1 && z !== 0 ) {
                if (ERRORS) raise( 13, 'argument' + notBool, z );
                if ( z != !!z ) z = null;
            }

            if ( !c ) return null;
            v = c.length - 1;
            n = v * LOG_BASE + 1;

            if ( v = c[v] ) {

                // Subtract the number of trailing zeros of the last element.
                for ( ; v % 10 == 0; v /= 10, n-- );

                // Add the number of digits of the first element.
                for ( v = c[0]; v >= 10; v /= 10, n++ );
            }

            if ( z && x.e + 1 > n ) n = x.e + 1;

            return n;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a maximum of
         * dp decimal places using rounding mode rm, or to 0 and ROUNDING_MODE respectively if
         * omitted.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'round() decimal places out of range: {dp}'
         * 'round() decimal places not an integer: {dp}'
         * 'round() rounding mode not an integer: {rm}'
         * 'round() rounding mode out of range: {rm}'
         */
        P.round = function ( dp, rm ) {
            var n = new BigNumber(this);

            if ( dp == null || isValidInt( dp, 0, MAX, 15 ) ) {
                round( n, ~~dp + this.e + 1, rm == null ||
                  !isValidInt( rm, 0, 8, 15, roundingMode ) ? ROUNDING_MODE : rm | 0 );
            }

            return n;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
         * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
         *
         * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
         *
         * If k is out of range and ERRORS is false, the result will be ±0 if k < 0, or ±Infinity
         * otherwise.
         *
         * 'shift() argument not an integer: {k}'
         * 'shift() argument out of range: {k}'
         */
        P.shift = function (k) {
            var n = this;
            return isValidInt( k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 16, 'argument' )

              // k < 1e+21, or truncate(k) will produce exponential notation.
              ? n.times( '1e' + truncate(k) )
              : new BigNumber( n.c && n.c[0] && ( k < -MAX_SAFE_INTEGER || k > MAX_SAFE_INTEGER )
                ? n.s * ( k < 0 ? 0 : 1 / 0 )
                : n );
        };


        /*
         *  sqrt(-n) =  N
         *  sqrt( N) =  N
         *  sqrt(-I) =  N
         *  sqrt( I) =  I
         *  sqrt( 0) =  0
         *  sqrt(-0) = -0
         *
         * Return a new BigNumber whose value is the square root of the value of this BigNumber,
         * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
         */
        P.squareRoot = P.sqrt = function () {
            var m, n, r, rep, t,
                x = this,
                c = x.c,
                s = x.s,
                e = x.e,
                dp = DECIMAL_PLACES + 4,
                half = new BigNumber('0.5');

            // Negative/NaN/Infinity/zero?
            if ( s !== 1 || !c || !c[0] ) {
                return new BigNumber( !s || s < 0 && ( !c || c[0] ) ? NaN : c ? x : 1 / 0 );
            }

            // Initial estimate.
            s = Math.sqrt( +x );

            // Math.sqrt underflow/overflow?
            // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
            if ( s == 0 || s == 1 / 0 ) {
                n = coeffToString(c);
                if ( ( n.length + e ) % 2 == 0 ) n += '0';
                s = Math.sqrt(n);
                e = bitFloor( ( e + 1 ) / 2 ) - ( e < 0 || e % 2 );

                if ( s == 1 / 0 ) {
                    n = '1e' + e;
                } else {
                    n = s.toExponential();
                    n = n.slice( 0, n.indexOf('e') + 1 ) + e;
                }

                r = new BigNumber(n);
            } else {
                r = new BigNumber( s + '' );
            }

            // Check for zero.
            // r could be zero if MIN_EXP is changed after the this value was created.
            // This would cause a division by zero (x/t) and hence Infinity below, which would cause
            // coeffToString to throw.
            if ( r.c[0] ) {
                e = r.e;
                s = e + dp;
                if ( s < 3 ) s = 0;

                // Newton-Raphson iteration.
                for ( ; ; ) {
                    t = r;
                    r = half.times( t.plus( div( x, t, dp, 1 ) ) );

                    if ( coeffToString( t.c   ).slice( 0, s ) === ( n =
                         coeffToString( r.c ) ).slice( 0, s ) ) {

                        // The exponent of r may here be one less than the final result exponent,
                        // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
                        // are indexed correctly.
                        if ( r.e < e ) --s;
                        n = n.slice( s - 3, s + 1 );

                        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
                        // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
                        // iteration.
                        if ( n == '9999' || !rep && n == '4999' ) {

                            // On the first iteration only, check to see if rounding up gives the
                            // exact result as the nines may infinitely repeat.
                            if ( !rep ) {
                                round( t, t.e + DECIMAL_PLACES + 2, 0 );

                                if ( t.times(t).eq(x) ) {
                                    r = t;
                                    break;
                                }
                            }

                            dp += 4;
                            s += 4;
                            rep = 1;
                        } else {

                            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
                            // result. If not, then there are further digits and m will be truthy.
                            if ( !+n || !+n.slice(1) && n.charAt(0) == '5' ) {

                                // Truncate to the first rounding digit.
                                round( r, r.e + DECIMAL_PLACES + 2, 1 );
                                m = !r.times(r).eq(x);
                            }

                            break;
                        }
                    }
                }
            }

            return round( r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m );
        };


        /*
         *  n * 0 = 0
         *  n * N = N
         *  n * I = I
         *  0 * n = 0
         *  0 * 0 = 0
         *  0 * N = N
         *  0 * I = N
         *  N * n = N
         *  N * 0 = N
         *  N * N = N
         *  N * I = N
         *  I * n = I
         *  I * 0 = N
         *  I * N = N
         *  I * I = I
         *
         * Return a new BigNumber whose value is the value of this BigNumber times the value of
         * BigNumber(y, b).
         */
        P.times = P.mul = function ( y, b ) {
            var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
                base, sqrtBase,
                x = this,
                xc = x.c,
                yc = ( id = 17, y = new BigNumber( y, b ) ).c;

            // Either NaN, ±Infinity or ±0?
            if ( !xc || !yc || !xc[0] || !yc[0] ) {

                // Return NaN if either is NaN, or one is 0 and the other is Infinity.
                if ( !x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc ) {
                    y.c = y.e = y.s = null;
                } else {
                    y.s *= x.s;

                    // Return ±Infinity if either is ±Infinity.
                    if ( !xc || !yc ) {
                        y.c = y.e = null;

                    // Return ±0 if either is ±0.
                    } else {
                        y.c = [0];
                        y.e = 0;
                    }
                }

                return y;
            }

            e = bitFloor( x.e / LOG_BASE ) + bitFloor( y.e / LOG_BASE );
            y.s *= x.s;
            xcL = xc.length;
            ycL = yc.length;

            // Ensure xc points to longer array and xcL to its length.
            if ( xcL < ycL ) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

            // Initialise the result array with zeros.
            for ( i = xcL + ycL, zc = []; i--; zc.push(0) );

            base = BASE;
            sqrtBase = SQRT_BASE;

            for ( i = ycL; --i >= 0; ) {
                c = 0;
                ylo = yc[i] % sqrtBase;
                yhi = yc[i] / sqrtBase | 0;

                for ( k = xcL, j = i + k; j > i; ) {
                    xlo = xc[--k] % sqrtBase;
                    xhi = xc[k] / sqrtBase | 0;
                    m = yhi * xlo + xhi * ylo;
                    xlo = ylo * xlo + ( ( m % sqrtBase ) * sqrtBase ) + zc[j] + c;
                    c = ( xlo / base | 0 ) + ( m / sqrtBase | 0 ) + yhi * xhi;
                    zc[j--] = xlo % base;
                }

                zc[j] = c;
            }

            if (c) {
                ++e;
            } else {
                zc.splice(0, 1);
            }

            return normalise( y, zc, e );
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a maximum of
         * sd significant digits using rounding mode rm, or ROUNDING_MODE if rm is omitted.
         *
         * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toDigits() precision out of range: {sd}'
         * 'toDigits() precision not an integer: {sd}'
         * 'toDigits() rounding mode not an integer: {rm}'
         * 'toDigits() rounding mode out of range: {rm}'
         */
        P.toDigits = function ( sd, rm ) {
            var n = new BigNumber(this);
            sd = sd == null || !isValidInt( sd, 1, MAX, 18, 'precision' ) ? null : sd | 0;
            rm = rm == null || !isValidInt( rm, 0, 8, 18, roundingMode ) ? ROUNDING_MODE : rm | 0;
            return sd ? round( n, sd, rm ) : n;
        };


        /*
         * Return a string representing the value of this BigNumber in exponential notation and
         * rounded using ROUNDING_MODE to dp fixed decimal places.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toExponential() decimal places not an integer: {dp}'
         * 'toExponential() decimal places out of range: {dp}'
         * 'toExponential() rounding mode not an integer: {rm}'
         * 'toExponential() rounding mode out of range: {rm}'
         */
        P.toExponential = function ( dp, rm ) {
            return format( this,
              dp != null && isValidInt( dp, 0, MAX, 19 ) ? ~~dp + 1 : null, rm, 19 );
        };


        /*
         * Return a string representing the value of this BigNumber in fixed-point notation rounding
         * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
         *
         * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
         * but e.g. (-0.00001).toFixed(0) is '-0'.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toFixed() decimal places not an integer: {dp}'
         * 'toFixed() decimal places out of range: {dp}'
         * 'toFixed() rounding mode not an integer: {rm}'
         * 'toFixed() rounding mode out of range: {rm}'
         */
        P.toFixed = function ( dp, rm ) {
            return format( this, dp != null && isValidInt( dp, 0, MAX, 20 )
              ? ~~dp + this.e + 1 : null, rm, 20 );
        };


        /*
         * Return a string representing the value of this BigNumber in fixed-point notation rounded
         * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
         * of the FORMAT object (see BigNumber.config).
         *
         * FORMAT = {
         *      decimalSeparator : '.',
         *      groupSeparator : ',',
         *      groupSize : 3,
         *      secondaryGroupSize : 0,
         *      fractionGroupSeparator : '\xA0',    // non-breaking space
         *      fractionGroupSize : 0
         * };
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toFormat() decimal places not an integer: {dp}'
         * 'toFormat() decimal places out of range: {dp}'
         * 'toFormat() rounding mode not an integer: {rm}'
         * 'toFormat() rounding mode out of range: {rm}'
         */
        P.toFormat = function ( dp, rm ) {
            var str = format( this, dp != null && isValidInt( dp, 0, MAX, 21 )
              ? ~~dp + this.e + 1 : null, rm, 21 );

            if ( this.c ) {
                var i,
                    arr = str.split('.'),
                    g1 = +FORMAT.groupSize,
                    g2 = +FORMAT.secondaryGroupSize,
                    groupSeparator = FORMAT.groupSeparator,
                    intPart = arr[0],
                    fractionPart = arr[1],
                    isNeg = this.s < 0,
                    intDigits = isNeg ? intPart.slice(1) : intPart,
                    len = intDigits.length;

                if (g2) i = g1, g1 = g2, g2 = i, len -= i;

                if ( g1 > 0 && len > 0 ) {
                    i = len % g1 || g1;
                    intPart = intDigits.substr( 0, i );

                    for ( ; i < len; i += g1 ) {
                        intPart += groupSeparator + intDigits.substr( i, g1 );
                    }

                    if ( g2 > 0 ) intPart += groupSeparator + intDigits.slice(i);
                    if (isNeg) intPart = '-' + intPart;
                }

                str = fractionPart
                  ? intPart + FORMAT.decimalSeparator + ( ( g2 = +FORMAT.fractionGroupSize )
                    ? fractionPart.replace( new RegExp( '\\d{' + g2 + '}\\B', 'g' ),
                      '$&' + FORMAT.fractionGroupSeparator )
                    : fractionPart )
                  : intPart;
            }

            return str;
        };


        /*
         * Return a string array representing the value of this BigNumber as a simple fraction with
         * an integer numerator and an integer denominator. The denominator will be a positive
         * non-zero value less than or equal to the specified maximum denominator. If a maximum
         * denominator is not specified, the denominator will be the lowest value necessary to
         * represent the number exactly.
         *
         * [md] {number|string|BigNumber} Integer >= 1 and < Infinity. The maximum denominator.
         *
         * 'toFraction() max denominator not an integer: {md}'
         * 'toFraction() max denominator out of range: {md}'
         */
        P.toFraction = function (md) {
            var arr, d0, d2, e, exp, n, n0, q, s,
                k = ERRORS,
                x = this,
                xc = x.c,
                d = new BigNumber(ONE),
                n1 = d0 = new BigNumber(ONE),
                d1 = n0 = new BigNumber(ONE);

            if ( md != null ) {
                ERRORS = false;
                n = new BigNumber(md);
                ERRORS = k;

                if ( !( k = n.isInt() ) || n.lt(ONE) ) {

                    if (ERRORS) {
                        raise( 22,
                          'max denominator ' + ( k ? 'out of range' : 'not an integer' ), md );
                    }

                    // ERRORS is false:
                    // If md is a finite non-integer >= 1, round it to an integer and use it.
                    md = !k && n.c && round( n, n.e + 1, 1 ).gte(ONE) ? n : null;
                }
            }

            if ( !xc ) return x.toString();
            s = coeffToString(xc);

            // Determine initial denominator.
            // d is a power of 10 and the minimum max denominator that specifies the value exactly.
            e = d.e = s.length - x.e - 1;
            d.c[0] = POWS_TEN[ ( exp = e % LOG_BASE ) < 0 ? LOG_BASE + exp : exp ];
            md = !md || n.cmp(d) > 0 ? ( e > 0 ? d : n1 ) : n;

            exp = MAX_EXP;
            MAX_EXP = 1 / 0;
            n = new BigNumber(s);

            // n0 = d1 = 0
            n0.c[0] = 0;

            for ( ; ; )  {
                q = div( n, d, 0, 1 );
                d2 = d0.plus( q.times(d1) );
                if ( d2.cmp(md) == 1 ) break;
                d0 = d1;
                d1 = d2;
                n1 = n0.plus( q.times( d2 = n1 ) );
                n0 = d2;
                d = n.minus( q.times( d2 = d ) );
                n = d2;
            }

            d2 = div( md.minus(d0), d1, 0, 1 );
            n0 = n0.plus( d2.times(n1) );
            d0 = d0.plus( d2.times(d1) );
            n0.s = n1.s = x.s;
            e *= 2;

            // Determine which fraction is closer to x, n0/d0 or n1/d1
            arr = div( n1, d1, e, ROUNDING_MODE ).minus(x).abs().cmp(
                  div( n0, d0, e, ROUNDING_MODE ).minus(x).abs() ) < 1
                    ? [ n1.toString(), d1.toString() ]
                    : [ n0.toString(), d0.toString() ];

            MAX_EXP = exp;
            return arr;
        };


        /*
         * Return the value of this BigNumber converted to a number primitive.
         */
        P.toNumber = function () {
            return +this;
        };


        /*
         * Return a BigNumber whose value is the value of this BigNumber raised to the power n.
         * If m is present, return the result modulo m.
         * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
         * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using
         * ROUNDING_MODE.
         *
         * The modular power operation works efficiently when x, n, and m are positive integers,
         * otherwise it is equivalent to calculating x.toPower(n).modulo(m) (with POW_PRECISION 0).
         *
         * n {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
         * [m] {number|string|BigNumber} The modulus.
         *
         * 'pow() exponent not an integer: {n}'
         * 'pow() exponent out of range: {n}'
         *
         * Performs 54 loop iterations for n of 9007199254740991.
         */
        P.toPower = P.pow = function ( n, m ) {
            var k, y, z,
                i = mathfloor( n < 0 ? -n : +n ),
                x = this;

            if ( m != null ) {
                id = 23;
                m = new BigNumber(m);
            }

            // Pass ±Infinity to Math.pow if exponent is out of range.
            if ( !isValidInt( n, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 23, 'exponent' ) &&
              ( !isFinite(n) || i > MAX_SAFE_INTEGER && ( n /= 0 ) ||
                parseFloat(n) != n && !( n = NaN ) ) || n == 0 ) {
                k = Math.pow( +x, n );
                return new BigNumber( m ? k % m : k );
            }

            if (m) {
                if ( n > 1 && x.gt(ONE) && x.isInt() && m.gt(ONE) && m.isInt() ) {
                    x = x.mod(m);
                } else {
                    z = m;

                    // Nullify m so only a single mod operation is performed at the end.
                    m = null;
                }
            } else if (POW_PRECISION) {

                // Truncating each coefficient array to a length of k after each multiplication
                // equates to truncating significant digits to POW_PRECISION + [28, 41],
                // i.e. there will be a minimum of 28 guard digits retained.
                // (Using + 1.5 would give [9, 21] guard digits.)
                k = mathceil( POW_PRECISION / LOG_BASE + 2 );
            }

            y = new BigNumber(ONE);

            for ( ; ; ) {
                if ( i % 2 ) {
                    y = y.times(x);
                    if ( !y.c ) break;
                    if (k) {
                        if ( y.c.length > k ) y.c.length = k;
                    } else if (m) {
                        y = y.mod(m);
                    }
                }

                i = mathfloor( i / 2 );
                if ( !i ) break;
                x = x.times(x);
                if (k) {
                    if ( x.c && x.c.length > k ) x.c.length = k;
                } else if (m) {
                    x = x.mod(m);
                }
            }

            if (m) return y;
            if ( n < 0 ) y = ONE.div(y);

            return z ? y.mod(z) : k ? round( y, POW_PRECISION, ROUNDING_MODE ) : y;
        };


        /*
         * Return a string representing the value of this BigNumber rounded to sd significant digits
         * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
         * necessary to represent the integer part of the value in fixed-point notation, then use
         * exponential notation.
         *
         * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toPrecision() precision not an integer: {sd}'
         * 'toPrecision() precision out of range: {sd}'
         * 'toPrecision() rounding mode not an integer: {rm}'
         * 'toPrecision() rounding mode out of range: {rm}'
         */
        P.toPrecision = function ( sd, rm ) {
            return format( this, sd != null && isValidInt( sd, 1, MAX, 24, 'precision' )
              ? sd | 0 : null, rm, 24 );
        };


        /*
         * Return a string representing the value of this BigNumber in base b, or base 10 if b is
         * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
         * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
         * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
         * TO_EXP_NEG, return exponential notation.
         *
         * [b] {number} Integer, 2 to 64 inclusive.
         *
         * 'toString() base not an integer: {b}'
         * 'toString() base out of range: {b}'
         */
        P.toString = function (b) {
            var str,
                n = this,
                s = n.s,
                e = n.e;

            // Infinity or NaN?
            if ( e === null ) {

                if (s) {
                    str = 'Infinity';
                    if ( s < 0 ) str = '-' + str;
                } else {
                    str = 'NaN';
                }
            } else {
                str = coeffToString( n.c );

                if ( b == null || !isValidInt( b, 2, 64, 25, 'base' ) ) {
                    str = e <= TO_EXP_NEG || e >= TO_EXP_POS
                      ? toExponential( str, e )
                      : toFixedPoint( str, e );
                } else {
                    str = convertBase( toFixedPoint( str, e ), b | 0, 10, s );
                }

                if ( s < 0 && n.c[0] ) str = '-' + str;
            }

            return str;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber truncated to a whole
         * number.
         */
        P.truncated = P.trunc = function () {
            return round( new BigNumber(this), this.e + 1, 1 );
        };


        /*
         * Return as toString, but do not accept a base argument, and include the minus sign for
         * negative zero.
         */
        P.valueOf = P.toJSON = function () {
            var str,
                n = this,
                e = n.e;

            if ( e === null ) return n.toString();

            str = coeffToString( n.c );

            str = e <= TO_EXP_NEG || e >= TO_EXP_POS
                ? toExponential( str, e )
                : toFixedPoint( str, e );

            return n.s < 0 ? '-' + str : str;
        };


        P.isBigNumber = true;

        if ( config != null ) BigNumber.config(config);

        return BigNumber;
    }


    // PRIVATE HELPER FUNCTIONS


    function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
    }


    // Return a coefficient array as a string of base 10 digits.
    function coeffToString(a) {
        var s, z,
            i = 1,
            j = a.length,
            r = a[0] + '';

        for ( ; i < j; ) {
            s = a[i++] + '';
            z = LOG_BASE - s.length;
            for ( ; z--; s = '0' + s );
            r += s;
        }

        // Determine trailing zeros.
        for ( j = r.length; r.charCodeAt(--j) === 48; );
        return r.slice( 0, j + 1 || 1 );
    }


    // Compare the value of BigNumbers x and y.
    function compare( x, y ) {
        var a, b,
            xc = x.c,
            yc = y.c,
            i = x.s,
            j = y.s,
            k = x.e,
            l = y.e;

        // Either NaN?
        if ( !i || !j ) return null;

        a = xc && !xc[0];
        b = yc && !yc[0];

        // Either zero?
        if ( a || b ) return a ? b ? 0 : -j : i;

        // Signs differ?
        if ( i != j ) return i;

        a = i < 0;
        b = k == l;

        // Either Infinity?
        if ( !xc || !yc ) return b ? 0 : !xc ^ a ? 1 : -1;

        // Compare exponents.
        if ( !b ) return k > l ^ a ? 1 : -1;

        j = ( k = xc.length ) < ( l = yc.length ) ? k : l;

        // Compare digit by digit.
        for ( i = 0; i < j; i++ ) if ( xc[i] != yc[i] ) return xc[i] > yc[i] ^ a ? 1 : -1;

        // Compare lengths.
        return k == l ? 0 : k > l ^ a ? 1 : -1;
    }


    /*
     * Return true if n is a valid number in range, otherwise false.
     * Use for argument validation when ERRORS is false.
     * Note: parseInt('1e+1') == 1 but parseFloat('1e+1') == 10.
     */
    function intValidatorNoErrors( n, min, max ) {
        return ( n = truncate(n) ) >= min && n <= max;
    }


    function isArray(obj) {
        return Object.prototype.toString.call(obj) == '[object Array]';
    }


    /*
     * Convert string of baseIn to an array of numbers of baseOut.
     * Eg. convertBase('255', 10, 16) returns [15, 15].
     * Eg. convertBase('ff', 16, 10) returns [2, 5, 5].
     */
    function toBaseOut( str, baseIn, baseOut ) {
        var j,
            arr = [0],
            arrL,
            i = 0,
            len = str.length;

        for ( ; i < len; ) {
            for ( arrL = arr.length; arrL--; arr[arrL] *= baseIn );
            arr[ j = 0 ] += ALPHABET.indexOf( str.charAt( i++ ) );

            for ( ; j < arr.length; j++ ) {

                if ( arr[j] > baseOut - 1 ) {
                    if ( arr[j + 1] == null ) arr[j + 1] = 0;
                    arr[j + 1] += arr[j] / baseOut | 0;
                    arr[j] %= baseOut;
                }
            }
        }

        return arr.reverse();
    }


    function toExponential( str, e ) {
        return ( str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str ) +
          ( e < 0 ? 'e' : 'e+' ) + e;
    }


    function toFixedPoint( str, e ) {
        var len, z;

        // Negative exponent?
        if ( e < 0 ) {

            // Prepend zeros.
            for ( z = '0.'; ++e; z += '0' );
            str = z + str;

        // Positive exponent
        } else {
            len = str.length;

            // Append zeros.
            if ( ++e > len ) {
                for ( z = '0', e -= len; --e; z += '0' );
                str += z;
            } else if ( e < len ) {
                str = str.slice( 0, e ) + '.' + str.slice(e);
            }
        }

        return str;
    }


    function truncate(n) {
        n = parseFloat(n);
        return n < 0 ? mathceil(n) : mathfloor(n);
    }


    // EXPORT


    BigNumber = constructorFactory();
    BigNumber['default'] = BigNumber.BigNumber = BigNumber;


    // AMD.
    if ( typeof define == 'function' && define.amd ) {
        define( function () { return BigNumber; } );

    // Node.js and other environments that support module.exports.
    } else if (  true && module.exports ) {
        module.exports = BigNumber;

    // Browser.
    } else {
        if ( !globalObj ) globalObj = typeof self != 'undefined' ? self : Function('return this')();
        globalObj.BigNumber = BigNumber;
    }
})(this);


/***/ }),

/***/ 8524:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

// ripple-secret-codec v1.0 github.com/professorhantzen/ripple-secret-codec
// Encodes/decodes Ripple secrets to and from hexadecimal or decimal seeds.
// NO WARRANTY EXPRESSED/IMPLIED, USE AT OWN RISK, NO RESPONSIBILITY TAKEN.
// npm i ripple-secret-codec; const rs_api = require('ripple-secret-codec')
// const secret_from_hex_seed = rs_api.encodeHex('<string: hex int. seed>')
// const secret_from_dec_seed = rs_api.encodeDec('<string: dec int. seed>')
// const hex_seed_from_secret = rs_api.decodeHex('<string: ripple secret>')
// const dec_seed_from_secret = rs_api.decodeDec('<string: ripple secret>')
// Hex int. seeds within range: 0x0000 - 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
// Dec int. seeds within range: 0 - 340282366920938463463374607431768211455

const alphab = 'rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz'
const base58 = __nccwpck_require__(3358)(alphab)
const bignum = __nccwpck_require__(5406)
const crypto = __nccwpck_require__(6113)
const sha256 = (data) => { return crypto.createHash('sha256').update(data).digest() }
const prefix = Buffer.from([33])
const pad128 = '0000000000000000000000000000000000000000' // zero pad for hex input and dec output

function encodeHex(r_seed_hex){
	const p_seed_hex = Buffer.concat([prefix, Buffer.from((pad128 + r_seed_hex.toString(16)).substr(-32), 'hex')])
	const chksum_hex = sha256(sha256(p_seed_hex)).slice(0,4)
	const secret_hex = Buffer.concat([p_seed_hex, chksum_hex])
	const secret_b58 = base58.encode(secret_hex)
	return { secret_hex, secret_b58 }
}

function decodeHex(secret_b58){
	const secret_hex = Buffer.from(base58.decode(secret_b58))
	const chksum_hex = secret_hex.slice(-4)
	const r_seed_hex = secret_hex.slice(1,17).toString('hex')
	return { secret_hex, r_seed_hex }
}

function encodeDec(r_seed_dec){
	const big_decnum = new bignum(r_seed_dec)
	const r_seed_hex = big_decnum.toString(16)
	return encodeHex(r_seed_hex)
}

function decodeDec(secret_b58){
	const decode_obj = decodeHex(secret_b58)
	const secret_hex = decode_obj.secret_hex
	const r_seed_hex = decode_obj.r_seed_hex
	const bignum_dec = new bignum(r_seed_hex, 16)
	const r_seed_dec = (pad128 + bignum_dec.toString(10)).substr(-39)
	return { secret_hex, r_seed_dec }
}

module.exports = { encodeHex, decodeHex, encodeDec, decodeDec }


/***/ }),

/***/ 6621:
/***/ ((module, exports, __nccwpck_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __nccwpck_require__(4300)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ 8400:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const os = __nccwpck_require__(2037);
const tty = __nccwpck_require__(6224);
const hasFlag = __nccwpck_require__(6125);

const {env} = process;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	forceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = 1;
}

if ('FORCE_COLOR' in env) {
	if (env.FORCE_COLOR === 'true') {
		forceColor = 1;
	} else if (env.FORCE_COLOR === 'false') {
		forceColor = 0;
	} else {
		forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, streamIsTTY) {
	if (forceColor === 0) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream, stream && stream.isTTY);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};


/***/ }),

/***/ 5303:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


try {
  module.exports = __nccwpck_require__(5000)
} catch (err) {
  module.exports = __nccwpck_require__(6738)
}


/***/ }),

/***/ 6738:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const BN = __nccwpck_require__(3693)
const EC = (__nccwpck_require__(1517).ec)
const secp256k1 = new EC('secp256k1')
const deterministicGenerateK = __nccwpck_require__(9482)

const ZERO32 = Buffer.alloc(32, 0)
const EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex')
const EC_P = Buffer.from('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f', 'hex')

const n = secp256k1.curve.n
const nDiv2 = n.shrn(1)
const G = secp256k1.curve.g

const THROW_BAD_PRIVATE = 'Expected Private'
const THROW_BAD_POINT = 'Expected Point'
const THROW_BAD_TWEAK = 'Expected Tweak'
const THROW_BAD_HASH = 'Expected Hash'
const THROW_BAD_SIGNATURE = 'Expected Signature'
const THROW_BAD_EXTRA_DATA = 'Expected Extra Data (32 bytes)'

function isScalar (x) {
  return Buffer.isBuffer(x) && x.length === 32
}

function isOrderScalar (x) {
  if (!isScalar(x)) return false
  return x.compare(EC_GROUP_ORDER) < 0 // < G
}

function isPoint (p) {
  if (!Buffer.isBuffer(p)) return false
  if (p.length < 33) return false

  const t = p[0]
  const x = p.slice(1, 33)
  if (x.compare(ZERO32) === 0) return false
  if (x.compare(EC_P) >= 0) return false
  if ((t === 0x02 || t === 0x03) && p.length === 33) {
    try { decodeFrom(p) } catch (e) { return false } // TODO: temporary
    return true
  }

  const y = p.slice(33)
  if (y.compare(ZERO32) === 0) return false
  if (y.compare(EC_P) >= 0) return false
  if (t === 0x04 && p.length === 65) return true
  return false
}

function __isPointCompressed (p) {
  return p[0] !== 0x04
}

function isPointCompressed (p) {
  if (!isPoint(p)) return false
  return __isPointCompressed(p)
}

function isPrivate (x) {
  if (!isScalar(x)) return false
  return x.compare(ZERO32) > 0 && // > 0
    x.compare(EC_GROUP_ORDER) < 0 // < G
}

function isSignature (value) {
  const r = value.slice(0, 32)
  const s = value.slice(32, 64)
  return Buffer.isBuffer(value) && value.length === 64 &&
    r.compare(EC_GROUP_ORDER) < 0 &&
    s.compare(EC_GROUP_ORDER) < 0
}

function assumeCompression (value, pubkey) {
  if (value === undefined && pubkey !== undefined) return __isPointCompressed(pubkey)
  if (value === undefined) return true
  return value
}

function fromBuffer (d) { return new BN(d) }
function toBuffer (d) { return d.toArrayLike(Buffer, 'be', 32) }
function decodeFrom (P) { return secp256k1.curve.decodePoint(P) }
function getEncoded (P, compressed) { return Buffer.from(P._encode(compressed)) }

function pointAdd (pA, pB, __compressed) {
  if (!isPoint(pA)) throw new TypeError(THROW_BAD_POINT)
  if (!isPoint(pB)) throw new TypeError(THROW_BAD_POINT)

  const a = decodeFrom(pA)
  const b = decodeFrom(pB)
  const pp = a.add(b)
  if (pp.isInfinity()) return null

  const compressed = assumeCompression(__compressed, pA)
  return getEncoded(pp, compressed)
}

function pointAddScalar (p, tweak, __compressed) {
  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)
  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)

  const compressed = assumeCompression(__compressed, p)
  const pp = decodeFrom(p)
  if (tweak.compare(ZERO32) === 0) return getEncoded(pp, compressed)

  const tt = fromBuffer(tweak)
  const qq = G.mul(tt)
  const uu = pp.add(qq)
  if (uu.isInfinity()) return null

  return getEncoded(uu, compressed)
}

function pointCompress (p, __compressed) {
  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)

  const pp = decodeFrom(p)
  if (pp.isInfinity()) throw new TypeError(THROW_BAD_POINT)

  const compressed = assumeCompression(__compressed, p)

  return getEncoded(pp, compressed)
}

function pointFromScalar (d, __compressed) {
  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)

  const dd = fromBuffer(d)
  const pp = G.mul(dd)
  if (pp.isInfinity()) return null

  const compressed = assumeCompression(__compressed)
  return getEncoded(pp, compressed)
}

function pointMultiply (p, tweak, __compressed) {
  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)
  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)

  const compressed = assumeCompression(__compressed, p)
  const pp = decodeFrom(p)
  const tt = fromBuffer(tweak)
  const qq = pp.mul(tt)
  if (qq.isInfinity()) return null

  return getEncoded(qq, compressed)
}

function privateAdd (d, tweak) {
  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)
  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)

  const dd = fromBuffer(d)
  const tt = fromBuffer(tweak)
  const dt = toBuffer(dd.add(tt).umod(n))
  if (!isPrivate(dt)) return null

  return dt
}

function privateSub (d, tweak) {
  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)
  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)

  const dd = fromBuffer(d)
  const tt = fromBuffer(tweak)
  const dt = toBuffer(dd.sub(tt).umod(n))
  if (!isPrivate(dt)) return null

  return dt
}

function sign (hash, x) {
  return __sign(hash, x)
}

function signWithEntropy (hash, x, addData) {
  return __sign(hash, x, addData)
}

function __sign (hash, x, addData) {
  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH)
  if (!isPrivate(x)) throw new TypeError(THROW_BAD_PRIVATE)
  if (addData !== undefined && !isScalar(addData)) throw new TypeError(THROW_BAD_EXTRA_DATA)

  const d = fromBuffer(x)
  const e = fromBuffer(hash)

  let r, s
  const checkSig = function (k) {
    const kI = fromBuffer(k)
    const Q = G.mul(kI)

    if (Q.isInfinity()) return false

    r = Q.x.umod(n)
    if (r.isZero() === 0) return false

    s = kI
      .invm(n)
      .mul(e.add(d.mul(r)))
      .umod(n)
    if (s.isZero() === 0) return false

    return true
  }

  deterministicGenerateK(hash, x, checkSig, isPrivate, addData)

  // enforce low S values, see bip62: 'low s values in signatures'
  if (s.cmp(nDiv2) > 0) {
    s = n.sub(s)
  }

  const buffer = Buffer.allocUnsafe(64)
  toBuffer(r).copy(buffer, 0)
  toBuffer(s).copy(buffer, 32)
  return buffer
}

function verify (hash, q, signature, strict) {
  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH)
  if (!isPoint(q)) throw new TypeError(THROW_BAD_POINT)

  // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1] (1, isSignature enforces '< n - 1')
  if (!isSignature(signature)) throw new TypeError(THROW_BAD_SIGNATURE)

  const Q = decodeFrom(q)
  const r = fromBuffer(signature.slice(0, 32))
  const s = fromBuffer(signature.slice(32, 64))

  if (strict && s.cmp(nDiv2) > 0) {
    return false
  }

  // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1] (2, enforces '> 0')
  if (r.gtn(0) <= 0 /* || r.compareTo(n) >= 0 */) return false
  if (s.gtn(0) <= 0 /* || s.compareTo(n) >= 0 */) return false

  // 1.4.2 H = Hash(M), already done by the user
  // 1.4.3 e = H
  const e = fromBuffer(hash)

  // Compute s^-1
  const sInv = s.invm(n)

  // 1.4.4 Compute u1 = es^−1 mod n
  //               u2 = rs^−1 mod n
  const u1 = e.mul(sInv).umod(n)
  const u2 = r.mul(sInv).umod(n)

  // 1.4.5 Compute R = (xR, yR)
  //               R = u1G + u2Q
  const R = G.mulAdd(u1, Q, u2)

  // 1.4.5 (cont.) Enforce R is not at infinity
  if (R.isInfinity()) return false

  // 1.4.6 Convert the field element R.x to an integer
  const xR = R.x

  // 1.4.7 Set v = xR mod n
  const v = xR.umod(n)

  // 1.4.8 If v = r, output "valid", and if v != r, output "invalid"
  return v.eq(r)
}

module.exports = {
  isPoint,
  isPointCompressed,
  isPrivate,
  pointAdd,
  pointAddScalar,
  pointCompress,
  pointFromScalar,
  pointMultiply,
  privateAdd,
  privateSub,
  sign,
  signWithEntropy,
  verify
}


/***/ }),

/***/ 5000:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let binding = require(__nccwpck_require__.ab + "build/Release/secp256k1.node")
delete binding.path

// NaN drops function names, add them for is* (via toJSON)
for (let key in binding) {
  if (key.indexOf('is') !== 0) continue

  binding[key].toJSON = function () { return key }
}

module.exports = binding


/***/ }),

/***/ 9482:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const createHmac = __nccwpck_require__(9922)

const ONE1 = Buffer.alloc(1, 1)
const ZERO1 = Buffer.alloc(1, 0)

// https://tools.ietf.org/html/rfc6979#section-3.2
function deterministicGenerateK (hash, x, checkSig, isPrivate, extraEntropy) {
  // Step A, ignored as hash already provided
  // Step B
  // Step C
  let k = Buffer.alloc(32, 0)
  let v = Buffer.alloc(32, 1)

  // Step D
  k = createHmac('sha256', k)
    .update(v)
    .update(ZERO1)
    .update(x)
    .update(hash)
    .update(extraEntropy || '')
    .digest()

  // Step E
  v = createHmac('sha256', k).update(v).digest()

  // Step F
  k = createHmac('sha256', k)
    .update(v)
    .update(ONE1)
    .update(x)
    .update(hash)
    .update(extraEntropy || '')
    .digest()

  // Step G
  v = createHmac('sha256', k).update(v).digest()

  // Step H1/H2a, ignored as tlen === qlen (256 bit)
  // Step H2b
  v = createHmac('sha256', k).update(v).digest()

  let T = v

  // Step H3, repeat until T is within the interval [1, n - 1] and is suitable for ECDSA
  while (!isPrivate(T) || !checkSig(T)) {
    k = createHmac('sha256', k)
      .update(v)
      .update(ZERO1)
      .digest()

    v = createHmac('sha256', k).update(v).digest()

    // Step H1/H2a, again, ignored as tlen === qlen (256 bit)
    // Step H2b again
    v = createHmac('sha256', k).update(v).digest()
    T = v
  }

  return T
}

module.exports = deterministicGenerateK


/***/ }),

/***/ 4021:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/**
 * Convert a typed array to a Buffer without a copy
 *
 * Author:   Feross Aboukhadijeh <https://feross.org>
 * License:  MIT
 *
 * `npm install typedarray-to-buffer`
 */

var isTypedArray = (__nccwpck_require__(4980).strict)

module.exports = function typedarrayToBuffer (arr) {
  if (isTypedArray(arr)) {
    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer
    var buf = Buffer.from(arr.buffer)
    if (arr.byteLength !== arr.buffer.byteLength) {
      // Respect the "view", i.e. byteOffset and byteLength, without doing a copy
      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength)
    }
    return buf
  } else {
    // Pass through all other types to `Buffer.from`
    return Buffer.from(arr)
  }
}


/***/ }),

/***/ 2580:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var native = __nccwpck_require__(5926)

function getTypeName (fn) {
  return fn.name || fn.toString().match(/function (.*?)\s*\(/)[1]
}

function getValueTypeName (value) {
  return native.Nil(value) ? '' : getTypeName(value.constructor)
}

function getValue (value) {
  if (native.Function(value)) return ''
  if (native.String(value)) return JSON.stringify(value)
  if (value && native.Object(value)) return ''
  return value
}

function captureStackTrace (e, t) {
  if (Error.captureStackTrace) {
    Error.captureStackTrace(e, t)
  }
}

function tfJSON (type) {
  if (native.Function(type)) return type.toJSON ? type.toJSON() : getTypeName(type)
  if (native.Array(type)) return 'Array'
  if (type && native.Object(type)) return 'Object'

  return type !== undefined ? type : ''
}

function tfErrorString (type, value, valueTypeName) {
  var valueJson = getValue(value)

  return 'Expected ' + tfJSON(type) + ', got' +
    (valueTypeName !== '' ? ' ' + valueTypeName : '') +
    (valueJson !== '' ? ' ' + valueJson : '')
}

function TfTypeError (type, value, valueTypeName) {
  valueTypeName = valueTypeName || getValueTypeName(value)
  this.message = tfErrorString(type, value, valueTypeName)

  captureStackTrace(this, TfTypeError)
  this.__type = type
  this.__value = value
  this.__valueTypeName = valueTypeName
}

TfTypeError.prototype = Object.create(Error.prototype)
TfTypeError.prototype.constructor = TfTypeError

function tfPropertyErrorString (type, label, name, value, valueTypeName) {
  var description = '" of type '
  if (label === 'key') description = '" with key type '

  return tfErrorString('property "' + tfJSON(name) + description + tfJSON(type), value, valueTypeName)
}

function TfPropertyTypeError (type, property, label, value, valueTypeName) {
  if (type) {
    valueTypeName = valueTypeName || getValueTypeName(value)
    this.message = tfPropertyErrorString(type, label, property, value, valueTypeName)
  } else {
    this.message = 'Unexpected property "' + property + '"'
  }

  captureStackTrace(this, TfTypeError)
  this.__label = label
  this.__property = property
  this.__type = type
  this.__value = value
  this.__valueTypeName = valueTypeName
}

TfPropertyTypeError.prototype = Object.create(Error.prototype)
TfPropertyTypeError.prototype.constructor = TfTypeError

function tfCustomError (expected, actual) {
  return new TfTypeError(expected, {}, actual)
}

function tfSubError (e, property, label) {
  // sub child?
  if (e instanceof TfPropertyTypeError) {
    property = property + '.' + e.__property

    e = new TfPropertyTypeError(
      e.__type, property, e.__label, e.__value, e.__valueTypeName
    )

  // child?
  } else if (e instanceof TfTypeError) {
    e = new TfPropertyTypeError(
      e.__type, property, label, e.__value, e.__valueTypeName
    )
  }

  captureStackTrace(e)
  return e
}

module.exports = {
  TfTypeError: TfTypeError,
  TfPropertyTypeError: TfPropertyTypeError,
  tfCustomError: tfCustomError,
  tfSubError: tfSubError,
  tfJSON: tfJSON,
  getValueTypeName: getValueTypeName
}


/***/ }),

/***/ 4613:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var NATIVE = __nccwpck_require__(5926)
var ERRORS = __nccwpck_require__(2580)

function _Buffer (value) {
  return Buffer.isBuffer(value)
}

function Hex (value) {
  return typeof value === 'string' && /^([0-9a-f]{2})+$/i.test(value)
}

function _LengthN (type, length) {
  var name = type.toJSON()

  function Length (value) {
    if (!type(value)) return false
    if (value.length === length) return true

    throw ERRORS.tfCustomError(name + '(Length: ' + length + ')', name + '(Length: ' + value.length + ')')
  }
  Length.toJSON = function () { return name }

  return Length
}

var _ArrayN = _LengthN.bind(null, NATIVE.Array)
var _BufferN = _LengthN.bind(null, _Buffer)
var _HexN = _LengthN.bind(null, Hex)
var _StringN = _LengthN.bind(null, NATIVE.String)

function Range (a, b, f) {
  f = f || NATIVE.Number
  function _range (value, strict) {
    return f(value, strict) && (value > a) && (value < b)
  }
  _range.toJSON = function () {
    return `${f.toJSON()} between [${a}, ${b}]`
  }
  return _range
}

var INT53_MAX = Math.pow(2, 53) - 1

function Finite (value) {
  return typeof value === 'number' && isFinite(value)
}
function Int8 (value) { return ((value << 24) >> 24) === value }
function Int16 (value) { return ((value << 16) >> 16) === value }
function Int32 (value) { return (value | 0) === value }
function Int53 (value) {
  return typeof value === 'number' &&
    value >= -INT53_MAX &&
    value <= INT53_MAX &&
    Math.floor(value) === value
}
function UInt8 (value) { return (value & 0xff) === value }
function UInt16 (value) { return (value & 0xffff) === value }
function UInt32 (value) { return (value >>> 0) === value }
function UInt53 (value) {
  return typeof value === 'number' &&
    value >= 0 &&
    value <= INT53_MAX &&
    Math.floor(value) === value
}

var types = {
  ArrayN: _ArrayN,
  Buffer: _Buffer,
  BufferN: _BufferN,
  Finite: Finite,
  Hex: Hex,
  HexN: _HexN,
  Int8: Int8,
  Int16: Int16,
  Int32: Int32,
  Int53: Int53,
  Range: Range,
  StringN: _StringN,
  UInt8: UInt8,
  UInt16: UInt16,
  UInt32: UInt32,
  UInt53: UInt53
}

for (var typeName in types) {
  types[typeName].toJSON = function (t) {
    return t
  }.bind(null, typeName)
}

module.exports = types


/***/ }),

/***/ 8158:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var ERRORS = __nccwpck_require__(2580)
var NATIVE = __nccwpck_require__(5926)

// short-hand
var tfJSON = ERRORS.tfJSON
var TfTypeError = ERRORS.TfTypeError
var TfPropertyTypeError = ERRORS.TfPropertyTypeError
var tfSubError = ERRORS.tfSubError
var getValueTypeName = ERRORS.getValueTypeName

var TYPES = {
  arrayOf: function arrayOf (type, options) {
    type = compile(type)
    options = options || {}

    function _arrayOf (array, strict) {
      if (!NATIVE.Array(array)) return false
      if (NATIVE.Nil(array)) return false
      if (options.minLength !== undefined && array.length < options.minLength) return false
      if (options.maxLength !== undefined && array.length > options.maxLength) return false
      if (options.length !== undefined && array.length !== options.length) return false

      return array.every(function (value, i) {
        try {
          return typeforce(type, value, strict)
        } catch (e) {
          throw tfSubError(e, i)
        }
      })
    }
    _arrayOf.toJSON = function () {
      var str = '[' + tfJSON(type) + ']'
      if (options.length !== undefined) {
        str += '{' + options.length + '}'
      } else if (options.minLength !== undefined || options.maxLength !== undefined) {
        str += '{' +
          (options.minLength === undefined ? 0 : options.minLength) + ',' +
          (options.maxLength === undefined ? Infinity : options.maxLength) + '}'
      }
      return str
    }

    return _arrayOf
  },

  maybe: function maybe (type) {
    type = compile(type)

    function _maybe (value, strict) {
      return NATIVE.Nil(value) || type(value, strict, maybe)
    }
    _maybe.toJSON = function () { return '?' + tfJSON(type) }

    return _maybe
  },

  map: function map (propertyType, propertyKeyType) {
    propertyType = compile(propertyType)
    if (propertyKeyType) propertyKeyType = compile(propertyKeyType)

    function _map (value, strict) {
      if (!NATIVE.Object(value)) return false
      if (NATIVE.Nil(value)) return false

      for (var propertyName in value) {
        try {
          if (propertyKeyType) {
            typeforce(propertyKeyType, propertyName, strict)
          }
        } catch (e) {
          throw tfSubError(e, propertyName, 'key')
        }

        try {
          var propertyValue = value[propertyName]
          typeforce(propertyType, propertyValue, strict)
        } catch (e) {
          throw tfSubError(e, propertyName)
        }
      }

      return true
    }

    if (propertyKeyType) {
      _map.toJSON = function () {
        return '{' + tfJSON(propertyKeyType) + ': ' + tfJSON(propertyType) + '}'
      }
    } else {
      _map.toJSON = function () { return '{' + tfJSON(propertyType) + '}' }
    }

    return _map
  },

  object: function object (uncompiled) {
    var type = {}

    for (var typePropertyName in uncompiled) {
      type[typePropertyName] = compile(uncompiled[typePropertyName])
    }

    function _object (value, strict) {
      if (!NATIVE.Object(value)) return false
      if (NATIVE.Nil(value)) return false

      var propertyName

      try {
        for (propertyName in type) {
          var propertyType = type[propertyName]
          var propertyValue = value[propertyName]

          typeforce(propertyType, propertyValue, strict)
        }
      } catch (e) {
        throw tfSubError(e, propertyName)
      }

      if (strict) {
        for (propertyName in value) {
          if (type[propertyName]) continue

          throw new TfPropertyTypeError(undefined, propertyName)
        }
      }

      return true
    }
    _object.toJSON = function () { return tfJSON(type) }

    return _object
  },

  anyOf: function anyOf () {
    var types = [].slice.call(arguments).map(compile)

    function _anyOf (value, strict) {
      return types.some(function (type) {
        try {
          return typeforce(type, value, strict)
        } catch (e) {
          return false
        }
      })
    }
    _anyOf.toJSON = function () { return types.map(tfJSON).join('|') }

    return _anyOf
  },

  allOf: function allOf () {
    var types = [].slice.call(arguments).map(compile)

    function _allOf (value, strict) {
      return types.every(function (type) {
        try {
          return typeforce(type, value, strict)
        } catch (e) {
          return false
        }
      })
    }
    _allOf.toJSON = function () { return types.map(tfJSON).join(' & ') }

    return _allOf
  },

  quacksLike: function quacksLike (type) {
    function _quacksLike (value) {
      return type === getValueTypeName(value)
    }
    _quacksLike.toJSON = function () { return type }

    return _quacksLike
  },

  tuple: function tuple () {
    var types = [].slice.call(arguments).map(compile)

    function _tuple (values, strict) {
      if (NATIVE.Nil(values)) return false
      if (NATIVE.Nil(values.length)) return false
      if (strict && (values.length !== types.length)) return false

      return types.every(function (type, i) {
        try {
          return typeforce(type, values[i], strict)
        } catch (e) {
          throw tfSubError(e, i)
        }
      })
    }
    _tuple.toJSON = function () { return '(' + types.map(tfJSON).join(', ') + ')' }

    return _tuple
  },

  value: function value (expected) {
    function _value (actual) {
      return actual === expected
    }
    _value.toJSON = function () { return expected }

    return _value
  }
}

// TODO: deprecate
TYPES.oneOf = TYPES.anyOf

function compile (type) {
  if (NATIVE.String(type)) {
    if (type[0] === '?') return TYPES.maybe(type.slice(1))

    return NATIVE[type] || TYPES.quacksLike(type)
  } else if (type && NATIVE.Object(type)) {
    if (NATIVE.Array(type)) {
      if (type.length !== 1) throw new TypeError('Expected compile() parameter of type Array of length 1')
      return TYPES.arrayOf(type[0])
    }

    return TYPES.object(type)
  } else if (NATIVE.Function(type)) {
    return type
  }

  return TYPES.value(type)
}

function typeforce (type, value, strict, surrogate) {
  if (NATIVE.Function(type)) {
    if (type(value, strict)) return true

    throw new TfTypeError(surrogate || type, value)
  }

  // JIT
  return typeforce(compile(type), value, strict)
}

// assign types to typeforce function
for (var typeName in NATIVE) {
  typeforce[typeName] = NATIVE[typeName]
}

for (typeName in TYPES) {
  typeforce[typeName] = TYPES[typeName]
}

var EXTRA = __nccwpck_require__(4613)
for (typeName in EXTRA) {
  typeforce[typeName] = EXTRA[typeName]
}

typeforce.compile = compile
typeforce.TfTypeError = TfTypeError
typeforce.TfPropertyTypeError = TfPropertyTypeError

module.exports = typeforce


/***/ }),

/***/ 5926:
/***/ ((module) => {

var types = {
  Array: function (value) { return value !== null && value !== undefined && value.constructor === Array },
  Boolean: function (value) { return typeof value === 'boolean' },
  Function: function (value) { return typeof value === 'function' },
  Nil: function (value) { return value === undefined || value === null },
  Number: function (value) { return typeof value === 'number' },
  Object: function (value) { return typeof value === 'object' },
  String: function (value) { return typeof value === 'string' },
  '': function () { return true }
}

// TODO: deprecate
types.Null = types.Nil

for (var typeName in types) {
  types[typeName].toJSON = function (t) {
    return t
  }.bind(null, typeName)
}

module.exports = types


/***/ }),

/***/ 9372:
/***/ ((module) => {

"use strict";


/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */
function isValidUTF8(buf) {
  const len = buf.length;
  let i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0x00) {  // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {  // 110xxxxx 10xxxxxx
      if (
        i + 1 === len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i] & 0xfe) === 0xc0  // overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {  // 1110xxxx 10xxxxxx 10xxxxxx
      if (
        i + 2 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 ||  // overlong
        buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0  // surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {  // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (
        i + 3 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i + 3] & 0xc0) !== 0x80 ||
        buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 ||  // overlong
        buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4  // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

module.exports = isValidUTF8;


/***/ }),

/***/ 3045:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


try {
  module.exports = require(__nccwpck_require__.ab + "prebuilds/linux-x64/node.napi1.node");
} catch (e) {
  module.exports = __nccwpck_require__(9372);
}


/***/ }),

/***/ 8590:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(3149);

/***/ }),

/***/ 9998:
/***/ ((module) => {

/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var Deprecation = {
    disableWarnings: false,

    deprecationWarningMap: {

    },

    warn: function(deprecationName) {
        if (!this.disableWarnings && this.deprecationWarningMap[deprecationName]) {
            console.warn('DEPRECATION WARNING: ' + this.deprecationWarningMap[deprecationName]);
            this.deprecationWarningMap[deprecationName] = false;
        }
    }
};

module.exports = Deprecation;


/***/ }),

/***/ 9290:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var WebSocketClient = __nccwpck_require__(3996);
var toBuffer = __nccwpck_require__(4021);
var yaeti = __nccwpck_require__(8707);


const CONNECTING = 0;
const OPEN = 1;
const CLOSING = 2;
const CLOSED = 3;


module.exports = W3CWebSocket;


function W3CWebSocket(url, protocols, origin, headers, requestOptions, clientConfig) {
    // Make this an EventTarget.
    yaeti.EventTarget.call(this);

    // Sanitize clientConfig.
    clientConfig = clientConfig || {};
    clientConfig.assembleFragments = true;  // Required in the W3C API.

    var self = this;

    this._url = url;
    this._readyState = CONNECTING;
    this._protocol = undefined;
    this._extensions = '';
    this._bufferedAmount = 0;  // Hack, always 0.
    this._binaryType = 'arraybuffer';  // TODO: Should be 'blob' by default, but Node has no Blob.

    // The WebSocketConnection instance.
    this._connection = undefined;

    // WebSocketClient instance.
    this._client = new WebSocketClient(clientConfig);

    this._client.on('connect', function(connection) {
        onConnect.call(self, connection);
    });

    this._client.on('connectFailed', function() {
        onConnectFailed.call(self);
    });

    this._client.connect(url, protocols, origin, headers, requestOptions);
}


// Expose W3C read only attributes.
Object.defineProperties(W3CWebSocket.prototype, {
    url:            { get: function() { return this._url;            } },
    readyState:     { get: function() { return this._readyState;     } },
    protocol:       { get: function() { return this._protocol;       } },
    extensions:     { get: function() { return this._extensions;     } },
    bufferedAmount: { get: function() { return this._bufferedAmount; } }
});


// Expose W3C write/read attributes.
Object.defineProperties(W3CWebSocket.prototype, {
    binaryType: {
        get: function() {
            return this._binaryType;
        },
        set: function(type) {
            // TODO: Just 'arraybuffer' supported.
            if (type !== 'arraybuffer') {
                throw new SyntaxError('just "arraybuffer" type allowed for "binaryType" attribute');
            }
            this._binaryType = type;
        }
    }
});


// Expose W3C readyState constants into the WebSocket instance as W3C states.
[['CONNECTING',CONNECTING], ['OPEN',OPEN], ['CLOSING',CLOSING], ['CLOSED',CLOSED]].forEach(function(property) {
    Object.defineProperty(W3CWebSocket.prototype, property[0], {
        get: function() { return property[1]; }
    });
});

// Also expose W3C readyState constants into the WebSocket class (not defined by the W3C,
// but there are so many libs relying on them).
[['CONNECTING',CONNECTING], ['OPEN',OPEN], ['CLOSING',CLOSING], ['CLOSED',CLOSED]].forEach(function(property) {
    Object.defineProperty(W3CWebSocket, property[0], {
        get: function() { return property[1]; }
    });
});


W3CWebSocket.prototype.send = function(data) {
    if (this._readyState !== OPEN) {
        throw new Error('cannot call send() while not connected');
    }

    // Text.
    if (typeof data === 'string' || data instanceof String) {
        this._connection.sendUTF(data);
    }
    // Binary.
    else {
        // Node Buffer.
        if (data instanceof Buffer) {
            this._connection.sendBytes(data);
        }
        // If ArrayBuffer or ArrayBufferView convert it to Node Buffer.
        else if (data.byteLength || data.byteLength === 0) {
            data = toBuffer(data);
            this._connection.sendBytes(data);
        }
        else {
            throw new Error('unknown binary data:', data);
        }
    }
};


W3CWebSocket.prototype.close = function(code, reason) {
    switch(this._readyState) {
        case CONNECTING:
            // NOTE: We don't have the WebSocketConnection instance yet so no
            // way to close the TCP connection.
            // Artificially invoke the onConnectFailed event.
            onConnectFailed.call(this);
            // And close if it connects after a while.
            this._client.on('connect', function(connection) {
                if (code) {
                    connection.close(code, reason);
                } else {
                    connection.close();
                }
            });
            break;
        case OPEN:
            this._readyState = CLOSING;
            if (code) {
                this._connection.close(code, reason);
            } else {
                this._connection.close();
            }
            break;
        case CLOSING:
        case CLOSED:
            break;
    }
};


/**
 * Private API.
 */


function createCloseEvent(code, reason) {
    var event = new yaeti.Event('close');

    event.code = code;
    event.reason = reason;
    event.wasClean = (typeof code === 'undefined' || code === 1000);

    return event;
}


function createMessageEvent(data) {
    var event = new yaeti.Event('message');

    event.data = data;

    return event;
}


function onConnect(connection) {
    var self = this;

    this._readyState = OPEN;
    this._connection = connection;
    this._protocol = connection.protocol;
    this._extensions = connection.extensions;

    this._connection.on('close', function(code, reason) {
        onClose.call(self, code, reason);
    });

    this._connection.on('message', function(msg) {
        onMessage.call(self, msg);
    });

    this.dispatchEvent(new yaeti.Event('open'));
}


function onConnectFailed() {
    destroy.call(this);
    this._readyState = CLOSED;

    try {
        this.dispatchEvent(new yaeti.Event('error'));
    } finally {
        this.dispatchEvent(createCloseEvent(1006, 'connection failed'));
    }
}


function onClose(code, reason) {
    destroy.call(this);
    this._readyState = CLOSED;

    this.dispatchEvent(createCloseEvent(code, reason || ''));
}


function onMessage(message) {
    if (message.utf8Data) {
        this.dispatchEvent(createMessageEvent(message.utf8Data));
    }
    else if (message.binaryData) {
        // Must convert from Node Buffer to ArrayBuffer.
        // TODO: or to a Blob (which does not exist in Node!).
        if (this.binaryType === 'arraybuffer') {
            var buffer = message.binaryData;
            var arraybuffer = new ArrayBuffer(buffer.length);
            var view = new Uint8Array(arraybuffer);
            for (var i=0, len=buffer.length; i<len; ++i) {
                view[i] = buffer[i];
            }
            this.dispatchEvent(createMessageEvent(arraybuffer));
        }
    }
}


function destroy() {
    this._client.removeAllListeners();
    if (this._connection) {
        this._connection.removeAllListeners();
    }
}


/***/ }),

/***/ 3996:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var utils = __nccwpck_require__(7192);
var extend = utils.extend;
var util = __nccwpck_require__(3837);
var EventEmitter = (__nccwpck_require__(2361).EventEmitter);
var http = __nccwpck_require__(3685);
var https = __nccwpck_require__(5687);
var url = __nccwpck_require__(7310);
var crypto = __nccwpck_require__(6113);
var WebSocketConnection = __nccwpck_require__(8042);
var bufferAllocUnsafe = utils.bufferAllocUnsafe;

var protocolSeparators = [
    '(', ')', '<', '>', '@',
    ',', ';', ':', '\\', '\"',
    '/', '[', ']', '?', '=',
    '{', '}', ' ', String.fromCharCode(9)
];

var excludedTlsOptions = ['hostname','port','method','path','headers'];

function WebSocketClient(config) {
    // Superclass Constructor
    EventEmitter.call(this);

    // TODO: Implement extensions

    this.config = {
        // 1MiB max frame size.
        maxReceivedFrameSize: 0x100000,

        // 8MiB max message size, only applicable if
        // assembleFragments is true
        maxReceivedMessageSize: 0x800000,

        // Outgoing messages larger than fragmentationThreshold will be
        // split into multiple fragments.
        fragmentOutgoingMessages: true,

        // Outgoing frames are fragmented if they exceed this threshold.
        // Default is 16KiB
        fragmentationThreshold: 0x4000,

        // Which version of the protocol to use for this session.  This
        // option will be removed once the protocol is finalized by the IETF
        // It is only available to ease the transition through the
        // intermediate draft protocol versions.
        // At present, it only affects the name of the Origin header.
        webSocketVersion: 13,

        // If true, fragmented messages will be automatically assembled
        // and the full message will be emitted via a 'message' event.
        // If false, each frame will be emitted via a 'frame' event and
        // the application will be responsible for aggregating multiple
        // fragmented frames.  Single-frame messages will emit a 'message'
        // event in addition to the 'frame' event.
        // Most users will want to leave this set to 'true'
        assembleFragments: true,

        // The Nagle Algorithm makes more efficient use of network resources
        // by introducing a small delay before sending small packets so that
        // multiple messages can be batched together before going onto the
        // wire.  This however comes at the cost of latency, so the default
        // is to disable it.  If you don't need low latency and are streaming
        // lots of small messages, you can change this to 'false'
        disableNagleAlgorithm: true,

        // The number of milliseconds to wait after sending a close frame
        // for an acknowledgement to come back before giving up and just
        // closing the socket.
        closeTimeout: 5000,

        // Options to pass to https.connect if connecting via TLS
        tlsOptions: {}
    };

    if (config) {
        var tlsOptions;
        if (config.tlsOptions) {
          tlsOptions = config.tlsOptions;
          delete config.tlsOptions;
        }
        else {
          tlsOptions = {};
        }
        extend(this.config, config);
        extend(this.config.tlsOptions, tlsOptions);
    }

    this._req = null;
    
    switch (this.config.webSocketVersion) {
        case 8:
        case 13:
            break;
        default:
            throw new Error('Requested webSocketVersion is not supported. Allowed values are 8 and 13.');
    }
}

util.inherits(WebSocketClient, EventEmitter);

WebSocketClient.prototype.connect = function(requestUrl, protocols, origin, headers, extraRequestOptions) {
    var self = this;
    
    if (typeof(protocols) === 'string') {
        if (protocols.length > 0) {
            protocols = [protocols];
        }
        else {
            protocols = [];
        }
    }
    if (!(protocols instanceof Array)) {
        protocols = [];
    }
    this.protocols = protocols;
    this.origin = origin;

    if (typeof(requestUrl) === 'string') {
        this.url = url.parse(requestUrl);
    }
    else {
        this.url = requestUrl; // in case an already parsed url is passed in.
    }
    if (!this.url.protocol) {
        throw new Error('You must specify a full WebSocket URL, including protocol.');
    }
    if (!this.url.host) {
        throw new Error('You must specify a full WebSocket URL, including hostname. Relative URLs are not supported.');
    }

    this.secure = (this.url.protocol === 'wss:');

    // validate protocol characters:
    this.protocols.forEach(function(protocol) {
        for (var i=0; i < protocol.length; i ++) {
            var charCode = protocol.charCodeAt(i);
            var character = protocol.charAt(i);
            if (charCode < 0x0021 || charCode > 0x007E || protocolSeparators.indexOf(character) !== -1) {
                throw new Error('Protocol list contains invalid character "' + String.fromCharCode(charCode) + '"');
            }
        }
    });

    var defaultPorts = {
        'ws:': '80',
        'wss:': '443'
    };

    if (!this.url.port) {
        this.url.port = defaultPorts[this.url.protocol];
    }

    var nonce = bufferAllocUnsafe(16);
    for (var i=0; i < 16; i++) {
        nonce[i] = Math.round(Math.random()*0xFF);
    }
    this.base64nonce = nonce.toString('base64');

    var hostHeaderValue = this.url.hostname;
    if ((this.url.protocol === 'ws:' && this.url.port !== '80') ||
        (this.url.protocol === 'wss:' && this.url.port !== '443'))  {
        hostHeaderValue += (':' + this.url.port);
    }

    var reqHeaders = {};
    if (this.secure && this.config.tlsOptions.hasOwnProperty('headers')) {
      // Allow for additional headers to be provided when connecting via HTTPS
      extend(reqHeaders, this.config.tlsOptions.headers);
    }
    if (headers) {
      // Explicitly provided headers take priority over any from tlsOptions
      extend(reqHeaders, headers);
    }
    extend(reqHeaders, {
        'Upgrade': 'websocket',
        'Connection': 'Upgrade',
        'Sec-WebSocket-Version': this.config.webSocketVersion.toString(10),
        'Sec-WebSocket-Key': this.base64nonce,
        'Host': reqHeaders.Host || hostHeaderValue
    });

    if (this.protocols.length > 0) {
        reqHeaders['Sec-WebSocket-Protocol'] = this.protocols.join(', ');
    }
    if (this.origin) {
        if (this.config.webSocketVersion === 13) {
            reqHeaders['Origin'] = this.origin;
        }
        else if (this.config.webSocketVersion === 8) {
            reqHeaders['Sec-WebSocket-Origin'] = this.origin;
        }
    }

    // TODO: Implement extensions

    var pathAndQuery;
    // Ensure it begins with '/'.
    if (this.url.pathname) {
        pathAndQuery = this.url.path;
    }
    else if (this.url.path) {
        pathAndQuery = '/' + this.url.path;
    }
    else {
        pathAndQuery = '/';
    }

    function handleRequestError(error) {
        self._req = null;
        self.emit('connectFailed', error);
    }

    var requestOptions = {
        agent: false
    };
    if (extraRequestOptions) {
        extend(requestOptions, extraRequestOptions);
    }
    // These options are always overridden by the library.  The user is not
    // allowed to specify these directly.
    extend(requestOptions, {
        hostname: this.url.hostname,
        port: this.url.port,
        method: 'GET',
        path: pathAndQuery,
        headers: reqHeaders
    });
    if (this.secure) {
        var tlsOptions = this.config.tlsOptions;
        for (var key in tlsOptions) {
            if (tlsOptions.hasOwnProperty(key) && excludedTlsOptions.indexOf(key) === -1) {
                requestOptions[key] = tlsOptions[key];
            }
        }
    }

    var req = this._req = (this.secure ? https : http).request(requestOptions);
    req.on('upgrade', function handleRequestUpgrade(response, socket, head) {
        self._req = null;
        req.removeListener('error', handleRequestError);
        self.socket = socket;
        self.response = response;
        self.firstDataChunk = head;
        self.validateHandshake();
    });
    req.on('error', handleRequestError);

    req.on('response', function(response) {
        self._req = null;
        if (utils.eventEmitterListenerCount(self, 'httpResponse') > 0) {
            self.emit('httpResponse', response, self);
            if (response.socket) {
                response.socket.end();
            }
        }
        else {
            var headerDumpParts = [];
            for (var headerName in response.headers) {
                headerDumpParts.push(headerName + ': ' + response.headers[headerName]);
            }
            self.failHandshake(
                'Server responded with a non-101 status: ' +
                response.statusCode + ' ' + response.statusMessage +
                '\nResponse Headers Follow:\n' +
                headerDumpParts.join('\n') + '\n'
            );
        }
    });
    req.end();
};

WebSocketClient.prototype.validateHandshake = function() {
    var headers = this.response.headers;

    if (this.protocols.length > 0) {
        this.protocol = headers['sec-websocket-protocol'];
        if (this.protocol) {
            if (this.protocols.indexOf(this.protocol) === -1) {
                this.failHandshake('Server did not respond with a requested protocol.');
                return;
            }
        }
        else {
            this.failHandshake('Expected a Sec-WebSocket-Protocol header.');
            return;
        }
    }

    if (!(headers['connection'] && headers['connection'].toLocaleLowerCase() === 'upgrade')) {
        this.failHandshake('Expected a Connection: Upgrade header from the server');
        return;
    }

    if (!(headers['upgrade'] && headers['upgrade'].toLocaleLowerCase() === 'websocket')) {
        this.failHandshake('Expected an Upgrade: websocket header from the server');
        return;
    }

    var sha1 = crypto.createHash('sha1');
    sha1.update(this.base64nonce + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');
    var expectedKey = sha1.digest('base64');

    if (!headers['sec-websocket-accept']) {
        this.failHandshake('Expected Sec-WebSocket-Accept header from server');
        return;
    }

    if (headers['sec-websocket-accept'] !== expectedKey) {
        this.failHandshake('Sec-WebSocket-Accept header from server didn\'t match expected value of ' + expectedKey);
        return;
    }

    // TODO: Support extensions

    this.succeedHandshake();
};

WebSocketClient.prototype.failHandshake = function(errorDescription) {
    if (this.socket && this.socket.writable) {
        this.socket.end();
    }
    this.emit('connectFailed', new Error(errorDescription));
};

WebSocketClient.prototype.succeedHandshake = function() {
    var connection = new WebSocketConnection(this.socket, [], this.protocol, true, this.config);

    connection.webSocketVersion = this.config.webSocketVersion;
    connection._addSocketEventListeners();

    this.emit('connect', connection);
    if (this.firstDataChunk.length > 0) {
        connection.handleSocketData(this.firstDataChunk);
    }
    this.firstDataChunk = null;
};

WebSocketClient.prototype.abort = function() {
    if (this._req) {
        this._req.abort();
    }
};

module.exports = WebSocketClient;


/***/ }),

/***/ 8042:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var util = __nccwpck_require__(3837);
var utils = __nccwpck_require__(7192);
var EventEmitter = (__nccwpck_require__(2361).EventEmitter);
var WebSocketFrame = __nccwpck_require__(2806);
var BufferList = __nccwpck_require__(5824);
var isValidUTF8 = __nccwpck_require__(3045);
var bufferAllocUnsafe = utils.bufferAllocUnsafe;
var bufferFromString = utils.bufferFromString;

// Connected, fully-open, ready to send and receive frames
const STATE_OPEN = 'open';
// Received a close frame from the remote peer
const STATE_PEER_REQUESTED_CLOSE = 'peer_requested_close';
// Sent close frame to remote peer.  No further data can be sent.
const STATE_ENDING = 'ending';
// Connection is fully closed.  No further data can be sent or received.
const STATE_CLOSED = 'closed';

var setImmediateImpl = ('setImmediate' in global) ?
                            global.setImmediate.bind(global) :
                            process.nextTick.bind(process);

var idCounter = 0;

function WebSocketConnection(socket, extensions, protocol, maskOutgoingPackets, config) {
    this._debug = utils.BufferingLogger('websocket:connection', ++idCounter);
    this._debug('constructor');
    
    if (this._debug.enabled) {
        instrumentSocketForDebugging(this, socket);
    }
    
    // Superclass Constructor
    EventEmitter.call(this);

    this._pingListenerCount = 0;
    this.on('newListener', function(ev) {
        if (ev === 'ping'){
            this._pingListenerCount++;
        }
      }).on('removeListener', function(ev) {
        if (ev === 'ping') {
            this._pingListenerCount--;
        }
    });

    this.config = config;
    this.socket = socket;
    this.protocol = protocol;
    this.extensions = extensions;
    this.remoteAddress = socket.remoteAddress;
    this.closeReasonCode = -1;
    this.closeDescription = null;
    this.closeEventEmitted = false;

    // We have to mask outgoing packets if we're acting as a WebSocket client.
    this.maskOutgoingPackets = maskOutgoingPackets;

    // We re-use the same buffers for the mask and frame header for all frames
    // received on each connection to avoid a small memory allocation for each
    // frame.
    this.maskBytes = bufferAllocUnsafe(4);
    this.frameHeader = bufferAllocUnsafe(10);

    // the BufferList will handle the data streaming in
    this.bufferList = new BufferList();

    // Prepare for receiving first frame
    this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
    this.fragmentationSize = 0; // data received so far...
    this.frameQueue = [];
    
    // Various bits of connection state
    this.connected = true;
    this.state = STATE_OPEN;
    this.waitingForCloseResponse = false;
    // Received TCP FIN, socket's readable stream is finished.
    this.receivedEnd = false;

    this.closeTimeout = this.config.closeTimeout;
    this.assembleFragments = this.config.assembleFragments;
    this.maxReceivedMessageSize = this.config.maxReceivedMessageSize;

    this.outputBufferFull = false;
    this.inputPaused = false;
    this.receivedDataHandler = this.processReceivedData.bind(this);
    this._closeTimerHandler = this.handleCloseTimer.bind(this);

    // Disable nagle algorithm?
    this.socket.setNoDelay(this.config.disableNagleAlgorithm);

    // Make sure there is no socket inactivity timeout
    this.socket.setTimeout(0);

    if (this.config.keepalive && !this.config.useNativeKeepalive) {
        if (typeof(this.config.keepaliveInterval) !== 'number') {
            throw new Error('keepaliveInterval must be specified and numeric ' +
                            'if keepalive is true.');
        }
        this._keepaliveTimerHandler = this.handleKeepaliveTimer.bind(this);
        this.setKeepaliveTimer();

        if (this.config.dropConnectionOnKeepaliveTimeout) {
            if (typeof(this.config.keepaliveGracePeriod) !== 'number') {
                throw new Error('keepaliveGracePeriod  must be specified and ' +
                                'numeric if dropConnectionOnKeepaliveTimeout ' +
                                'is true.');
            }
            this._gracePeriodTimerHandler = this.handleGracePeriodTimer.bind(this);
        }
    }
    else if (this.config.keepalive && this.config.useNativeKeepalive) {
        if (!('setKeepAlive' in this.socket)) {
            throw new Error('Unable to use native keepalive: unsupported by ' +
                            'this version of Node.');
        }
        this.socket.setKeepAlive(true, this.config.keepaliveInterval);
    }
    
    // The HTTP Client seems to subscribe to socket error events
    // and re-dispatch them in such a way that doesn't make sense
    // for users of our client, so we want to make sure nobody
    // else is listening for error events on the socket besides us.
    this.socket.removeAllListeners('error');
}

WebSocketConnection.CLOSE_REASON_NORMAL = 1000;
WebSocketConnection.CLOSE_REASON_GOING_AWAY = 1001;
WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR = 1002;
WebSocketConnection.CLOSE_REASON_UNPROCESSABLE_INPUT = 1003;
WebSocketConnection.CLOSE_REASON_RESERVED = 1004; // Reserved value.  Undefined meaning.
WebSocketConnection.CLOSE_REASON_NOT_PROVIDED = 1005; // Not to be used on the wire
WebSocketConnection.CLOSE_REASON_ABNORMAL = 1006; // Not to be used on the wire
WebSocketConnection.CLOSE_REASON_INVALID_DATA = 1007;
WebSocketConnection.CLOSE_REASON_POLICY_VIOLATION = 1008;
WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG = 1009;
WebSocketConnection.CLOSE_REASON_EXTENSION_REQUIRED = 1010;
WebSocketConnection.CLOSE_REASON_INTERNAL_SERVER_ERROR = 1011;
WebSocketConnection.CLOSE_REASON_TLS_HANDSHAKE_FAILED = 1015; // Not to be used on the wire

WebSocketConnection.CLOSE_DESCRIPTIONS = {
    1000: 'Normal connection closure',
    1001: 'Remote peer is going away',
    1002: 'Protocol error',
    1003: 'Unprocessable input',
    1004: 'Reserved',
    1005: 'Reason not provided',
    1006: 'Abnormal closure, no further detail available',
    1007: 'Invalid data received',
    1008: 'Policy violation',
    1009: 'Message too big',
    1010: 'Extension requested by client is required',
    1011: 'Internal Server Error',
    1015: 'TLS Handshake Failed'
};

function validateCloseReason(code) {
    if (code < 1000) {
        // Status codes in the range 0-999 are not used
        return false;
    }
    if (code >= 1000 && code <= 2999) {
        // Codes from 1000 - 2999 are reserved for use by the protocol.  Only
        // a few codes are defined, all others are currently illegal.
        return [1000, 1001, 1002, 1003, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015].indexOf(code) !== -1;
    }
    if (code >= 3000 && code <= 3999) {
        // Reserved for use by libraries, frameworks, and applications.
        // Should be registered with IANA.  Interpretation of these codes is
        // undefined by the WebSocket protocol.
        return true;
    }
    if (code >= 4000 && code <= 4999) {
        // Reserved for private use.  Interpretation of these codes is
        // undefined by the WebSocket protocol.
        return true;
    }
    if (code >= 5000) {
        return false;
    }
}

util.inherits(WebSocketConnection, EventEmitter);

WebSocketConnection.prototype._addSocketEventListeners = function() {
    this.socket.on('error', this.handleSocketError.bind(this));
    this.socket.on('end', this.handleSocketEnd.bind(this));
    this.socket.on('close', this.handleSocketClose.bind(this));
    this.socket.on('drain', this.handleSocketDrain.bind(this));
    this.socket.on('pause', this.handleSocketPause.bind(this));
    this.socket.on('resume', this.handleSocketResume.bind(this));
    this.socket.on('data', this.handleSocketData.bind(this));
};

// set or reset the keepalive timer when data is received.
WebSocketConnection.prototype.setKeepaliveTimer = function() {
    this._debug('setKeepaliveTimer');
    if (!this.config.keepalive  || this.config.useNativeKeepalive) { return; }
    this.clearKeepaliveTimer();
    this.clearGracePeriodTimer();
    this._keepaliveTimeoutID = setTimeout(this._keepaliveTimerHandler, this.config.keepaliveInterval);
};

WebSocketConnection.prototype.clearKeepaliveTimer = function() {
    if (this._keepaliveTimeoutID) {
        clearTimeout(this._keepaliveTimeoutID);
    }
};

// No data has been received within config.keepaliveTimeout ms.
WebSocketConnection.prototype.handleKeepaliveTimer = function() {
    this._debug('handleKeepaliveTimer');
    this._keepaliveTimeoutID = null;
    this.ping();

    // If we are configured to drop connections if the client doesn't respond
    // then set the grace period timer.
    if (this.config.dropConnectionOnKeepaliveTimeout) {
        this.setGracePeriodTimer();
    }
    else {
        // Otherwise reset the keepalive timer to send the next ping.
        this.setKeepaliveTimer();
    }
};

WebSocketConnection.prototype.setGracePeriodTimer = function() {
    this._debug('setGracePeriodTimer');
    this.clearGracePeriodTimer();
    this._gracePeriodTimeoutID = setTimeout(this._gracePeriodTimerHandler, this.config.keepaliveGracePeriod);
};

WebSocketConnection.prototype.clearGracePeriodTimer = function() {
    if (this._gracePeriodTimeoutID) {
        clearTimeout(this._gracePeriodTimeoutID);
    }
};

WebSocketConnection.prototype.handleGracePeriodTimer = function() {
    this._debug('handleGracePeriodTimer');
    // If this is called, the client has not responded and is assumed dead.
    this._gracePeriodTimeoutID = null;
    this.drop(WebSocketConnection.CLOSE_REASON_ABNORMAL, 'Peer not responding.', true);
};

WebSocketConnection.prototype.handleSocketData = function(data) {
    this._debug('handleSocketData');
    // Reset the keepalive timer when receiving data of any kind.
    this.setKeepaliveTimer();

    // Add received data to our bufferList, which efficiently holds received
    // data chunks in a linked list of Buffer objects.
    this.bufferList.write(data);

    this.processReceivedData();
};

WebSocketConnection.prototype.processReceivedData = function() {
    this._debug('processReceivedData');
    // If we're not connected, we should ignore any data remaining on the buffer.
    if (!this.connected) { return; }

    // Receiving/parsing is expected to be halted when paused.
    if (this.inputPaused) { return; }

    var frame = this.currentFrame;

    // WebSocketFrame.prototype.addData returns true if all data necessary to
    // parse the frame was available.  It returns false if we are waiting for
    // more data to come in on the wire.
    if (!frame.addData(this.bufferList)) { this._debug('-- insufficient data for frame'); return; }

    var self = this;

    // Handle possible parsing errors
    if (frame.protocolError) {
        // Something bad happened.. get rid of this client.
        this._debug('-- protocol error');
        process.nextTick(function() {
            self.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, frame.dropReason);
        });
        return;
    }
    else if (frame.frameTooLarge) {
        this._debug('-- frame too large');
        process.nextTick(function() {
            self.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG, frame.dropReason);
        });
        return;
    }

    // For now since we don't support extensions, all RSV bits are illegal
    if (frame.rsv1 || frame.rsv2 || frame.rsv3) {
        this._debug('-- illegal rsv flag');
        process.nextTick(function() {
            self.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,
              'Unsupported usage of rsv bits without negotiated extension.');
        });
        return;
    }

    if (!this.assembleFragments) {
        this._debug('-- emitting frame');
        process.nextTick(function() { self.emit('frame', frame); });
    }

    process.nextTick(function() { self.processFrame(frame); });
    
    this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);

    // If there's data remaining, schedule additional processing, but yield
    // for now so that other connections have a chance to have their data
    // processed.  We use setImmediate here instead of process.nextTick to
    // explicitly indicate that we wish for other I/O to be handled first.
    if (this.bufferList.length > 0) {
        setImmediateImpl(this.receivedDataHandler);
    }
};

WebSocketConnection.prototype.handleSocketError = function(error) {
    this._debug('handleSocketError: %j', error);
    if (this.state === STATE_CLOSED) {
		// See https://github.com/theturtle32/WebSocket-Node/issues/288
        this._debug('  --- Socket \'error\' after \'close\'');
        return;
    }
    this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;
    this.closeDescription = 'Socket Error: ' + error.syscall + ' ' + error.code;
    this.connected = false;
    this.state = STATE_CLOSED;
    this.fragmentationSize = 0;
    if (utils.eventEmitterListenerCount(this, 'error') > 0) {
        this.emit('error', error);
    }
    this.socket.destroy();
    this._debug.printOutput();
};

WebSocketConnection.prototype.handleSocketEnd = function() {
    this._debug('handleSocketEnd: received socket end.  state = %s', this.state);
    this.receivedEnd = true;
    if (this.state === STATE_CLOSED) {
        // When using the TLS module, sometimes the socket will emit 'end'
        // after it emits 'close'.  I don't think that's correct behavior,
        // but we should deal with it gracefully by ignoring it.
        this._debug('  --- Socket \'end\' after \'close\'');
        return;
    }
    if (this.state !== STATE_PEER_REQUESTED_CLOSE &&
        this.state !== STATE_ENDING) {
      this._debug('  --- UNEXPECTED socket end.');
      this.socket.end();
    }
};

WebSocketConnection.prototype.handleSocketClose = function(hadError) {
    this._debug('handleSocketClose: received socket close');
    this.socketHadError = hadError;
    this.connected = false;
    this.state = STATE_CLOSED;
    // If closeReasonCode is still set to -1 at this point then we must
    // not have received a close frame!!
    if (this.closeReasonCode === -1) {
        this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;
        this.closeDescription = 'Connection dropped by remote peer.';
    }
    this.clearCloseTimer();
    this.clearKeepaliveTimer();
    this.clearGracePeriodTimer();
    if (!this.closeEventEmitted) {
        this.closeEventEmitted = true;
        this._debug('-- Emitting WebSocketConnection close event');
        this.emit('close', this.closeReasonCode, this.closeDescription);
    }
};

WebSocketConnection.prototype.handleSocketDrain = function() {
    this._debug('handleSocketDrain: socket drain event');
    this.outputBufferFull = false;
    this.emit('drain');
};

WebSocketConnection.prototype.handleSocketPause = function() {
    this._debug('handleSocketPause: socket pause event');
    this.inputPaused = true;
    this.emit('pause');
};

WebSocketConnection.prototype.handleSocketResume = function() {
    this._debug('handleSocketResume: socket resume event');
    this.inputPaused = false;
    this.emit('resume');
    this.processReceivedData();
};

WebSocketConnection.prototype.pause = function() {
    this._debug('pause: pause requested');
    this.socket.pause();
};

WebSocketConnection.prototype.resume = function() {
    this._debug('resume: resume requested');
    this.socket.resume();
};

WebSocketConnection.prototype.close = function(reasonCode, description) {
    if (this.connected) {
        this._debug('close: Initating clean WebSocket close sequence.');
        if ('number' !== typeof reasonCode) {
            reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;
        }
        if (!validateCloseReason(reasonCode)) {
            throw new Error('Close code ' + reasonCode + ' is not valid.');
        }
        if ('string' !== typeof description) {
            description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];
        }
        this.closeReasonCode = reasonCode;
        this.closeDescription = description;
        this.setCloseTimer();
        this.sendCloseFrame(this.closeReasonCode, this.closeDescription);
        this.state = STATE_ENDING;
        this.connected = false;
    }
};

WebSocketConnection.prototype.drop = function(reasonCode, description, skipCloseFrame) {
    this._debug('drop');
    if (typeof(reasonCode) !== 'number') {
        reasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;
    }

    if (typeof(description) !== 'string') {
        // If no description is provided, try to look one up based on the
        // specified reasonCode.
        description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];
    }

    this._debug('Forcefully dropping connection. skipCloseFrame: %s, code: %d, description: %s',
        skipCloseFrame, reasonCode, description
    );

    this.closeReasonCode = reasonCode;
    this.closeDescription = description;
    this.frameQueue = [];
    this.fragmentationSize = 0;
    if (!skipCloseFrame) {
        this.sendCloseFrame(reasonCode, description);
    }
    this.connected = false;
    this.state = STATE_CLOSED;
    this.clearCloseTimer();
    this.clearKeepaliveTimer();
    this.clearGracePeriodTimer();

    if (!this.closeEventEmitted) {
        this.closeEventEmitted = true;
        this._debug('Emitting WebSocketConnection close event');
        this.emit('close', this.closeReasonCode, this.closeDescription);
    }
    
    this._debug('Drop: destroying socket');
    this.socket.destroy();
};

WebSocketConnection.prototype.setCloseTimer = function() {
    this._debug('setCloseTimer');
    this.clearCloseTimer();
    this._debug('Setting close timer');
    this.waitingForCloseResponse = true;
    this.closeTimer = setTimeout(this._closeTimerHandler, this.closeTimeout);
};

WebSocketConnection.prototype.clearCloseTimer = function() {
    this._debug('clearCloseTimer');
    if (this.closeTimer) {
        this._debug('Clearing close timer');
        clearTimeout(this.closeTimer);
        this.waitingForCloseResponse = false;
        this.closeTimer = null;
    }
};

WebSocketConnection.prototype.handleCloseTimer = function() {
    this._debug('handleCloseTimer');
    this.closeTimer = null;
    if (this.waitingForCloseResponse) {
        this._debug('Close response not received from client.  Forcing socket end.');
        this.waitingForCloseResponse = false;
        this.state = STATE_CLOSED;
        this.socket.end();
    }
};

WebSocketConnection.prototype.processFrame = function(frame) {
    this._debug('processFrame');
    this._debug(' -- frame: %s', frame);
    
    // Any non-control opcode besides 0x00 (continuation) received in the
    // middle of a fragmented message is illegal.
    if (this.frameQueue.length !== 0 && (frame.opcode > 0x00 && frame.opcode < 0x08)) {
        this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,
          'Illegal frame opcode 0x' + frame.opcode.toString(16) + ' ' +
          'received in middle of fragmented message.');
        return;
    }

    switch(frame.opcode) {
        case 0x02: // WebSocketFrame.BINARY_FRAME
            this._debug('-- Binary Frame');
            if (this.assembleFragments) {
                if (frame.fin) {
                    // Complete single-frame message received
                    this._debug('---- Emitting \'message\' event');
                    this.emit('message', {
                        type: 'binary',
                        binaryData: frame.binaryPayload
                    });
                }
                else {
                    // beginning of a fragmented message
                    this.frameQueue.push(frame);
                    this.fragmentationSize = frame.length;
                }
            }
            break;
        case 0x01: // WebSocketFrame.TEXT_FRAME
            this._debug('-- Text Frame');
            if (this.assembleFragments) {
                if (frame.fin) {
                    if (!isValidUTF8(frame.binaryPayload)) {
                        this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA,
                          'Invalid UTF-8 Data Received');
                        return;
                    }
                    // Complete single-frame message received
                    this._debug('---- Emitting \'message\' event');
                    this.emit('message', {
                        type: 'utf8',
                        utf8Data: frame.binaryPayload.toString('utf8')
                    });
                }
                else {
                    // beginning of a fragmented message
                    this.frameQueue.push(frame);
                    this.fragmentationSize = frame.length;
                }
            }
            break;
        case 0x00: // WebSocketFrame.CONTINUATION
            this._debug('-- Continuation Frame');
            if (this.assembleFragments) {
                if (this.frameQueue.length === 0) {
                    this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,
                      'Unexpected Continuation Frame');
                    return;
                }

                this.fragmentationSize += frame.length;

                if (this.fragmentationSize > this.maxReceivedMessageSize) {
                    this.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG,
                      'Maximum message size exceeded.');
                    return;
                }

                this.frameQueue.push(frame);

                if (frame.fin) {
                    // end of fragmented message, so we process the whole
                    // message now.  We also have to decode the utf-8 data
                    // for text frames after combining all the fragments.
                    var bytesCopied = 0;
                    var binaryPayload = bufferAllocUnsafe(this.fragmentationSize);
                    var opcode = this.frameQueue[0].opcode;
                    this.frameQueue.forEach(function (currentFrame) {
                        currentFrame.binaryPayload.copy(binaryPayload, bytesCopied);
                        bytesCopied += currentFrame.binaryPayload.length;
                    });
                    this.frameQueue = [];
                    this.fragmentationSize = 0;

                    switch (opcode) {
                        case 0x02: // WebSocketOpcode.BINARY_FRAME
                            this.emit('message', {
                                type: 'binary',
                                binaryData: binaryPayload
                            });
                            break;
                        case 0x01: // WebSocketOpcode.TEXT_FRAME
                            if (!isValidUTF8(binaryPayload)) {
                                this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA,
                                  'Invalid UTF-8 Data Received');
                                return;
                            }
                            this.emit('message', {
                                type: 'utf8',
                                utf8Data: binaryPayload.toString('utf8')
                            });
                            break;
                        default:
                            this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,
                              'Unexpected first opcode in fragmentation sequence: 0x' + opcode.toString(16));
                            return;
                    }
                }
            }
            break;
        case 0x09: // WebSocketFrame.PING
            this._debug('-- Ping Frame');

            if (this._pingListenerCount > 0) {
                // logic to emit the ping frame: this is only done when a listener is known to exist
                // Expose a function allowing the user to override the default ping() behavior
                var cancelled = false;
                var cancel = function() { 
                  cancelled = true; 
                };
                this.emit('ping', cancel, frame.binaryPayload);

                // Only send a pong if the client did not indicate that he would like to cancel
                if (!cancelled) {
                    this.pong(frame.binaryPayload);
                }
            }
            else {
                this.pong(frame.binaryPayload);
            }

            break;
        case 0x0A: // WebSocketFrame.PONG
            this._debug('-- Pong Frame');
            this.emit('pong', frame.binaryPayload);
            break;
        case 0x08: // WebSocketFrame.CONNECTION_CLOSE
            this._debug('-- Close Frame');
            if (this.waitingForCloseResponse) {
                // Got response to our request to close the connection.
                // Close is complete, so we just hang up.
                this._debug('---- Got close response from peer.  Completing closing handshake.');
                this.clearCloseTimer();
                this.waitingForCloseResponse = false;
                this.state = STATE_CLOSED;
                this.socket.end();
                return;
            }
            
            this._debug('---- Closing handshake initiated by peer.');
            // Got request from other party to close connection.
            // Send back acknowledgement and then hang up.
            this.state = STATE_PEER_REQUESTED_CLOSE;
            var respondCloseReasonCode;

            // Make sure the close reason provided is legal according to
            // the protocol spec.  Providing no close status is legal.
            // WebSocketFrame sets closeStatus to -1 by default, so if it
            // is still -1, then no status was provided.
            if (frame.invalidCloseFrameLength) {
                this.closeReasonCode = 1005; // 1005 = No reason provided.
                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;
            }
            else if (frame.closeStatus === -1 || validateCloseReason(frame.closeStatus)) {
                this.closeReasonCode = frame.closeStatus;
                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;
            }
            else {
                this.closeReasonCode = frame.closeStatus;
                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;
            }
            
            // If there is a textual description in the close frame, extract it.
            if (frame.binaryPayload.length > 1) {
                if (!isValidUTF8(frame.binaryPayload)) {
                    this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA,
                      'Invalid UTF-8 Data Received');
                    return;
                }
                this.closeDescription = frame.binaryPayload.toString('utf8');
            }
            else {
                this.closeDescription = WebSocketConnection.CLOSE_DESCRIPTIONS[this.closeReasonCode];
            }
            this._debug(
                '------ Remote peer %s - code: %d - %s - close frame payload length: %d',
                this.remoteAddress, this.closeReasonCode,
                this.closeDescription, frame.length
            );
            this._debug('------ responding to remote peer\'s close request.');
            this.sendCloseFrame(respondCloseReasonCode, null);
            this.connected = false;
            break;
        default:
            this._debug('-- Unrecognized Opcode %d', frame.opcode);
            this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,
              'Unrecognized Opcode: 0x' + frame.opcode.toString(16));
            break;
    }
};

WebSocketConnection.prototype.send = function(data, cb) {
    this._debug('send');
    if (Buffer.isBuffer(data)) {
        this.sendBytes(data, cb);
    }
    else if (typeof(data['toString']) === 'function') {
        this.sendUTF(data, cb);
    }
    else {
        throw new Error('Data provided must either be a Node Buffer or implement toString()');
    }
};

WebSocketConnection.prototype.sendUTF = function(data, cb) {
    data = bufferFromString(data.toString(), 'utf8');
    this._debug('sendUTF: %d bytes', data.length);
    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
    frame.opcode = 0x01; // WebSocketOpcode.TEXT_FRAME
    frame.binaryPayload = data;
    this.fragmentAndSend(frame, cb);
};

WebSocketConnection.prototype.sendBytes = function(data, cb) {
    this._debug('sendBytes');
    if (!Buffer.isBuffer(data)) {
        throw new Error('You must pass a Node Buffer object to WebSocketConnection.prototype.sendBytes()');
    }
    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
    frame.opcode = 0x02; // WebSocketOpcode.BINARY_FRAME
    frame.binaryPayload = data;
    this.fragmentAndSend(frame, cb);
};

WebSocketConnection.prototype.ping = function(data) {
    this._debug('ping');
    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
    frame.opcode = 0x09; // WebSocketOpcode.PING
    frame.fin = true;
    if (data) {
        if (!Buffer.isBuffer(data)) {
            data = bufferFromString(data.toString(), 'utf8');
        }
        if (data.length > 125) {
            this._debug('WebSocket: Data for ping is longer than 125 bytes.  Truncating.');
            data = data.slice(0,124);
        }
        frame.binaryPayload = data;
    }
    this.sendFrame(frame);
};

// Pong frames have to echo back the contents of the data portion of the
// ping frame exactly, byte for byte.
WebSocketConnection.prototype.pong = function(binaryPayload) {
    this._debug('pong');
    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
    frame.opcode = 0x0A; // WebSocketOpcode.PONG
    if (Buffer.isBuffer(binaryPayload) && binaryPayload.length > 125) {
        this._debug('WebSocket: Data for pong is longer than 125 bytes.  Truncating.');
        binaryPayload = binaryPayload.slice(0,124);
    }
    frame.binaryPayload = binaryPayload;
    frame.fin = true;
    this.sendFrame(frame);
};

WebSocketConnection.prototype.fragmentAndSend = function(frame, cb) {
    this._debug('fragmentAndSend');
    if (frame.opcode > 0x07) {
        throw new Error('You cannot fragment control frames.');
    }

    var threshold = this.config.fragmentationThreshold;
    var length = frame.binaryPayload.length;

    // Send immediately if fragmentation is disabled or the message is not
    // larger than the fragmentation threshold.
    if (!this.config.fragmentOutgoingMessages || (frame.binaryPayload && length <= threshold)) {
        frame.fin = true;
        this.sendFrame(frame, cb);
        return;
    }
    
    var numFragments = Math.ceil(length / threshold);
    var sentFragments = 0;
    var sentCallback = function fragmentSentCallback(err) {
        if (err) {
            if (typeof cb === 'function') {
                // pass only the first error
                cb(err);
                cb = null;
            }
            return;
        }
        ++sentFragments;
        if ((sentFragments === numFragments) && (typeof cb === 'function')) {
            cb();
        }
    };
    for (var i=1; i <= numFragments; i++) {
        var currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
        
        // continuation opcode except for first frame.
        currentFrame.opcode = (i === 1) ? frame.opcode : 0x00;
        
        // fin set on last frame only
        currentFrame.fin = (i === numFragments);
        
        // length is likely to be shorter on the last fragment
        var currentLength = (i === numFragments) ? length - (threshold * (i-1)) : threshold;
        var sliceStart = threshold * (i-1);
        
        // Slice the right portion of the original payload
        currentFrame.binaryPayload = frame.binaryPayload.slice(sliceStart, sliceStart + currentLength);
        
        this.sendFrame(currentFrame, sentCallback);
    }
};

WebSocketConnection.prototype.sendCloseFrame = function(reasonCode, description, cb) {
    if (typeof(reasonCode) !== 'number') {
        reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;
    }
    
    this._debug('sendCloseFrame state: %s, reasonCode: %d, description: %s', this.state, reasonCode, description);
    
    if (this.state !== STATE_OPEN && this.state !== STATE_PEER_REQUESTED_CLOSE) { return; }
    
    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
    frame.fin = true;
    frame.opcode = 0x08; // WebSocketOpcode.CONNECTION_CLOSE
    frame.closeStatus = reasonCode;
    if (typeof(description) === 'string') {
        frame.binaryPayload = bufferFromString(description, 'utf8');
    }
    
    this.sendFrame(frame, cb);
    this.socket.end();
};

WebSocketConnection.prototype.sendFrame = function(frame, cb) {
    this._debug('sendFrame');
    frame.mask = this.maskOutgoingPackets;
    var flushed = this.socket.write(frame.toBuffer(), cb);
    this.outputBufferFull = !flushed;
    return flushed;
};

module.exports = WebSocketConnection;



function instrumentSocketForDebugging(connection, socket) {
    /* jshint loopfunc: true */
    if (!connection._debug.enabled) { return; }
    
    var originalSocketEmit = socket.emit;
    socket.emit = function(event) {
        connection._debug('||| Socket Event  \'%s\'', event);
        originalSocketEmit.apply(this, arguments);
    };
    
    for (var key in socket) {
        if ('function' !== typeof(socket[key])) { continue; }
        if (['emit'].indexOf(key) !== -1) { continue; }
        (function(key) {
            var original = socket[key];
            if (key === 'on') {
                socket[key] = function proxyMethod__EventEmitter__On() {
                    connection._debug('||| Socket method called:  %s (%s)', key, arguments[0]);
                    return original.apply(this, arguments);
                };
                return;
            }
            socket[key] = function proxyMethod() {
                connection._debug('||| Socket method called:  %s', key);
                return original.apply(this, arguments);
            };
        })(key);
    }
}


/***/ }),

/***/ 2806:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var bufferUtil = __nccwpck_require__(264);
var bufferAllocUnsafe = (__nccwpck_require__(7192).bufferAllocUnsafe);

const DECODE_HEADER = 1;
const WAITING_FOR_16_BIT_LENGTH = 2;
const WAITING_FOR_64_BIT_LENGTH = 3;
const WAITING_FOR_MASK_KEY = 4;
const WAITING_FOR_PAYLOAD = 5;
const COMPLETE = 6;

// WebSocketConnection will pass shared buffer objects for maskBytes and
// frameHeader into the constructor to avoid tons of small memory allocations
// for each frame we have to parse.  This is only used for parsing frames
// we receive off the wire.
function WebSocketFrame(maskBytes, frameHeader, config) {
    this.maskBytes = maskBytes;
    this.frameHeader = frameHeader;
    this.config = config;
    this.maxReceivedFrameSize = config.maxReceivedFrameSize;
    this.protocolError = false;
    this.frameTooLarge = false;
    this.invalidCloseFrameLength = false;
    this.parseState = DECODE_HEADER;
    this.closeStatus = -1;
}

WebSocketFrame.prototype.addData = function(bufferList) {
    if (this.parseState === DECODE_HEADER) {
        if (bufferList.length >= 2) {
            bufferList.joinInto(this.frameHeader, 0, 0, 2);
            bufferList.advance(2);
            var firstByte = this.frameHeader[0];
            var secondByte = this.frameHeader[1];

            this.fin     = Boolean(firstByte  & 0x80);
            this.rsv1    = Boolean(firstByte  & 0x40);
            this.rsv2    = Boolean(firstByte  & 0x20);
            this.rsv3    = Boolean(firstByte  & 0x10);
            this.mask    = Boolean(secondByte & 0x80);

            this.opcode  = firstByte  & 0x0F;
            this.length = secondByte & 0x7F;

            // Control frame sanity check
            if (this.opcode >= 0x08) {
                if (this.length > 125) {
                    this.protocolError = true;
                    this.dropReason = 'Illegal control frame longer than 125 bytes.';
                    return true;
                }
                if (!this.fin) {
                    this.protocolError = true;
                    this.dropReason = 'Control frames must not be fragmented.';
                    return true;
                }
            }

            if (this.length === 126) {
                this.parseState = WAITING_FOR_16_BIT_LENGTH;
            }
            else if (this.length === 127) {
                this.parseState = WAITING_FOR_64_BIT_LENGTH;
            }
            else {
                this.parseState = WAITING_FOR_MASK_KEY;
            }
        }
    }
    if (this.parseState === WAITING_FOR_16_BIT_LENGTH) {
        if (bufferList.length >= 2) {
            bufferList.joinInto(this.frameHeader, 2, 0, 2);
            bufferList.advance(2);
            this.length = this.frameHeader.readUInt16BE(2);
            this.parseState = WAITING_FOR_MASK_KEY;
        }
    }
    else if (this.parseState === WAITING_FOR_64_BIT_LENGTH) {
        if (bufferList.length >= 8) {
            bufferList.joinInto(this.frameHeader, 2, 0, 8);
            bufferList.advance(8);
            var lengthPair = [
              this.frameHeader.readUInt32BE(2),
              this.frameHeader.readUInt32BE(2+4)
            ];

            if (lengthPair[0] !== 0) {
                this.protocolError = true;
                this.dropReason = 'Unsupported 64-bit length frame received';
                return true;
            }
            this.length = lengthPair[1];
            this.parseState = WAITING_FOR_MASK_KEY;
        }
    }

    if (this.parseState === WAITING_FOR_MASK_KEY) {
        if (this.mask) {
            if (bufferList.length >= 4) {
                bufferList.joinInto(this.maskBytes, 0, 0, 4);
                bufferList.advance(4);
                this.parseState = WAITING_FOR_PAYLOAD;
            }
        }
        else {
            this.parseState = WAITING_FOR_PAYLOAD;
        }
    }

    if (this.parseState === WAITING_FOR_PAYLOAD) {
        if (this.length > this.maxReceivedFrameSize) {
            this.frameTooLarge = true;
            this.dropReason = 'Frame size of ' + this.length.toString(10) +
                              ' bytes exceeds maximum accepted frame size';
            return true;
        }

        if (this.length === 0) {
            this.binaryPayload = bufferAllocUnsafe(0);
            this.parseState = COMPLETE;
            return true;
        }
        if (bufferList.length >= this.length) {
            this.binaryPayload = bufferList.take(this.length);
            bufferList.advance(this.length);
            if (this.mask) {
                bufferUtil.unmask(this.binaryPayload, this.maskBytes);
                // xor(this.binaryPayload, this.maskBytes, 0);
            }

            if (this.opcode === 0x08) { // WebSocketOpcode.CONNECTION_CLOSE
                if (this.length === 1) {
                    // Invalid length for a close frame.  Must be zero or at least two.
                    this.binaryPayload = bufferAllocUnsafe(0);
                    this.invalidCloseFrameLength = true;
                }
                if (this.length >= 2) {
                    this.closeStatus = this.binaryPayload.readUInt16BE(0);
                    this.binaryPayload = this.binaryPayload.slice(2);
                }
            }

            this.parseState = COMPLETE;
            return true;
        }
    }
    return false;
};

WebSocketFrame.prototype.throwAwayPayload = function(bufferList) {
    if (bufferList.length >= this.length) {
        bufferList.advance(this.length);
        this.parseState = COMPLETE;
        return true;
    }
    return false;
};

WebSocketFrame.prototype.toBuffer = function(nullMask) {
    var maskKey;
    var headerLength = 2;
    var data;
    var outputPos;
    var firstByte = 0x00;
    var secondByte = 0x00;

    if (this.fin) {
        firstByte |= 0x80;
    }
    if (this.rsv1) {
        firstByte |= 0x40;
    }
    if (this.rsv2) {
        firstByte |= 0x20;
    }
    if (this.rsv3) {
        firstByte |= 0x10;
    }
    if (this.mask) {
        secondByte |= 0x80;
    }

    firstByte |= (this.opcode & 0x0F);

    // the close frame is a special case because the close reason is
    // prepended to the payload data.
    if (this.opcode === 0x08) {
        this.length = 2;
        if (this.binaryPayload) {
            this.length += this.binaryPayload.length;
        }
        data = bufferAllocUnsafe(this.length);
        data.writeUInt16BE(this.closeStatus, 0);
        if (this.length > 2) {
            this.binaryPayload.copy(data, 2);
        }
    }
    else if (this.binaryPayload) {
        data = this.binaryPayload;
        this.length = data.length;
    }
    else {
        this.length = 0;
    }

    if (this.length <= 125) {
        // encode the length directly into the two-byte frame header
        secondByte |= (this.length & 0x7F);
    }
    else if (this.length > 125 && this.length <= 0xFFFF) {
        // Use 16-bit length
        secondByte |= 126;
        headerLength += 2;
    }
    else if (this.length > 0xFFFF) {
        // Use 64-bit length
        secondByte |= 127;
        headerLength += 8;
    }

    var output = bufferAllocUnsafe(this.length + headerLength + (this.mask ? 4 : 0));

    // write the frame header
    output[0] = firstByte;
    output[1] = secondByte;

    outputPos = 2;

    if (this.length > 125 && this.length <= 0xFFFF) {
        // write 16-bit length
        output.writeUInt16BE(this.length, outputPos);
        outputPos += 2;
    }
    else if (this.length > 0xFFFF) {
        // write 64-bit length
        output.writeUInt32BE(0x00000000, outputPos);
        output.writeUInt32BE(this.length, outputPos + 4);
        outputPos += 8;
    }

    if (this.mask) {
        maskKey = nullMask ? 0 : ((Math.random() * 0xFFFFFFFF) >>> 0);
        this.maskBytes.writeUInt32BE(maskKey, 0);

        // write the mask key
        this.maskBytes.copy(output, outputPos);
        outputPos += 4;

        if (data) {
          bufferUtil.mask(data, this.maskBytes, output, outputPos, this.length);
        }
    }
    else if (data) {
        data.copy(output, outputPos);
    }

    return output;
};

WebSocketFrame.prototype.toString = function() {
    return 'Opcode: ' + this.opcode + ', fin: ' + this.fin + ', length: ' + this.length + ', hasPayload: ' + Boolean(this.binaryPayload) + ', masked: ' + this.mask;
};


module.exports = WebSocketFrame;


/***/ }),

/***/ 1908:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var crypto = __nccwpck_require__(6113);
var util = __nccwpck_require__(3837);
var url = __nccwpck_require__(7310);
var EventEmitter = (__nccwpck_require__(2361).EventEmitter);
var WebSocketConnection = __nccwpck_require__(8042);

var headerValueSplitRegExp = /,\s*/;
var headerParamSplitRegExp = /;\s*/;
var headerSanitizeRegExp = /[\r\n]/g;
var xForwardedForSeparatorRegExp = /,\s*/;
var separators = [
    '(', ')', '<', '>', '@',
    ',', ';', ':', '\\', '\"',
    '/', '[', ']', '?', '=',
    '{', '}', ' ', String.fromCharCode(9)
];
var controlChars = [String.fromCharCode(127) /* DEL */];
for (var i=0; i < 31; i ++) {
    /* US-ASCII Control Characters */
    controlChars.push(String.fromCharCode(i));
}

var cookieNameValidateRegEx = /([\x00-\x20\x22\x28\x29\x2c\x2f\x3a-\x3f\x40\x5b-\x5e\x7b\x7d\x7f])/;
var cookieValueValidateRegEx = /[^\x21\x23-\x2b\x2d-\x3a\x3c-\x5b\x5d-\x7e]/;
var cookieValueDQuoteValidateRegEx = /^"[^"]*"$/;
var controlCharsAndSemicolonRegEx = /[\x00-\x20\x3b]/g;

var cookieSeparatorRegEx = /[;,] */;

var httpStatusDescriptions = {
    100: 'Continue',
    101: 'Switching Protocols',
    200: 'OK',
    201: 'Created',
    203: 'Non-Authoritative Information',
    204: 'No Content',
    205: 'Reset Content',
    206: 'Partial Content',
    300: 'Multiple Choices',
    301: 'Moved Permanently',
    302: 'Found',
    303: 'See Other',
    304: 'Not Modified',
    305: 'Use Proxy',
    307: 'Temporary Redirect',
    400: 'Bad Request',
    401: 'Unauthorized',
    402: 'Payment Required',
    403: 'Forbidden',
    404: 'Not Found',
    406: 'Not Acceptable',
    407: 'Proxy Authorization Required',
    408: 'Request Timeout',
    409: 'Conflict',
    410: 'Gone',
    411: 'Length Required',
    412: 'Precondition Failed',
    413: 'Request Entity Too Long',
    414: 'Request-URI Too Long',
    415: 'Unsupported Media Type',
    416: 'Requested Range Not Satisfiable',
    417: 'Expectation Failed',
    426: 'Upgrade Required',
    500: 'Internal Server Error',
    501: 'Not Implemented',
    502: 'Bad Gateway',
    503: 'Service Unavailable',
    504: 'Gateway Timeout',
    505: 'HTTP Version Not Supported'
};

function WebSocketRequest(socket, httpRequest, serverConfig) {
    // Superclass Constructor
    EventEmitter.call(this);

    this.socket = socket;
    this.httpRequest = httpRequest;
    this.resource = httpRequest.url;
    this.remoteAddress = socket.remoteAddress;
    this.remoteAddresses = [this.remoteAddress];
    this.serverConfig = serverConfig;

    // Watch for the underlying TCP socket closing before we call accept
    this._socketIsClosing = false;
    this._socketCloseHandler = this._handleSocketCloseBeforeAccept.bind(this);
    this.socket.on('end', this._socketCloseHandler);
    this.socket.on('close', this._socketCloseHandler);

    this._resolved = false;
}

util.inherits(WebSocketRequest, EventEmitter);

WebSocketRequest.prototype.readHandshake = function() {
    var self = this;
    var request = this.httpRequest;

    // Decode URL
    this.resourceURL = url.parse(this.resource, true);

    this.host = request.headers['host'];
    if (!this.host) {
        throw new Error('Client must provide a Host header.');
    }

    this.key = request.headers['sec-websocket-key'];
    if (!this.key) {
        throw new Error('Client must provide a value for Sec-WebSocket-Key.');
    }

    this.webSocketVersion = parseInt(request.headers['sec-websocket-version'], 10);

    if (!this.webSocketVersion || isNaN(this.webSocketVersion)) {
        throw new Error('Client must provide a value for Sec-WebSocket-Version.');
    }

    switch (this.webSocketVersion) {
        case 8:
        case 13:
            break;
        default:
            var e = new Error('Unsupported websocket client version: ' + this.webSocketVersion +
                              'Only versions 8 and 13 are supported.');
            e.httpCode = 426;
            e.headers = {
                'Sec-WebSocket-Version': '13'
            };
            throw e;
    }

    if (this.webSocketVersion === 13) {
        this.origin = request.headers['origin'];
    }
    else if (this.webSocketVersion === 8) {
        this.origin = request.headers['sec-websocket-origin'];
    }

    // Protocol is optional.
    var protocolString = request.headers['sec-websocket-protocol'];
    this.protocolFullCaseMap = {};
    this.requestedProtocols = [];
    if (protocolString) {
        var requestedProtocolsFullCase = protocolString.split(headerValueSplitRegExp);
        requestedProtocolsFullCase.forEach(function(protocol) {
            var lcProtocol = protocol.toLocaleLowerCase();
            self.requestedProtocols.push(lcProtocol);
            self.protocolFullCaseMap[lcProtocol] = protocol;
        });
    }

    if (!this.serverConfig.ignoreXForwardedFor &&
        request.headers['x-forwarded-for']) {
        var immediatePeerIP = this.remoteAddress;
        this.remoteAddresses = request.headers['x-forwarded-for']
            .split(xForwardedForSeparatorRegExp);
        this.remoteAddresses.push(immediatePeerIP);
        this.remoteAddress = this.remoteAddresses[0];
    }

    // Extensions are optional.
    if (this.serverConfig.parseExtensions) {
        var extensionsString = request.headers['sec-websocket-extensions'];
        this.requestedExtensions = this.parseExtensions(extensionsString);
    } else {
        this.requestedExtensions = [];
    }

    // Cookies are optional
    if (this.serverConfig.parseCookies) {
        var cookieString = request.headers['cookie'];
        this.cookies = this.parseCookies(cookieString);
    } else {
        this.cookies = [];
    }
};

WebSocketRequest.prototype.parseExtensions = function(extensionsString) {
    if (!extensionsString || extensionsString.length === 0) {
        return [];
    }
    var extensions = extensionsString.toLocaleLowerCase().split(headerValueSplitRegExp);
    extensions.forEach(function(extension, index, array) {
        var params = extension.split(headerParamSplitRegExp);
        var extensionName = params[0];
        var extensionParams = params.slice(1);
        extensionParams.forEach(function(rawParam, index, array) {
            var arr = rawParam.split('=');
            var obj = {
                name: arr[0],
                value: arr[1]
            };
            array.splice(index, 1, obj);
        });
        var obj = {
            name: extensionName,
            params: extensionParams
        };
        array.splice(index, 1, obj);
    });
    return extensions;
};

// This function adapted from node-cookie
// https://github.com/shtylman/node-cookie
WebSocketRequest.prototype.parseCookies = function(str) {
    // Sanity Check
    if (!str || typeof(str) !== 'string') {
        return [];
    }

    var cookies = [];
    var pairs = str.split(cookieSeparatorRegEx);

    pairs.forEach(function(pair) {
        var eq_idx = pair.indexOf('=');
        if (eq_idx === -1) {
            cookies.push({
                name: pair,
                value: null
            });
            return;
        }

        var key = pair.substr(0, eq_idx).trim();
        var val = pair.substr(++eq_idx, pair.length).trim();

        // quoted values
        if ('"' === val[0]) {
            val = val.slice(1, -1);
        }

        cookies.push({
            name: key,
            value: decodeURIComponent(val)
        });
    });

    return cookies;
};

WebSocketRequest.prototype.accept = function(acceptedProtocol, allowedOrigin, cookies) {
    this._verifyResolution();

    // TODO: Handle extensions

    var protocolFullCase;

    if (acceptedProtocol) {
        protocolFullCase = this.protocolFullCaseMap[acceptedProtocol.toLocaleLowerCase()];
        if (typeof(protocolFullCase) === 'undefined') {
            protocolFullCase = acceptedProtocol;
        }
    }
    else {
        protocolFullCase = acceptedProtocol;
    }
    this.protocolFullCaseMap = null;

    // Create key validation hash
    var sha1 = crypto.createHash('sha1');
    sha1.update(this.key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');
    var acceptKey = sha1.digest('base64');

    var response = 'HTTP/1.1 101 Switching Protocols\r\n' +
                   'Upgrade: websocket\r\n' +
                   'Connection: Upgrade\r\n' +
                   'Sec-WebSocket-Accept: ' + acceptKey + '\r\n';

    if (protocolFullCase) {
        // validate protocol
        for (var i=0; i < protocolFullCase.length; i++) {
            var charCode = protocolFullCase.charCodeAt(i);
            var character = protocolFullCase.charAt(i);
            if (charCode < 0x21 || charCode > 0x7E || separators.indexOf(character) !== -1) {
                this.reject(500);
                throw new Error('Illegal character "' + String.fromCharCode(character) + '" in subprotocol.');
            }
        }
        if (this.requestedProtocols.indexOf(acceptedProtocol) === -1) {
            this.reject(500);
            throw new Error('Specified protocol was not requested by the client.');
        }

        protocolFullCase = protocolFullCase.replace(headerSanitizeRegExp, '');
        response += 'Sec-WebSocket-Protocol: ' + protocolFullCase + '\r\n';
    }
    this.requestedProtocols = null;

    if (allowedOrigin) {
        allowedOrigin = allowedOrigin.replace(headerSanitizeRegExp, '');
        if (this.webSocketVersion === 13) {
            response += 'Origin: ' + allowedOrigin + '\r\n';
        }
        else if (this.webSocketVersion === 8) {
            response += 'Sec-WebSocket-Origin: ' + allowedOrigin + '\r\n';
        }
    }

    if (cookies) {
        if (!Array.isArray(cookies)) {
            this.reject(500);
            throw new Error('Value supplied for "cookies" argument must be an array.');
        }
        var seenCookies = {};
        cookies.forEach(function(cookie) {
            if (!cookie.name || !cookie.value) {
                this.reject(500);
                throw new Error('Each cookie to set must at least provide a "name" and "value"');
            }

            // Make sure there are no \r\n sequences inserted
            cookie.name = cookie.name.replace(controlCharsAndSemicolonRegEx, '');
            cookie.value = cookie.value.replace(controlCharsAndSemicolonRegEx, '');

            if (seenCookies[cookie.name]) {
                this.reject(500);
                throw new Error('You may not specify the same cookie name twice.');
            }
            seenCookies[cookie.name] = true;

            // token (RFC 2616, Section 2.2)
            var invalidChar = cookie.name.match(cookieNameValidateRegEx);
            if (invalidChar) {
                this.reject(500);
                throw new Error('Illegal character ' + invalidChar[0] + ' in cookie name');
            }

            // RFC 6265, Section 4.1.1
            // *cookie-octet / ( DQUOTE *cookie-octet DQUOTE ) | %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
            if (cookie.value.match(cookieValueDQuoteValidateRegEx)) {
                invalidChar = cookie.value.slice(1, -1).match(cookieValueValidateRegEx);
            } else {
                invalidChar = cookie.value.match(cookieValueValidateRegEx);
            }
            if (invalidChar) {
                this.reject(500);
                throw new Error('Illegal character ' + invalidChar[0] + ' in cookie value');
            }

            var cookieParts = [cookie.name + '=' + cookie.value];

            // RFC 6265, Section 4.1.1
            // 'Path=' path-value | <any CHAR except CTLs or ';'>
            if(cookie.path){
                invalidChar = cookie.path.match(controlCharsAndSemicolonRegEx);
                if (invalidChar) {
                    this.reject(500);
                    throw new Error('Illegal character ' + invalidChar[0] + ' in cookie path');
                }
                cookieParts.push('Path=' + cookie.path);
            }

            // RFC 6265, Section 4.1.2.3
            // 'Domain=' subdomain
            if (cookie.domain) {
                if (typeof(cookie.domain) !== 'string') {
                    this.reject(500);
                    throw new Error('Domain must be specified and must be a string.');
                }
                invalidChar = cookie.domain.match(controlCharsAndSemicolonRegEx);
                if (invalidChar) {
                    this.reject(500);
                    throw new Error('Illegal character ' + invalidChar[0] + ' in cookie domain');
                }
                cookieParts.push('Domain=' + cookie.domain.toLowerCase());
            }

            // RFC 6265, Section 4.1.1
            //'Expires=' sane-cookie-date | Force Date object requirement by using only epoch
            if (cookie.expires) {
                if (!(cookie.expires instanceof Date)){
                    this.reject(500);
                    throw new Error('Value supplied for cookie "expires" must be a vaild date object');
                }
                cookieParts.push('Expires=' + cookie.expires.toGMTString());
            }

            // RFC 6265, Section 4.1.1
            //'Max-Age=' non-zero-digit *DIGIT
            if (cookie.maxage) {
                var maxage = cookie.maxage;
                if (typeof(maxage) === 'string') {
                    maxage = parseInt(maxage, 10);
                }
                if (isNaN(maxage) || maxage <= 0 ) {
                    this.reject(500);
                    throw new Error('Value supplied for cookie "maxage" must be a non-zero number');
                }
                maxage = Math.round(maxage);
                cookieParts.push('Max-Age=' + maxage.toString(10));
            }

            // RFC 6265, Section 4.1.1
            //'Secure;'
            if (cookie.secure) {
                if (typeof(cookie.secure) !== 'boolean') {
                    this.reject(500);
                    throw new Error('Value supplied for cookie "secure" must be of type boolean');
                }
                cookieParts.push('Secure');
            }

            // RFC 6265, Section 4.1.1
            //'HttpOnly;'
            if (cookie.httponly) {
                if (typeof(cookie.httponly) !== 'boolean') {
                    this.reject(500);
                    throw new Error('Value supplied for cookie "httponly" must be of type boolean');
                }
                cookieParts.push('HttpOnly');
            }

            response += ('Set-Cookie: ' + cookieParts.join(';') + '\r\n');
        }.bind(this));
    }

    // TODO: handle negotiated extensions
    // if (negotiatedExtensions) {
    //     response += 'Sec-WebSocket-Extensions: ' + negotiatedExtensions.join(', ') + '\r\n';
    // }

    // Mark the request resolved now so that the user can't call accept or
    // reject a second time.
    this._resolved = true;
    this.emit('requestResolved', this);

    response += '\r\n';

    var connection = new WebSocketConnection(this.socket, [], acceptedProtocol, false, this.serverConfig);
    connection.webSocketVersion = this.webSocketVersion;
    connection.remoteAddress = this.remoteAddress;
    connection.remoteAddresses = this.remoteAddresses;

    var self = this;

    if (this._socketIsClosing) {
        // Handle case when the client hangs up before we get a chance to
        // accept the connection and send our side of the opening handshake.
        cleanupFailedConnection(connection);
    }
    else {
        this.socket.write(response, 'ascii', function(error) {
            if (error) {
                cleanupFailedConnection(connection);
                return;
            }

            self._removeSocketCloseListeners();
            connection._addSocketEventListeners();
        });
    }

    this.emit('requestAccepted', connection);
    return connection;
};

WebSocketRequest.prototype.reject = function(status, reason, extraHeaders) {
    this._verifyResolution();

    // Mark the request resolved now so that the user can't call accept or
    // reject a second time.
    this._resolved = true;
    this.emit('requestResolved', this);

    if (typeof(status) !== 'number') {
        status = 403;
    }
    var response = 'HTTP/1.1 ' + status + ' ' + httpStatusDescriptions[status] + '\r\n' +
                   'Connection: close\r\n';
    if (reason) {
        reason = reason.replace(headerSanitizeRegExp, '');
        response += 'X-WebSocket-Reject-Reason: ' + reason + '\r\n';
    }

    if (extraHeaders) {
        for (var key in extraHeaders) {
            var sanitizedValue = extraHeaders[key].toString().replace(headerSanitizeRegExp, '');
            var sanitizedKey = key.replace(headerSanitizeRegExp, '');
            response += (sanitizedKey + ': ' + sanitizedValue + '\r\n');
        }
    }

    response += '\r\n';
    this.socket.end(response, 'ascii');

    this.emit('requestRejected', this);
};

WebSocketRequest.prototype._handleSocketCloseBeforeAccept = function() {
    this._socketIsClosing = true;
    this._removeSocketCloseListeners();
};

WebSocketRequest.prototype._removeSocketCloseListeners = function() {
    this.socket.removeListener('end', this._socketCloseHandler);
    this.socket.removeListener('close', this._socketCloseHandler);
};

WebSocketRequest.prototype._verifyResolution = function() {
    if (this._resolved) {
        throw new Error('WebSocketRequest may only be accepted or rejected one time.');
    }
};

function cleanupFailedConnection(connection) {
    // Since we have to return a connection object even if the socket is
    // already dead in order not to break the API, we schedule a 'close'
    // event on the connection object to occur immediately.
    process.nextTick(function() {
        // WebSocketConnection.CLOSE_REASON_ABNORMAL = 1006
        // Third param: Skip sending the close frame to a dead socket
        connection.drop(1006, 'TCP connection lost before handshake completed.', true);
    });
}

module.exports = WebSocketRequest;


/***/ }),

/***/ 3300:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var extend = (__nccwpck_require__(7192).extend);
var util = __nccwpck_require__(3837);
var EventEmitter = (__nccwpck_require__(2361).EventEmitter);
var WebSocketRouterRequest = __nccwpck_require__(1216);

function WebSocketRouter(config) {
    // Superclass Constructor
    EventEmitter.call(this);

    this.config = {
        // The WebSocketServer instance to attach to.
        server: null
    };
    if (config) {
        extend(this.config, config);
    }
    this.handlers = [];

    this._requestHandler = this.handleRequest.bind(this);
    if (this.config.server) {
        this.attachServer(this.config.server);
    }
}

util.inherits(WebSocketRouter, EventEmitter);

WebSocketRouter.prototype.attachServer = function(server) {
    if (server) {
        this.server = server;
        this.server.on('request', this._requestHandler);
    }
    else {
        throw new Error('You must specify a WebSocketServer instance to attach to.');
    }
};

WebSocketRouter.prototype.detachServer = function() {
    if (this.server) {
        this.server.removeListener('request', this._requestHandler);
        this.server = null;
    }
    else {
        throw new Error('Cannot detach from server: not attached.');
    }
};

WebSocketRouter.prototype.mount = function(path, protocol, callback) {
    if (!path) {
        throw new Error('You must specify a path for this handler.');
    }
    if (!protocol) {
        protocol = '____no_protocol____';
    }
    if (!callback) {
        throw new Error('You must specify a callback for this handler.');
    }

    path = this.pathToRegExp(path);
    if (!(path instanceof RegExp)) {
        throw new Error('Path must be specified as either a string or a RegExp.');
    }
    var pathString = path.toString();

    // normalize protocol to lower-case
    protocol = protocol.toLocaleLowerCase();

    if (this.findHandlerIndex(pathString, protocol) !== -1) {
        throw new Error('You may only mount one handler per path/protocol combination.');
    }

    this.handlers.push({
        'path': path,
        'pathString': pathString,
        'protocol': protocol,
        'callback': callback
    });
};
WebSocketRouter.prototype.unmount = function(path, protocol) {
    var index = this.findHandlerIndex(this.pathToRegExp(path).toString(), protocol);
    if (index !== -1) {
        this.handlers.splice(index, 1);
    }
    else {
        throw new Error('Unable to find a route matching the specified path and protocol.');
    }
};

WebSocketRouter.prototype.findHandlerIndex = function(pathString, protocol) {
    protocol = protocol.toLocaleLowerCase();
    for (var i=0, len=this.handlers.length; i < len; i++) {
        var handler = this.handlers[i];
        if (handler.pathString === pathString && handler.protocol === protocol) {
            return i;
        }
    }
    return -1;
};

WebSocketRouter.prototype.pathToRegExp = function(path) {
    if (typeof(path) === 'string') {
        if (path === '*') {
            path = /^.*$/;
        }
        else {
            path = path.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
            path = new RegExp('^' + path + '$');
        }
    }
    return path;
};

WebSocketRouter.prototype.handleRequest = function(request) {
    var requestedProtocols = request.requestedProtocols;
    if (requestedProtocols.length === 0) {
        requestedProtocols = ['____no_protocol____'];
    }

    // Find a handler with the first requested protocol first
    for (var i=0; i < requestedProtocols.length; i++) {
        var requestedProtocol = requestedProtocols[i].toLocaleLowerCase();

        // find the first handler that can process this request
        for (var j=0, len=this.handlers.length; j < len; j++) {
            var handler = this.handlers[j];
            if (handler.path.test(request.resourceURL.pathname)) {
                if (requestedProtocol === handler.protocol ||
                    handler.protocol === '*')
                {
                    var routerRequest = new WebSocketRouterRequest(request, requestedProtocol);
                    handler.callback(routerRequest);
                    return;
                }
            }
        }
    }

    // If we get here we were unable to find a suitable handler.
    request.reject(404, 'No handler is available for the given request.');
};

module.exports = WebSocketRouter;


/***/ }),

/***/ 1216:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var util = __nccwpck_require__(3837);
var EventEmitter = (__nccwpck_require__(2361).EventEmitter);

function WebSocketRouterRequest(webSocketRequest, resolvedProtocol) {
    // Superclass Constructor
    EventEmitter.call(this);

    this.webSocketRequest = webSocketRequest;
    if (resolvedProtocol === '____no_protocol____') {
        this.protocol = null;
    }
    else {
        this.protocol = resolvedProtocol;
    }
    this.origin = webSocketRequest.origin;
    this.resource = webSocketRequest.resource;
    this.resourceURL = webSocketRequest.resourceURL;
    this.httpRequest = webSocketRequest.httpRequest;
    this.remoteAddress = webSocketRequest.remoteAddress;
    this.webSocketVersion = webSocketRequest.webSocketVersion;
    this.requestedExtensions = webSocketRequest.requestedExtensions;
    this.cookies = webSocketRequest.cookies;
}

util.inherits(WebSocketRouterRequest, EventEmitter);

WebSocketRouterRequest.prototype.accept = function(origin, cookies) {
    var connection = this.webSocketRequest.accept(this.protocol, origin, cookies);
    this.emit('requestAccepted', connection);
    return connection;
};

WebSocketRouterRequest.prototype.reject = function(status, reason, extraHeaders) {
    this.webSocketRequest.reject(status, reason, extraHeaders);
    this.emit('requestRejected', this);
};

module.exports = WebSocketRouterRequest;


/***/ }),

/***/ 289:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var extend = (__nccwpck_require__(7192).extend);
var utils = __nccwpck_require__(7192);
var util = __nccwpck_require__(3837);
var debug = __nccwpck_require__(5346)('websocket:server');
var EventEmitter = (__nccwpck_require__(2361).EventEmitter);
var WebSocketRequest = __nccwpck_require__(1908);

var WebSocketServer = function WebSocketServer(config) {
    // Superclass Constructor
    EventEmitter.call(this);

    this._handlers = {
        upgrade: this.handleUpgrade.bind(this),
        requestAccepted: this.handleRequestAccepted.bind(this),
        requestResolved: this.handleRequestResolved.bind(this)
    };
    this.connections = [];
    this.pendingRequests = [];
    if (config) {
        this.mount(config);
    }
};

util.inherits(WebSocketServer, EventEmitter);

WebSocketServer.prototype.mount = function(config) {
    this.config = {
        // The http server instance to attach to.  Required.
        httpServer: null,

        // 64KiB max frame size.
        maxReceivedFrameSize: 0x10000,

        // 1MiB max message size, only applicable if
        // assembleFragments is true
        maxReceivedMessageSize: 0x100000,

        // Outgoing messages larger than fragmentationThreshold will be
        // split into multiple fragments.
        fragmentOutgoingMessages: true,

        // Outgoing frames are fragmented if they exceed this threshold.
        // Default is 16KiB
        fragmentationThreshold: 0x4000,

        // If true, the server will automatically send a ping to all
        // clients every 'keepaliveInterval' milliseconds.  The timer is
        // reset on any received data from the client.
        keepalive: true,

        // The interval to send keepalive pings to connected clients if the
        // connection is idle.  Any received data will reset the counter.
        keepaliveInterval: 20000,

        // If true, the server will consider any connection that has not
        // received any data within the amount of time specified by
        // 'keepaliveGracePeriod' after a keepalive ping has been sent to
        // be dead, and will drop the connection.
        // Ignored if keepalive is false.
        dropConnectionOnKeepaliveTimeout: true,

        // The amount of time to wait after sending a keepalive ping before
        // closing the connection if the connected peer does not respond.
        // Ignored if keepalive is false.
        keepaliveGracePeriod: 10000,

        // Whether to use native TCP keep-alive instead of WebSockets ping
        // and pong packets.  Native TCP keep-alive sends smaller packets
        // on the wire and so uses bandwidth more efficiently.  This may
        // be more important when talking to mobile devices.
        // If this value is set to true, then these values will be ignored:
        //   keepaliveGracePeriod
        //   dropConnectionOnKeepaliveTimeout
        useNativeKeepalive: false,

        // If true, fragmented messages will be automatically assembled
        // and the full message will be emitted via a 'message' event.
        // If false, each frame will be emitted via a 'frame' event and
        // the application will be responsible for aggregating multiple
        // fragmented frames.  Single-frame messages will emit a 'message'
        // event in addition to the 'frame' event.
        // Most users will want to leave this set to 'true'
        assembleFragments: true,

        // If this is true, websocket connections will be accepted
        // regardless of the path and protocol specified by the client.
        // The protocol accepted will be the first that was requested
        // by the client.  Clients from any origin will be accepted.
        // This should only be used in the simplest of cases.  You should
        // probably leave this set to 'false' and inspect the request
        // object to make sure it's acceptable before accepting it.
        autoAcceptConnections: false,

        // Whether or not the X-Forwarded-For header should be respected.
        // It's important to set this to 'true' when accepting connections
        // from untrusted clients, as a malicious client could spoof its
        // IP address by simply setting this header.  It's meant to be added
        // by a trusted proxy or other intermediary within your own
        // infrastructure.
        // See:  http://en.wikipedia.org/wiki/X-Forwarded-For
        ignoreXForwardedFor: false,

        // If this is true, 'cookie' headers are parsed and exposed as WebSocketRequest.cookies
        parseCookies: true,

        // If this is true, 'sec-websocket-extensions' headers are parsed and exposed as WebSocketRequest.requestedExtensions
        parseExtensions: true,

        // The Nagle Algorithm makes more efficient use of network resources
        // by introducing a small delay before sending small packets so that
        // multiple messages can be batched together before going onto the
        // wire.  This however comes at the cost of latency, so the default
        // is to disable it.  If you don't need low latency and are streaming
        // lots of small messages, you can change this to 'false'
        disableNagleAlgorithm: true,

        // The number of milliseconds to wait after sending a close frame
        // for an acknowledgement to come back before giving up and just
        // closing the socket.
        closeTimeout: 5000
    };
    extend(this.config, config);

    if (this.config.httpServer) {
        if (!Array.isArray(this.config.httpServer)) {
            this.config.httpServer = [this.config.httpServer];
        }
        var upgradeHandler = this._handlers.upgrade;
        this.config.httpServer.forEach(function(httpServer) {
            httpServer.on('upgrade', upgradeHandler);
        });
    }
    else {
        throw new Error('You must specify an httpServer on which to mount the WebSocket server.');
    }
};

WebSocketServer.prototype.unmount = function() {
    var upgradeHandler = this._handlers.upgrade;
    this.config.httpServer.forEach(function(httpServer) {
        httpServer.removeListener('upgrade', upgradeHandler);
    });
};

WebSocketServer.prototype.closeAllConnections = function() {
    this.connections.forEach(function(connection) {
        connection.close();
    });
    this.pendingRequests.forEach(function(request) {
        process.nextTick(function() {
          request.reject(503); // HTTP 503 Service Unavailable
        });
    });
};

WebSocketServer.prototype.broadcast = function(data) {
    if (Buffer.isBuffer(data)) {
        this.broadcastBytes(data);
    }
    else if (typeof(data.toString) === 'function') {
        this.broadcastUTF(data);
    }
};

WebSocketServer.prototype.broadcastUTF = function(utfData) {
    this.connections.forEach(function(connection) {
        connection.sendUTF(utfData);
    });
};

WebSocketServer.prototype.broadcastBytes = function(binaryData) {
    this.connections.forEach(function(connection) {
        connection.sendBytes(binaryData);
    });
};

WebSocketServer.prototype.shutDown = function() {
    this.unmount();
    this.closeAllConnections();
};

WebSocketServer.prototype.handleUpgrade = function(request, socket) {
    var self = this;
    var wsRequest = new WebSocketRequest(socket, request, this.config);
    try {
        wsRequest.readHandshake();
    }
    catch(e) {
        wsRequest.reject(
            e.httpCode ? e.httpCode : 400,
            e.message,
            e.headers
        );
        debug('Invalid handshake: %s', e.message);
        this.emit('upgradeError', e);
        return;
    }

    this.pendingRequests.push(wsRequest);

    wsRequest.once('requestAccepted', this._handlers.requestAccepted);
    wsRequest.once('requestResolved', this._handlers.requestResolved);
    socket.once('close', function () {
        self._handlers.requestResolved(wsRequest);
    });

    if (!this.config.autoAcceptConnections && utils.eventEmitterListenerCount(this, 'request') > 0) {
        this.emit('request', wsRequest);
    }
    else if (this.config.autoAcceptConnections) {
        wsRequest.accept(wsRequest.requestedProtocols[0], wsRequest.origin);
    }
    else {
        wsRequest.reject(404, 'No handler is configured to accept the connection.');
    }
};

WebSocketServer.prototype.handleRequestAccepted = function(connection) {
    var self = this;
    connection.once('close', function(closeReason, description) {
        self.handleConnectionClose(connection, closeReason, description);
    });
    this.connections.push(connection);
    this.emit('connect', connection);
};

WebSocketServer.prototype.handleConnectionClose = function(connection, closeReason, description) {
    var index = this.connections.indexOf(connection);
    if (index !== -1) {
        this.connections.splice(index, 1);
    }
    this.emit('close', connection, closeReason, description);
};

WebSocketServer.prototype.handleRequestResolved = function(request) {
    var index = this.pendingRequests.indexOf(request);
    if (index !== -1) { this.pendingRequests.splice(index, 1); }
};

module.exports = WebSocketServer;


/***/ }),

/***/ 7192:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

var noop = exports.noop = function(){};

exports.extend = function extend(dest, source) {
    for (var prop in source) {
        dest[prop] = source[prop];
    }
};

exports.eventEmitterListenerCount =
    (__nccwpck_require__(2361).EventEmitter.listenerCount) ||
    function(emitter, type) { return emitter.listeners(type).length; };

exports.bufferAllocUnsafe = Buffer.allocUnsafe ?
    Buffer.allocUnsafe :
    function oldBufferAllocUnsafe(size) { return new Buffer(size); };

exports.bufferFromString = Buffer.from ?
    Buffer.from :
    function oldBufferFromString(string, encoding) {
      return new Buffer(string, encoding);
    };

exports.BufferingLogger = function createBufferingLogger(identifier, uniqueID) {
    var logFunction = __nccwpck_require__(5346)(identifier);
    if (logFunction.enabled) {
        var logger = new BufferingLogger(identifier, uniqueID, logFunction);
        var debug = logger.log.bind(logger);
        debug.printOutput = logger.printOutput.bind(logger);
        debug.enabled = logFunction.enabled;
        return debug;
    }
    logFunction.printOutput = noop;
    return logFunction;
};

function BufferingLogger(identifier, uniqueID, logFunction) {
    this.logFunction = logFunction;
    this.identifier = identifier;
    this.uniqueID = uniqueID;
    this.buffer = [];
}

BufferingLogger.prototype.log = function() {
  this.buffer.push([ new Date(), Array.prototype.slice.call(arguments) ]);
  return this;
};

BufferingLogger.prototype.clear = function() {
  this.buffer = [];
  return this;
};

BufferingLogger.prototype.printOutput = function(logFunction) {
    if (!logFunction) { logFunction = this.logFunction; }
    var uniqueID = this.uniqueID;
    this.buffer.forEach(function(entry) {
        var date = entry[0].toLocaleString();
        var args = entry[1].slice();
        var formatString = args[0];
        if (formatString !== (void 0) && formatString !== null) {
            formatString = '%s - %s - ' + formatString.toString();
            args.splice(0, 1, formatString, date, uniqueID);
            logFunction.apply(global, args);
        }
    });
};


/***/ }),

/***/ 1276:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(9794).version;


/***/ }),

/***/ 3149:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = {
    'server'       : __nccwpck_require__(289),
    'client'       : __nccwpck_require__(3996),
    'router'       : __nccwpck_require__(3300),
    'frame'        : __nccwpck_require__(2806),
    'request'      : __nccwpck_require__(1908),
    'connection'   : __nccwpck_require__(8042),
    'w3cwebsocket' : __nccwpck_require__(9290),
    'deprecation'  : __nccwpck_require__(9998),
    'version'      : __nccwpck_require__(1276)
};


/***/ }),

/***/ 9748:
/***/ ((module, exports, __nccwpck_require__) => {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __nccwpck_require__(8710);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),

/***/ 8710:
/***/ ((module, exports, __nccwpck_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __nccwpck_require__(520);

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ 5346:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  module.exports = __nccwpck_require__(9748);
} else {
  module.exports = __nccwpck_require__(4271);
}


/***/ }),

/***/ 4271:
/***/ ((module, exports, __nccwpck_require__) => {

/**
 * Module dependencies.
 */

var tty = __nccwpck_require__(6224);
var util = __nccwpck_require__(3837);

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __nccwpck_require__(8710);
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()
}

var stream = 1 === fd ? process.stdout :
             2 === fd ? process.stderr :
             createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString()
      + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream (fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = __nccwpck_require__(7147);
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = __nccwpck_require__(1808);
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());


/***/ }),

/***/ 520:
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),

/***/ 5824:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

// This file was copied from https://github.com/substack/node-bufferlist
// and modified to be able to copy bytes from the bufferlist directly into
// a pre-existing fixed-size buffer without an additional memory allocation.

// bufferlist.js
// Treat a linked list of buffers as a single variable-size buffer.
var Buffer = (__nccwpck_require__(4300).Buffer);
var EventEmitter = (__nccwpck_require__(2361).EventEmitter);
var bufferAllocUnsafe = (__nccwpck_require__(7192).bufferAllocUnsafe);

module.exports = BufferList;
module.exports.BufferList = BufferList; // backwards compatibility

function BufferList(opts) {
    if (!(this instanceof BufferList)) return new BufferList(opts);
    EventEmitter.call(this);
    var self = this;
    
    if (typeof(opts) == 'undefined') opts = {};
    
    // default encoding to use for take(). Leaving as 'undefined'
    // makes take() return a Buffer instead.
    self.encoding = opts.encoding;
    
    var head = { next : null, buffer : null };
    var last = { next : null, buffer : null };
    
    // length can get negative when advanced past the end
    // and this is the desired behavior
    var length = 0;
    self.__defineGetter__('length', function () {
        return length;
    });
    
    // keep an offset of the head to decide when to head = head.next
    var offset = 0;
    
    // Write to the bufferlist. Emits 'write'. Always returns true.
    self.write = function (buf) {
        if (!head.buffer) {
            head.buffer = buf;
            last = head;
        }
        else {
            last.next = { next : null, buffer : buf };
            last = last.next;
        }
        length += buf.length;
        self.emit('write', buf);
        return true;
    };
    
    self.end = function (buf) {
        if (Buffer.isBuffer(buf)) self.write(buf);
    };
    
    // Push buffers to the end of the linked list. (deprecated)
    // Return this (self).
    self.push = function () {
        var args = [].concat.apply([], arguments);
        args.forEach(self.write);
        return self;
    };
    
    // For each buffer, perform some action.
    // If fn's result is a true value, cut out early.
    // Returns this (self).
    self.forEach = function (fn) {
        if (!head.buffer) return bufferAllocUnsafe(0);
        
        if (head.buffer.length - offset <= 0) return self;
        var firstBuf = head.buffer.slice(offset);
        
        var b = { buffer : firstBuf, next : head.next };
        
        while (b && b.buffer) {
            var r = fn(b.buffer);
            if (r) break;
            b = b.next;
        }
        
        return self;
    };
    
    // Create a single Buffer out of all the chunks or some subset specified by
    // start and one-past the end (like slice) in bytes.
    self.join = function (start, end) {
        if (!head.buffer) return bufferAllocUnsafe(0);
        if (start == undefined) start = 0;
        if (end == undefined) end = self.length;
        
        var big = bufferAllocUnsafe(end - start);
        var ix = 0;
        self.forEach(function (buffer) {
            if (start < (ix + buffer.length) && ix < end) {
                // at least partially contained in the range
                buffer.copy(
                    big,
                    Math.max(0, ix - start),
                    Math.max(0, start - ix),
                    Math.min(buffer.length, end - ix)
                );
            }
            ix += buffer.length;
            if (ix > end) return true; // stop processing past end
        });
        
        return big;
    };
    
    self.joinInto = function (targetBuffer, targetStart, sourceStart, sourceEnd) {
        if (!head.buffer) return new bufferAllocUnsafe(0);
        if (sourceStart == undefined) sourceStart = 0;
        if (sourceEnd == undefined) sourceEnd = self.length;
        
        var big = targetBuffer;
        if (big.length - targetStart < sourceEnd - sourceStart) {
            throw new Error("Insufficient space available in target Buffer.");
        }
        var ix = 0;
        self.forEach(function (buffer) {
            if (sourceStart < (ix + buffer.length) && ix < sourceEnd) {
                // at least partially contained in the range
                buffer.copy(
                    big,
                    Math.max(targetStart, targetStart + ix - sourceStart),
                    Math.max(0, sourceStart - ix),
                    Math.min(buffer.length, sourceEnd - ix)
                );
            }
            ix += buffer.length;
            if (ix > sourceEnd) return true; // stop processing past end
        });
        
        return big;
    };
    
    // Advance the buffer stream by n bytes.
    // If n the aggregate advance offset passes the end of the buffer list,
    // operations such as .take() will return empty strings until enough data is
    // pushed.
    // Returns this (self).
    self.advance = function (n) {
        offset += n;
        length -= n;
        while (head.buffer && offset >= head.buffer.length) {
            offset -= head.buffer.length;
            head = head.next
                ? head.next
                : { buffer : null, next : null }
            ;
        }
        if (head.buffer === null) last = { next : null, buffer : null };
        self.emit('advance', n);
        return self;
    };
    
    // Take n bytes from the start of the buffers.
    // Returns a string.
    // If there are less than n bytes in all the buffers or n is undefined,
    // returns the entire concatenated buffer string.
    self.take = function (n, encoding) {
        if (n == undefined) n = self.length;
        else if (typeof n !== 'number') {
            encoding = n;
            n = self.length;
        }
        var b = head;
        if (!encoding) encoding = self.encoding;
        if (encoding) {
            var acc = '';
            self.forEach(function (buffer) {
                if (n <= 0) return true;
                acc += buffer.toString(
                    encoding, 0, Math.min(n,buffer.length)
                );
                n -= buffer.length;
            });
            return acc;
        } else {
            // If no 'encoding' is specified, then return a Buffer.
            return self.join(0, n);
        }
    };
    
    // The entire concatenated buffer as a string.
    self.toString = function () {
        return self.take('binary');
    };
}
(__nccwpck_require__(3837).inherits)(BufferList, EventEmitter);


/***/ }),

/***/ 8445:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var bs58check = __nccwpck_require__(1768)

function decodeRaw (buffer, version) {
  // check version only if defined
  if (version !== undefined && buffer[0] !== version) throw new Error('Invalid network version')

  // uncompressed
  if (buffer.length === 33) {
    return {
      version: buffer[0],
      privateKey: buffer.slice(1, 33),
      compressed: false
    }
  }

  // invalid length
  if (buffer.length !== 34) throw new Error('Invalid WIF length')

  // invalid compression flag
  if (buffer[33] !== 0x01) throw new Error('Invalid compression flag')

  return {
    version: buffer[0],
    privateKey: buffer.slice(1, 33),
    compressed: true
  }
}

function encodeRaw (version, privateKey, compressed) {
  var result = new Buffer(compressed ? 34 : 33)

  result.writeUInt8(version, 0)
  privateKey.copy(result, 1)

  if (compressed) {
    result[33] = 0x01
  }

  return result
}

function decode (string, version) {
  return decodeRaw(bs58check.decode(string), version)
}

function encode (version, privateKey, compressed) {
  if (typeof version === 'number') return bs58check.encode(encodeRaw(version, privateKey, compressed))

  return bs58check.encode(
    encodeRaw(
      version.version,
      version.privateKey,
      version.compressed
    )
  )
}

module.exports = {
  decode: decode,
  decodeRaw: decodeRaw,
  encode: encode,
  encodeRaw: encodeRaw
}


/***/ }),

/***/ 6036:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const WebSocket = __nccwpck_require__(3413);

WebSocket.createWebSocketStream = __nccwpck_require__(9417);
WebSocket.Server = __nccwpck_require__(7378);
WebSocket.Receiver = __nccwpck_require__(3318);
WebSocket.Sender = __nccwpck_require__(1445);

WebSocket.WebSocket = WebSocket;
WebSocket.WebSocketServer = WebSocket.Server;

module.exports = WebSocket;


/***/ }),

/***/ 3735:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { EMPTY_BUFFER } = __nccwpck_require__(13);

const FastBuffer = Buffer[Symbol.species];

/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER;
  if (list.length === 1) return list[0];

  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    target.set(buf, offset);
    offset += buf.length;
  }

  if (offset < totalLength) {
    return new FastBuffer(target.buffer, target.byteOffset, offset);
  }

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask(source, mask, output, offset, length) {
  for (let i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask(buffer, mask) {
  for (let i = 0; i < buffer.length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */
function toArrayBuffer(buf) {
  if (buf.length === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
}

/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */
function toBuffer(data) {
  toBuffer.readOnly = true;

  if (Buffer.isBuffer(data)) return data;

  let buf;

  if (data instanceof ArrayBuffer) {
    buf = new FastBuffer(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer.readOnly = false;
  }

  return buf;
}

module.exports = {
  concat,
  mask: _mask,
  toArrayBuffer,
  toBuffer,
  unmask: _unmask
};

/* istanbul ignore else  */
if (!process.env.WS_NO_BUFFER_UTIL) {
  try {
    const bufferUtil = __nccwpck_require__(264);

    module.exports.mask = function (source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bufferUtil.mask(source, mask, output, offset, length);
    };

    module.exports.unmask = function (buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bufferUtil.unmask(buffer, mask);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}


/***/ }),

/***/ 13:
/***/ ((module) => {

"use strict";


module.exports = {
  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
  EMPTY_BUFFER: Buffer.alloc(0),
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
  kListener: Symbol('kListener'),
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  NOOP: () => {}
};


/***/ }),

/***/ 3610:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { kForOnEventAttribute, kListener } = __nccwpck_require__(13);

const kCode = Symbol('kCode');
const kData = Symbol('kData');
const kError = Symbol('kError');
const kMessage = Symbol('kMessage');
const kReason = Symbol('kReason');
const kTarget = Symbol('kTarget');
const kType = Symbol('kType');
const kWasClean = Symbol('kWasClean');

/**
 * Class representing an event.
 */
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @throws {TypeError} If the `type` argument is not specified
   */
  constructor(type) {
    this[kTarget] = null;
    this[kType] = type;
  }

  /**
   * @type {*}
   */
  get target() {
    return this[kTarget];
  }

  /**
   * @type {String}
   */
  get type() {
    return this[kType];
  }
}

Object.defineProperty(Event.prototype, 'target', { enumerable: true });
Object.defineProperty(Event.prototype, 'type', { enumerable: true });

/**
 * Class representing a close event.
 *
 * @extends Event
 */
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {Number} [options.code=0] The status code explaining why the
   *     connection was closed
   * @param {String} [options.reason=''] A human-readable string explaining why
   *     the connection was closed
   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
   *     connection was cleanly closed
   */
  constructor(type, options = {}) {
    super(type);

    this[kCode] = options.code === undefined ? 0 : options.code;
    this[kReason] = options.reason === undefined ? '' : options.reason;
    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
  }

  /**
   * @type {Number}
   */
  get code() {
    return this[kCode];
  }

  /**
   * @type {String}
   */
  get reason() {
    return this[kReason];
  }

  /**
   * @type {Boolean}
   */
  get wasClean() {
    return this[kWasClean];
  }
}

Object.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });

/**
 * Class representing an error event.
 *
 * @extends Event
 */
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.error=null] The error that generated this event
   * @param {String} [options.message=''] The error message
   */
  constructor(type, options = {}) {
    super(type);

    this[kError] = options.error === undefined ? null : options.error;
    this[kMessage] = options.message === undefined ? '' : options.message;
  }

  /**
   * @type {*}
   */
  get error() {
    return this[kError];
  }

  /**
   * @type {String}
   */
  get message() {
    return this[kMessage];
  }
}

Object.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });
Object.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });

/**
 * Class representing a message event.
 *
 * @extends Event
 */
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.data=null] The message content
   */
  constructor(type, options = {}) {
    super(type);

    this[kData] = options.data === undefined ? null : options.data;
  }

  /**
   * @type {*}
   */
  get data() {
    return this[kData];
  }
}

Object.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {(Function|Object)} handler The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, handler, options = {}) {
    for (const listener of this.listeners(type)) {
      if (
        !options[kForOnEventAttribute] &&
        listener[kListener] === handler &&
        !listener[kForOnEventAttribute]
      ) {
        return;
      }
    }

    let wrapper;

    if (type === 'message') {
      wrapper = function onMessage(data, isBinary) {
        const event = new MessageEvent('message', {
          data: isBinary ? data : data.toString()
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'close') {
      wrapper = function onClose(code, message) {
        const event = new CloseEvent('close', {
          code,
          reason: message.toString(),
          wasClean: this._closeFrameReceived && this._closeFrameSent
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'error') {
      wrapper = function onError(error) {
        const event = new ErrorEvent('error', {
          error,
          message: error.message
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'open') {
      wrapper = function onOpen() {
        const event = new Event('open');

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else {
      return;
    }

    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
    wrapper[kListener] = handler;

    if (options.once) {
      this.once(type, wrapper);
    } else {
      this.on(type, wrapper);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {(Function|Object)} handler The listener to remove
   * @public
   */
  removeEventListener(type, handler) {
    for (const listener of this.listeners(type)) {
      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
        this.removeListener(type, listener);
        break;
      }
    }
  }
};

module.exports = {
  CloseEvent,
  ErrorEvent,
  Event,
  EventTarget,
  MessageEvent
};

/**
 * Call an event listener
 *
 * @param {(Function|Object)} listener The listener to call
 * @param {*} thisArg The value to use as `this`` when calling the listener
 * @param {Event} event The event to pass to the listener
 * @private
 */
function callListener(listener, thisArg, event) {
  if (typeof listener === 'object' && listener.handleEvent) {
    listener.handleEvent.call(listener, event);
  } else {
    listener.call(thisArg, event);
  }
}


/***/ }),

/***/ 5853:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { tokenChars } = __nccwpck_require__(8415);

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];
  else dest[name].push(elem);
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse(header) {
  const offers = Object.create(null);
  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let code = -1;
  let end = -1;
  let i = 0;

  for (; i < header.length; i++) {
    code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (
        i !== 0 &&
        (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
      ) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        let value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, params);
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                let values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k}=${v}`))
                  .join('; ');
              })
            )
            .join('; ');
        })
        .join(', ');
    })
    .join(', ');
}

module.exports = { format, parse };


/***/ }),

/***/ 261:
/***/ ((module) => {

"use strict";


const kDone = Symbol('kDone');
const kRun = Symbol('kRun');

/**
 * A very simple job queue with adjustable concurrency. Adapted from
 * https://github.com/STRML/async-limiter
 */
class Limiter {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }

  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }

  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun]() {
    if (this.pending === this.concurrency) return;

    if (this.jobs.length) {
      const job = this.jobs.shift();

      this.pending++;
      job(this[kDone]);
    }
  }
}

module.exports = Limiter;


/***/ }),

/***/ 5705:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const zlib = __nccwpck_require__(9796);

const bufferUtil = __nccwpck_require__(3735);
const Limiter = __nccwpck_require__(261);
const { kStatusCode } = __nccwpck_require__(13);

const FastBuffer = Buffer[Symbol.species];
const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed if context takeover is disabled
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter = new Limiter(concurrency);
    }
  }

  /**
   * @type {String}
   */
  static get extensionName() {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }

    if (this._deflate) {
      const callback = this._deflate[kCallback];

      this._deflate.close();
      this._deflate = null;

      if (callback) {
        callback(
          new Error(
            'The deflate stream was closed while data was being processed'
          )
        );
      }
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    }

    this._inflate[kCallback] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      if (this._inflate._readableState.endEmitted) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];

        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._inflate.reset();
        }
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      this._deflate.on('data', deflateOnData);
    }

    this._deflate[kCallback] = callback;

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // The deflate stream was closed while data was being processed.
        //
        return;
      }

      let data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) {
        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);
      }

      //
      // Ensure that the callback will not be called again in
      // `PerMessageDeflate#cleanup()`.
      //
      this._deflate[kCallback] = null;

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.reset();
      }

      callback(null, data);
    });
  }
}

module.exports = PerMessageDeflate;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
  this[kError][kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode] = 1007;
  this[kCallback](err);
}


/***/ }),

/***/ 3318:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { Writable } = __nccwpck_require__(2781);

const PerMessageDeflate = __nccwpck_require__(5705);
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  kStatusCode,
  kWebSocket
} = __nccwpck_require__(13);
const { concat, toArrayBuffer, unmask } = __nccwpck_require__(3735);
const { isValidStatusCode, isValidUTF8 } = __nccwpck_require__(8415);

const FastBuffer = Buffer[Symbol.species];
const promise = Promise.resolve();

//
// `queueMicrotask()` is not available in Node.js < 11.
//
const queueTask =
  typeof queueMicrotask === 'function' ? queueMicrotask : queueMicrotaskShim;

const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;
const DEFER_EVENT = 6;

/**
 * HyBi Receiver implementation.
 *
 * @extends Writable
 */
class Receiver extends Writable {
  /**
   * Creates a Receiver instance.
   *
   * @param {Object} [options] Options object
   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {String} [options.binaryType=nodebuffer] The type for binary data
   * @param {Object} [options.extensions] An object containing the negotiated
   *     extensions
   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
   *     client or server mode
   * @param {Number} [options.maxPayload=0] The maximum allowed message length
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   */
  constructor(options = {}) {
    super();

    this._allowSynchronousEvents = !!options.allowSynchronousEvents;
    this._binaryType = options.binaryType || BINARY_TYPES[0];
    this._extensions = options.extensions || {};
    this._isServer = !!options.isServer;
    this._maxPayload = options.maxPayload | 0;
    this._skipUTF8Validation = !!options.skipUTF8Validation;
    this[kWebSocket] = undefined;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._errored = false;
    this._loop = false;
    this._state = GET_INFO;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = new FastBuffer(
        buf.buffer,
        buf.byteOffset + n,
        buf.length - n
      );

      return new FastBuffer(buf.buffer, buf.byteOffset, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];
      const offset = dst.length - n;

      if (n >= buf.length) {
        dst.set(this._buffers.shift(), offset);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
        this._buffers[0] = new FastBuffer(
          buf.buffer,
          buf.byteOffset + n,
          buf.length - n
        );
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO:
          this.getInfo(cb);
          break;
        case GET_PAYLOAD_LENGTH_16:
          this.getPayloadLength16(cb);
          break;
        case GET_PAYLOAD_LENGTH_64:
          this.getPayloadLength64(cb);
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          this.getData(cb);
          break;
        case INFLATING:
        case DEFER_EVENT:
          this._loop = false;
          return;
      }
    } while (this._loop);

    if (!this._errored) cb();
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @param {Function} cb Callback
   * @private
   */
  getInfo(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      const error = this.createError(
        RangeError,
        'RSV2 and RSV3 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_2_3'
      );

      cb(error);
      return;
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
      const error = this.createError(
        RangeError,
        'RSV1 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_1'
      );

      cb(error);
      return;
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        const error = this.createError(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );

        cb(error);
        return;
      }

      if (!this._fragmented) {
        const error = this.createError(
          RangeError,
          'invalid opcode 0',
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );

        cb(error);
        return;
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        const error = this.createError(
          RangeError,
          `invalid opcode ${this._opcode}`,
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );

        cb(error);
        return;
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        const error = this.createError(
          RangeError,
          'FIN must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_FIN'
        );

        cb(error);
        return;
      }

      if (compressed) {
        const error = this.createError(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );

        cb(error);
        return;
      }

      if (
        this._payloadLength > 0x7d ||
        (this._opcode === 0x08 && this._payloadLength === 1)
      ) {
        const error = this.createError(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002,
          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
        );

        cb(error);
        return;
      }
    } else {
      const error = this.createError(
        RangeError,
        `invalid opcode ${this._opcode}`,
        true,
        1002,
        'WS_ERR_INVALID_OPCODE'
      );

      cb(error);
      return;
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._isServer) {
      if (!this._masked) {
        const error = this.createError(
          RangeError,
          'MASK must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_MASK'
        );

        cb(error);
        return;
      }
    } else if (this._masked) {
      const error = this.createError(
        RangeError,
        'MASK must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_MASK'
      );

      cb(error);
      return;
    }

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else this.haveLength(cb);
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength16(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    this.haveLength(cb);
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength64(cb) {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      const error = this.createError(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009,
        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'
      );

      cb(error);
      return;
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    this.haveLength(cb);
  }

  /**
   * Payload length has been read.
   *
   * @param {Function} cb Callback
   * @private
   */
  haveLength(cb) {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        const error = this.createError(
          RangeError,
          'Max payload size exceeded',
          false,
          1009,
          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
        );

        cb(error);
        return;
      }
    }

    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @private
   */
  getData(cb) {
    let data = EMPTY_BUFFER;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);

      if (
        this._masked &&
        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0
      ) {
        unmask(data, this._mask);
      }
    }

    if (this._opcode > 0x07) {
      this.controlMessage(data, cb);
      return;
    }

    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its length is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    this.dataMessage(cb);
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          const error = this.createError(
            RangeError,
            'Max payload size exceeded',
            false,
            1009,
            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
          );

          cb(error);
          return;
        }

        this._fragments.push(buf);
      }

      this.dataMessage(cb);
      if (this._state === GET_INFO) this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @param {Function} cb Callback
   * @private
   */
  dataMessage(cb) {
    if (!this._fin) {
      this._state = GET_INFO;
      return;
    }

    const messageLength = this._messageLength;
    const fragments = this._fragments;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragmented = 0;
    this._fragments = [];

    if (this._opcode === 2) {
      let data;

      if (this._binaryType === 'nodebuffer') {
        data = concat(fragments, messageLength);
      } else if (this._binaryType === 'arraybuffer') {
        data = toArrayBuffer(concat(fragments, messageLength));
      } else {
        data = fragments;
      }

      //
      // If the state is `INFLATING`, it means that the frame data was
      // decompressed asynchronously, so there is no need to defer the event
      // as it will be emitted asynchronously anyway.
      //
      if (this._state === INFLATING || this._allowSynchronousEvents) {
        this.emit('message', data, true);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        queueTask(() => {
          this.emit('message', data, true);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    } else {
      const buf = concat(fragments, messageLength);

      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
        const error = this.createError(
          Error,
          'invalid UTF-8 sequence',
          true,
          1007,
          'WS_ERR_INVALID_UTF8'
        );

        cb(error);
        return;
      }

      if (this._state === INFLATING || this._allowSynchronousEvents) {
        this.emit('message', buf, false);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        queueTask(() => {
          this.emit('message', buf, false);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    }
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data, cb) {
    if (this._opcode === 0x08) {
      if (data.length === 0) {
        this._loop = false;
        this.emit('conclude', 1005, EMPTY_BUFFER);
        this.end();
      } else {
        const code = data.readUInt16BE(0);

        if (!isValidStatusCode(code)) {
          const error = this.createError(
            RangeError,
            `invalid status code ${code}`,
            true,
            1002,
            'WS_ERR_INVALID_CLOSE_CODE'
          );

          cb(error);
          return;
        }

        const buf = new FastBuffer(
          data.buffer,
          data.byteOffset + 2,
          data.length - 2
        );

        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          const error = this.createError(
            Error,
            'invalid UTF-8 sequence',
            true,
            1007,
            'WS_ERR_INVALID_UTF8'
          );

          cb(error);
          return;
        }

        this._loop = false;
        this.emit('conclude', code, buf);
        this.end();
      }

      this._state = GET_INFO;
      return;
    }

    if (this._allowSynchronousEvents) {
      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
      this._state = GET_INFO;
    } else {
      this._state = DEFER_EVENT;
      queueTask(() => {
        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
        this._state = GET_INFO;
        this.startLoop(cb);
      });
    }
  }

  /**
   * Builds an error object.
   *
   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
   * @param {String} message The error message
   * @param {Boolean} prefix Specifies whether or not to add a default prefix to
   *     `message`
   * @param {Number} statusCode The status code
   * @param {String} errorCode The exposed error code
   * @return {(Error|RangeError)} The error
   * @private
   */
  createError(ErrorCtor, message, prefix, statusCode, errorCode) {
    this._loop = false;
    this._errored = true;

    const err = new ErrorCtor(
      prefix ? `Invalid WebSocket frame: ${message}` : message
    );

    Error.captureStackTrace(err, this.createError);
    err.code = errorCode;
    err[kStatusCode] = statusCode;
    return err;
  }
}

module.exports = Receiver;

/**
 * A shim for `queueMicrotask()`.
 *
 * @param {Function} cb Callback
 */
function queueMicrotaskShim(cb) {
  promise.then(cb).catch(throwErrorNextTick);
}

/**
 * Throws an error.
 *
 * @param {Error} err The error to throw
 * @private
 */
function throwError(err) {
  throw err;
}

/**
 * Throws an error in the next tick.
 *
 * @param {Error} err The error to throw
 * @private
 */
function throwErrorNextTick(err) {
  process.nextTick(throwError, err);
}


/***/ }),

/***/ 1445:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex" }] */



const { Duplex } = __nccwpck_require__(2781);
const { randomFillSync } = __nccwpck_require__(6113);

const PerMessageDeflate = __nccwpck_require__(5705);
const { EMPTY_BUFFER } = __nccwpck_require__(13);
const { isValidStatusCode } = __nccwpck_require__(8415);
const { mask: applyMask, toBuffer } = __nccwpck_require__(3735);

const kByteLength = Symbol('kByteLength');
const maskBuffer = Buffer.alloc(4);

/**
 * HyBi Sender implementation.
 */
class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {Duplex} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   * @param {Function} [generateMask] The function used to generate the masking
   *     key
   */
  constructor(socket, extensions, generateMask) {
    this._extensions = extensions || {};

    if (generateMask) {
      this._generateMask = generateMask;
      this._maskBuffer = Buffer.alloc(4);
    }

    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._deflating = false;
    this._queue = [];
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {(Buffer|String)} data The data to frame
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {(Buffer|String)[]} The framed data
   * @public
   */
  static frame(data, options) {
    let mask;
    let merge = false;
    let offset = 2;
    let skipMasking = false;

    if (options.mask) {
      mask = options.maskBuffer || maskBuffer;

      if (options.generateMask) {
        options.generateMask(mask);
      } else {
        randomFillSync(mask, 0, 4);
      }

      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
      offset = 6;
    }

    let dataLength;

    if (typeof data === 'string') {
      if (
        (!options.mask || skipMasking) &&
        options[kByteLength] !== undefined
      ) {
        dataLength = options[kByteLength];
      } else {
        data = Buffer.from(data);
        dataLength = data.length;
      }
    } else {
      dataLength = data.length;
      merge = options.mask && options.readOnly && !skipMasking;
    }

    let payloadLength = dataLength;

    if (dataLength >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (dataLength > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    target[1] = payloadLength;

    if (payloadLength === 126) {
      target.writeUInt16BE(dataLength, 2);
    } else if (payloadLength === 127) {
      target[2] = target[3] = 0;
      target.writeUIntBE(dataLength, 4, 6);
    }

    if (!options.mask) return [target, data];

    target[1] |= 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (skipMasking) return [target, data];

    if (merge) {
      applyMask(data, mask, target, offset, dataLength);
      return [target];
    }

    applyMask(data, mask, data, 0, dataLength);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {Number} [code] The status code component of the body
   * @param {(String|Buffer)} [data] The message component of the body
   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
   * @param {Function} [cb] Callback
   * @public
   */
  close(code, data, mask, cb) {
    let buf;

    if (code === undefined) {
      buf = EMPTY_BUFFER;
    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || !data.length) {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data);

      if (length > 123) {
        throw new RangeError('The message must not be greater than 123 bytes');
      }

      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);

      if (typeof data === 'string') {
        buf.write(data, 2);
      } else {
        buf.set(data, 2);
      }
    }

    const options = {
      [kByteLength]: buf.length,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x08,
      readOnly: false,
      rsv1: false
    };

    if (this._deflating) {
      this.enqueue([this.dispatch, buf, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(buf, options), cb);
    }
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  ping(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x09,
      readOnly,
      rsv1: false
    };

    if (this._deflating) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  pong(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x0a,
      readOnly,
      rsv1: false
    };

    if (this._deflating) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
   *     or text
   * @param {Boolean} [options.compress=false] Specifies whether or not to
   *     compress `data`
   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Function} [cb] Callback
   * @public
   */
  send(data, options, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
    let opcode = options.binary ? 2 : 1;
    let rsv1 = options.compress;

    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (this._firstFragment) {
      this._firstFragment = false;
      if (
        rsv1 &&
        perMessageDeflate &&
        perMessageDeflate.params[
          perMessageDeflate._isServer
            ? 'server_no_context_takeover'
            : 'client_no_context_takeover'
        ]
      ) {
        rsv1 = byteLength >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    if (perMessageDeflate) {
      const opts = {
        [kByteLength]: byteLength,
        fin: options.fin,
        generateMask: this._generateMask,
        mask: options.mask,
        maskBuffer: this._maskBuffer,
        opcode,
        readOnly,
        rsv1
      };

      if (this._deflating) {
        this.enqueue([this.dispatch, data, this._compress, opts, cb]);
      } else {
        this.dispatch(data, this._compress, opts, cb);
      }
    } else {
      this.sendFrame(
        Sender.frame(data, {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1: false
        }),
        cb
      );
    }
  }

  /**
   * Dispatches a message.
   *
   * @param {(Buffer|String)} data The message to send
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     `data`
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  dispatch(data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    this._bufferedBytes += options[kByteLength];
    this._deflating = true;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err = new Error(
          'The socket was closed while data was being compressed'
        );

        if (typeof cb === 'function') cb(err);

        for (let i = 0; i < this._queue.length; i++) {
          const params = this._queue[i];
          const callback = params[params.length - 1];

          if (typeof callback === 'function') callback(err);
        }

        return;
      }

      this._bufferedBytes -= options[kByteLength];
      this._deflating = false;
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (!this._deflating && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[3][kByteLength];
      Reflect.apply(params[0], this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[3][kByteLength];
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {Buffer[]} list The frame to send
   * @param {Function} [cb] Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
}

module.exports = Sender;


/***/ }),

/***/ 9417:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { Duplex } = __nccwpck_require__(2781);

/**
 * Emits the `'close'` event on a stream.
 *
 * @param {Duplex} stream The stream.
 * @private
 */
function emitClose(stream) {
  stream.emit('close');
}

/**
 * The listener of the `'end'` event.
 *
 * @private
 */
function duplexOnEnd() {
  if (!this.destroyed && this._writableState.finished) {
    this.destroy();
  }
}

/**
 * The listener of the `'error'` event.
 *
 * @param {Error} err The error
 * @private
 */
function duplexOnError(err) {
  this.removeListener('error', duplexOnError);
  this.destroy();
  if (this.listenerCount('error') === 0) {
    // Do not suppress the throwing behavior.
    this.emit('error', err);
  }
}

/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param {WebSocket} ws The `WebSocket` to wrap
 * @param {Object} [options] The options for the `Duplex` constructor
 * @return {Duplex} The duplex stream
 * @public
 */
function createWebSocketStream(ws, options) {
  let terminateOnDestroy = true;

  const duplex = new Duplex({
    ...options,
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    writableObjectMode: false
  });

  ws.on('message', function message(msg, isBinary) {
    const data =
      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;

    if (!duplex.push(data)) ws.pause();
  });

  ws.once('error', function error(err) {
    if (duplex.destroyed) return;

    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
    //
    // - If the `'error'` event is emitted before the `'open'` event, then
    //   `ws.terminate()` is a noop as no socket is assigned.
    // - Otherwise, the error is re-emitted by the listener of the `'error'`
    //   event of the `Receiver` object. The listener already closes the
    //   connection by calling `ws.close()`. This allows a close frame to be
    //   sent to the other peer. If `ws.terminate()` is called right after this,
    //   then the close frame might not be sent.
    terminateOnDestroy = false;
    duplex.destroy(err);
  });

  ws.once('close', function close() {
    if (duplex.destroyed) return;

    duplex.push(null);
  });

  duplex._destroy = function (err, callback) {
    if (ws.readyState === ws.CLOSED) {
      callback(err);
      process.nextTick(emitClose, duplex);
      return;
    }

    let called = false;

    ws.once('error', function error(err) {
      called = true;
      callback(err);
    });

    ws.once('close', function close() {
      if (!called) callback(err);
      process.nextTick(emitClose, duplex);
    });

    if (terminateOnDestroy) ws.terminate();
  };

  duplex._final = function (callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._final(callback);
      });
      return;
    }

    // If the value of the `_socket` property is `null` it means that `ws` is a
    // client websocket and the handshake failed. In fact, when this happens, a
    // socket is never assigned to the websocket. Wait for the `'error'` event
    // that will be emitted by the websocket.
    if (ws._socket === null) return;

    if (ws._socket._writableState.finished) {
      callback();
      if (duplex._readableState.endEmitted) duplex.destroy();
    } else {
      ws._socket.once('finish', function finish() {
        // `duplex` is not destroyed here because the `'end'` event will be
        // emitted on `duplex` after this `'finish'` event. The EOF signaling
        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
        callback();
      });
      ws.close();
    }
  };

  duplex._read = function () {
    if (ws.isPaused) ws.resume();
  };

  duplex._write = function (chunk, encoding, callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._write(chunk, encoding, callback);
      });
      return;
    }

    ws.send(chunk, callback);
  };

  duplex.on('end', duplexOnEnd);
  duplex.on('error', duplexOnError);
  return duplex;
}

module.exports = createWebSocketStream;


/***/ }),

/***/ 4421:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { tokenChars } = __nccwpck_require__(8415);

/**
 * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
 *
 * @param {String} header The field value of the header
 * @return {Set} The subprotocol names
 * @public
 */
function parse(header) {
  const protocols = new Set();
  let start = -1;
  let end = -1;
  let i = 0;

  for (i; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (end === -1 && tokenChars[code] === 1) {
      if (start === -1) start = i;
    } else if (
      i !== 0 &&
      (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
    ) {
      if (end === -1 && start !== -1) end = i;
    } else if (code === 0x2c /* ',' */) {
      if (start === -1) {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }

      if (end === -1) end = i;

      const protocol = header.slice(start, end);

      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }

      protocols.add(protocol);
      start = end = -1;
    } else {
      throw new SyntaxError(`Unexpected character at index ${i}`);
    }
  }

  if (start === -1 || end !== -1) {
    throw new SyntaxError('Unexpected end of input');
  }

  const protocol = header.slice(start, i);

  if (protocols.has(protocol)) {
    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
  }

  protocols.add(protocol);
  return protocols;
}

module.exports = { parse };


/***/ }),

/***/ 8415:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { isUtf8 } = __nccwpck_require__(4300);

//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
function isValidStatusCode(code) {
  return (
    (code >= 1000 &&
      code <= 1014 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
}

/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */
function _isValidUTF8(buf) {
  const len = buf.length;
  let i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0) {
      // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {
      // 110xxxxx 10xxxxxx
      if (
        i + 1 === len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i] & 0xfe) === 0xc0 // Overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {
      // 1110xxxx 10xxxxxx 10xxxxxx
      if (
        i + 2 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong
        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {
      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (
        i + 3 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i + 3] & 0xc0) !== 0x80 ||
        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong
        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
        buf[i] > 0xf4 // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

module.exports = {
  isValidStatusCode,
  isValidUTF8: _isValidUTF8,
  tokenChars
};

if (isUtf8) {
  module.exports.isValidUTF8 = function (buf) {
    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
  };
} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {
  try {
    const isValidUTF8 = __nccwpck_require__(3045);

    module.exports.isValidUTF8 = function (buf) {
      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}


/***/ }),

/***/ 7378:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex$" }] */



const EventEmitter = __nccwpck_require__(2361);
const http = __nccwpck_require__(3685);
const { Duplex } = __nccwpck_require__(2781);
const { createHash } = __nccwpck_require__(6113);

const extension = __nccwpck_require__(5853);
const PerMessageDeflate = __nccwpck_require__(5705);
const subprotocol = __nccwpck_require__(4421);
const WebSocket = __nccwpck_require__(3413);
const { GUID, kWebSocket } = __nccwpck_require__(13);

const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

const RUNNING = 0;
const CLOSING = 1;
const CLOSED = 2;

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Boolean} [options.autoPong=true] Specifies whether or not to
   *     automatically send a pong in response to a ping
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
   *     server to use
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
   *     class to use. It must be the `WebSocket` class or class that extends it
   * @param {Function} [callback] A listener for the `listening` event
   */
  constructor(options, callback) {
    super();

    options = {
      allowSynchronousEvents: false,
      autoPong: true,
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      WebSocket,
      ...options
    };

    if (
      (options.port == null && !options.server && !options.noServer) ||
      (options.port != null && (options.server || options.noServer)) ||
      (options.server && options.noServer)
    ) {
      throw new TypeError(
        'One and only one of the "port", "server", or "noServer" options ' +
          'must be specified'
      );
    }

    if (options.port != null) {
      this._server = http.createServer((req, res) => {
        const body = http.STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      const emitConnection = this.emit.bind(this, 'connection');

      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, emitConnection);
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) {
      this.clients = new Set();
      this._shouldEmitClose = false;
    }

    this.options = options;
    this._state = RUNNING;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Stop the server from accepting new connections and emit the `'close'` event
   * when all existing connections are closed.
   *
   * @param {Function} [cb] A one-time listener for the `'close'` event
   * @public
   */
  close(cb) {
    if (this._state === CLOSED) {
      if (cb) {
        this.once('close', () => {
          cb(new Error('The server is not running'));
        });
      }

      process.nextTick(emitClose, this);
      return;
    }

    if (cb) this.once('close', cb);

    if (this._state === CLOSING) return;
    this._state = CLOSING;

    if (this.options.noServer || this.options.server) {
      if (this._server) {
        this._removeListeners();
        this._removeListeners = this._server = null;
      }

      if (this.clients) {
        if (!this.clients.size) {
          process.nextTick(emitClose, this);
        } else {
          this._shouldEmitClose = true;
        }
      } else {
        process.nextTick(emitClose, this);
      }
    } else {
      const server = this._server;

      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // The HTTP/S server was created internally. Close it, and rely on its
      // `'close'` event.
      //
      server.close(() => {
        emitClose(this);
      });
    }
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) {
    if (this.options.path) {
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) {
    socket.on('error', socketOnError);

    const key = req.headers['sec-websocket-key'];
    const version = +req.headers['sec-websocket-version'];

    if (req.method !== 'GET') {
      const message = 'Invalid HTTP method';
      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
      return;
    }

    if (req.headers.upgrade.toLowerCase() !== 'websocket') {
      const message = 'Invalid Upgrade header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (!key || !keyRegex.test(key)) {
      const message = 'Missing or invalid Sec-WebSocket-Key header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (version !== 8 && version !== 13) {
      const message = 'Missing or invalid Sec-WebSocket-Version header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (!this.shouldHandle(req)) {
      abortHandshake(socket, 400);
      return;
    }

    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
    let protocols = new Set();

    if (secWebSocketProtocol !== undefined) {
      try {
        protocols = subprotocol.parse(secWebSocketProtocol);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Protocol header';
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }

    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
    const extensions = {};

    if (
      this.options.perMessageDeflate &&
      secWebSocketExtensions !== undefined
    ) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = extension.parse(secWebSocketExtensions);

        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        const message =
          'Invalid or unacceptable Sec-WebSocket-Extensions header';
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin:
          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.socket.authorized || req.socket.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }

          this.completeUpgrade(
            extensions,
            key,
            protocols,
            req,
            socket,
            head,
            cb
          );
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }

    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {Object} extensions The accepted extensions
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Set} protocols The subprotocols
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    if (socket[kWebSocket]) {
      throw new Error(
        'server.handleUpgrade() was called more than once with the same ' +
          'socket, possibly due to a misconfiguration'
      );
    }

    if (this._state > RUNNING) return abortHandshake(socket, 503);

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${digest}`
    ];

    const ws = new this.options.WebSocket(null, undefined, this.options);

    if (protocols.size) {
      //
      // Optionally call external protocol selection handler.
      //
      const protocol = this.options.handleProtocols
        ? this.options.handleProtocols(protocols, req)
        : protocols.values().next().value;

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws._protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = extension.format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, {
      allowSynchronousEvents: this.options.allowSynchronousEvents,
      maxPayload: this.options.maxPayload,
      skipUTF8Validation: this.options.skipUTF8Validation
    });

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => {
        this.clients.delete(ws);

        if (this._shouldEmitClose && !this.clients.size) {
          process.nextTick(emitClose, this);
        }
      });
    }

    cb(ws, req);
  }
}

module.exports = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when
 *     called
 * @private
 */
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */
function emitClose(server) {
  server._state = CLOSED;
  server.emit('close');
}

/**
 * Handle socket errors.
 *
 * @private
 */
function socketOnError() {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {Duplex} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) {
  //
  // The socket is writable unless the user destroyed or ended it before calling
  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user
  // error. Handling this does not make much sense as the worst that can happen
  // is that some of the data written by the user might be discarded due to the
  // call to `socket.end()` below, which triggers an `'error'` event that in
  // turn causes the socket to be destroyed.
  //
  message = message || http.STATUS_CODES[code];
  headers = {
    Connection: 'close',
    'Content-Type': 'text/html',
    'Content-Length': Buffer.byteLength(message),
    ...headers
  };

  socket.once('finish', socket.destroy);

  socket.end(
    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` +
      Object.keys(headers)
        .map((h) => `${h}: ${headers[h]}`)
        .join('\r\n') +
      '\r\n\r\n' +
      message
  );
}

/**
 * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
 * one listener for it, otherwise call `abortHandshake()`.
 *
 * @param {WebSocketServer} server The WebSocket server
 * @param {http.IncomingMessage} req The request object
 * @param {Duplex} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} message The HTTP response body
 * @private
 */
function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
  if (server.listenerCount('wsClientError')) {
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);

    server.emit('wsClientError', err, socket, req);
  } else {
    abortHandshake(socket, code, message);
  }
}


/***/ }),

/***/ 3413:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex|Readable$" }] */



const EventEmitter = __nccwpck_require__(2361);
const https = __nccwpck_require__(5687);
const http = __nccwpck_require__(3685);
const net = __nccwpck_require__(1808);
const tls = __nccwpck_require__(4404);
const { randomBytes, createHash } = __nccwpck_require__(6113);
const { Duplex, Readable } = __nccwpck_require__(2781);
const { URL } = __nccwpck_require__(7310);

const PerMessageDeflate = __nccwpck_require__(5705);
const Receiver = __nccwpck_require__(3318);
const Sender = __nccwpck_require__(1445);
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID,
  kForOnEventAttribute,
  kListener,
  kStatusCode,
  kWebSocket,
  NOOP
} = __nccwpck_require__(13);
const {
  EventTarget: { addEventListener, removeEventListener }
} = __nccwpck_require__(3610);
const { format, parse } = __nccwpck_require__(5853);
const { toBuffer } = __nccwpck_require__(3735);

const closeTimeout = 30 * 1000;
const kAborted = Symbol('kAborted');
const protocolVersions = [8, 13];
const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
class WebSocket extends EventEmitter {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  constructor(address, protocols, options) {
    super();

    this._binaryType = BINARY_TYPES[0];
    this._closeCode = 1006;
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = EMPTY_BUFFER;
    this._closeTimer = null;
    this._extensions = {};
    this._paused = false;
    this._protocol = '';
    this._readyState = WebSocket.CONNECTING;
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;

      if (protocols === undefined) {
        protocols = [];
      } else if (!Array.isArray(protocols)) {
        if (typeof protocols === 'object' && protocols !== null) {
          options = protocols;
          protocols = [];
        } else {
          protocols = [protocols];
        }
      }

      initAsClient(this, address, protocols, options);
    } else {
      this._autoPong = options.autoPong;
      this._isServer = true;
    }
  }

  /**
   * This deviates from the WHATWG interface since ws doesn't support the
   * required default "blob" type (instead we define a custom "nodebuffer"
   * type).
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return this._bufferedAmount;

    return this._socket._writableState.length + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * @type {Boolean}
   */
  get isPaused() {
    return this._paused;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onclose() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onerror() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onopen() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onmessage() {
    return null;
  }

  /**
   * @type {String}
   */
  get protocol() {
    return this._protocol;
  }

  /**
   * @type {Number}
   */
  get readyState() {
    return this._readyState;
  }

  /**
   * @type {String}
   */
  get url() {
    return this._url;
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Object} options Options object
   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Number} [options.maxPayload=0] The maximum allowed message size
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @private
   */
  setSocket(socket, head, options) {
    const receiver = new Receiver({
      allowSynchronousEvents: options.allowSynchronousEvents,
      binaryType: this.binaryType,
      extensions: this._extensions,
      isServer: this._isServer,
      maxPayload: options.maxPayload,
      skipUTF8Validation: options.skipUTF8Validation
    });

    this._sender = new Sender(socket, this._extensions, options.generateMask);
    this._receiver = receiver;
    this._socket = socket;

    receiver[kWebSocket] = this;
    socket[kWebSocket] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    //
    // These methods may not be available if `socket` is just a `Duplex`.
    //
    if (socket.setTimeout) socket.setTimeout(0);
    if (socket.setNoDelay) socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError);

    this._readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this._readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate.extensionName]) {
      this._extensions[PerMessageDeflate.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this._readyState = WebSocket.CLOSED;
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {(String|Buffer)} [data] The reason why the connection is
   *     closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      abortHandshake(this, this._req, msg);
      return;
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (
        this._closeFrameSent &&
        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)
      ) {
        this._socket.end();
      }

      return;
    }

    this._readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;

      if (
        this._closeFrameReceived ||
        this._receiver._writableState.errorEmitted
      ) {
        this._socket.end();
      }
    });

    //
    // Specify a timeout for the closing handshake to complete.
    //
    this._closeTimer = setTimeout(
      this._socket.destroy.bind(this._socket),
      closeTimeout
    );
  }

  /**
   * Pause the socket.
   *
   * @public
   */
  pause() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = true;
    this._socket.pause();
  }

  /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Resume the socket.
   *
   * @public
   */
  resume() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = false;
    if (!this._receiver._writableState.needDrain) this._socket.resume();
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    const opts = {
      binary: typeof data !== 'string',
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options
    };

    if (!this._extensions[PerMessageDeflate.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      abortHandshake(this, this._req, msg);
      return;
    }

    if (this._socket) {
      this._readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
}

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

[
  'binaryType',
  'bufferedAmount',
  'extensions',
  'isPaused',
  'protocol',
  'readyState',
  'url'
].forEach((property) => {
  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket.prototype, `on${method}`, {
    enumerable: true,
    get() {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) return listener[kListener];
      }

      return null;
    },
    set(handler) {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) {
          this.removeListener(method, listener);
          break;
        }
      }

      if (typeof handler !== 'function') return;

      this.addEventListener(method, handler, {
        [kForOnEventAttribute]: true
      });
    }
  });
});

WebSocket.prototype.addEventListener = addEventListener;
WebSocket.prototype.removeEventListener = removeEventListener;

module.exports = WebSocket;

/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|URL)} address The URL to which to connect
 * @param {Array} protocols The subprotocols
 * @param {Object} [options] Connection options
 * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether any
 *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
 *     times in the same tick
 * @param {Boolean} [options.autoPong=true] Specifies whether or not to
 *     automatically send a pong in response to a ping
 * @param {Function} [options.finishRequest] A function which can be used to
 *     customize the headers of each http request before it is sent
 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
 *     redirects
 * @param {Function} [options.generateMask] The function used to generate the
 *     masking key
 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
 *     handshake request
 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
 *     size
 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
 *     allowed
 * @param {String} [options.origin] Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
 *     permessage-deflate
 * @param {Number} [options.protocolVersion=13] Value of the
 *     `Sec-WebSocket-Version` header
 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
 *     not to skip UTF-8 validation for text and close messages
 * @private
 */
function initAsClient(websocket, address, protocols, options) {
  const opts = {
    allowSynchronousEvents: false,
    autoPong: true,
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options,
    createConnection: undefined,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: 'GET',
    host: undefined,
    path: undefined,
    port: undefined
  };

  websocket._autoPong = opts.autoPong;

  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  let parsedUrl;

  if (address instanceof URL) {
    parsedUrl = address;
  } else {
    try {
      parsedUrl = new URL(address);
    } catch (e) {
      throw new SyntaxError(`Invalid URL: ${address}`);
    }
  }

  if (parsedUrl.protocol === 'http:') {
    parsedUrl.protocol = 'ws:';
  } else if (parsedUrl.protocol === 'https:') {
    parsedUrl.protocol = 'wss:';
  }

  websocket._url = parsedUrl.href;

  const isSecure = parsedUrl.protocol === 'wss:';
  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';
  let invalidUrlMessage;

  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
    invalidUrlMessage =
      'The URL\'s protocol must be one of "ws:", "wss:", ' +
      '"http:", "https", or "ws+unix:"';
  } else if (isIpcUrl && !parsedUrl.pathname) {
    invalidUrlMessage = "The URL's pathname is empty";
  } else if (parsedUrl.hash) {
    invalidUrlMessage = 'The URL contains a fragment identifier';
  }

  if (invalidUrlMessage) {
    const err = new SyntaxError(invalidUrlMessage);

    if (websocket._redirects === 0) {
      throw err;
    } else {
      emitErrorAndClose(websocket, err);
      return;
    }
  }

  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString('base64');
  const request = isSecure ? https.request : http.request;
  const protocolSet = new Set();
  let perMessageDeflate;

  opts.createConnection = isSecure ? tlsConnect : netConnect;
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  opts.headers = {
    ...opts.headers,
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket'
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers['Sec-WebSocket-Extensions'] = format({
      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols.length) {
    for (const protocol of protocols) {
      if (
        typeof protocol !== 'string' ||
        !subprotocolRegex.test(protocol) ||
        protocolSet.has(protocol)
      ) {
        throw new SyntaxError(
          'An invalid or duplicated subprotocol was specified'
        );
      }

      protocolSet.add(protocol);
    }

    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isIpcUrl) {
    const parts = opts.path.split(':');

    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  let req;

  if (opts.followRedirects) {
    if (websocket._redirects === 0) {
      websocket._originalIpc = isIpcUrl;
      websocket._originalSecure = isSecure;
      websocket._originalHostOrSocketPath = isIpcUrl
        ? opts.socketPath
        : parsedUrl.host;

      const headers = options && options.headers;

      //
      // Shallow copy the user provided options so that headers can be changed
      // without mutating the original object.
      //
      options = { ...options, headers: {} };

      if (headers) {
        for (const [key, value] of Object.entries(headers)) {
          options.headers[key.toLowerCase()] = value;
        }
      }
    } else if (websocket.listenerCount('redirect') === 0) {
      const isSameHost = isIpcUrl
        ? websocket._originalIpc
          ? opts.socketPath === websocket._originalHostOrSocketPath
          : false
        : websocket._originalIpc
          ? false
          : parsedUrl.host === websocket._originalHostOrSocketPath;

      if (!isSameHost || (websocket._originalSecure && !isSecure)) {
        //
        // Match curl 7.77.0 behavior and drop the following headers. These
        // headers are also dropped when following a redirect to a subdomain.
        //
        delete opts.headers.authorization;
        delete opts.headers.cookie;

        if (!isSameHost) delete opts.headers.host;

        opts.auth = undefined;
      }
    }

    //
    // Match curl 7.77.0 behavior and make the first `Authorization` header win.
    // If the `Authorization` header is set, then there is nothing to do as it
    // will take precedence.
    //
    if (opts.auth && !options.headers.authorization) {
      options.headers.authorization =
        'Basic ' + Buffer.from(opts.auth).toString('base64');
    }

    req = websocket._req = request(opts);

    if (websocket._redirects) {
      //
      // Unlike what is done for the `'upgrade'` event, no early exit is
      // triggered here if the user calls `websocket.close()` or
      // `websocket.terminate()` from a listener of the `'redirect'` event. This
      // is because the user can also call `request.destroy()` with an error
      // before calling `websocket.close()` or `websocket.terminate()` and this
      // would result in an error being emitted on the `request` object with no
      // `'error'` event listeners attached.
      //
      websocket.emit('redirect', websocket.url, req);
    }
  } else {
    req = websocket._req = request(opts);
  }

  if (opts.timeout) {
    req.on('timeout', () => {
      abortHandshake(websocket, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', (err) => {
    if (req === null || req[kAborted]) return;

    req = websocket._req = null;
    emitErrorAndClose(websocket, err);
  });

  req.on('response', (res) => {
    const location = res.headers.location;
    const statusCode = res.statusCode;

    if (
      location &&
      opts.followRedirects &&
      statusCode >= 300 &&
      statusCode < 400
    ) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake(websocket, req, 'Maximum redirects exceeded');
        return;
      }

      req.abort();

      let addr;

      try {
        addr = new URL(location, address);
      } catch (e) {
        const err = new SyntaxError(`Invalid URL: ${location}`);
        emitErrorAndClose(websocket, err);
        return;
      }

      initAsClient(websocket, addr, protocols, options);
    } else if (!websocket.emit('unexpected-response', req, res)) {
      abortHandshake(
        websocket,
        req,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });

  req.on('upgrade', (res, socket, head) => {
    websocket.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the
    // `'upgrade'` event.
    //
    if (websocket.readyState !== WebSocket.CONNECTING) return;

    req = websocket._req = null;

    if (res.headers.upgrade.toLowerCase() !== 'websocket') {
      abortHandshake(websocket, socket, 'Invalid Upgrade header');
      return;
    }

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    let protError;

    if (serverProt !== undefined) {
      if (!protocolSet.size) {
        protError = 'Server sent a subprotocol but none was requested';
      } else if (!protocolSet.has(serverProt)) {
        protError = 'Server sent an invalid subprotocol';
      }
    } else if (protocolSet.size) {
      protError = 'Server sent no subprotocol';
    }

    if (protError) {
      abortHandshake(websocket, socket, protError);
      return;
    }

    if (serverProt) websocket._protocol = serverProt;

    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];

    if (secWebSocketExtensions !== undefined) {
      if (!perMessageDeflate) {
        const message =
          'Server sent a Sec-WebSocket-Extensions header but no extension ' +
          'was requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      let extensions;

      try {
        extensions = parse(secWebSocketExtensions);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, message);
        return;
      }

      const extensionNames = Object.keys(extensions);

      if (
        extensionNames.length !== 1 ||
        extensionNames[0] !== PerMessageDeflate.extensionName
      ) {
        const message = 'Server indicated an extension that was not requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      try {
        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, message);
        return;
      }

      websocket._extensions[PerMessageDeflate.extensionName] =
        perMessageDeflate;
    }

    websocket.setSocket(socket, head, {
      allowSynchronousEvents: opts.allowSynchronousEvents,
      generateMask: opts.generateMask,
      maxPayload: opts.maxPayload,
      skipUTF8Validation: opts.skipUTF8Validation
    });
  });

  if (opts.finishRequest) {
    opts.finishRequest(req, websocket);
  } else {
    req.end();
  }
}

/**
 * Emit the `'error'` and `'close'` events.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {Error} The error to emit
 * @private
 */
function emitErrorAndClose(websocket, err) {
  websocket._readyState = WebSocket.CLOSING;
  websocket.emit('error', err);
  websocket.emitClose();
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect(options) {
  options.path = options.socketPath;
  return net.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect(options) {
  options.path = undefined;

  if (!options.servername && options.servername !== '') {
    options.servername = net.isIP(options.host) ? '' : options.host;
  }

  return tls.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
 *     abort or the socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake(websocket, stream, message) {
  websocket._readyState = WebSocket.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) {
    stream[kAborted] = true;
    stream.abort();

    if (stream.socket && !stream.socket.destroyed) {
      //
      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
      // called after the request completed. See
      // https://github.com/websockets/ws/issues/1869.
      //
      stream.socket.destroy();
    }

    process.nextTick(emitErrorAndClose, websocket, err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} [data] The data to send
 * @param {Function} [cb] Callback
 * @private
 */
function sendAfterClose(websocket, data, cb) {
  if (data) {
    const length = toBuffer(data).length;

    //
    // The `_bufferedAmount` property is used only when the peer is a client and
    // the opening handshake fails. Under these circumstances, in fact, the
    // `setSocket()` method is not called, so the `_socket` and `_sender`
    // properties are set to `null`.
    //
    if (websocket._socket) websocket._sender._bufferedBytes += length;
    else websocket._bufferedAmount += length;
  }

  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket.readyState} ` +
        `(${readyStates[websocket.readyState]})`
    );
    process.nextTick(cb, err);
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {Buffer} reason The reason for closing
 * @private
 */
function receiverOnConclude(code, reason) {
  const websocket = this[kWebSocket];

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (websocket._socket[kWebSocket] === undefined) return;

  websocket._socket.removeListener('data', socketOnData);
  process.nextTick(resume, websocket._socket);

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain() {
  const websocket = this[kWebSocket];

  if (!websocket.isPaused) websocket._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError(err) {
  const websocket = this[kWebSocket];

  if (websocket._socket[kWebSocket] !== undefined) {
    websocket._socket.removeListener('data', socketOnData);

    //
    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
    // https://github.com/websockets/ws/issues/1940.
    //
    process.nextTick(resume, websocket._socket);

    websocket.close(err[kStatusCode]);
  }

  websocket.emit('error', err);
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish() {
  this[kWebSocket].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {Buffer|ArrayBuffer|Buffer[])} data The message
 * @param {Boolean} isBinary Specifies whether the message is binary or not
 * @private
 */
function receiverOnMessage(data, isBinary) {
  this[kWebSocket].emit('message', data, isBinary);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing(data) {
  const websocket = this[kWebSocket];

  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong(data) {
  this[kWebSocket].emit('pong', data);
}

/**
 * Resume a readable stream
 *
 * @param {Readable} stream The readable stream
 * @private
 */
function resume(stream) {
  stream.resume();
}

/**
 * The listener of the socket `'close'` event.
 *
 * @private
 */
function socketOnClose() {
  const websocket = this[kWebSocket];

  this.removeListener('close', socketOnClose);
  this.removeListener('data', socketOnData);
  this.removeListener('end', socketOnEnd);

  websocket._readyState = WebSocket.CLOSING;

  let chunk;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk.
  //
  if (
    !this._readableState.endEmitted &&
    !websocket._closeFrameReceived &&
    !websocket._receiver._writableState.errorEmitted &&
    (chunk = websocket._socket.read()) !== null
  ) {
    websocket._receiver.write(chunk);
  }

  websocket._receiver.end();

  this[kWebSocket] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the socket `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the socket `'end'` event.
 *
 * @private
 */
function socketOnEnd() {
  const websocket = this[kWebSocket];

  websocket._readyState = WebSocket.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the socket `'error'` event.
 *
 * @private
 */
function socketOnError() {
  const websocket = this[kWebSocket];

  this.removeListener('error', socketOnError);
  this.on('error', NOOP);

  if (websocket) {
    websocket._readyState = WebSocket.CLOSING;
    this.destroy();
  }
}


/***/ }),

/***/ 6991:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var ripple_keypairs_1 = __nccwpck_require__(8150);
var Utils = __importStar(__nccwpck_require__(8135));
var Account_1 = __importDefault(__nccwpck_require__(3619));
var familySeed = function (familyseed, options) {
    var Keypair = (0, ripple_keypairs_1.deriveKeypair)(familyseed, options);
    var Address = (0, ripple_keypairs_1.deriveAddress)(Keypair.publicKey);
    return new Account_1.default({
        algorithm: Utils.getAlgorithmFromKey(Keypair.privateKey),
        address: Address,
        familySeed: familyseed,
        keypair: Keypair
    });
};
exports["default"] = familySeed;


/***/ }),

/***/ 4346:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.passphrase = exports.privatekey = exports.secretNumbers = exports.familySeed = exports.mnemonic = void 0;
var mnemonic_1 = __importDefault(__nccwpck_require__(5310));
exports.mnemonic = mnemonic_1.default;
var familySeed_1 = __importDefault(__nccwpck_require__(6991));
exports.familySeed = familySeed_1.default;
var secretNumbers_1 = __importDefault(__nccwpck_require__(6314));
exports.secretNumbers = secretNumbers_1.default;
var privatekey_1 = __importDefault(__nccwpck_require__(5643));
exports.privatekey = privatekey_1.default;
var passphrase_1 = __importDefault(__nccwpck_require__(3806));
exports.passphrase = passphrase_1.default;


/***/ }),

/***/ 5310:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var bip39_1 = __nccwpck_require__(781);
var Bip32 = __importStar(__nccwpck_require__(821));
var ripple_keypairs_1 = __nccwpck_require__(8150);
var Account_1 = __importDefault(__nccwpck_require__(3619));
var Utils = __importStar(__nccwpck_require__(8135));
var mnemonic = function (words, options) {
    if (options === void 0) { options = {}; }
    var passphrase = options.passphrase ? options.passphrase : undefined;
    var accountPath = options.accountPath && !isNaN(parseInt(options.accountPath))
        ? options.accountPath
        : 0;
    var changePath = options.changePath && !isNaN(parseInt(options.changePath))
        ? options.changePath
        : 0;
    var addressIndex = options.addressIndex && !isNaN(options.addressIndex)
        ? options.addressIndex
        : 0;
    var Path = "m/44'/144'/".concat(accountPath, "'/").concat(changePath, "/").concat(addressIndex);
    var Seed = (0, bip39_1.mnemonicToSeedSync)(words, passphrase);
    var m = Bip32.fromSeed(Seed);
    var Node = m.derivePath(Path);
    var publicKey = Utils.bufferToHext(Node.publicKey);
    // @ts-ignore
    var privateKey = Utils.bufferToHext(Node.privateKey);
    var Keypair = {
        publicKey: publicKey,
        privateKey: "00" + privateKey
    };
    var Address = (0, ripple_keypairs_1.deriveAddress)(Keypair.publicKey);
    return new Account_1.default({
        address: Address,
        mnemonic: words,
        passphrase: passphrase,
        keypair: Keypair,
        path: Path
    });
};
exports["default"] = mnemonic;


/***/ }),

/***/ 3806:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var hash_js_1 = __importDefault(__nccwpck_require__(609));
var ripple_secret_codec_1 = __nccwpck_require__(8524);
var ripple_keypairs_1 = __nccwpck_require__(8150);
var Account_1 = __importDefault(__nccwpck_require__(3619));
var passphrase = function (phrase) {
    var hash = hash_js_1.default
        .sha512()
        .update(phrase)
        .digest("hex")
        .toUpperCase();
    var hexSeed = hash.substring(0, 32);
    var familySeed = (0, ripple_secret_codec_1.encodeHex)(hexSeed).secret_b58;
    var keypair = (0, ripple_keypairs_1.deriveKeypair)(familySeed);
    var address = (0, ripple_keypairs_1.deriveAddress)(keypair.publicKey);
    return new Account_1.default({
        familySeed: familySeed,
        address: address,
        passphrase: phrase,
        keypair: keypair
    });
};
exports["default"] = passphrase;


/***/ }),

/***/ 5643:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Account_1 = __importDefault(__nccwpck_require__(3619));
var privatekey = function (hex) {
    // Account{} will recover required data
    return new Account_1.default({
        keypair: { privateKey: hex }
    });
};
exports["default"] = privatekey;


/***/ }),

/***/ 6314:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var XrplSecretNumbers = __importStar(__nccwpck_require__(8030));
var Utils = __importStar(__nccwpck_require__(8135));
var Account_1 = __importDefault(__nccwpck_require__(3619));
var secretNumbers = function (numbers, skipChecksum) {
    if (skipChecksum === void 0) { skipChecksum = false; }
    var secretNumbers = numbers;
    if (skipChecksum) {
        var notChecksummed = Array.isArray(numbers)
            ? numbers
            : numbers.split(' ');
        if (notChecksummed.every(function (c) { return String(c).length === 5 || String(c).length === 6; })) {
            secretNumbers = notChecksummed.map(function (n, i) {
                var s = String(n).slice(0, 5);
                return s + XrplSecretNumbers.Utils.calculateChecksum(i, Number(s));
            });
        }
    }
    var secretNumbersAccount = new XrplSecretNumbers.Account(secretNumbers);
    var keypair = secretNumbersAccount.getKeypair();
    return new Account_1.default({
        algorithm: Utils.getAlgorithmFromKey(keypair.privateKey),
        address: secretNumbersAccount.getAddress(),
        familySeed: secretNumbersAccount.getFamilySeed(),
        keypair: keypair,
        secretNumbers: secretNumbersAccount.getSecret()
    });
};
exports["default"] = secretNumbers;


/***/ }),

/***/ 5591:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var ripple_keypairs_1 = __nccwpck_require__(8150);
var Account_1 = __importDefault(__nccwpck_require__(3619));
var familySeed = function (options) {
    if (options === void 0) { options = {}; }
    options = Object.assign(options, {
        algorithm: options.algorithm === "ed25519" ? "ed25519" : "secp256k1"
    });
    var Familyseed = (0, ripple_keypairs_1.generateSeed)(options);
    var Keypair = (0, ripple_keypairs_1.deriveKeypair)(Familyseed);
    var Address = (0, ripple_keypairs_1.deriveAddress)(Keypair.publicKey);
    return new Account_1.default({
        algorithm: options.algorithm,
        address: Address,
        familySeed: Familyseed,
        keypair: Keypair
    });
};
exports["default"] = familySeed;


/***/ }),

/***/ 3738:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.secretNumbers = exports.familySeed = exports.mnemonic = void 0;
var mnemonic_1 = __importDefault(__nccwpck_require__(8237));
exports.mnemonic = mnemonic_1.default;
var familySeed_1 = __importDefault(__nccwpck_require__(5591));
exports.familySeed = familySeed_1.default;
var secretNumbers_1 = __importDefault(__nccwpck_require__(1124));
exports.secretNumbers = secretNumbers_1.default;


/***/ }),

/***/ 8237:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var bip39_1 = __nccwpck_require__(781);
var Bip32 = __importStar(__nccwpck_require__(821));
var ripple_keypairs_1 = __nccwpck_require__(8150);
var crypto_1 = __nccwpck_require__(6113);
var Account_1 = __importDefault(__nccwpck_require__(3619));
var Utils = __importStar(__nccwpck_require__(8135));
var mnemonic = function (options) {
    if (options === void 0) { options = {}; }
    var passphrase = options.passphrase ? options.passphrase : undefined;
    var strength = options.strength ? options.strength : 256;
    var Wordlist = options.wordlist && Object.keys(bip39_1.wordlists).indexOf(options.wordlist) > -1
        ? bip39_1.wordlists[options.wordlist]
        : undefined;
    var words = (0, bip39_1.generateMnemonic)(strength, function (size) { return Buffer.from((0, crypto_1.randomBytes)(size)); }, Wordlist);
    var accountPath = options.accountPath && !isNaN(parseInt(options.accountPath))
        ? options.accountPath
        : 0;
    var changePath = options.changePath && !isNaN(parseInt(options.changePath))
        ? options.changePath
        : 0;
    var addressIndex = options.addressIndex && !isNaN(options.addressIndex)
        ? options.addressIndex
        : 0;
    var Path = "m/44'/144'/".concat(accountPath, "'/").concat(changePath, "/").concat(addressIndex);
    var Seed = (0, bip39_1.mnemonicToSeedSync)(words, passphrase);
    var m = Bip32.fromSeed(Seed);
    var Node = m.derivePath(Path);
    var publicKey = Utils.bufferToHext(Node.publicKey);
    // @ts-ignore
    var privateKey = Utils.bufferToHext(Node.privateKey);
    var Keypair = {
        publicKey: publicKey,
        privateKey: "00" + privateKey,
    };
    var Address = (0, ripple_keypairs_1.deriveAddress)(Keypair.publicKey);
    return new Account_1.default({
        address: Address,
        mnemonic: words,
        passphrase: passphrase,
        keypair: Keypair,
        path: Path,
    });
};
exports["default"] = mnemonic;


/***/ }),

/***/ 1124:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var XrplSecretNumbers = __importStar(__nccwpck_require__(8030));
var Utils = __importStar(__nccwpck_require__(8135));
var Account_1 = __importDefault(__nccwpck_require__(3619));
var secretNumbers = function () {
    var secretNumbersAccount = new XrplSecretNumbers.Account();
    var keypair = secretNumbersAccount.getKeypair();
    return new Account_1.default({
        algorithm: Utils.getAlgorithmFromKey(keypair.privateKey),
        address: secretNumbersAccount.getAddress(),
        familySeed: secretNumbersAccount.getFamilySeed(),
        keypair: keypair,
        secretNumbers: secretNumbersAccount.getSecret()
    });
};
exports["default"] = secretNumbers;


/***/ }),

/***/ 2335:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.libraries = exports.nativeAsset = exports.XrplClient = exports.binary = exports.XrplDefinitions = exports.rawSigning = exports.utils = exports.signAndSubmit = exports.sign = exports.derive = exports.generate = exports.XRPL_Account = void 0;
/* Methods ================================================================== */
var generate = __importStar(__nccwpck_require__(3738));
exports.generate = generate;
var derive = __importStar(__nccwpck_require__(4346));
exports.derive = derive;
var utils = __importStar(__nccwpck_require__(8135));
exports.utils = utils;
var sign_1 = __nccwpck_require__(2842);
Object.defineProperty(exports, "sign", ({ enumerable: true, get: function () { return sign_1.sign; } }));
Object.defineProperty(exports, "signAndSubmit", ({ enumerable: true, get: function () { return sign_1.signAndSubmit; } }));
var rawSigning = __importStar(__nccwpck_require__(606));
exports.rawSigning = rawSigning;
/* Types ==================================================================== */
var Account_1 = __importDefault(__nccwpck_require__(3619));
exports.XRPL_Account = Account_1.default;
/* Client =================================================================== */
var xrpl_client_1 = __nccwpck_require__(3907);
Object.defineProperty(exports, "XrplClient", ({ enumerable: true, get: function () { return xrpl_client_1.XrplClient; } }));
/* All Libs ================================================================= */
var rippleAddressCodec = __importStar(__nccwpck_require__(597));
var rippleKeypairs = __importStar(__nccwpck_require__(8150));
var rippleSecretCodec = __importStar(__nccwpck_require__(8524));
var xrplBinaryCodecPrerelease = __importStar(__nccwpck_require__(305));
/* Defs ===================================================================== */
var xrpl_binary_codec_prerelease_1 = __nccwpck_require__(305);
Object.defineProperty(exports, "XrplDefinitions", ({ enumerable: true, get: function () { return xrpl_binary_codec_prerelease_1.XrplDefinitions; } }));
Object.defineProperty(exports, "nativeAsset", ({ enumerable: true, get: function () { return xrpl_binary_codec_prerelease_1.nativeAsset; } }));
var definitions_json_1 = __importDefault(__nccwpck_require__(1698));
var binary = {
    encode: xrpl_binary_codec_prerelease_1.encode,
    decode: xrpl_binary_codec_prerelease_1.decode,
    encodeForSigning: xrpl_binary_codec_prerelease_1.encodeForSigning,
    encodeForMultisigning: xrpl_binary_codec_prerelease_1.encodeForMultisigning,
    encodeForSigningClaim: xrpl_binary_codec_prerelease_1.encodeForSigningClaim,
    DEFAULT_DEFINITIONS: definitions_json_1.default
};
exports.binary = binary;
var libraries = {
    rippleAddressCodec: rippleAddressCodec,
    rippleKeypairs: rippleKeypairs,
    rippleSecretCodec: rippleSecretCodec,
    xrplBinaryCodecPrerelease: xrplBinaryCodecPrerelease,
    rippleBinaryCodec: xrplBinaryCodecPrerelease,
};
exports.libraries = libraries;


/***/ }),

/***/ 606:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.completeMultiSigned = exports.complete = exports.prepare = exports.accountAddress = void 0;
var Utils = __importStar(__nccwpck_require__(8135));
var sign_1 = __nccwpck_require__(2842);
var assert_1 = __importDefault(__nccwpck_require__(9491));
var xrpl_binary_codec_prerelease_1 = __nccwpck_require__(305);
var assertValidPubkey = function (pubkey) {
    (0, assert_1.default)(typeof pubkey === "string", "Uncompressed PubKey: string expected");
    if (pubkey.length === 64) {
        // ED Uncompressed
        (0, assert_1.default)(Utils.getAlgorithmFromKey("ED" + pubkey) === "ed25519", "Key length ed25519, algo not ed25519");
    }
    else if (pubkey.length === 66) {
        // Compressed (?)
        (0, assert_1.default)(Utils.deriveAddress("A" + pubkey.slice(1)), "Compressed PubKey length, invalid address derivation");
    }
    else {
        // Secp256k1 Uncompressed
        (0, assert_1.default)(pubkey.length === 130, "Uncompressed PubKey: incorrect length");
        (0, assert_1.default)(pubkey.slice(0, 2) === "04", 'Uncompressed PubKey: should start with "04"');
    }
};
/**
 * Prepare a transaction for a Raw card: get Hash to sign
 */
var prepare = function (txJson, pubkey, multiSign, definitions) {
    if (multiSign === void 0) { multiSign = false; }
    assertValidPubkey(pubkey);
    var signingPubKey = Utils.compressPubKey(pubkey);
    var transaction = Object.assign({}, __assign({}, txJson));
    (0, sign_1.setNativeAsset)(transaction);
    (0, assert_1.default)(typeof transaction === "object" && transaction !== null, "Transaction: Object expected");
    if (typeof transaction.signingPubKey === "undefined") {
        Object.assign(transaction, { SigningPubKey: signingPubKey });
    }
    if (multiSign) {
        Object.assign(transaction, { SigningPubKey: "" });
    }
    // Payment Channel Authorization
    if (String((transaction === null || transaction === void 0 ? void 0 : transaction.TransactionType) || "").toLowerCase() ===
        "paymentchannelauthorize" ||
        String((transaction === null || transaction === void 0 ? void 0 : transaction.command) || "").toLowerCase() === "channel_authorize" ||
        (!(transaction === null || transaction === void 0 ? void 0 : transaction.TransactionType) &&
            !(transaction === null || transaction === void 0 ? void 0 : transaction.command) &&
            (((transaction === null || transaction === void 0 ? void 0 : transaction.channel) && (transaction === null || transaction === void 0 ? void 0 : transaction.amount)) ||
                ((transaction === null || transaction === void 0 ? void 0 : transaction.Channel) && (transaction === null || transaction === void 0 ? void 0 : transaction.Amount))))) {
        Object.assign(transaction, {
            TransactionType: undefined,
            command: undefined,
            channel: (transaction === null || transaction === void 0 ? void 0 : transaction.channel) || (transaction === null || transaction === void 0 ? void 0 : transaction.Channel),
            amount: (transaction === null || transaction === void 0 ? void 0 : transaction.amount) || (transaction === null || transaction === void 0 ? void 0 : transaction.Amount),
        });
    }
    var message = Utils.encodeTransaction(transaction, multiSign ? Utils.deriveAddress(signingPubKey) : undefined, definitions);
    var hashToSign = Utils.getAlgorithmFromKey(signingPubKey) === "ed25519"
        ? message
        : Utils.bytesToHex(Utils.hash(message));
    return {
        pubkey: pubkey,
        signingPubKey: signingPubKey,
        multiSign: multiSign,
        transaction: transaction,
        message: message,
        hashToSign: hashToSign,
    };
};
exports.prepare = prepare;
var complete = function (Prepared, signature, definitions) {
    assertValidPubkey(Prepared.pubkey);
    (0, assert_1.default)(typeof signature === "string", "signature: string expected");
    (0, assert_1.default)(signature.length === 128, "signature: incorrect length");
    var txnSignature = Utils.getAlgorithmFromKey(Prepared.signingPubKey) === "ed25519"
        ? signature
        : Utils.secp256k1_p1363ToFullyCanonicalDerSignature(signature);
    var signatureVerifies = Utils.verifySignature(Prepared.message, txnSignature, Prepared.signingPubKey);
    var isPayChanAuth = false;
    var txJson = {};
    var signedTransaction = "";
    var id = "";
    Object.assign(txJson, Prepared.transaction);
    (0, sign_1.setNativeAsset)(txJson);
    if (signatureVerifies) {
        Object.assign(txJson, { TxnSignature: txnSignature });
        signedTransaction = Utils.encodeTransaction(txJson, undefined, definitions);
        id = Utils.computeBinaryTransactionHash(signedTransaction);
    }
    // Payment channel auth
    if (!(txJson === null || txJson === void 0 ? void 0 : txJson.TransactionType) &&
        !(txJson === null || txJson === void 0 ? void 0 : txJson.command) &&
        (txJson === null || txJson === void 0 ? void 0 : txJson.channel) &&
        (txJson === null || txJson === void 0 ? void 0 : txJson.amount)) {
        isPayChanAuth = true;
        id = "";
        signedTransaction = String(txJson.TxnSignature || "");
        txJson = {
            channel: txJson.channel,
            amount: txJson.amount,
        };
    }
    return {
        type: isPayChanAuth ? "SignedPayChanAuth" : "SignedTx",
        txnSignature: txnSignature,
        signatureVerifies: signatureVerifies,
        txJson: txJson,
        signedTransaction: signedTransaction,
        id: id,
    };
};
exports.complete = complete;
var completeMultiSigned = function (txJson, SignersAndSignatures, definitions) {
    (0, assert_1.default)(Array.isArray(SignersAndSignatures), "SignersAndSignatures not array");
    (0, assert_1.default)(SignersAndSignatures.length > 0, "SignersAndSignatures empty");
    var transaction = Object.assign({}, txJson);
    (0, sign_1.setNativeAsset)(txJson);
    Object.assign(transaction, { SigningPubKey: "" });
    // const hashToSign = Utils.bytesToHex(Utils.hash(message))
    var toCombine = SignersAndSignatures.map(function (SignerAndSignature) {
        var pubKey = SignerAndSignature.pubKey.length === 130
            ? Utils.compressPubKey(SignerAndSignature.pubKey)
            : SignerAndSignature.pubKey.length === 64
                ? "ED" + SignerAndSignature.pubKey
                : SignerAndSignature.pubKey;
        var signerAddress = Utils.deriveAddress(pubKey);
        var txnSignature = Utils.getAlgorithmFromKey(pubKey) === "ed25519"
            ? SignerAndSignature.signature
            : Utils.secp256k1_p1363ToFullyCanonicalDerSignature(SignerAndSignature.signature);
        var message = Utils.encodeTransaction(transaction, signerAddress, definitions);
        // console.log({message, txnSignature, pubKey})
        var signatureVerifies = Utils.verifySignature(message, txnSignature, pubKey);
        (0, assert_1.default)(signatureVerifies, "Invalid signature by/for " + signerAddress);
        Object.assign(transaction, {
            Signers: [
                {
                    Signer: {
                        Account: signerAddress,
                        SigningPubKey: pubKey,
                        TxnSignature: txnSignature,
                    },
                },
            ],
        });
        var MultiSignature = {
            signerAddress: signerAddress,
            signature: SignerAndSignature.signature,
            verifies: signatureVerifies,
            transaction: transaction,
            signedTransaction: Utils.encodeTransaction(transaction, undefined, definitions),
        };
        return MultiSignature;
    });
    // console.dir(toCombine, {depth: null})
    var combined = Utils.combine(toCombine.map(function (c) { return c.signedTransaction; }));
    var signedTransaction = String(combined.signedTransaction || "");
    return {
        type: "MultiSignedTx",
        txnSignature: "",
        signatureVerifies: toCombine.every(function (s) { return s.verifies; }),
        txJson: (0, xrpl_binary_codec_prerelease_1.decode)(signedTransaction, definitions),
        signedTransaction: signedTransaction,
        id: String(combined.id || ""),
    };
};
exports.completeMultiSigned = completeMultiSigned;
var accountAddress = function (pubkey) {
    assertValidPubkey(pubkey);
    var signingPubKey = Utils.compressPubKey(pubkey);
    return Utils.deriveAddress(signingPubKey);
};
exports.accountAddress = accountAddress;


/***/ }),

/***/ 3619:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AccountTypes = void 0;
var ripple_keypairs_1 = __nccwpck_require__(8150);
var AddressCodec = __importStar(__nccwpck_require__(597));
var Elliptic = __importStar(__nccwpck_require__(1517));
var Utils = __importStar(__nccwpck_require__(8135));
var Ed25519 = new Elliptic.eddsa("ed25519");
var Secp256k1 = new Elliptic.ec("secp256k1");
/* Types ==================================================================== */
var AccountTypes;
(function (AccountTypes) {
    AccountTypes["Passphrase"] = "passphrase";
    AccountTypes["FamilySeed"] = "familySeed";
    AccountTypes["Mnemonic"] = "mnemonic";
    AccountTypes["Hex"] = "hex";
    AccountTypes["SecretNumbers"] = "secretNumbers";
})(AccountTypes = exports.AccountTypes || (exports.AccountTypes = {}));
/* Class ==================================================================== */
var XRPL_Account = /** @class */ (function () {
    function XRPL_Account(options) {
        if (options === void 0) { options = {}; }
        /**
         * Define object struct
         */
        this.accountType = null;
        this.address = null;
        this.secret = {
            familySeed: null,
            mnemonic: null,
            passphrase: null,
            path: null,
            secretNumbers: null,
        };
        this.keypair = {
            algorithm: null,
            publicKey: null,
            privateKey: null,
        };
        /**
         * Check & apply address
         */
        if (options.address) {
            if (AddressCodec.isValidClassicAddress(options.address)) {
                this.address = options.address;
            }
        }
        /**
         * Check & apply account type [familySeed / mnemonic / passphrase]
         */
        if (options.passphrase) {
            this.accountType = AccountTypes.Passphrase;
            this.secret.passphrase = options.passphrase;
        }
        if (options.familySeed) {
            this.accountType = AccountTypes.FamilySeed;
            this.secret.familySeed = options.familySeed;
            if (options.secretNumbers) {
                this.secret.secretNumbers = options.secretNumbers;
                this.accountType = AccountTypes.SecretNumbers;
            }
        }
        else if (options.mnemonic) {
            this.accountType = AccountTypes.Mnemonic;
            this.secret.mnemonic = options.mnemonic;
            if (options.path) {
                this.secret.path = options.path;
            }
        }
        /**
         * Check & apply keypair, derive publicKey if only privateKey is known
         */
        if (options.keypair && options.keypair instanceof Object) {
            if (options.keypair.privateKey) {
                var prefix = "";
                if (options.keypair.privateKey.length === 64) {
                    prefix = "00";
                }
                this.keypair.privateKey = prefix + options.keypair.privateKey;
                if (this.accountType === null) {
                    this.accountType = AccountTypes.Hex;
                }
            }
            if (options.keypair.publicKey) {
                this.keypair.publicKey = options.keypair.publicKey;
            }
            else if (this.keypair.privateKey) {
                if (
                // @ts-ignore
                options.keypair.privateKey.slice(0, 2) === "ED" ||
                    (options.algorithm && options.algorithm === "ed25519")) {
                    var priv = this.keypair.privateKey.slice(2);
                    // @ts-ignore
                    var keyBytes = Ed25519.keyFromSecret(priv).pubBytes();
                    this.keypair.publicKey = "ED" + Utils.bytesToHex(keyBytes);
                }
                else {
                    var priv = this.keypair.privateKey.slice(2);
                    var keyBytes = Secp256k1.keyFromPrivate(priv)
                        .getPublic()
                        .encodeCompressed("array");
                    // @ts-ignore
                    this.keypair.publicKey = Utils.bytesToHex(keyBytes);
                }
            }
        }
        /**
         * Check & apply algorithm, or retrieve from private key
         */
        if (options.algorithm) {
            this.keypair.algorithm = options.algorithm;
        }
        else {
            if (this.keypair.privateKey) {
                this.keypair.algorithm = Utils.getAlgorithmFromKey(this.keypair.privateKey);
            }
        }
        /**
         * Derive address from publicKey if address unknown
         */
        if (this.address === null && this.keypair.publicKey) {
            this.address = (0, ripple_keypairs_1.deriveAddress)(this.keypair.publicKey);
        }
    }
    XRPL_Account.prototype.signAs = function (address) {
        if (AddressCodec.isValidClassicAddress(address)) {
            this._signAs = address;
        }
        else {
            throw new Error("Invalid signAs address (should contain account address, rXXX...)");
        }
        return this;
    };
    XRPL_Account.prototype.toString = function () {
        return "XPRL Account" + (this.address ? ": " + this.address : "");
    };
    return XRPL_Account;
}());
exports["default"] = XRPL_Account;


/***/ }),

/***/ 2842:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setNativeAsset = exports.signAndSubmit = exports.sign = void 0;
var assert_1 = __importDefault(__nccwpck_require__(9491));
var xrpl_binary_codec_prerelease_1 = __nccwpck_require__(305);
var ripple_keypairs_1 = __nccwpck_require__(8150);
var xrpl_client_1 = __nccwpck_require__(3907);
var xrpl_sign_keypairs_1 = __importDefault(__nccwpck_require__(2481));
var Account_1 = __importDefault(__nccwpck_require__(3619));
var utils_1 = __nccwpck_require__(8135);
var __1 = __nccwpck_require__(2335);
var setNativeAsset = function (Tx) {
    __1.nativeAsset.set("XRP");
    // Xahau Mainnet, Xahau Testnet
    if ([21337, 21338].indexOf(Tx === null || Tx === void 0 ? void 0 : Tx.NetworkID) > -1) {
        __1.nativeAsset.set("XAH");
    }
    // console.log(nativeAsset.get())
};
exports.setNativeAsset = setNativeAsset;
var sign = function (transaction, account, definitions) {
    var _a, _b, _c;
    var accounts = [];
    var Tx = Object.assign({}, transaction);
    setNativeAsset(Tx);
    if (Object.keys(Tx).indexOf("TransactionType") > -1) {
        if (((_a = Tx === null || Tx === void 0 ? void 0 : Tx.TransactionType) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === "signin") {
            Object.assign(Tx, {
                TransactionType: undefined,
                SignIn: true,
            });
        }
    }
    if (account instanceof Object && !Array.isArray(account)) {
        if (account instanceof Account_1.default) {
            accounts.push(account);
        }
        else {
            throw new Error("Account not instanceof XRPL Account");
        }
    }
    else if (Array.isArray(account)) {
        account.forEach(function (account) {
            if (account instanceof Account_1.default) {
                accounts.push(account);
            }
            else {
                throw new Error("Account not instanceof XRPL Account");
            }
        });
    }
    if (((_b = Tx === null || Tx === void 0 ? void 0 : Tx.TransactionType) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === "paymentchannelauthorize" ||
        ((_c = Tx === null || Tx === void 0 ? void 0 : Tx.command) === null || _c === void 0 ? void 0 : _c.toLowerCase()) === "channel_authorize" ||
        (!(Tx === null || Tx === void 0 ? void 0 : Tx.TransactionType) &&
            !(Tx === null || Tx === void 0 ? void 0 : Tx.command) &&
            (((Tx === null || Tx === void 0 ? void 0 : Tx.channel) && (Tx === null || Tx === void 0 ? void 0 : Tx.amount)) || ((Tx === null || Tx === void 0 ? void 0 : Tx.Channel) && (Tx === null || Tx === void 0 ? void 0 : Tx.Amount))))) {
        if (accounts.length === 1) {
            if (typeof accounts[0]._signAs === "string" &&
                accounts[0]._signAs !== "") {
                throw new Error("Payment channel authorization: cannot Sign As");
            }
            var claimInput = (Tx === null || Tx === void 0 ? void 0 : Tx.channel) && (Tx === null || Tx === void 0 ? void 0 : Tx.amount)
                ? { channel: Tx.channel, amount: Tx.amount }
                : { channel: Tx.Channel, amount: Tx.Amount };
            var claim = (0, xrpl_binary_codec_prerelease_1.encodeForSigningClaim)(claimInput);
            var signed = (0, ripple_keypairs_1.sign)(claim, accounts[0].keypair.privateKey);
            return {
                type: "SignedPayChanAuth",
                id: "",
                signedTransaction: signed,
                txJson: claimInput,
                signers: [accounts[0].address || ""],
            };
        }
        else {
            throw new Error("Payment channel authorization: multi-signing not supported");
        }
    }
    if (accounts.length === 1) {
        var txJSON = JSON.stringify(Tx);
        var options = { signAs: undefined, definitions: definitions };
        if (typeof accounts[0]._signAs === "string" && accounts[0]._signAs !== "") {
            // signAs explicitly set
            options.signAs = accounts[0]._signAs;
        }
        var tx = (0, xrpl_sign_keypairs_1.default)(txJSON, accounts[0].keypair, options);
        return {
            type: "SignedTx",
            id: tx.id,
            signedTransaction: tx.signedTransaction,
            txJson: tx.txJson,
            signers: [
                typeof accounts[0]._signAs === "string"
                    ? accounts[0]._signAs
                    : accounts[0].address || "",
            ],
        };
    }
    else {
        var Codec = __nccwpck_require__(305);
        var MultiSignedTransactionBinary = (function () {
            if (transaction instanceof Object &&
                Array.isArray(transaction) &&
                accounts.length === 0 &&
                transaction.length > 0) {
                if (transaction.length ===
                    transaction.filter(function (t) {
                        return (t instanceof Object &&
                            t !== null &&
                            typeof t.signedTransaction === "string");
                    }).length) {
                    // MultiSign [ { signedTransaction: ... } , ... ]
                    return (0, utils_1.combine)(transaction.map(function (t) {
                        return t.signedTransaction.toUpperCase();
                    }), definitions);
                }
                else if (transaction.length ===
                    transaction.filter(function (t) {
                        return (typeof t === "string" && t.toUpperCase().match(/^[A-F0-9]+$/));
                    }).length) {
                    // MultiSign [ 'AEF9...', 'C6DA...' ]
                    return (0, utils_1.combine)(transaction.map(function (t) {
                        return t.toUpperCase();
                    }), definitions);
                }
                else {
                    throw new Error("TX Blob for multiSign not an array of { signedTransaction: ... } objects or blob strings");
                }
            }
            else {
                // MultiSign [ lib.sign(...), lib.sign(...) ]
                return (0, utils_1.combine)(accounts.map(function (account) {
                    return (0, xrpl_sign_keypairs_1.default)(JSON.stringify(Tx), account.keypair, {
                        signAs: typeof account._signAs === "string"
                            ? account._signAs
                            : account.address,
                        definitions: definitions,
                    }).signedTransaction;
                }), definitions);
            }
        })();
        var txJson = Codec.decode(MultiSignedTransactionBinary.signedTransaction, definitions);
        return {
            type: "MultiSignedTx",
            id: MultiSignedTransactionBinary.id,
            signedTransaction: MultiSignedTransactionBinary.signedTransaction,
            txJson: txJson,
            signers: txJson.Signers,
        };
    }
};
exports.sign = sign;
var signAndSubmit = function (transaction, client, account) { return __awaiter(void 0, void 0, void 0, function () {
    var connection, definitions, network, Fee, _a, signedTransaction, id, submitResponse;
    var _b;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                (0, assert_1.default)(typeof client !== "undefined", "First param. must be XrplClient (npm: xrpl-client) or wss:// node endpoint");
                connection = typeof client === "string" ? new xrpl_client_1.XrplClient(client) : client;
                return [4 /*yield*/, connection.definitions()];
            case 1:
                definitions = _c.sent();
                return [4 /*yield*/, (0, utils_1.networkInfo)(connection, true /** keep alive */)];
            case 2:
                network = _c.sent();
                if (!(network.features.hooks &&
                    String(Number((_b = transaction) === null || _b === void 0 ? void 0 : _b.Fee)) === "0")) return [3 /*break*/, 4];
                return [4 /*yield*/, (0, utils_1.networkTxFee)(connection, transaction)];
            case 3:
                Fee = _c.sent();
                Object.assign(transaction, { Fee: Fee });
                _c.label = 4;
            case 4:
                _a = sign(transaction, account, definitions ? new xrpl_binary_codec_prerelease_1.XrplDefinitions(definitions) : undefined), signedTransaction = _a.signedTransaction, id = _a.id;
                return [4 /*yield*/, connection.send({
                        command: "submit",
                        tx_blob: signedTransaction,
                    })];
            case 5:
                submitResponse = _c.sent();
                if (typeof client === "string") {
                    // If constructed on demand: close
                    connection.close();
                }
                return [2 /*return*/, {
                        tx_blob: signedTransaction,
                        tx_id: id,
                        response: submitResponse,
                    }];
        }
    });
}); };
exports.signAndSubmit = signAndSubmit;
exports["default"] = sign;


/***/ }),

/***/ 8135:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.networkTxFee = exports.networkInfo = exports.txNetworkAndAccountValues = exports.accountAndLedgerSequence = exports.combine = exports.computeBinaryTransactionHash = exports.verifySignature = exports.secp256k1_p1363ToFullyCanonicalDerSignature = exports.encodeTransaction = exports.hash = exports.compressPubKey = exports.deriveAddress = exports.isValidMnemnic = exports.isValidSeed = exports.isValidClassicAddress = exports.isValidAddress = exports.getAlgorithmFromKey = exports.bufferToHext = exports.hexToBytes = exports.bytesToHex = void 0;
var bn_js_1 = __importDefault(__nccwpck_require__(5552));
var lodash_1 = __nccwpck_require__(2219);
var ripple_address_codec_1 = __nccwpck_require__(597);
var buffer_1 = __nccwpck_require__(3365);
var AddressCodec = __importStar(__nccwpck_require__(597));
var bip39_1 = __nccwpck_require__(781);
var elliptic = __importStar(__nccwpck_require__(1517));
var ripple_keypairs_1 = __nccwpck_require__(8150);
Object.defineProperty(exports, "verifySignature", ({ enumerable: true, get: function () { return ripple_keypairs_1.verify; } }));
var assert_1 = __importDefault(__nccwpck_require__(9491));
var hash_js_1 = __importDefault(__nccwpck_require__(609));
var hash_prefixes_1 = __nccwpck_require__(745);
var hashes_1 = __nccwpck_require__(9698);
var xrpl_binary_codec_prerelease_1 = __nccwpck_require__(305);
var derive_1 = __nccwpck_require__(4346);
var sign_1 = __nccwpck_require__(2842);
var xrpl_client_1 = __nccwpck_require__(3907);
var sign_2 = __nccwpck_require__(2842);
// Ugly, but no definitions when directly loading the lib file, and Signature() not exported in lib
var Signature = __nccwpck_require__(256);
function computeBinaryTransactionHash(txBlobHex) {
    var prefix = hash_prefixes_1.HashPrefix.transactionID.toString("hex").toUpperCase();
    var input = buffer_1.Buffer.from(prefix + txBlobHex, "hex");
    return (0, hashes_1.sha512Half)(input).toString("hex").toUpperCase();
}
exports.computeBinaryTransactionHash = computeBinaryTransactionHash;
function bytesToHex(a) {
    return a
        .map(function (byteValue) {
        var hex = byteValue.toString(16).toUpperCase();
        return hex.length > 1 ? hex : "0" + hex;
    })
        .join("");
}
exports.bytesToHex = bytesToHex;
function deriveAddressWithEdPrefixer(publicKey) {
    (0, assert_1.default)(typeof publicKey === "string", "PubKey: not hex string");
    (0, assert_1.default)(publicKey.length === 64 || publicKey.length === 66, "PubKey: invalid length");
    (0, assert_1.default)(publicKey.match(/^[a-fA-F0-9]{64,66}$/), "PubKey: invalid characters (non HEX)");
    var pubKey = publicKey.length === 64 &&
        getAlgorithmFromKey("ED" + publicKey) === "ed25519"
        ? "ED" + publicKey
        : publicKey;
    return (0, ripple_keypairs_1.deriveAddress)(pubKey);
}
exports.deriveAddress = deriveAddressWithEdPrefixer;
function hexToBytes(a) {
    return new bn_js_1.default(a, 16).toArray(undefined, a.length / 2);
}
exports.hexToBytes = hexToBytes;
function bufferToHext(buffer) {
    return buffer.toString("hex").toUpperCase();
}
exports.bufferToHext = bufferToHext;
function getAlgorithmFromKey(key) {
    var bytes = hexToBytes(key);
    return bytes.length === 33 && bytes[0] === 0xed ? "ed25519" : "secp256k1";
}
exports.getAlgorithmFromKey = getAlgorithmFromKey;
function isValidClassicAddress(address) {
    return AddressCodec.isValidClassicAddress(address);
}
exports.isValidClassicAddress = isValidClassicAddress;
function isValidAddress(address) {
    return isValidClassicAddress(address);
}
exports.isValidAddress = isValidAddress;
function isValidSeed(seed) {
    try {
        return !!AddressCodec.decodeSeed(seed);
    }
    catch (e) {
        return false;
    }
}
exports.isValidSeed = isValidSeed;
function isValidMnemnic(words) {
    try {
        return !!(0, bip39_1.validateMnemonic)(words);
    }
    catch (e) {
        return false;
    }
}
exports.isValidMnemnic = isValidMnemnic;
function compressPubKey(pubkey) {
    (0, assert_1.default)(typeof pubkey === "string", "Uncompressed PubKey: not hex string");
    if (pubkey.length === 64) {
        // ed25519
        var edPubKey = "ED" + pubkey;
        (0, assert_1.default)(getAlgorithmFromKey(edPubKey) === "ed25519", "Key length ed25519, algo not ed25519");
        return edPubKey;
    }
    else if (pubkey.length === 66) {
        // Already compressed
        return pubkey;
    }
    else {
        // secp256k1
        (0, assert_1.default)(pubkey.length === 130, "Uncompressed pubkey: not 1+32+32 length");
    }
    // @ts-ignore
    var c = elliptic.curves.secp256k1.curve;
    var p = c.point(pubkey.slice(2, 66), pubkey.slice(66));
    var compressedPubKey = p.encodeCompressed("hex").toUpperCase();
    var algo = getAlgorithmFromKey(compressedPubKey);
    (0, assert_1.default)(algo === "secp256k1", "Unsupported curve: " + algo);
    return compressedPubKey;
}
exports.compressPubKey = compressPubKey;
function hash(hex) {
    return hash_js_1.default.sha512().update(hexToBytes(hex)).digest().slice(0, 32);
}
exports.hash = hash;
function encodeTransaction(TxJson, MultiSignAccount, definitions) {
    var Transaction = Object.assign({}, TxJson);
    (0, sign_2.setNativeAsset)(Transaction);
    if (typeof MultiSignAccount !== "undefined") {
        Object.assign(Transaction, { SigningPubKey: "" });
        return (0, xrpl_binary_codec_prerelease_1.encodeForMultisigning)(Transaction, MultiSignAccount, definitions);
    }
    else if (typeof Transaction.TxnSignature === "undefined" &&
        typeof Transaction.Signers === "undefined") {
        if (!(Transaction === null || Transaction === void 0 ? void 0 : Transaction.TransactionType) &&
            !(Transaction === null || Transaction === void 0 ? void 0 : Transaction.command) &&
            (((Transaction === null || Transaction === void 0 ? void 0 : Transaction.channel) && (Transaction === null || Transaction === void 0 ? void 0 : Transaction.amount)) ||
                ((Transaction === null || Transaction === void 0 ? void 0 : Transaction.Channel) && (Transaction === null || Transaction === void 0 ? void 0 : Transaction.Amount)))) {
            // Payment Channel Authorization
            return (0, xrpl_binary_codec_prerelease_1.encodeForSigningClaim)({
                channel: (Transaction === null || Transaction === void 0 ? void 0 : Transaction.channel) || (Transaction === null || Transaction === void 0 ? void 0 : Transaction.Channel),
                amount: (Transaction === null || Transaction === void 0 ? void 0 : Transaction.amount) || (Transaction === null || Transaction === void 0 ? void 0 : Transaction.Amount),
            });
        }
        // Regular TX signing
        return (0, xrpl_binary_codec_prerelease_1.encodeForSigning)(Transaction, definitions);
    }
    else {
        // Signed TX (tx_blob)
        return (0, xrpl_binary_codec_prerelease_1.encode)(Transaction, definitions);
    }
}
exports.encodeTransaction = encodeTransaction;
function secp256k1_p1363ToFullyCanonicalDerSignature(p1363Signature) {
    var rs = {
        n: "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141",
        r: p1363Signature.slice(0, 64),
        s: p1363Signature.slice(64),
    };
    var bn = {
        n: new bn_js_1.default(rs.n, 16),
        s: new bn_js_1.default(rs.s, 16),
    };
    var nMinusS = bn.n.sub(bn.s);
    rs.s = (nMinusS.lt(bn.s) ? nMinusS : bn.s).toString(16).toUpperCase();
    var nonCanonicalDer = new Signature(rs).toDER();
    return Buffer.from(nonCanonicalDer).toString("hex").toUpperCase();
}
exports.secp256k1_p1363ToFullyCanonicalDerSignature = secp256k1_p1363ToFullyCanonicalDerSignature;
function addressToBigNumber(address) {
    var hex = Buffer.from((0, ripple_address_codec_1.decodeAccountID)(address)).toString("hex");
    return new bn_js_1.default(hex, 16);
}
function compareSigners(left, right) {
    return addressToBigNumber(left.Signer.Account).cmp(addressToBigNumber(right.Signer.Account));
}
function combine(multiSignedTxHex, definitions) {
    // Signers must be sorted in the combined transaction - See compareSigners' documentation for more details
    var multiSignedTx = multiSignedTxHex.map(function (encoded) {
        return (0, xrpl_binary_codec_prerelease_1.decode)(encoded, definitions);
    });
    var sortedSigners = (0, lodash_1.flatMap)(multiSignedTx, function (tx) { var _a; return (_a = tx.Signers) !== null && _a !== void 0 ? _a : []; }).sort(compareSigners);
    var signedTransaction = (0, xrpl_binary_codec_prerelease_1.encode)(__assign(__assign({}, multiSignedTx[0]), { Signers: sortedSigners }), definitions);
    return {
        id: computeBinaryTransactionHash(signedTransaction),
        signedTransaction: signedTransaction,
    };
}
exports.combine = combine;
var networkInfo = function (client, keepCreatedConnectionAlive) {
    if (keepCreatedConnectionAlive === void 0) { keepCreatedConnectionAlive = false; }
    return __awaiter(void 0, void 0, void 0, function () {
        var connection, ledger, amendments, endpoint, networkId, ledgerSequence;
        var _a, _b, _c, _d, _e;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0:
                    (0, assert_1.default)(typeof client !== "undefined", "First param. must be XrplClient (npm: xrpl-client) or wss:// node endpoint");
                    connection = typeof client === "string" ? new xrpl_client_1.XrplClient(client) : client;
                    return [4 /*yield*/, connection.send({
                            command: "ledger",
                        })];
                case 1:
                    ledger = _f.sent();
                    return [4 /*yield*/, connection.send({
                            command: "ledger_entry",
                            index: "7DB0788C020F02780A673DC74757F23823FA3014C1866E72CC4CD8B226CD6EF4",
                            validated: true,
                        })];
                case 2:
                    amendments = (_b = (_a = (_f.sent())) === null || _a === void 0 ? void 0 : _a.node) === null || _b === void 0 ? void 0 : _b.Amendments;
                    if (typeof client === "string" && !keepCreatedConnectionAlive) {
                        // If constructed on demand: close
                        connection.close();
                    }
                    endpoint = connection.getState().server.uri;
                    networkId = connection.getState().server.networkId;
                    ledgerSequence = Number(((_c = connection.getState().ledger) === null || _c === void 0 ? void 0 : _c.last) || ((_e = (_d = ledger === null || ledger === void 0 ? void 0 : ledger.closed) === null || _d === void 0 ? void 0 : _d.ledger) === null || _e === void 0 ? void 0 : _e.seqNum) || 0);
                    return [2 /*return*/, {
                            endpoint: endpoint,
                            networkId: networkId,
                            ledgerSequence: ledgerSequence,
                            ledger: ledger,
                            amendments: amendments,
                            features: {
                                hooks: amendments.indexOf("ECE6819DBA5DB528F1A241695F5A9811EF99467CDE22510954FD357780BBD078") > -1,
                            },
                            connection: keepCreatedConnectionAlive ? connection : null,
                        }];
            }
        });
    });
};
exports.networkInfo = networkInfo;
var networkTxFee = function (client, tx, keepCreatedConnectionAlive) {
    if (keepCreatedConnectionAlive === void 0) { keepCreatedConnectionAlive = false; }
    return __awaiter(void 0, void 0, void 0, function () {
        var _a, features, connection, getHooksTxFee, fee, _b, _c;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0: return [4 /*yield*/, networkInfo(client, true // keep alive
                    )];
                case 1:
                    _a = _d.sent(), features = _a.features, connection = _a.connection;
                    getHooksTxFee = function (tx) { return __awaiter(void 0, void 0, void 0, function () {
                        var definitions, _a, transaction, tx_blob, fee;
                        var _b, _c, _d;
                        return __generator(this, function (_e) {
                            switch (_e.label) {
                                case 0:
                                    (0, assert_1.default)(typeof tx === "string" || (typeof tx === "object" && tx !== null), "Network fee calculation on Hooks enabled networks requires a TX to calculate the fee for");
                                    _a = xrpl_binary_codec_prerelease_1.XrplDefinitions.bind;
                                    return [4 /*yield*/, (connection === null || connection === void 0 ? void 0 : connection.definitions())];
                                case 1:
                                    definitions = new (_a.apply(xrpl_binary_codec_prerelease_1.XrplDefinitions, [void 0, (_e.sent())]))();
                                    transaction = Object.assign({}, __assign(__assign({}, (typeof tx === "object"
                                        ? Object.assign({}, tx)
                                        : (0, xrpl_binary_codec_prerelease_1.decode)(tx, definitions))), { Fee: "0", SigningPubKey: "" }));
                                    if (((_b = transaction) === null || _b === void 0 ? void 0 : _b.TransactionType) === "Import" &&
                                        ((_c = transaction) === null || _c === void 0 ? void 0 : _c.Sequence) === 0) {
                                        // New account, import, fee will be zero
                                        return [2 /*return*/, "0"];
                                    }
                                    tx_blob = (0, sign_1.sign)(transaction, (0, derive_1.passphrase)(""), definitions).signedTransaction;
                                    return [4 /*yield*/, (connection === null || connection === void 0 ? void 0 : connection.send({ command: "fee", tx_blob: tx_blob }))];
                                case 2:
                                    fee = _e.sent();
                                    (0, assert_1.default)(typeof (fee === null || fee === void 0 ? void 0 : fee.error) === "undefined", "Could not get fee for tx blob from network");
                                    return [2 /*return*/, ((_d = fee === null || fee === void 0 ? void 0 : fee.drops) === null || _d === void 0 ? void 0 : _d.base_fee) || null];
                            }
                        });
                    }); };
                    if (!features.hooks) return [3 /*break*/, 5];
                    if (!tx) return [3 /*break*/, 3];
                    return [4 /*yield*/, getHooksTxFee(tx)];
                case 2:
                    _c = _d.sent();
                    return [3 /*break*/, 4];
                case 3:
                    _c = null;
                    _d.label = 4;
                case 4:
                    _b = _c;
                    return [3 /*break*/, 6];
                case 5:
                    _b = Math.min(((connection === null || connection === void 0 ? void 0 : connection.getState().fee.avg) ||
                        (connection === null || connection === void 0 ? void 0 : connection.getState().fee.last) ||
                        50000) + 8, // Beat the queue.
                    50000 // Absurd.
                    );
                    _d.label = 6;
                case 6:
                    fee = _b;
                    if (typeof client === "string" && !keepCreatedConnectionAlive) {
                        // If constructed on demand: close
                        connection === null || connection === void 0 ? void 0 : connection.close();
                    }
                    return [2 /*return*/, String(Number(fee))];
            }
        });
    });
};
exports.networkTxFee = networkTxFee;
var accountAndLedgerSequence = function (client, account) { return __awaiter(void 0, void 0, void 0, function () {
    var accountAddress, _a, endpoint, networkId, ledgerSequence, features, connection, accountInfo, fee, accountSequence;
    var _b;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                (0, assert_1.default)(typeof client !== "undefined", "First param. must be XrplClient (npm: xrpl-client) or wss:// node endpoint");
                accountAddress = typeof account === "string" ? account : account.address;
                return [4 /*yield*/, networkInfo(client, true // keep alive
                    )];
            case 1:
                _a = _c.sent(), endpoint = _a.endpoint, networkId = _a.networkId, ledgerSequence = _a.ledgerSequence, features = _a.features, connection = _a.connection;
                return [4 /*yield*/, (connection === null || connection === void 0 ? void 0 : connection.send({
                        command: "account_info",
                        account: accountAddress,
                    }))];
            case 2:
                accountInfo = _c.sent();
                return [4 /*yield*/, networkTxFee(connection ? connection : client, undefined, true // keep alive
                    )];
            case 3:
                fee = _c.sent();
                if (typeof client === "string") {
                    // If constructed on demand: close
                    connection === null || connection === void 0 ? void 0 : connection.close();
                }
                accountSequence = Number(((_b = accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.account_data) === null || _b === void 0 ? void 0 : _b.Sequence) || 0);
                return [2 /*return*/, {
                        networkInfo: {
                            ledgerSequence: ledgerSequence > 0 ? ledgerSequence : null,
                            accountSequence: accountSequence > 0 ? accountSequence : null,
                            endpoint: endpoint,
                            networkId: networkId,
                            features: features,
                        },
                        txValues: {
                            Account: accountAddress,
                            NetworkID: networkId,
                            Sequence: accountSequence,
                            LastLedgerSequence: ledgerSequence > 0 ? ledgerSequence + 20 : undefined,
                            Fee: String(Number(fee)),
                        },
                    }];
        }
    });
}); };
exports.accountAndLedgerSequence = accountAndLedgerSequence;
exports.txNetworkAndAccountValues = accountAndLedgerSequence;


/***/ }),

/***/ 5552:
/***/ (function(module, __unused_webpack_exports, __nccwpck_require__) {

/* module decorator */ module = __nccwpck_require__.nmd(module);
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = (__nccwpck_require__(4300).Buffer);
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this._strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // '0' - '9'
    if (c >= 48 && c <= 57) {
      return c - 48;
    // 'A' - 'F'
    } else if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    } else {
      assert(false, 'Invalid character in ' + string);
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this._strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        b = c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        b = c - 17 + 0xa;

      // '0' - '9'
      } else {
        b = c;
      }
      assert(c >= 0 && b < mul, 'Invalid character');
      r += b;
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this._strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  function move (dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
  }

  BN.prototype._move = function _move (dest) {
    move(dest, this);
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype._strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  // Check Symbol.for because not everywhere where Symbol defined
  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
    try {
      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
    } catch (e) {
      BN.prototype.inspect = inspect;
    }
  } else {
    BN.prototype.inspect = inspect;
  }

  function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  }

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modrn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16, 2);
  };

  if (Buffer) {
    BN.prototype.toBuffer = function toBuffer (endian, length) {
      return this.toArrayLike(Buffer, endian, length);
    };
  }

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  var allocate = function allocate (ArrayType, size) {
    if (ArrayType.allocUnsafe) {
      return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    this._strip();

    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    var res = allocate(ArrayType, reqLength);
    var postfix = endian === 'le' ? 'LE' : 'BE';
    this['_toArrayLike' + postfix](res, byteLength);
    return res;
  };

  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
    var position = 0;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position++] = word & 0xff;
      if (position < res.length) {
        res[position++] = (word >> 8) & 0xff;
      }
      if (position < res.length) {
        res[position++] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position < res.length) {
          res[position++] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position < res.length) {
      res[position++] = carry;

      while (position < res.length) {
        res[position++] = 0;
      }
    }
  };

  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
    var position = res.length - 1;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position--] = word & 0xff;
      if (position >= 0) {
        res[position--] = (word >> 8) & 0xff;
      }
      if (position >= 0) {
        res[position--] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position >= 0) {
          res[position--] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position >= 0) {
      res[position--] = carry;

      while (position >= 0) {
        res[position--] = 0;
      }
    }
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] >>> wbit) & 0x01;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this._strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this._strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this._strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this._strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this._strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this._strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out._strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out._strip();
  }

  function jumboMulTo (self, num, out) {
    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
    // var fftm = new FFTM();
    // return fftm.mulp(self, num, out);
    return bigMulTo(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this._strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this._strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this._strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) <= num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this._strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this._strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this._strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q._strip();
    }
    a._strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modrn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modrn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modrn = function modrn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return isNegNum ? -acc : acc;
  };

  // WARNING: DEPRECATED
  BN.prototype.modn = function modn (num) {
    return this.modrn(num);
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    this._strip();
    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this._strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is a BN v4 instance
        r.strip();
      } else {
        // r is a BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

    move(a, a.umod(this.m)._forceRed(this));
    return a;
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})( false || module, this);


/***/ }),

/***/ 2789:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/* eslint-disable func-style */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.transactionID = exports.sha512Half = exports.binaryToJSON = exports.signingClaimData = exports.signingData = exports.multiSigningData = exports.readJSON = exports.serializeObject = exports.makeParser = exports.BytesList = exports.BinarySerializer = exports.BinaryParser = void 0;
const types_1 = __nccwpck_require__(825);
const binary_parser_1 = __nccwpck_require__(8416);
Object.defineProperty(exports, "BinaryParser", ({ enumerable: true, get: function () { return binary_parser_1.BinaryParser; } }));
const hash_prefixes_1 = __nccwpck_require__(745);
const binary_serializer_1 = __nccwpck_require__(8540);
Object.defineProperty(exports, "BinarySerializer", ({ enumerable: true, get: function () { return binary_serializer_1.BinarySerializer; } }));
Object.defineProperty(exports, "BytesList", ({ enumerable: true, get: function () { return binary_serializer_1.BytesList; } }));
const hashes_1 = __nccwpck_require__(9698);
Object.defineProperty(exports, "sha512Half", ({ enumerable: true, get: function () { return hashes_1.sha512Half; } }));
Object.defineProperty(exports, "transactionID", ({ enumerable: true, get: function () { return hashes_1.transactionID; } }));
const enums_1 = __nccwpck_require__(1701);
const bigInt = __nccwpck_require__(4922);
/**
 * Construct a BinaryParser
 *
 * @param bytes hex-string to construct BinaryParser from
 * @param definitions rippled definitions used to parse the values of transaction types and such.
 *                          Can be customized for sidechains and amendments.
 * @returns A BinaryParser
 */
const makeParser = (bytes, definitions) => new binary_parser_1.BinaryParser(bytes, definitions);
exports.makeParser = makeParser;
/**
 * Parse BinaryParser into JSON
 *
 * @param parser BinaryParser object
 * @param definitions rippled definitions used to parse the values of transaction types and such.
 *                          Can be customized for sidechains and amendments.
 * @returns JSON for the bytes in the BinaryParser
 */
const readJSON = (parser, definitions = enums_1.DEFAULT_DEFINITIONS) => parser.readType(types_1.coreTypes.STObject).toJSON(definitions);
exports.readJSON = readJSON;
/**
 * Parse a hex-string into its JSON interpretation
 *
 * @param bytes hex-string to parse into JSON
 * @param definitions rippled definitions used to parse the values of transaction types and such.
 *                          Can be customized for sidechains and amendments.
 * @returns JSON
 */
const binaryToJSON = (bytes, definitions) => readJSON(makeParser(bytes, definitions), definitions);
exports.binaryToJSON = binaryToJSON;
/**
 * Function to serialize JSON object representing a transaction
 *
 * @param object JSON object to serialize
 * @param opts options for serializing, including optional prefix, suffix, signingFieldOnly, and definitions
 * @returns A Buffer containing the serialized object
 */
function serializeObject(object, opts = {}) {
    const { prefix, suffix, signingFieldsOnly = false, definitions } = opts;
    const bytesList = new binary_serializer_1.BytesList();
    if (prefix) {
        bytesList.put(prefix);
    }
    const filter = signingFieldsOnly
        ? (f) => f.isSigningField
        : undefined;
    types_1.coreTypes.STObject
        .from(object, filter, definitions)
        .toBytesSink(bytesList);
    if (suffix) {
        bytesList.put(suffix);
    }
    return bytesList.toBytes();
}
exports.serializeObject = serializeObject;
/**
 * Serialize an object for signing
 *
 * @param transaction Transaction to serialize
 * @param prefix Prefix bytes to put before the serialized object
 * @param opts.definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.
 * @returns A Buffer with the serialized object
 */
function signingData(transaction, prefix = hash_prefixes_1.HashPrefix.transactionSig, opts = {}) {
    return serializeObject(transaction, {
        prefix,
        signingFieldsOnly: true,
        definitions: opts.definitions,
    });
}
exports.signingData = signingData;
/**
 * Serialize a signingClaim
 *
 * @param claim A claim object to serialize
 * @param opts.definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.
 * @returns the serialized object with appropriate prefix
 */
function signingClaimData(claim) {
    const num = bigInt(String(claim.amount));
    const prefix = hash_prefixes_1.HashPrefix.paymentChannelClaim;
    const channel = types_1.coreTypes.Hash256.from(claim.channel).toBytes();
    const amount = types_1.coreTypes.UInt64.from(num).toBytes();
    const bytesList = new binary_serializer_1.BytesList();
    bytesList.put(prefix);
    bytesList.put(channel);
    bytesList.put(amount);
    return bytesList.toBytes();
}
exports.signingClaimData = signingClaimData;
/**
 * Serialize a transaction object for multiSigning
 *
 * @param transaction transaction to serialize
 * @param signingAccount Account to sign the transaction with
 * @param opts.definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.
 * @returns serialized transaction with appropriate prefix and suffix
 */
function multiSigningData(transaction, signingAccount, opts = {
    definitions: enums_1.DEFAULT_DEFINITIONS,
}) {
    const prefix = hash_prefixes_1.HashPrefix.transactionMultiSig;
    const suffix = types_1.coreTypes.AccountID.from(signingAccount).toBytes();
    return serializeObject(transaction, {
        prefix,
        suffix,
        signingFieldsOnly: true,
        definitions: opts.definitions,
    });
}
exports.multiSigningData = multiSigningData;
//# sourceMappingURL=binary.js.map

/***/ }),

/***/ 1286:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.types = exports.ShaMap = exports.HashPrefix = exports.quality = exports.TransactionResult = exports.Type = exports.LedgerEntryType = exports.TransactionType = exports.Field = exports.DEFAULT_DEFINITIONS = exports.ledgerHashes = exports.binary = exports.hashes = void 0;
const enums_1 = __nccwpck_require__(1701);
Object.defineProperty(exports, "DEFAULT_DEFINITIONS", ({ enumerable: true, get: function () { return enums_1.DEFAULT_DEFINITIONS; } }));
Object.defineProperty(exports, "Field", ({ enumerable: true, get: function () { return enums_1.Field; } }));
Object.defineProperty(exports, "TransactionType", ({ enumerable: true, get: function () { return enums_1.TransactionType; } }));
Object.defineProperty(exports, "LedgerEntryType", ({ enumerable: true, get: function () { return enums_1.LedgerEntryType; } }));
Object.defineProperty(exports, "Type", ({ enumerable: true, get: function () { return enums_1.Type; } }));
Object.defineProperty(exports, "TransactionResult", ({ enumerable: true, get: function () { return enums_1.TransactionResult; } }));
const types = __importStar(__nccwpck_require__(825));
exports.types = types;
const binary = __importStar(__nccwpck_require__(2789));
exports.binary = binary;
const shamap_1 = __nccwpck_require__(8313);
Object.defineProperty(exports, "ShaMap", ({ enumerable: true, get: function () { return shamap_1.ShaMap; } }));
const ledgerHashes = __importStar(__nccwpck_require__(7679));
exports.ledgerHashes = ledgerHashes;
const hashes = __importStar(__nccwpck_require__(9698));
exports.hashes = hashes;
const quality_1 = __nccwpck_require__(6166);
Object.defineProperty(exports, "quality", ({ enumerable: true, get: function () { return quality_1.quality; } }));
const hash_prefixes_1 = __nccwpck_require__(745);
Object.defineProperty(exports, "HashPrefix", ({ enumerable: true, get: function () { return hash_prefixes_1.HashPrefix; } }));
//# sourceMappingURL=coretypes.js.map

/***/ }),

/***/ 2397:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BytesLookup = exports.Bytes = void 0;
const buffer_1 = __nccwpck_require__(3365);
/*
 * @brief: Bytes, name, and ordinal representing one type, ledger_type, transaction type, or result
 */
class Bytes {
    constructor(name, ordinal, ordinalWidth) {
        this.name = name;
        this.ordinal = ordinal;
        this.ordinalWidth = ordinalWidth;
        this.bytes = buffer_1.Buffer.alloc(ordinalWidth);
        for (let i = 0; i < ordinalWidth; i++) {
            this.bytes[ordinalWidth - i - 1] = (ordinal >>> (i * 8)) & 0xff;
        }
    }
    toJSON() {
        return this.name;
    }
    toBytesSink(sink) {
        sink.put(this.bytes);
    }
    toBytes() {
        return this.bytes;
    }
}
exports.Bytes = Bytes;
/*
 * @brief: Collection of Bytes objects, mapping bidirectionally
 */
class BytesLookup {
    constructor(types, ordinalWidth) {
        this.ordinalWidth = ordinalWidth;
        Object.entries(types).forEach(([k, v]) => {
            this.add(k, v);
        });
    }
    /**
     * Add a new name value pair to the BytesLookup.
     *
     * @param name - A human readable name for the field.
     * @param value - The numeric value for the field.
     * @throws if the name or value already exist in the lookup because it's unclear how to decode.
     */
    add(name, value) {
        if (this[name]) {
            throw new SyntaxError(`Attempted to add a value with a duplicate name "${name}". This is not allowed because it is unclear how to decode.`);
        }
        if (this[value.toString()]) {
            throw new SyntaxError(`Attempted to add a duplicate value under a different name (Given name: "${name}" and previous name: "${this[value.toString()]}. This is not allowed because it is unclear how to decode.\nGiven value: ${value.toString()}`);
        }
        this[name] = new Bytes(name, value, this.ordinalWidth);
        this[value.toString()] = this[name];
    }
    from(value) {
        return value instanceof Bytes ? value : this[value];
    }
    fromParser(parser) {
        return this.from(parser.readUIntN(this.ordinalWidth).toString());
    }
}
exports.BytesLookup = BytesLookup;
//# sourceMappingURL=bytes.js.map

/***/ }),

/***/ 4602:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TRANSACTION_RESULT_WIDTH = exports.TRANSACTION_TYPE_WIDTH = exports.LEDGER_ENTRY_WIDTH = exports.TYPE_WIDTH = void 0;
exports.TYPE_WIDTH = 2;
exports.LEDGER_ENTRY_WIDTH = 2;
exports.TRANSACTION_TYPE_WIDTH = 2;
exports.TRANSACTION_RESULT_WIDTH = 1;
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ 3451:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FieldLookup = void 0;
const bytes_1 = __nccwpck_require__(2397);
const serialized_type_1 = __nccwpck_require__(2753);
const constants_1 = __nccwpck_require__(4602);
const buffer_1 = __nccwpck_require__(3365);
/*
 * @brief: Serialize a field based on type_code and Field.nth
 */
function fieldHeader(type, nth) {
    const header = [];
    if (type < 16) {
        if (nth < 16) {
            header.push((type << 4) | nth);
        }
        else {
            header.push(type << 4, nth);
        }
    }
    else if (nth < 16) {
        header.push(nth, type);
    }
    else {
        header.push(0, type, nth);
    }
    return buffer_1.Buffer.from(header);
}
function buildField([name, info], typeOrdinal) {
    const field = fieldHeader(typeOrdinal, info.nth);
    return {
        name: name,
        nth: info.nth,
        isVariableLengthEncoded: info.isVLEncoded,
        isSerialized: info.isSerialized,
        isSigningField: info.isSigningField,
        ordinal: (typeOrdinal << 16) | info.nth,
        type: new bytes_1.Bytes(info.type, typeOrdinal, constants_1.TYPE_WIDTH),
        header: field,
        associatedType: serialized_type_1.SerializedType, // For later assignment in ./types/index.js or Definitions.updateAll(...)
    };
}
/*
 * @brief: The collection of all fields as defined in definitions.json
 */
class FieldLookup {
    constructor(fields, types) {
        fields.forEach(([name, field_info]) => {
            const typeOrdinal = types[field_info.type];
            this[name] = buildField([name, field_info], typeOrdinal);
            this[this[name].ordinal.toString()] = this[name];
        });
    }
    fromString(value) {
        return this[value];
    }
}
exports.FieldLookup = FieldLookup;
//# sourceMappingURL=field.js.map

/***/ }),

/***/ 1701:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TRANSACTION_TYPES = exports.TransactionType = exports.TransactionResult = exports.LedgerEntryType = exports.Type = exports.Field = exports.DEFAULT_DEFINITIONS = exports.XrplDefinitionsBase = exports.Bytes = void 0;
const enums = __importStar(__nccwpck_require__(1698));
const xrpl_definitions_base_1 = __nccwpck_require__(5576);
Object.defineProperty(exports, "XrplDefinitionsBase", ({ enumerable: true, get: function () { return xrpl_definitions_base_1.XrplDefinitionsBase; } }));
Object.defineProperty(exports, "Bytes", ({ enumerable: true, get: function () { return xrpl_definitions_base_1.Bytes; } }));
/**
 * By default, coreTypes from the `types` folder is where known type definitions are initialized to avoid import cycles.
 */
const DEFAULT_DEFINITIONS = new xrpl_definitions_base_1.XrplDefinitionsBase(enums, {});
exports.DEFAULT_DEFINITIONS = DEFAULT_DEFINITIONS;
const Type = DEFAULT_DEFINITIONS.type;
exports.Type = Type;
const LedgerEntryType = DEFAULT_DEFINITIONS.ledgerEntryType;
exports.LedgerEntryType = LedgerEntryType;
const TransactionType = DEFAULT_DEFINITIONS.transactionType;
exports.TransactionType = TransactionType;
const TransactionResult = DEFAULT_DEFINITIONS.transactionResult;
exports.TransactionResult = TransactionResult;
const Field = DEFAULT_DEFINITIONS.field;
exports.Field = Field;
/*
 * @brief: All valid transaction types
 */
const TRANSACTION_TYPES = DEFAULT_DEFINITIONS.transactionNames;
exports.TRANSACTION_TYPES = TRANSACTION_TYPES;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 5576:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BytesLookup = exports.Bytes = exports.FieldLookup = exports.XrplDefinitionsBase = void 0;
const bytes_1 = __nccwpck_require__(2397);
Object.defineProperty(exports, "Bytes", ({ enumerable: true, get: function () { return bytes_1.Bytes; } }));
Object.defineProperty(exports, "BytesLookup", ({ enumerable: true, get: function () { return bytes_1.BytesLookup; } }));
const field_1 = __nccwpck_require__(3451);
Object.defineProperty(exports, "FieldLookup", ({ enumerable: true, get: function () { return field_1.FieldLookup; } }));
const constants_1 = __nccwpck_require__(4602);
/**
 * Stores the various types and fields for rippled to be used to encode/decode information later on.
 * XrplDefinitions should be instantiated instead of this class.
 */
class XrplDefinitionsBase {
    /**
     * Present rippled types in a typed and updatable format.
     * For an example of the input format see `definitions.json`
     * To generate a new definitions file from rippled source code, use this tool: https://github.com/RichardAH/xrpl-codec-gen
     *
     * See the definitions.test.js file for examples of how to create your own updated definitions.json.
     *
     * @param enums - A json encoding of the core types, transaction types, transaction results, transaction names, and fields.
     * @param types - A list of type objects with the same name as the fields defined.
     *              You can use the coreTypes object if you are not adding new types.
     */
    constructor(enums, types) {
        this.type = new bytes_1.BytesLookup(enums.TYPES, constants_1.TYPE_WIDTH);
        this.nativeAsset = enums === null || enums === void 0 ? void 0 : enums.native_currency_code;
        this.hash = enums === null || enums === void 0 ? void 0 : enums.hash;
        this.ledgerEntryType = new bytes_1.BytesLookup(enums.LEDGER_ENTRY_TYPES, constants_1.LEDGER_ENTRY_WIDTH);
        this.transactionType = new bytes_1.BytesLookup(enums.TRANSACTION_TYPES, constants_1.TRANSACTION_TYPE_WIDTH);
        this.transactionResult = new bytes_1.BytesLookup(enums.TRANSACTION_RESULTS, constants_1.TRANSACTION_RESULT_WIDTH);
        this.field = new field_1.FieldLookup(enums.FIELDS, enums.TYPES);
        this.transactionNames = Object.entries(enums.TRANSACTION_TYPES)
            .filter(([_key, value]) => value >= 0)
            .map(([key, _value]) => key);
        this.dataTypes = {}; // Filled in via associateTypes
        this.associateTypes(types);
    }
    /**
     * Associates each Field to a corresponding class that TypeScript can recognize.
     *
     * @param types a list of type objects with the same name as the fields defined.
     *              Defaults to xrpl.js's core type definitions.
     */
    associateTypes(types) {
        // Overwrite any existing type definitions with the given types
        this.dataTypes = Object.assign({}, this.dataTypes, types);
        Object.values(this.field).forEach((field) => {
            field.associatedType = this.dataTypes[field.type.name];
        });
        this.field['TransactionType'].associatedType = this.transactionType;
        this.field['TransactionResult'].associatedType = this.transactionResult;
        this.field['LedgerEntryType'].associatedType = this.ledgerEntryType;
    }
    getAssociatedTypes() {
        return this.dataTypes;
    }
    getNativeAsset() {
        return (this === null || this === void 0 ? void 0 : this.nativeAsset) || 'XRP';
    }
    getHash() {
        return ((this === null || this === void 0 ? void 0 : this.hash) ||
            '0000000000000000000000000000000000000000000000000000000000000000');
    }
}
exports.XrplDefinitionsBase = XrplDefinitionsBase;
//# sourceMappingURL=xrpl-definitions-base.js.map

/***/ }),

/***/ 9738:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.XrplDefinitions = void 0;
const xrpl_definitions_base_1 = __nccwpck_require__(5576);
const types_1 = __nccwpck_require__(825);
/**
 * Stores the various types and fields for rippled to be used to encode/decode information later on.
 * Should be used instead of XrplDefinitionsBase since this defines default `types` for serializing/deserializing
 * ledger data.
 */
class XrplDefinitions extends xrpl_definitions_base_1.XrplDefinitionsBase {
    /**
     * Present rippled types in a typed and updatable format.
     * For an example of the input format see `definitions.json`
     * To generate a new definitions file from rippled source code, use this tool: https://github.com/RichardAH/xrpl-codec-gen
     *
     * See the definitions.test.js file for examples of how to create your own updated definitions.json.
     *
     * @param enums - A json encoding of the core types, transaction types, transaction results, transaction names, and fields.
     * @param additionalTypes - A list of SerializedType objects with the same name as the fields defined.
     *              These types will be included in addition to the coreTypes used on mainnet.
     */
    constructor(enums, additionalTypes) {
        const types = Object.assign({}, types_1.coreTypes, additionalTypes);
        super(enums, types);
    }
}
exports.XrplDefinitions = XrplDefinitions;
//# sourceMappingURL=xrpl-definitions.js.map

/***/ }),

/***/ 745:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HashPrefix = void 0;
const buffer_1 = __nccwpck_require__(3365);
/**
 * Write a 32 bit integer to a Buffer
 *
 * @param uint32 32 bit integer to write to buffer
 * @returns a buffer with the bytes representation of uint32
 */
function bytes(uint32) {
    const result = buffer_1.Buffer.alloc(4);
    result.writeUInt32BE(uint32, 0);
    return result;
}
/**
 * Maps HashPrefix names to their byte representation
 */
const HashPrefix = {
    transactionID: bytes(0x54584e00),
    // transaction plus metadata
    transaction: bytes(0x534e4400),
    // account state
    accountStateEntry: bytes(0x4d4c4e00),
    // inner node in tree
    innerNode: bytes(0x4d494e00),
    // ledger master data for signing
    ledgerHeader: bytes(0x4c575200),
    // inner transaction to sign
    transactionSig: bytes(0x53545800),
    // inner transaction to sign
    transactionMultiSig: bytes(0x534d5400),
    // validation for signing
    validation: bytes(0x56414c00),
    // proposal for signing
    proposal: bytes(0x50525000),
    // payment channel claim
    paymentChannelClaim: bytes(0x434c4d00),
};
exports.HashPrefix = HashPrefix;
//# sourceMappingURL=hash-prefixes.js.map

/***/ }),

/***/ 9698:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.transactionID = exports.sha512Half = exports.Sha512Half = void 0;
const hash_prefixes_1 = __nccwpck_require__(745);
const createHash = __nccwpck_require__(3614);
const hash_256_1 = __nccwpck_require__(8989);
const binary_serializer_1 = __nccwpck_require__(8540);
const buffer_1 = __nccwpck_require__(3365);
/**
 * Class for hashing with SHA512
 * @extends BytesList So SerializedTypes can write bytes to a Sha512Half
 */
class Sha512Half extends binary_serializer_1.BytesList {
    constructor() {
        super(...arguments);
        this.hash = createHash('sha512');
    }
    /**
     * Construct a new Sha512Hash and write bytes this.hash
     *
     * @param bytes bytes to write to this.hash
     * @returns the new Sha512Hash object
     */
    static put(bytes) {
        return new Sha512Half().put(bytes);
    }
    /**
     * Write bytes to an existing Sha512Hash
     *
     * @param bytes bytes to write to object
     * @returns the Sha512 object
     */
    put(bytes) {
        this.hash.update(bytes);
        return this;
    }
    /**
     * Compute SHA512 hash and slice in half
     *
     * @returns half of a SHA512 hash
     */
    finish256() {
        return buffer_1.Buffer.from(this.hash.digest().slice(0, 32));
    }
    /**
     * Constructs a Hash256 from the Sha512Half object
     *
     * @returns a Hash256 object
     */
    finish() {
        return new hash_256_1.Hash256(this.finish256());
    }
}
exports.Sha512Half = Sha512Half;
/**
 * compute SHA512 hash of a list of bytes
 *
 * @param args zero or more arguments to hash
 * @returns the sha512half hash of the arguments.
 */
function sha512Half(...args) {
    const hash = new Sha512Half();
    args.forEach((a) => hash.put(a));
    return hash.finish256();
}
exports.sha512Half = sha512Half;
/**
 * Construct a transactionID from a Serialized Transaction
 *
 * @param serialized bytes to hash
 * @returns a Hash256 object
 */
function transactionID(serialized) {
    return new hash_256_1.Hash256(sha512Half(hash_prefixes_1.HashPrefix.transactionID, serialized));
}
exports.transactionID = transactionID;
//# sourceMappingURL=hashes.js.map

/***/ }),

/***/ 305:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.nativeAsset = exports.coreTypes = exports.DEFAULT_DEFINITIONS = exports.XrplDefinitionsBase = exports.XrplDefinitions = exports.TRANSACTION_TYPES = exports.decodeLedgerData = exports.decodeQuality = exports.encodeQuality = exports.encodeForMultisigning = exports.encodeForSigningClaim = exports.encodeForSigning = exports.encode = exports.decode = void 0;
const assert = __importStar(__nccwpck_require__(9491));
const coretypes_1 = __nccwpck_require__(1286);
const ledger_hashes_1 = __nccwpck_require__(7679);
Object.defineProperty(exports, "decodeLedgerData", ({ enumerable: true, get: function () { return ledger_hashes_1.decodeLedgerData; } }));
const enums_1 = __nccwpck_require__(1701);
Object.defineProperty(exports, "XrplDefinitionsBase", ({ enumerable: true, get: function () { return enums_1.XrplDefinitionsBase; } }));
Object.defineProperty(exports, "TRANSACTION_TYPES", ({ enumerable: true, get: function () { return enums_1.TRANSACTION_TYPES; } }));
Object.defineProperty(exports, "DEFAULT_DEFINITIONS", ({ enumerable: true, get: function () { return enums_1.DEFAULT_DEFINITIONS; } }));
const xrpl_definitions_1 = __nccwpck_require__(9738);
Object.defineProperty(exports, "XrplDefinitions", ({ enumerable: true, get: function () { return xrpl_definitions_1.XrplDefinitions; } }));
const types_1 = __nccwpck_require__(825);
Object.defineProperty(exports, "coreTypes", ({ enumerable: true, get: function () { return types_1.coreTypes; } }));
const nativeasset_1 = __nccwpck_require__(4110);
Object.defineProperty(exports, "nativeAsset", ({ enumerable: true, get: function () { return nativeasset_1.nativeAsset; } }));
const { signingData, signingClaimData, multiSigningData, binaryToJSON, serializeObject, } = coretypes_1.binary;
/**
 * Decode a transaction
 *
 * @param binary hex-string of the encoded transaction
 * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.
 * @returns the JSON representation of the transaction
 */
function decode(binary, definitions) {
    assert.ok(typeof binary === 'string', 'binary must be a hex string');
    return binaryToJSON(binary, definitions);
}
exports.decode = decode;
/**
 * Encode a transaction
 *
 * @param json The JSON representation of a transaction
 * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.
 *
 * @returns A hex-string of the encoded transaction
 */
function encode(json, definitions) {
    assert.ok(typeof json === 'object');
    return serializeObject(json, { definitions })
        .toString('hex')
        .toUpperCase();
}
exports.encode = encode;
/**
 * Encode a transaction and prepare for signing
 *
 * @param json JSON object representing the transaction
 * @param signer string representing the account to sign the transaction with
 * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.
 * @returns a hex string of the encoded transaction
 */
function encodeForSigning(json, definitions) {
    assert.ok(typeof json === 'object');
    return signingData(json, coretypes_1.HashPrefix.transactionSig, {
        definitions,
    })
        .toString('hex')
        .toUpperCase();
}
exports.encodeForSigning = encodeForSigning;
/**
 * Encode a transaction and prepare for signing with a claim
 *
 * @param json JSON object representing the transaction
 * @param signer string representing the account to sign the transaction with
 * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.
 * @returns a hex string of the encoded transaction
 */
function encodeForSigningClaim(json) {
    assert.ok(typeof json === 'object');
    return signingClaimData(json)
        .toString('hex')
        .toUpperCase();
}
exports.encodeForSigningClaim = encodeForSigningClaim;
/**
 * Encode a transaction and prepare for multi-signing
 *
 * @param json JSON object representing the transaction
 * @param signer string representing the account to sign the transaction with
 * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.
 * @returns a hex string of the encoded transaction
 */
function encodeForMultisigning(json, signer, definitions) {
    assert.ok(typeof json === 'object');
    assert.equal(json['SigningPubKey'], '');
    const definitionsOpt = definitions ? { definitions } : undefined;
    return multiSigningData(json, signer, definitionsOpt)
        .toString('hex')
        .toUpperCase();
}
exports.encodeForMultisigning = encodeForMultisigning;
/**
 * Encode a quality value
 *
 * @param value string representation of a number
 * @returns a hex-string representing the quality
 */
function encodeQuality(value) {
    assert.ok(typeof value === 'string');
    return coretypes_1.quality.encode(value).toString('hex').toUpperCase();
}
exports.encodeQuality = encodeQuality;
/**
 * Decode a quality value
 *
 * @param value hex-string of a quality
 * @returns a string representing the quality
 */
function decodeQuality(value) {
    assert.ok(typeof value === 'string');
    return coretypes_1.quality.decode(value).toString();
}
exports.decodeQuality = decodeQuality;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7679:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeLedgerData = exports.ledgerHash = exports.transactionTreeHash = exports.accountStateHash = void 0;
const assert = __importStar(__nccwpck_require__(9491));
const shamap_1 = __nccwpck_require__(8313);
const hash_prefixes_1 = __nccwpck_require__(745);
const hashes_1 = __nccwpck_require__(9698);
const binary_1 = __nccwpck_require__(2789);
const hash_256_1 = __nccwpck_require__(8989);
const st_object_1 = __nccwpck_require__(1930);
const uint_64_1 = __nccwpck_require__(7872);
const uint_32_1 = __nccwpck_require__(8345);
const uint_8_1 = __nccwpck_require__(7887);
const binary_parser_1 = __nccwpck_require__(8416);
const bigInt = __nccwpck_require__(4922);
/**
 * Computes the hash of a list of objects
 *
 * @param itemizer Converts an item into a format that can be added to SHAMap
 * @param itemsJson Array of items to add to a SHAMap
 * @returns the hash of the SHAMap
 */
function computeHash(itemizer, itemsJson) {
    const map = new shamap_1.ShaMap();
    itemsJson.forEach((item) => map.addItem(...itemizer(item)));
    return map.hash();
}
/**
 * Convert a transaction into an index and an item
 *
 * @param json transaction with metadata
 * @returns a tuple of index and item to be added to SHAMap
 */
function transactionItemizer(json) {
    assert.ok(json.hash);
    const index = hash_256_1.Hash256.from(json.hash);
    const item = {
        hashPrefix() {
            return hash_prefixes_1.HashPrefix.transaction;
        },
        toBytesSink(sink) {
            const serializer = new binary_1.BinarySerializer(sink);
            serializer.writeLengthEncoded(st_object_1.STObject.from(json));
            serializer.writeLengthEncoded(st_object_1.STObject.from(json.metaData));
        },
    };
    return [index, item, undefined];
}
/**
 * Convert an entry to a pair Hash256 and ShaMapNode
 *
 * @param json JSON describing a ledger entry item
 * @returns a tuple of index and item to be added to SHAMap
 */
function entryItemizer(json) {
    const index = hash_256_1.Hash256.from(json.index);
    const bytes = (0, binary_1.serializeObject)(json);
    const item = {
        hashPrefix() {
            return hash_prefixes_1.HashPrefix.accountStateEntry;
        },
        toBytesSink(sink) {
            sink.put(bytes);
        },
    };
    return [index, item, undefined];
}
/**
 * Function computing the hash of a transaction tree
 *
 * @param param An array of transaction objects to hash
 * @returns A Hash256 object
 */
function transactionTreeHash(param) {
    const itemizer = transactionItemizer;
    return computeHash(itemizer, param);
}
exports.transactionTreeHash = transactionTreeHash;
/**
 * Function computing the hash of accountState
 *
 * @param param A list of accountStates hash
 * @returns A Hash256 object
 */
function accountStateHash(param) {
    const itemizer = entryItemizer;
    return computeHash(itemizer, param);
}
exports.accountStateHash = accountStateHash;
/**
 * Serialize and hash a ledger header
 *
 * @param header a ledger header
 * @returns the hash of header
 */
function ledgerHash(header) {
    const hash = new hashes_1.Sha512Half();
    hash.put(hash_prefixes_1.HashPrefix.ledgerHeader);
    assert.ok(header.parent_close_time !== undefined);
    assert.ok(header.close_flags !== undefined);
    uint_32_1.UInt32.from(header.ledger_index).toBytesSink(hash);
    uint_64_1.UInt64.from(bigInt(String(header.total_coins))).toBytesSink(hash);
    hash_256_1.Hash256.from(header.parent_hash).toBytesSink(hash);
    hash_256_1.Hash256.from(header.transaction_hash).toBytesSink(hash);
    hash_256_1.Hash256.from(header.account_hash).toBytesSink(hash);
    uint_32_1.UInt32.from(header.parent_close_time).toBytesSink(hash);
    uint_32_1.UInt32.from(header.close_time).toBytesSink(hash);
    uint_8_1.UInt8.from(header.close_time_resolution).toBytesSink(hash);
    uint_8_1.UInt8.from(header.close_flags).toBytesSink(hash);
    return hash.finish();
}
exports.ledgerHash = ledgerHash;
/**
 * Decodes a serialized ledger header
 *
 * @param binary A serialized ledger header
 * @param definitions Type definitions to parse the ledger objects.
 *      Used if there are non-default ledger objects to decode.
 * @returns A JSON object describing a ledger header
 */
function decodeLedgerData(binary, definitions) {
    assert.ok(typeof binary === 'string', 'binary must be a hex string');
    const parser = new binary_parser_1.BinaryParser(binary, definitions);
    return {
        ledger_index: parser.readUInt32(),
        total_coins: parser.readType(uint_64_1.UInt64).valueOf().toString(),
        parent_hash: parser.readType(hash_256_1.Hash256).toHex(),
        transaction_hash: parser.readType(hash_256_1.Hash256).toHex(),
        account_hash: parser.readType(hash_256_1.Hash256).toHex(),
        parent_close_time: parser.readUInt32(),
        close_time: parser.readUInt32(),
        close_time_resolution: parser.readUInt8(),
        close_flags: parser.readUInt8(),
    };
}
exports.decodeLedgerData = decodeLedgerData;
//# sourceMappingURL=ledger-hashes.js.map

/***/ }),

/***/ 4110:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.nativeAsset = void 0;
class NativeAsset {
    constructor() {
        this.nativeAsset = 'XRP';
        //
    }
    set(asset) {
        this.nativeAsset = asset.trim().toUpperCase();
    }
    get() {
        return this.nativeAsset;
    }
}
const nativeAsset = new NativeAsset();
exports.nativeAsset = nativeAsset;
//# sourceMappingURL=nativeasset.js.map

/***/ }),

/***/ 6166:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.quality = void 0;
const types_1 = __nccwpck_require__(825);
const decimal_js_1 = __nccwpck_require__(7569);
const bigInt = __nccwpck_require__(4922);
const buffer_1 = __nccwpck_require__(3365);
/**
 * class for encoding and decoding quality
 */
class quality {
    /**
     * Encode quality amount
     *
     * @param arg string representation of an amount
     * @returns Serialized quality
     */
    static encode(quality) {
        const decimal = new decimal_js_1.Decimal(quality);
        const exponent = decimal.e - 15;
        const qualityString = decimal.times(`1e${-exponent}`).abs().toString();
        const bytes = types_1.coreTypes.UInt64.from(bigInt(qualityString)).toBytes();
        bytes[0] = exponent + 100;
        return bytes;
    }
    /**
     * Decode quality amount
     *
     * @param arg hex-string denoting serialized quality
     * @returns deserialized quality
     */
    static decode(quality) {
        const bytes = buffer_1.Buffer.from(quality, 'hex').slice(-8);
        const exponent = bytes[0] - 100;
        const mantissa = new decimal_js_1.Decimal(`0x${bytes.slice(1).toString('hex')}`);
        return mantissa.times(`1e${exponent}`);
    }
}
exports.quality = quality;
//# sourceMappingURL=quality.js.map

/***/ }),

/***/ 8416:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BinaryParser = void 0;
const assert = __importStar(__nccwpck_require__(9491));
const enums_1 = __nccwpck_require__(1701);
const buffer_1 = __nccwpck_require__(3365);
/**
 * BinaryParser is used to compute fields and values from a HexString
 */
class BinaryParser {
    /**
     * Initialize bytes to a hex string
     *
     * @param hexBytes a hex string
     * @param definitions Rippled definitions used to parse the values of transaction types and such.
     *                          Can be customized for sidechains and amendments.
     */
    constructor(hexBytes, definitions = enums_1.DEFAULT_DEFINITIONS) {
        this.bytes = buffer_1.Buffer.from(hexBytes, 'hex');
        this.definitions = definitions;
    }
    /**
     * Peek the first byte of the BinaryParser
     *
     * @returns The first byte of the BinaryParser
     */
    peek() {
        assert.ok(this.bytes.byteLength !== 0);
        return this.bytes[0];
    }
    /**
     * Consume the first n bytes of the BinaryParser
     *
     * @param n the number of bytes to skip
     */
    skip(n) {
        assert.ok(n <= this.bytes.byteLength);
        this.bytes = this.bytes.slice(n);
    }
    /**
     * read the first n bytes from the BinaryParser
     *
     * @param n The number of bytes to read
     * @return The bytes
     */
    read(n) {
        assert.ok(n <= this.bytes.byteLength);
        const slice = this.bytes.slice(0, n);
        this.skip(n);
        return slice;
    }
    /**
     * Read an integer of given size
     *
     * @param n The number of bytes to read
     * @return The number represented by those bytes
     */
    readUIntN(n) {
        assert.ok(0 < n && n <= 4, 'invalid n');
        return this.read(n).reduce((a, b) => (a << 8) | b) >>> 0;
    }
    readUInt8() {
        return this.readUIntN(1);
    }
    readUInt16() {
        return this.readUIntN(2);
    }
    readUInt32() {
        return this.readUIntN(4);
    }
    size() {
        return this.bytes.byteLength;
    }
    end(customEnd) {
        const length = this.bytes.byteLength;
        return length === 0 || (customEnd !== undefined && length <= customEnd);
    }
    /**
     * Reads variable length encoded bytes
     *
     * @return The variable length bytes
     */
    readVariableLength() {
        return this.read(this.readVariableLengthLength());
    }
    /**
     * Reads the length of the variable length encoded bytes
     *
     * @return The length of the variable length encoded bytes
     */
    readVariableLengthLength() {
        const b1 = this.readUInt8();
        if (b1 <= 192) {
            return b1;
        }
        else if (b1 <= 240) {
            const b2 = this.readUInt8();
            return 193 + (b1 - 193) * 256 + b2;
        }
        else if (b1 <= 254) {
            const b2 = this.readUInt8();
            const b3 = this.readUInt8();
            return 12481 + (b1 - 241) * 65536 + b2 * 256 + b3;
        }
        throw new Error('Invalid variable length indicator');
    }
    /**
     * Reads the field ordinal from the BinaryParser
     *
     * @return Field ordinal
     */
    readFieldOrdinal() {
        let type = this.readUInt8();
        let nth = type & 15;
        type >>= 4;
        if (type === 0) {
            type = this.readUInt8();
            if (type === 0 || type < 16) {
                throw new Error('Cannot read FieldOrdinal, type_code out of range');
            }
        }
        if (nth === 0) {
            nth = this.readUInt8();
            if (nth === 0 || nth < 16) {
                throw new Error('Cannot read FieldOrdinal, field_code out of range');
            }
        }
        return (type << 16) | nth;
    }
    /**
     * Read the field from the BinaryParser
     *
     * @return The field represented by the bytes at the head of the BinaryParser
     */
    readField() {
        return this.definitions.field.fromString(this.readFieldOrdinal().toString());
    }
    /**
     * Read a given type from the BinaryParser
     *
     * @param type The type that you want to read from the BinaryParser
     * @return The instance of that type read from the BinaryParser
     */
    readType(type) {
        return type.fromParser(this);
    }
    /**
     * Get the type associated with a given field
     *
     * @param field The field that you wan to get the type of
     * @return The type associated with the given field
     */
    typeForField(field) {
        return field.associatedType;
    }
    /**
     * Read value of the type specified by field from the BinaryParser
     *
     * @param field The field that you want to get the associated value for
     * @return The value associated with the given field
     */
    readFieldValue(field) {
        const type = this.typeForField(field);
        if (!type) {
            throw new Error(`unsupported: (${field.name}, ${field.type.name})`);
        }
        const sizeHint = field.isVariableLengthEncoded
            ? this.readVariableLengthLength()
            : undefined;
        const value = type.fromParser(this, sizeHint);
        if (value === undefined) {
            throw new Error(`fromParser for (${field.name}, ${field.type.name}) -> undefined `);
        }
        return value;
    }
    /**
     * Get the next field and value from the BinaryParser
     *
     * @return The field and value
     */
    readFieldAndValue() {
        const field = this.readField();
        return [field, this.readFieldValue(field)];
    }
}
exports.BinaryParser = BinaryParser;
//# sourceMappingURL=binary-parser.js.map

/***/ }),

/***/ 8540:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BinarySerializer = exports.BytesList = void 0;
const assert = __importStar(__nccwpck_require__(9491));
const buffer_1 = __nccwpck_require__(3365);
/**
 * Bytes list is a collection of buffer objects
 */
class BytesList {
    constructor() {
        this.bytesArray = [];
    }
    /**
     * Get the total number of bytes in the BytesList
     *
     * @return the number of bytes
     */
    getLength() {
        return buffer_1.Buffer.concat(this.bytesArray).byteLength;
    }
    /**
     * Put bytes in the BytesList
     *
     * @param bytesArg A Buffer
     * @return this BytesList
     */
    put(bytesArg) {
        const bytes = buffer_1.Buffer.from(bytesArg); // Temporary, to catch instances of Uint8Array being passed in
        this.bytesArray.push(bytes);
        return this;
    }
    /**
     * Write this BytesList to the back of another bytes list
     *
     *  @param list The BytesList to write to
     */
    toBytesSink(list) {
        list.put(this.toBytes());
    }
    toBytes() {
        return buffer_1.Buffer.concat(this.bytesArray);
    }
    toHex() {
        return this.toBytes().toString('hex').toUpperCase();
    }
}
exports.BytesList = BytesList;
/**
 * BinarySerializer is used to write fields and values to buffers
 */
class BinarySerializer {
    constructor(sink) {
        this.sink = new BytesList();
        this.sink = sink;
    }
    /**
     * Write a value to this BinarySerializer
     *
     * @param value a SerializedType value
     */
    write(value) {
        value.toBytesSink(this.sink);
    }
    /**
     * Write bytes to this BinarySerializer
     *
     * @param bytes the bytes to write
     */
    put(bytes) {
        this.sink.put(bytes);
    }
    /**
     * Write a value of a given type to this BinarySerializer
     *
     * @param type the type to write
     * @param value a value of that type
     */
    writeType(type, value) {
        this.write(type.from(value));
    }
    /**
     * Write BytesList to this BinarySerializer
     *
     * @param bl BytesList to write to BinarySerializer
     */
    writeBytesList(bl) {
        bl.toBytesSink(this.sink);
    }
    /**
     * Calculate the header of Variable Length encoded bytes
     *
     * @param length the length of the bytes
     */
    encodeVariableLength(length) {
        const lenBytes = buffer_1.Buffer.alloc(3);
        if (length <= 192) {
            lenBytes[0] = length;
            return lenBytes.slice(0, 1);
        }
        else if (length <= 12480) {
            length -= 193;
            lenBytes[0] = 193 + (length >>> 8);
            lenBytes[1] = length & 0xff;
            return lenBytes.slice(0, 2);
        }
        else if (length <= 918744) {
            length -= 12481;
            lenBytes[0] = 241 + (length >>> 16);
            lenBytes[1] = (length >> 8) & 0xff;
            lenBytes[2] = length & 0xff;
            return lenBytes.slice(0, 3);
        }
        throw new Error('Overflow error');
    }
    /**
     * Write field and value to BinarySerializer
     *
     * @param field field to write to BinarySerializer
     * @param value value to write to BinarySerializer
     */
    writeFieldAndValue(field, value, isUnlModifyWorkaround = false) {
        const associatedValue = field.associatedType.from(value);
        assert.ok(associatedValue.toBytesSink !== undefined);
        assert.ok(field.name !== undefined);
        this.sink.put(field.header);
        if (field.isVariableLengthEncoded) {
            this.writeLengthEncoded(associatedValue, isUnlModifyWorkaround);
        }
        else {
            associatedValue.toBytesSink(this.sink);
        }
    }
    /**
     * Write a variable length encoded value to the BinarySerializer
     *
     * @param value length encoded value to write to BytesList
     */
    writeLengthEncoded(value, isUnlModifyWorkaround = false) {
        const bytes = new BytesList();
        if (!isUnlModifyWorkaround) {
            // this part doesn't happen for the Account field in a UNLModify transaction
            value.toBytesSink(bytes);
        }
        this.put(this.encodeVariableLength(bytes.getLength()));
        this.writeBytesList(bytes);
    }
}
exports.BinarySerializer = BinarySerializer;
//# sourceMappingURL=binary-serializer.js.map

/***/ }),

/***/ 8313:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShaMapLeaf = exports.ShaMapNode = exports.ShaMap = void 0;
const assert_1 = __nccwpck_require__(9491);
const types_1 = __nccwpck_require__(825);
const hash_prefixes_1 = __nccwpck_require__(745);
const hashes_1 = __nccwpck_require__(9698);
const buffer_1 = __nccwpck_require__(3365);
/**
 * Abstract class describing a SHAMapNode
 */
class ShaMapNode {
}
exports.ShaMapNode = ShaMapNode;
/**
 * Class describing a Leaf of SHAMap
 */
class ShaMapLeaf extends ShaMapNode {
    constructor(index, item) {
        super();
        this.index = index;
        this.item = item;
    }
    /**
     * @returns true as ShaMapLeaf is a leaf node
     */
    isLeaf() {
        return true;
    }
    /**
     * @returns false as ShaMapLeaf is not an inner node
     */
    isInner() {
        return false;
    }
    /**
     * Get the prefix of the this.item
     *
     * @returns The hash prefix, unless this.item is undefined, then it returns an empty Buffer
     */
    hashPrefix() {
        return this.item === undefined ? buffer_1.Buffer.alloc(0) : this.item.hashPrefix();
    }
    /**
     * Hash the bytes representation of this
     *
     * @returns hash of this.item concatenated with this.index
     */
    hash() {
        const hash = hashes_1.Sha512Half.put(this.hashPrefix());
        this.toBytesSink(hash);
        return hash.finish();
    }
    /**
     * Write the bytes representation of this to a BytesList
     * @param list BytesList to write bytes to
     */
    toBytesSink(list) {
        if (this.item !== undefined) {
            this.item.toBytesSink(list);
        }
        this.index.toBytesSink(list);
    }
}
exports.ShaMapLeaf = ShaMapLeaf;
/**
 * Class defining an Inner Node of a SHAMap
 */
class ShaMapInner extends ShaMapNode {
    constructor(depth = 0) {
        super();
        this.depth = depth;
        this.slotBits = 0;
        this.branches = Array(16);
    }
    /**
     * @returns true as ShaMapInner is an inner node
     */
    isInner() {
        return true;
    }
    /**
     * @returns false as ShaMapInner is not a leaf node
     */
    isLeaf() {
        return false;
    }
    /**
     * Get the hash prefix for this node
     *
     * @returns hash prefix describing an inner node
     */
    hashPrefix() {
        return hash_prefixes_1.HashPrefix.innerNode;
    }
    /**
     * Set a branch of this node to be another node
     *
     * @param slot Slot to add branch to this.branches
     * @param branch Branch to add
     */
    setBranch(slot, branch) {
        this.slotBits = this.slotBits | (1 << slot);
        this.branches[slot] = branch;
    }
    /**
     * @returns true if node is empty
     */
    empty() {
        return this.slotBits === 0;
    }
    /**
     * Compute the hash of this node
     *
     * @returns The hash of this node
     */
    hash() {
        if (this.empty()) {
            return types_1.coreTypes.Hash256.ZERO_256;
        }
        const hash = hashes_1.Sha512Half.put(this.hashPrefix());
        this.toBytesSink(hash);
        return hash.finish();
    }
    /**
     * Writes the bytes representation of this node to a BytesList
     *
     * @param list BytesList to write bytes to
     */
    toBytesSink(list) {
        for (let i = 0; i < this.branches.length; i++) {
            const branch = this.branches[i];
            const hash = branch
                ? branch.hash()
                : types_1.coreTypes.Hash256.ZERO_256;
            hash.toBytesSink(list);
        }
    }
    /**
     * Add item to the SHAMap
     *
     * @param index Hash of the index of the item being inserted
     * @param item Item to insert in the map
     * @param leaf Leaf node to insert when branch doesn't exist
     */
    addItem(index, item, leaf) {
        assert_1.strict.ok(index !== undefined);
        if (index !== undefined) {
            const nibble = index.nibblet(this.depth);
            const existing = this.branches[nibble];
            if (existing === undefined) {
                this.setBranch(nibble, leaf || new ShaMapLeaf(index, item));
            }
            else if (existing instanceof ShaMapLeaf) {
                const newInner = new ShaMapInner(this.depth + 1);
                newInner.addItem(existing.index, undefined, existing);
                newInner.addItem(index, item, leaf);
                this.setBranch(nibble, newInner);
            }
            else if (existing instanceof ShaMapInner) {
                existing.addItem(index, item, leaf);
            }
            else {
                throw new Error('invalid ShaMap.addItem call');
            }
        }
    }
}
class ShaMap extends ShaMapInner {
}
exports.ShaMap = ShaMap;
//# sourceMappingURL=shamap.js.map

/***/ }),

/***/ 4659:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AccountID = void 0;
const ripple_address_codec_1 = __nccwpck_require__(597);
const hash_160_1 = __nccwpck_require__(9026);
const buffer_1 = __nccwpck_require__(3365);
const HEX_REGEX = /^[A-F0-9]{40}$/;
/**
 * Class defining how to encode and decode an AccountID
 */
class AccountID extends hash_160_1.Hash160 {
    constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : AccountID.defaultAccountID.bytes);
    }
    /**
     * Defines how to construct an AccountID
     *
     * @param value either an existing AccountID, a hex-string, or a base58 r-Address
     * @returns an AccountID object
     */
    static from(value) {
        if (value instanceof AccountID) {
            return value;
        }
        if (typeof value === 'string') {
            if (value === '') {
                return new AccountID();
            }
            return HEX_REGEX.test(value)
                ? new AccountID(buffer_1.Buffer.from(value, 'hex'))
                : this.fromBase58(value);
        }
        throw new Error('Cannot construct AccountID from value given');
    }
    /**
     * Defines how to build an AccountID from a base58 r-Address
     *
     * @param value a base58 r-Address
     * @returns an AccountID object
     */
    static fromBase58(value) {
        if ((0, ripple_address_codec_1.isValidXAddress)(value)) {
            const classic = (0, ripple_address_codec_1.xAddressToClassicAddress)(value);
            if (classic.tag !== false)
                throw new Error('Only allowed to have tag on Account or Destination');
            value = classic.classicAddress;
        }
        return new AccountID(buffer_1.Buffer.from((0, ripple_address_codec_1.decodeAccountID)(value)));
    }
    /**
     * Overload of toJSON
     *
     * @returns the base58 string for this AccountID
     */
    toJSON() {
        return this.toBase58();
    }
    /**
     * Defines how to encode AccountID into a base58 address
     *
     * @returns the base58 string defined by this.bytes
     */
    toBase58() {
        /* eslint-disable @typescript-eslint/no-explicit-any */
        return (0, ripple_address_codec_1.encodeAccountID)(this.bytes);
        /* eslint-enable @typescript-eslint/no-explicit-any */
    }
}
exports.AccountID = AccountID;
AccountID.defaultAccountID = new AccountID(buffer_1.Buffer.alloc(20));
//# sourceMappingURL=account-id.js.map

/***/ }),

/***/ 2853:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Amount = void 0;
const decimal_js_1 = __nccwpck_require__(7569);
const binary_parser_1 = __nccwpck_require__(8416);
const account_id_1 = __nccwpck_require__(4659);
const currency_1 = __nccwpck_require__(8519);
const serialized_type_1 = __nccwpck_require__(2753);
const bigInt = __nccwpck_require__(4922);
const buffer_1 = __nccwpck_require__(3365);
/**
 * Constants for validating amounts
 */
const MIN_IOU_EXPONENT = -96;
const MAX_IOU_EXPONENT = 80;
const MAX_IOU_PRECISION = 16;
const MAX_DROPS = new decimal_js_1.Decimal('1e17');
const MIN_NATIVE_ASSET = new decimal_js_1.Decimal('1e-6');
const mask = bigInt(0x00000000ffffffff);
/**
 * decimal.js configuration for Amount IOUs
 */
decimal_js_1.Decimal.config({
    toExpPos: MAX_IOU_EXPONENT + MAX_IOU_PRECISION,
    toExpNeg: MIN_IOU_EXPONENT - MAX_IOU_PRECISION,
});
/**
 * Type guard for AmountObject
 */
function isAmountObject(arg) {
    const keys = Object.keys(arg).sort();
    return (keys.length === 3 &&
        keys[0] === 'currency' &&
        keys[1] === 'issuer' &&
        keys[2] === 'value');
}
/**
 * Class for serializing/Deserializing Amounts
 */
class Amount extends serialized_type_1.SerializedType {
    constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : Amount.defaultAmount.bytes);
    }
    /**
     * Construct an amount from an IOU or string amount
     *
     * @param value An Amount, object representing an IOU, or a string
     *     representing an integer amount
     * @returns An Amount object
     */
    static from(value) {
        if (value instanceof Amount) {
            return value;
        }
        let amount = buffer_1.Buffer.alloc(8);
        if (typeof value === 'string') {
            Amount.assertNativeAssetIsValid(value);
            const number = bigInt(value);
            const intBuf = [buffer_1.Buffer.alloc(4), buffer_1.Buffer.alloc(4)];
            intBuf[0].writeUInt32BE(Number(number.shiftRight(32)), 0);
            intBuf[1].writeUInt32BE(Number(number.and(mask)), 0);
            amount = buffer_1.Buffer.concat(intBuf);
            amount[0] |= 0x40;
            return new Amount(amount);
        }
        if (isAmountObject(value)) {
            const number = new decimal_js_1.Decimal(value.value);
            Amount.assertIouIsValid(number);
            if (number.isZero()) {
                amount[0] |= 0x80;
            }
            else {
                const integerNumberString = number
                    .times(`1e${-(number.e - 15)}`)
                    .abs()
                    .toString();
                const num = bigInt(integerNumberString);
                const intBuf = [buffer_1.Buffer.alloc(4), buffer_1.Buffer.alloc(4)];
                intBuf[0].writeUInt32BE(Number(num.shiftRight(32)), 0);
                intBuf[1].writeUInt32BE(Number(num.and(mask)), 0);
                amount = buffer_1.Buffer.concat(intBuf);
                amount[0] |= 0x80;
                if (number.gt(new decimal_js_1.Decimal(0))) {
                    amount[0] |= 0x40;
                }
                const exponent = number.e - 15;
                const exponentByte = 97 + exponent;
                amount[0] |= exponentByte >>> 2;
                amount[1] |= (exponentByte & 0x03) << 6;
            }
            const currency = currency_1.Currency.from(value.currency).toBytes();
            const issuer = account_id_1.AccountID.from(value.issuer).toBytes();
            return new Amount(buffer_1.Buffer.concat([amount, currency, issuer]));
        }
        throw new Error('Invalid type to construct an Amount');
    }
    /**
     * Read an amount from a BinaryParser
     *
     * @param parser BinaryParser to read the Amount from
     * @returns An Amount object
     */
    static fromParser(parser) {
        const isNativeAsset = parser.peek() & 0x80;
        const numBytes = isNativeAsset ? 48 : 8;
        return new Amount(parser.read(numBytes));
    }
    /**
     * Get the JSON representation of this Amount
     *
     * @returns the JSON interpretation of this.bytes
     */
    toJSON() {
        if (this.isNative()) {
            const bytes = this.bytes;
            const isPositive = bytes[0] & 0x40;
            const sign = isPositive ? '' : '-';
            bytes[0] &= 0x3f;
            const msb = bigInt(bytes.slice(0, 4).readUInt32BE(0));
            const lsb = bigInt(bytes.slice(4).readUInt32BE(0));
            const num = msb.shiftLeft(32).or(lsb);
            return `${sign}${num.toString()}`;
        }
        else {
            const parser = new binary_parser_1.BinaryParser(this.toString());
            const mantissa = parser.read(8);
            const currency = currency_1.Currency.fromParser(parser);
            const issuer = account_id_1.AccountID.fromParser(parser);
            const b1 = mantissa[0];
            const b2 = mantissa[1];
            const isPositive = b1 & 0x40;
            const sign = isPositive ? '' : '-';
            const exponent = ((b1 & 0x3f) << 2) + ((b2 & 0xff) >> 6) - 97;
            mantissa[0] = 0;
            mantissa[1] &= 0x3f;
            const value = new decimal_js_1.Decimal(`${sign}0x${mantissa.toString('hex')}`).times(`1e${exponent}`);
            Amount.assertIouIsValid(value);
            return {
                value: value.toString(),
                currency: currency.toJSON(),
                issuer: issuer.toJSON(),
            };
        }
    }
    /**
     * Validate Native Asset amount
     *
     * @param amount String representing Native Asset amount
     * @returns void, but will throw if invalid amount
     */
    static assertNativeAssetIsValid(amount) {
        if (amount.indexOf('.') !== -1) {
            throw new Error(`${amount.toString()} is an illegal amount`);
        }
        const decimal = new decimal_js_1.Decimal(amount);
        if (!decimal.isZero()) {
            if (decimal.lt(MIN_NATIVE_ASSET) || decimal.gt(MAX_DROPS)) {
                throw new Error(`${amount.toString()} is an illegal amount`);
            }
        }
    }
    /**
     * Validate IOU.value amount
     *
     * @param decimal Decimal.js object representing IOU.value
     * @returns void, but will throw if invalid amount
     */
    static assertIouIsValid(decimal) {
        if (!decimal.isZero()) {
            const p = decimal.precision();
            const e = decimal.e - 15;
            if (p > MAX_IOU_PRECISION ||
                e > MAX_IOU_EXPONENT ||
                e < MIN_IOU_EXPONENT) {
                throw new Error('Decimal precision out of range');
            }
            this.verifyNoDecimal(decimal);
        }
    }
    /**
     * Ensure that the value after being multiplied by the exponent does not
     * contain a decimal.
     *
     * @param decimal a Decimal object
     * @returns a string of the object without a decimal
     */
    static verifyNoDecimal(decimal) {
        const integerNumberString = decimal
            .times(`1e${-(decimal.e - 15)}`)
            .abs()
            .toString();
        if (integerNumberString.indexOf('.') !== -1) {
            throw new Error('Decimal place found in integerNumberString');
        }
    }
    /**
     * Test if this amount is in units of Native Currency(Native Asset)
     *
     * @returns true if Native (Native Asset)
     */
    isNative() {
        return (this.bytes[0] & 0x80) === 0;
    }
}
exports.Amount = Amount;
Amount.defaultAmount = new Amount(buffer_1.Buffer.from('4000000000000000', 'hex'));
//# sourceMappingURL=amount.js.map

/***/ }),

/***/ 8692:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Blob = void 0;
const serialized_type_1 = __nccwpck_require__(2753);
const buffer_1 = __nccwpck_require__(3365);
/**
 * Variable length encoded type
 */
class Blob extends serialized_type_1.SerializedType {
    constructor(bytes) {
        super(bytes);
    }
    /**
     * Defines how to read a Blob from a BinaryParser
     *
     * @param parser The binary parser to read the Blob from
     * @param hint The length of the blob, computed by readVariableLengthLength() and passed in
     * @returns A Blob object
     */
    static fromParser(parser, hint) {
        return new Blob(parser.read(hint));
    }
    /**
     * Create a Blob object from a hex-string
     *
     * @param value existing Blob object or a hex-string
     * @returns A Blob object
     */
    static from(value) {
        if (value instanceof Blob) {
            return value;
        }
        if (typeof value === 'string') {
            return new Blob(buffer_1.Buffer.from(value, 'hex'));
        }
        throw new Error('Cannot construct Blob from value given');
    }
}
exports.Blob = Blob;
//# sourceMappingURL=blob.js.map

/***/ }),

/***/ 8519:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Currency = void 0;
const hash_160_1 = __nccwpck_require__(9026);
const buffer_1 = __nccwpck_require__(3365);
const nativeasset_1 = __nccwpck_require__(4110);
const NATIVE_ASSET_HEX_REGEX = /^0{40}$/;
const ISO_REGEX = /^[A-Z0-9a-z?!@#$%^&*(){}[\]|]{3}$/;
const HEX_REGEX = /^[A-F0-9]{40}$/;
// eslint-disable-next-line no-control-regex
const STANDARD_FORMAT_HEX_REGEX = /^0{24}[\x00-\x7F]{6}0{10}$/;
/**
 * Convert an ISO code to a currency bytes representation
 */
function isoToBytes(iso) {
    const bytes = buffer_1.Buffer.alloc(20);
    if (iso !== nativeasset_1.nativeAsset.get()) {
        const isoBytes = iso.split('').map((c) => c.charCodeAt(0));
        bytes.set(isoBytes, 12);
    }
    return bytes;
}
/**
 * Tests if ISO is a valid iso code
 */
function isIsoCode(iso) {
    return ISO_REGEX.test(iso);
}
function isoCodeFromHex(code) {
    const iso = code.toString();
    if (iso === nativeasset_1.nativeAsset.get()) {
        return null;
    }
    if (isIsoCode(iso)) {
        return iso;
    }
    return null;
}
/**
 * Tests if hex is a valid hex-string
 */
function isHex(hex) {
    return HEX_REGEX.test(hex);
}
/**
 * Tests if a string is a valid representation of a currency
 */
function isStringRepresentation(input) {
    return input.length === 3 || isHex(input);
}
/**
 * Tests if a Buffer is a valid representation of a currency
 */
function isBytesArray(bytes) {
    return bytes.byteLength === 20;
}
/**
 * Ensures that a value is a valid representation of a currency
 */
function isValidRepresentation(input) {
    return input instanceof buffer_1.Buffer
        ? isBytesArray(input)
        : isStringRepresentation(input);
}
/**
 * Generate bytes from a string or buffer representation of a currency
 */
function bytesFromRepresentation(input) {
    if (!isValidRepresentation(input)) {
        throw new Error(`Unsupported Currency representation: ${input}`);
    }
    return input.length === 3 ? isoToBytes(input) : buffer_1.Buffer.from(input, 'hex');
}
/**
 * Class defining how to encode and decode Currencies
 */
class Currency extends hash_160_1.Hash160 {
    constructor(byteBuf) {
        super(byteBuf !== null && byteBuf !== void 0 ? byteBuf : Currency.NATIVE_ASSET.bytes);
        const hex = this.bytes.toString('hex');
        if (NATIVE_ASSET_HEX_REGEX.test(hex)) {
            this._iso = nativeasset_1.nativeAsset.get();
        }
        else if (STANDARD_FORMAT_HEX_REGEX.test(hex)) {
            this._iso = isoCodeFromHex(this.bytes.slice(12, 15));
        }
        else {
            this._iso = null;
        }
    }
    /**
     * Return the ISO code of this currency
     *
     * @returns ISO code if it exists, else null
     */
    iso() {
        return this._iso;
    }
    /**
     * Constructs a Currency object
     *
     * @param val Currency object or a string representation of a currency
     */
    static from(value) {
        if (value instanceof Currency) {
            return value;
        }
        if (typeof value === 'string') {
            return new Currency(bytesFromRepresentation(value));
        }
        throw new Error('Cannot construct Currency from value given');
    }
    /**
     * Gets the JSON representation of a currency
     *
     * @returns JSON representation
     */
    toJSON() {
        const iso = this.iso();
        if (iso !== null) {
            return iso;
        }
        return this.bytes.toString('hex').toUpperCase();
    }
}
exports.Currency = Currency;
Currency.NATIVE_ASSET = new Currency(buffer_1.Buffer.alloc(20));
//# sourceMappingURL=currency.js.map

/***/ }),

/***/ 8239:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Hash128 = void 0;
const hash_1 = __nccwpck_require__(9452);
const buffer_1 = __nccwpck_require__(3365);
/**
 * Hash with a width of 128 bits
 */
class Hash128 extends hash_1.Hash {
    constructor(bytes) {
        if (bytes && bytes.byteLength === 0) {
            bytes = Hash128.ZERO_128.bytes;
        }
        super(bytes !== null && bytes !== void 0 ? bytes : Hash128.ZERO_128.bytes);
    }
    /**
     * Get the hex representation of a hash-128 bytes, allowing unset
     *
     * @returns hex String of this.bytes
     */
    toHex() {
        const hex = this.toBytes().toString('hex').toUpperCase();
        if (/^0+$/.exec(hex)) {
            return '';
        }
        return hex;
    }
}
exports.Hash128 = Hash128;
Hash128.width = 16;
Hash128.ZERO_128 = new Hash128(buffer_1.Buffer.alloc(Hash128.width));
//# sourceMappingURL=hash-128.js.map

/***/ }),

/***/ 9026:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Hash160 = void 0;
const hash_1 = __nccwpck_require__(9452);
const buffer_1 = __nccwpck_require__(3365);
/**
 * Hash with a width of 160 bits
 */
class Hash160 extends hash_1.Hash {
    constructor(bytes) {
        if (bytes && bytes.byteLength === 0) {
            bytes = Hash160.ZERO_160.bytes;
        }
        super(bytes !== null && bytes !== void 0 ? bytes : Hash160.ZERO_160.bytes);
    }
}
exports.Hash160 = Hash160;
Hash160.width = 20;
Hash160.ZERO_160 = new Hash160(buffer_1.Buffer.alloc(Hash160.width));
//# sourceMappingURL=hash-160.js.map

/***/ }),

/***/ 8989:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Hash256 = void 0;
const hash_1 = __nccwpck_require__(9452);
const buffer_1 = __nccwpck_require__(3365);
/**
 * Hash with a width of 256 bits
 */
class Hash256 extends hash_1.Hash {
    constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : Hash256.ZERO_256.bytes);
    }
}
exports.Hash256 = Hash256;
Hash256.width = 32;
Hash256.ZERO_256 = new Hash256(buffer_1.Buffer.alloc(Hash256.width));
//# sourceMappingURL=hash-256.js.map

/***/ }),

/***/ 9452:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Hash = void 0;
const serialized_type_1 = __nccwpck_require__(2753);
const buffer_1 = __nccwpck_require__(3365);
/**
 * Base class defining how to encode and decode hashes
 */
class Hash extends serialized_type_1.Comparable {
    constructor(bytes) {
        super(bytes);
        if (this.bytes.byteLength !== this.constructor.width) {
            throw new Error(`Invalid Hash length ${this.bytes.byteLength}`);
        }
    }
    /**
     * Construct a Hash object from an existing Hash object or a hex-string
     *
     * @param value A hash object or hex-string of a hash
     */
    static from(value) {
        if (value instanceof this) {
            return value;
        }
        if (typeof value === 'string') {
            return new this(buffer_1.Buffer.from(value, 'hex'));
        }
        throw new Error('Cannot construct Hash from given value');
    }
    /**
     * Read a Hash object from a BinaryParser
     *
     * @param parser BinaryParser to read the hash from
     * @param hint length of the bytes to read, optional
     */
    static fromParser(parser, hint) {
        return new this(parser.read(hint !== null && hint !== void 0 ? hint : this.width));
    }
    /**
     * Overloaded operator for comparing two hash objects
     *
     * @param other The Hash to compare this to
     */
    compareTo(other) {
        return this.bytes.compare(this.constructor.from(other).bytes);
    }
    /**
     * @returns the hex-string representation of this Hash
     */
    toString() {
        return this.toHex();
    }
    /**
     * Returns four bits at the specified depth within a hash
     *
     * @param depth The depth of the four bits
     * @returns The number represented by the four bits
     */
    nibblet(depth) {
        const byteIx = depth > 0 ? (depth / 2) | 0 : 0;
        let b = this.bytes[byteIx];
        if (depth % 2 === 0) {
            b = (b & 0xf0) >>> 4;
        }
        else {
            b = b & 0x0f;
        }
        return b;
    }
}
exports.Hash = Hash;
//# sourceMappingURL=hash.js.map

/***/ }),

/***/ 825:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Vector256 = exports.UInt64 = exports.UInt32 = exports.UInt16 = exports.UInt8 = exports.STObject = exports.STArray = exports.PathSet = exports.Hash256 = exports.Hash160 = exports.Hash128 = exports.Currency = exports.Blob = exports.Amount = exports.AccountID = exports.coreTypes = void 0;
const account_id_1 = __nccwpck_require__(4659);
Object.defineProperty(exports, "AccountID", ({ enumerable: true, get: function () { return account_id_1.AccountID; } }));
const amount_1 = __nccwpck_require__(2853);
Object.defineProperty(exports, "Amount", ({ enumerable: true, get: function () { return amount_1.Amount; } }));
const blob_1 = __nccwpck_require__(8692);
Object.defineProperty(exports, "Blob", ({ enumerable: true, get: function () { return blob_1.Blob; } }));
const currency_1 = __nccwpck_require__(8519);
Object.defineProperty(exports, "Currency", ({ enumerable: true, get: function () { return currency_1.Currency; } }));
const hash_128_1 = __nccwpck_require__(8239);
Object.defineProperty(exports, "Hash128", ({ enumerable: true, get: function () { return hash_128_1.Hash128; } }));
const hash_160_1 = __nccwpck_require__(9026);
Object.defineProperty(exports, "Hash160", ({ enumerable: true, get: function () { return hash_160_1.Hash160; } }));
const hash_256_1 = __nccwpck_require__(8989);
Object.defineProperty(exports, "Hash256", ({ enumerable: true, get: function () { return hash_256_1.Hash256; } }));
const issue_1 = __nccwpck_require__(6427);
const path_set_1 = __nccwpck_require__(71);
Object.defineProperty(exports, "PathSet", ({ enumerable: true, get: function () { return path_set_1.PathSet; } }));
const st_array_1 = __nccwpck_require__(1095);
Object.defineProperty(exports, "STArray", ({ enumerable: true, get: function () { return st_array_1.STArray; } }));
const st_object_1 = __nccwpck_require__(1930);
Object.defineProperty(exports, "STObject", ({ enumerable: true, get: function () { return st_object_1.STObject; } }));
const uint_16_1 = __nccwpck_require__(9838);
Object.defineProperty(exports, "UInt16", ({ enumerable: true, get: function () { return uint_16_1.UInt16; } }));
const uint_32_1 = __nccwpck_require__(8345);
Object.defineProperty(exports, "UInt32", ({ enumerable: true, get: function () { return uint_32_1.UInt32; } }));
const uint_64_1 = __nccwpck_require__(7872);
Object.defineProperty(exports, "UInt64", ({ enumerable: true, get: function () { return uint_64_1.UInt64; } }));
const uint_8_1 = __nccwpck_require__(7887);
Object.defineProperty(exports, "UInt8", ({ enumerable: true, get: function () { return uint_8_1.UInt8; } }));
const vector_256_1 = __nccwpck_require__(1196);
Object.defineProperty(exports, "Vector256", ({ enumerable: true, get: function () { return vector_256_1.Vector256; } }));
const xchain_bridge_1 = __nccwpck_require__(2457);
const enums_1 = __nccwpck_require__(1701);
const coreTypes = {
    AccountID: account_id_1.AccountID,
    Amount: amount_1.Amount,
    Blob: blob_1.Blob,
    Currency: currency_1.Currency,
    Hash128: hash_128_1.Hash128,
    Hash160: hash_160_1.Hash160,
    Hash256: hash_256_1.Hash256,
    Issue: issue_1.Issue,
    PathSet: path_set_1.PathSet,
    STArray: st_array_1.STArray,
    STObject: st_object_1.STObject,
    UInt8: uint_8_1.UInt8,
    UInt16: uint_16_1.UInt16,
    UInt32: uint_32_1.UInt32,
    UInt64: uint_64_1.UInt64,
    Vector256: vector_256_1.Vector256,
    XChainBridge: xchain_bridge_1.XChainBridge,
};
exports.coreTypes = coreTypes;
// Ensures that the DEFAULT_DEFINITIONS object connects these types to fields for serializing/deserializing
// This is done here instead of in enums/index.ts to avoid a circular dependency
// because some of the above types depend on BinarySerializer which depends on enums/index.ts.
enums_1.DEFAULT_DEFINITIONS.associateTypes(coreTypes);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 6427:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Issue = void 0;
const binary_parser_1 = __nccwpck_require__(8416);
const account_id_1 = __nccwpck_require__(4659);
const currency_1 = __nccwpck_require__(8519);
const serialized_type_1 = __nccwpck_require__(2753);
const buffer_1 = __nccwpck_require__(3365);
const nativeasset_1 = __nccwpck_require__(4110);
/**
 * Type guard for AmountObject
 */
function isIssueObject(arg) {
    const keys = Object.keys(arg).sort();
    if (keys.length === 1) {
        return keys[0] === 'currency';
    }
    return keys.length === 2 && keys[0] === 'currency' && keys[1] === 'issuer';
}
/**
 * Class for serializing/Deserializing Amounts
 */
class Issue extends serialized_type_1.SerializedType {
    constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : Issue.ZERO_ISSUED_CURRENCY.bytes);
    }
    /**
     * Construct an amount from an IOU or string amount
     *
     * @param value An Amount, object representing an IOU, or a string
     *     representing an integer amount
     * @returns An Amount object
     */
    static from(value) {
        if (value instanceof Issue) {
            return value;
        }
        if (isIssueObject(value)) {
            const currency = currency_1.Currency.from(value.currency).toBytes();
            if (value.issuer == null) {
                return new Issue(currency);
            }
            const issuer = account_id_1.AccountID.from(value.issuer).toBytes();
            return new Issue(buffer_1.Buffer.concat([currency, issuer]));
        }
        throw new Error('Invalid type to construct an Amount');
    }
    /**
     * Read an amount from a BinaryParser
     *
     * @param parser BinaryParser to read the Amount from
     * @returns An Amount object
     */
    static fromParser(parser) {
        const currency = parser.read(20);
        if (new currency_1.Currency(currency).toJSON() === nativeasset_1.nativeAsset.get()) {
            return new Issue(currency);
        }
        const currencyAndIssuer = [currency, parser.read(20)];
        return new Issue(buffer_1.Buffer.concat(currencyAndIssuer));
    }
    /**
     * Get the JSON representation of this Amount
     *
     * @returns the JSON interpretation of this.bytes
     */
    toJSON() {
        const parser = new binary_parser_1.BinaryParser(this.toString());
        const currency = currency_1.Currency.fromParser(parser);
        if (currency.toJSON() === nativeasset_1.nativeAsset.get()) {
            return { currency: currency.toJSON() };
        }
        const issuer = account_id_1.AccountID.fromParser(parser);
        return {
            currency: currency.toJSON(),
            issuer: issuer.toJSON(),
        };
    }
}
exports.Issue = Issue;
Issue.ZERO_ISSUED_CURRENCY = new Issue(buffer_1.Buffer.alloc(20));
//# sourceMappingURL=issue.js.map

/***/ }),

/***/ 71:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PathSet = void 0;
const account_id_1 = __nccwpck_require__(4659);
const currency_1 = __nccwpck_require__(8519);
const binary_parser_1 = __nccwpck_require__(8416);
const serialized_type_1 = __nccwpck_require__(2753);
const buffer_1 = __nccwpck_require__(3365);
/**
 * Constants for separating Paths in a PathSet
 */
const PATHSET_END_BYTE = 0x00;
const PATH_SEPARATOR_BYTE = 0xff;
/**
 * Constant for masking types of a Hop
 */
const TYPE_ACCOUNT = 0x01;
const TYPE_CURRENCY = 0x10;
const TYPE_ISSUER = 0x20;
/**
 * TypeGuard for HopObject
 */
function isHopObject(arg) {
    return (arg.issuer !== undefined ||
        arg.account !== undefined ||
        arg.currency !== undefined);
}
/**
 * TypeGuard for PathSet
 */
function isPathSet(arg) {
    return ((Array.isArray(arg) && arg.length === 0) ||
        (Array.isArray(arg) && Array.isArray(arg[0]) && arg[0].length === 0) ||
        (Array.isArray(arg) && Array.isArray(arg[0]) && isHopObject(arg[0][0])));
}
/**
 * Serialize and Deserialize a Hop
 */
class Hop extends serialized_type_1.SerializedType {
    /**
     * Create a Hop from a HopObject
     *
     * @param value Either a hop or HopObject to create a hop with
     * @returns a Hop
     */
    static from(value) {
        if (value instanceof Hop) {
            return value;
        }
        const bytes = [buffer_1.Buffer.from([0])];
        if (value.account) {
            bytes.push(account_id_1.AccountID.from(value.account).toBytes());
            bytes[0][0] |= TYPE_ACCOUNT;
        }
        if (value.currency) {
            bytes.push(currency_1.Currency.from(value.currency).toBytes());
            bytes[0][0] |= TYPE_CURRENCY;
        }
        if (value.issuer) {
            bytes.push(account_id_1.AccountID.from(value.issuer).toBytes());
            bytes[0][0] |= TYPE_ISSUER;
        }
        return new Hop(buffer_1.Buffer.concat(bytes));
    }
    /**
     * Construct a Hop from a BinaryParser
     *
     * @param parser BinaryParser to read the Hop from
     * @returns a Hop
     */
    static fromParser(parser) {
        const type = parser.readUInt8();
        const bytes = [buffer_1.Buffer.from([type])];
        if (type & TYPE_ACCOUNT) {
            bytes.push(parser.read(account_id_1.AccountID.width));
        }
        if (type & TYPE_CURRENCY) {
            bytes.push(parser.read(currency_1.Currency.width));
        }
        if (type & TYPE_ISSUER) {
            bytes.push(parser.read(account_id_1.AccountID.width));
        }
        return new Hop(buffer_1.Buffer.concat(bytes));
    }
    /**
     * Get the JSON interpretation of this hop
     *
     * @returns a HopObject, an JS object with optional account, issuer, and currency
     */
    toJSON() {
        const hopParser = new binary_parser_1.BinaryParser(this.bytes.toString('hex'));
        const type = hopParser.readUInt8();
        let account, currency, issuer;
        if (type & TYPE_ACCOUNT) {
            account = account_id_1.AccountID.fromParser(hopParser).toJSON();
        }
        if (type & TYPE_CURRENCY) {
            currency = currency_1.Currency.fromParser(hopParser).toJSON();
        }
        if (type & TYPE_ISSUER) {
            issuer = account_id_1.AccountID.fromParser(hopParser).toJSON();
        }
        const result = {};
        if (account) {
            result.account = account;
        }
        if (issuer) {
            result.issuer = issuer;
        }
        if (currency) {
            result.currency = currency;
        }
        return result;
    }
    /**
     * get a number representing the type of this hop
     *
     * @returns a number to be bitwise and-ed with TYPE_ constants to describe the types in the hop
     */
    type() {
        return this.bytes[0];
    }
}
/**
 * Class for serializing/deserializing Paths
 */
class Path extends serialized_type_1.SerializedType {
    /**
     * construct a Path from an array of Hops
     *
     * @param value Path or array of HopObjects to construct a Path
     * @returns the Path
     */
    static from(value) {
        if (value instanceof Path) {
            return value;
        }
        const bytes = [];
        value.forEach((hop) => {
            bytes.push(Hop.from(hop).toBytes());
        });
        return new Path(buffer_1.Buffer.concat(bytes));
    }
    /**
     * Read a Path from a BinaryParser
     *
     * @param parser BinaryParser to read Path from
     * @returns the Path represented by the bytes read from the BinaryParser
     */
    static fromParser(parser) {
        const bytes = [];
        while (!parser.end()) {
            bytes.push(Hop.fromParser(parser).toBytes());
            if (parser.peek() === PATHSET_END_BYTE ||
                parser.peek() === PATH_SEPARATOR_BYTE) {
                break;
            }
        }
        return new Path(buffer_1.Buffer.concat(bytes));
    }
    /**
     * Get the JSON representation of this Path
     *
     * @returns an Array of HopObject constructed from this.bytes
     */
    toJSON() {
        const json = [];
        const pathParser = new binary_parser_1.BinaryParser(this.toString());
        while (!pathParser.end()) {
            json.push(Hop.fromParser(pathParser).toJSON());
        }
        return json;
    }
}
/**
 * Deserialize and Serialize the PathSet type
 */
class PathSet extends serialized_type_1.SerializedType {
    /**
     * Construct a PathSet from an Array of Arrays representing paths
     *
     * @param value A PathSet or Array of Array of HopObjects
     * @returns the PathSet constructed from value
     */
    static from(value) {
        if (value instanceof PathSet) {
            return value;
        }
        if (isPathSet(value)) {
            const bytes = [];
            value.forEach((path) => {
                bytes.push(Path.from(path).toBytes());
                bytes.push(buffer_1.Buffer.from([PATH_SEPARATOR_BYTE]));
            });
            bytes[bytes.length - 1] = buffer_1.Buffer.from([PATHSET_END_BYTE]);
            return new PathSet(buffer_1.Buffer.concat(bytes));
        }
        throw new Error('Cannot construct PathSet from given value');
    }
    /**
     * Construct a PathSet from a BinaryParser
     *
     * @param parser A BinaryParser to read PathSet from
     * @returns the PathSet read from parser
     */
    static fromParser(parser) {
        const bytes = [];
        while (!parser.end()) {
            bytes.push(Path.fromParser(parser).toBytes());
            bytes.push(parser.read(1));
            if (bytes[bytes.length - 1][0] == PATHSET_END_BYTE) {
                break;
            }
        }
        return new PathSet(buffer_1.Buffer.concat(bytes));
    }
    /**
     * Get the JSON representation of this PathSet
     *
     * @returns an Array of Array of HopObjects, representing this PathSet
     */
    toJSON() {
        const json = [];
        const pathParser = new binary_parser_1.BinaryParser(this.toString());
        while (!pathParser.end()) {
            json.push(Path.fromParser(pathParser).toJSON());
            pathParser.skip(1);
        }
        return json;
    }
}
exports.PathSet = PathSet;
//# sourceMappingURL=path-set.js.map

/***/ }),

/***/ 2753:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Comparable = exports.SerializedType = void 0;
const binary_serializer_1 = __nccwpck_require__(8540);
const buffer_1 = __nccwpck_require__(3365);
/**
 * The base class for all binary-codec types
 */
class SerializedType {
    constructor(bytes) {
        this.bytes = buffer_1.Buffer.alloc(0);
        this.bytes = bytes !== null && bytes !== void 0 ? bytes : buffer_1.Buffer.alloc(0);
    }
    static fromParser(parser, hint) {
        throw new Error('fromParser not implemented');
        return this.fromParser(parser, hint);
    }
    static from(value) {
        throw new Error('from not implemented');
        return this.from(value);
    }
    /**
     * Write the bytes representation of a SerializedType to a BytesList
     *
     * @param list The BytesList to write SerializedType bytes to
     */
    toBytesSink(list) {
        list.put(this.bytes);
    }
    /**
     * Get the hex representation of a SerializedType's bytes
     *
     * @returns hex String of this.bytes
     */
    toHex() {
        return this.toBytes().toString('hex').toUpperCase();
    }
    /**
     * Get the bytes representation of a SerializedType
     *
     * @returns A buffer of the bytes
     */
    toBytes() {
        if (this.bytes) {
            return this.bytes;
        }
        const bytes = new binary_serializer_1.BytesList();
        this.toBytesSink(bytes);
        return bytes.toBytes();
    }
    /**
     * Return the JSON representation of a SerializedType
     *
     * @param _definitions rippled definitions used to parse the values of transaction types and such.
     *                          Unused in default, but used in STObject, STArray
     *                          Can be customized for sidechains and amendments.
     * @returns any type, if not overloaded returns hexString representation of bytes
     */
    toJSON(_definitions) {
        return this.toHex();
    }
    /**
     * @returns hexString representation of this.bytes
     */
    toString() {
        return this.toHex();
    }
}
exports.SerializedType = SerializedType;
/**
 * Base class for SerializedTypes that are comparable
 */
class Comparable extends SerializedType {
    lt(other) {
        return this.compareTo(other) < 0;
    }
    eq(other) {
        return this.compareTo(other) === 0;
    }
    gt(other) {
        return this.compareTo(other) > 0;
    }
    gte(other) {
        return this.compareTo(other) > -1;
    }
    lte(other) {
        return this.compareTo(other) < 1;
    }
    /**
     * Overload this method to define how two Comparable SerializedTypes are compared
     *
     * @param other The comparable object to compare this to
     * @returns A number denoting the relationship of this and other
     */
    compareTo(other) {
        throw new Error(`cannot compare ${this.toString()} and ${other.toString()}`);
    }
}
exports.Comparable = Comparable;
//# sourceMappingURL=serialized-type.js.map

/***/ }),

/***/ 1095:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.STArray = void 0;
const enums_1 = __nccwpck_require__(1701);
const serialized_type_1 = __nccwpck_require__(2753);
const st_object_1 = __nccwpck_require__(1930);
const binary_parser_1 = __nccwpck_require__(8416);
const buffer_1 = __nccwpck_require__(3365);
const ARRAY_END_MARKER = buffer_1.Buffer.from([0xf1]);
const ARRAY_END_MARKER_NAME = 'ArrayEndMarker';
const OBJECT_END_MARKER = buffer_1.Buffer.from([0xe1]);
/**
 * TypeGuard for Array<JsonObject>
 */
function isObjects(args) {
    return (Array.isArray(args) && (args.length === 0 || typeof args[0] === 'object'));
}
/**
 * Class for serializing and deserializing Arrays of Objects
 */
class STArray extends serialized_type_1.SerializedType {
    /**
     * Construct an STArray from a BinaryParser
     *
     * @param parser BinaryParser to parse an STArray from
     * @returns An STArray Object
     */
    static fromParser(parser) {
        const bytes = [];
        while (!parser.end()) {
            const field = parser.readField();
            if (field.name === ARRAY_END_MARKER_NAME) {
                break;
            }
            bytes.push(field.header, parser.readFieldValue(field).toBytes(), OBJECT_END_MARKER);
        }
        bytes.push(ARRAY_END_MARKER);
        return new STArray(buffer_1.Buffer.concat(bytes));
    }
    /**
     * Construct an STArray from an Array of JSON Objects
     *
     * @param value STArray or Array of Objects to parse into an STArray
     * @param definitions optional, types and values to use to encode/decode a transaction
     * @returns An STArray object
     */
    static from(value, definitions = enums_1.DEFAULT_DEFINITIONS) {
        if (value instanceof STArray) {
            return value;
        }
        if (isObjects(value)) {
            const bytes = [];
            value.forEach((obj) => {
                bytes.push(st_object_1.STObject.from(obj, undefined, definitions).toBytes());
            });
            bytes.push(ARRAY_END_MARKER);
            return new STArray(buffer_1.Buffer.concat(bytes));
        }
        throw new Error('Cannot construct STArray from value given');
    }
    /**
     * Return the JSON representation of this.bytes
     *
     * @param definitions optional, types and values to use to encode/decode a transaction
     * @returns An Array of JSON objects
     */
    toJSON(definitions = enums_1.DEFAULT_DEFINITIONS) {
        const result = [];
        const arrayParser = new binary_parser_1.BinaryParser(this.toString(), definitions);
        while (!arrayParser.end()) {
            const field = arrayParser.readField();
            if (field.name === ARRAY_END_MARKER_NAME) {
                break;
            }
            const outer = {};
            outer[field.name] = st_object_1.STObject.fromParser(arrayParser).toJSON(definitions);
            result.push(outer);
        }
        return result;
    }
}
exports.STArray = STArray;
//# sourceMappingURL=st-array.js.map

/***/ }),

/***/ 1930:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.STObject = void 0;
const enums_1 = __nccwpck_require__(1701);
const serialized_type_1 = __nccwpck_require__(2753);
const ripple_address_codec_1 = __nccwpck_require__(597);
const binary_parser_1 = __nccwpck_require__(8416);
const binary_serializer_1 = __nccwpck_require__(8540);
const buffer_1 = __nccwpck_require__(3365);
const st_array_1 = __nccwpck_require__(1095);
const OBJECT_END_MARKER_BYTE = buffer_1.Buffer.from([0xe1]);
const OBJECT_END_MARKER = 'ObjectEndMarker';
const ST_OBJECT = 'STObject';
const DESTINATION = 'Destination';
const ACCOUNT = 'Account';
const SOURCE_TAG = 'SourceTag';
const DEST_TAG = 'DestinationTag';
/**
 * Break down an X-Address into an account and a tag
 *
 * @param field Name of field
 * @param xAddress X-Address corresponding to the field
 */
function handleXAddress(field, xAddress) {
    const decoded = (0, ripple_address_codec_1.xAddressToClassicAddress)(xAddress);
    let tagName;
    if (field === DESTINATION)
        tagName = DEST_TAG;
    else if (field === ACCOUNT)
        tagName = SOURCE_TAG;
    else if (decoded.tag !== false)
        throw new Error(`${field} cannot have an associated tag`);
    return decoded.tag !== false
        ? { [field]: decoded.classicAddress, [tagName]: decoded.tag }
        : { [field]: decoded.classicAddress };
}
/**
 * Validate that two objects don't both have the same tag fields
 *
 * @param obj1 First object to check for tags
 * @param obj2 Second object to check for tags
 * @throws When both objects have SourceTag or DestinationTag
 */
function checkForDuplicateTags(obj1, obj2) {
    if (!(obj1[SOURCE_TAG] === undefined || obj2[SOURCE_TAG] === undefined))
        throw new Error('Cannot have Account X-Address and SourceTag');
    if (!(obj1[DEST_TAG] === undefined || obj2[DEST_TAG] === undefined))
        throw new Error('Cannot have Destination X-Address and DestinationTag');
}
/**
 * Class for Serializing/Deserializing objects
 */
class STObject extends serialized_type_1.SerializedType {
    /**
     * Construct a STObject from a BinaryParser
     *
     * @param parser BinaryParser to read STObject from
     * @returns A STObject object
     */
    static fromParser(parser) {
        const list = new binary_serializer_1.BytesList();
        const bytes = new binary_serializer_1.BinarySerializer(list);
        while (!parser.end()) {
            const field = parser.readField();
            if (field.name === OBJECT_END_MARKER) {
                break;
            }
            const associatedValue = parser.readFieldValue(field);
            bytes.writeFieldAndValue(field, associatedValue);
            if (field.type.name === ST_OBJECT) {
                bytes.put(OBJECT_END_MARKER_BYTE);
            }
        }
        return new STObject(list.toBytes());
    }
    /**
     * Construct a STObject from a JSON object
     *
     * @param value An object to include
     * @param filter optional, denote which field to include in serialized object
     * @param definitions optional, types and values to use to encode/decode a transaction
     * @returns a STObject object
     */
    static from(value, filter, definitions = enums_1.DEFAULT_DEFINITIONS) {
        if (value instanceof STObject) {
            return value;
        }
        const list = new binary_serializer_1.BytesList();
        const bytes = new binary_serializer_1.BinarySerializer(list);
        let isUnlModify = false;
        const xAddressDecoded = Object.entries(value).reduce((acc, [key, val]) => {
            let handled = undefined;
            if (val && (0, ripple_address_codec_1.isValidXAddress)(val.toString())) {
                handled = handleXAddress(key, val.toString());
                checkForDuplicateTags(handled, value);
            }
            return Object.assign(acc, handled !== null && handled !== void 0 ? handled : { [key]: val });
        }, {});
        let sorted = Object.keys(xAddressDecoded)
            .map((f) => definitions.field[f])
            .filter((f) => f !== undefined &&
            xAddressDecoded[f.name] !== undefined &&
            f.isSerialized)
            .sort((a, b) => {
            return a.ordinal - b.ordinal;
        });
        if (filter !== undefined) {
            sorted = sorted.filter(filter);
        }
        sorted.forEach((field) => {
            const associatedValue = field.type.name === ST_OBJECT
                ? this.from(xAddressDecoded[field.name], undefined, definitions)
                : field.type.name === 'STArray'
                    ? st_array_1.STArray.from(xAddressDecoded[field.name], definitions)
                    : field.associatedType.from(xAddressDecoded[field.name]);
            if (associatedValue == undefined) {
                throw new TypeError(`Unable to interpret "${field.name}: ${xAddressDecoded[field.name]}".`);
            }
            if (associatedValue.name === 'UNLModify') {
                // triggered when the TransactionType field has a value of 'UNLModify'
                isUnlModify = true;
            }
            // true when in the UNLModify pseudotransaction (after the transaction type has been processed) and working with the
            // Account field
            // The Account field must not be a part of the UNLModify pseudotransaction encoding, due to a bug in rippled
            const isUnlModifyWorkaround = field.name == 'Account' && isUnlModify;
            bytes.writeFieldAndValue(field, associatedValue, isUnlModifyWorkaround);
            if (field.type.name === ST_OBJECT) {
                bytes.put(OBJECT_END_MARKER_BYTE);
            }
        });
        return new STObject(list.toBytes());
    }
    /**
     * Get the JSON interpretation of this.bytes
     * @param definitions rippled definitions used to parse the values of transaction types and such.
     *                          Can be customized for sidechains and amendments.
     * @returns a JSON object
     */
    toJSON(definitions) {
        const objectParser = new binary_parser_1.BinaryParser(this.toString(), definitions);
        const accumulator = {};
        while (!objectParser.end()) {
            const field = objectParser.readField();
            if (field.name === OBJECT_END_MARKER) {
                break;
            }
            accumulator[field.name] = objectParser
                .readFieldValue(field)
                .toJSON(definitions);
        }
        return accumulator;
    }
}
exports.STObject = STObject;
//# sourceMappingURL=st-object.js.map

/***/ }),

/***/ 9838:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UInt16 = void 0;
const uint_1 = __nccwpck_require__(4649);
const buffer_1 = __nccwpck_require__(3365);
/**
 * Derived UInt class for serializing/deserializing 16 bit UInt
 */
class UInt16 extends uint_1.UInt {
    constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : UInt16.defaultUInt16.bytes);
    }
    static fromParser(parser) {
        return new UInt16(parser.read(UInt16.width));
    }
    /**
     * Construct a UInt16 object from a number
     *
     * @param val UInt16 object or number
     */
    static from(val) {
        if (val instanceof UInt16) {
            return val;
        }
        if (typeof val === 'number') {
            const buf = buffer_1.Buffer.alloc(UInt16.width);
            buf.writeUInt16BE(val, 0);
            return new UInt16(buf);
        }
        throw new Error('Can not construct UInt16 with given value');
    }
    /**
     * get the value of a UInt16 object
     *
     * @returns the number represented by this.bytes
     */
    valueOf() {
        return this.bytes.readUInt16BE(0);
    }
}
exports.UInt16 = UInt16;
UInt16.width = 16 / 8; // 2
UInt16.defaultUInt16 = new UInt16(buffer_1.Buffer.alloc(UInt16.width));
//# sourceMappingURL=uint-16.js.map

/***/ }),

/***/ 8345:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UInt32 = void 0;
const uint_1 = __nccwpck_require__(4649);
const buffer_1 = __nccwpck_require__(3365);
/**
 * Derived UInt class for serializing/deserializing 32 bit UInt
 */
class UInt32 extends uint_1.UInt {
    constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : UInt32.defaultUInt32.bytes);
    }
    static fromParser(parser) {
        return new UInt32(parser.read(UInt32.width));
    }
    /**
     * Construct a UInt32 object from a number
     *
     * @param val UInt32 object or number
     */
    static from(val) {
        if (val instanceof UInt32) {
            return val;
        }
        const buf = buffer_1.Buffer.alloc(UInt32.width);
        if (typeof val === 'string') {
            const num = Number.parseInt(val);
            buf.writeUInt32BE(num, 0);
            return new UInt32(buf);
        }
        if (typeof val === 'number') {
            buf.writeUInt32BE(val, 0);
            return new UInt32(buf);
        }
        throw new Error('Cannot construct UInt32 from given value');
    }
    /**
     * get the value of a UInt32 object
     *
     * @returns the number represented by this.bytes
     */
    valueOf() {
        return this.bytes.readUInt32BE(0);
    }
}
exports.UInt32 = UInt32;
UInt32.width = 32 / 8; // 4
UInt32.defaultUInt32 = new UInt32(buffer_1.Buffer.alloc(UInt32.width));
//# sourceMappingURL=uint-32.js.map

/***/ }),

/***/ 7872:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UInt64 = void 0;
const uint_1 = __nccwpck_require__(4649);
const bigInt = __nccwpck_require__(4922);
const big_integer_1 = __nccwpck_require__(4922);
const buffer_1 = __nccwpck_require__(3365);
const HEX_REGEX = /^[a-fA-F0-9]{1,16}$/;
const mask = bigInt(0x00000000ffffffff);
/**
 * Derived UInt class for serializing/deserializing 64 bit UInt
 */
class UInt64 extends uint_1.UInt {
    constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : UInt64.defaultUInt64.bytes);
    }
    static fromParser(parser) {
        return new UInt64(parser.read(UInt64.width));
    }
    /**
     * Construct a UInt64 object
     *
     * @param val A UInt64, hex-string, bigInt, or number
     * @returns A UInt64 object
     */
    static from(val) {
        if (val instanceof UInt64) {
            return val;
        }
        let buf = buffer_1.Buffer.alloc(UInt64.width);
        if (typeof val === 'number') {
            if (val < 0) {
                throw new Error('value must be an unsigned integer');
            }
            const number = bigInt(val);
            const intBuf = [buffer_1.Buffer.alloc(4), buffer_1.Buffer.alloc(4)];
            intBuf[0].writeUInt32BE(Number(number.shiftRight(32)), 0);
            intBuf[1].writeUInt32BE(Number(number.and(mask)), 0);
            return new UInt64(buffer_1.Buffer.concat(intBuf));
        }
        if (typeof val === 'string') {
            if (!HEX_REGEX.test(val)) {
                throw new Error(`${val} is not a valid hex-string`);
            }
            const strBuf = val.padStart(16, '0');
            buf = buffer_1.Buffer.from(strBuf, 'hex');
            return new UInt64(buf);
        }
        if ((0, big_integer_1.isInstance)(val)) {
            const intBuf = [buffer_1.Buffer.alloc(4), buffer_1.Buffer.alloc(4)];
            intBuf[0].writeUInt32BE(Number(val.shiftRight(bigInt(32))), 0);
            intBuf[1].writeUInt32BE(Number(val.and(mask)), 0);
            return new UInt64(buffer_1.Buffer.concat(intBuf));
        }
        throw new Error('Cannot construct UInt64 from given value');
    }
    /**
     * The JSON representation of a UInt64 object
     *
     * @returns a hex-string
     */
    toJSON() {
        return this.bytes.toString('hex').toUpperCase();
    }
    /**
     * Get the value of the UInt64
     *
     * @returns the number represented buy this.bytes
     */
    valueOf() {
        const msb = bigInt(this.bytes.slice(0, 4).readUInt32BE(0));
        const lsb = bigInt(this.bytes.slice(4).readUInt32BE(0));
        return msb.shiftLeft(bigInt(32)).or(lsb);
    }
    /**
     * Get the bytes representation of the UInt64 object
     *
     * @returns 8 bytes representing the UInt64
     */
    toBytes() {
        return this.bytes;
    }
}
exports.UInt64 = UInt64;
UInt64.width = 64 / 8; // 8
UInt64.defaultUInt64 = new UInt64(buffer_1.Buffer.alloc(UInt64.width));
//# sourceMappingURL=uint-64.js.map

/***/ }),

/***/ 7887:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UInt8 = void 0;
const uint_1 = __nccwpck_require__(4649);
const buffer_1 = __nccwpck_require__(3365);
/**
 * Derived UInt class for serializing/deserializing 8 bit UInt
 */
class UInt8 extends uint_1.UInt {
    constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : UInt8.defaultUInt8.bytes);
    }
    static fromParser(parser) {
        return new UInt8(parser.read(UInt8.width));
    }
    /**
     * Construct a UInt8 object from a number
     *
     * @param val UInt8 object or number
     */
    static from(val) {
        if (val instanceof UInt8) {
            return val;
        }
        if (typeof val === 'number') {
            const buf = buffer_1.Buffer.alloc(UInt8.width);
            buf.writeUInt8(val, 0);
            return new UInt8(buf);
        }
        throw new Error('Cannot construct UInt8 from given value');
    }
    /**
     * get the value of a UInt8 object
     *
     * @returns the number represented by this.bytes
     */
    valueOf() {
        return this.bytes.readUInt8(0);
    }
}
exports.UInt8 = UInt8;
UInt8.width = 8 / 8; // 1
UInt8.defaultUInt8 = new UInt8(buffer_1.Buffer.alloc(UInt8.width));
//# sourceMappingURL=uint-8.js.map

/***/ }),

/***/ 4649:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UInt = void 0;
const serialized_type_1 = __nccwpck_require__(2753);
/**
 * Compare numbers and bigInts n1 and n2
 *
 * @param n1 First object to compare
 * @param n2 Second object to compare
 * @returns -1, 0, or 1, depending on how the two objects compare
 */
function compare(n1, n2) {
    return n1 < n2 ? -1 : n1 == n2 ? 0 : 1;
}
/**
 * Base class for serializing and deserializing unsigned integers.
 */
class UInt extends serialized_type_1.Comparable {
    constructor(bytes) {
        super(bytes);
    }
    /**
     * Overload of compareTo for Comparable
     *
     * @param other other UInt to compare this to
     * @returns -1, 0, or 1 depending on how the objects relate to each other
     */
    compareTo(other) {
        return compare(this.valueOf(), other.valueOf());
    }
    /**
     * Convert a UInt object to JSON
     *
     * @returns number or string represented by this.bytes
     */
    toJSON() {
        const val = this.valueOf();
        return typeof val === 'number' ? val : val.toString();
    }
}
exports.UInt = UInt;
//# sourceMappingURL=uint.js.map

/***/ }),

/***/ 1196:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Vector256 = void 0;
const serialized_type_1 = __nccwpck_require__(2753);
const hash_256_1 = __nccwpck_require__(8989);
const binary_serializer_1 = __nccwpck_require__(8540);
/**
 * TypeGuard for Array<string>
 */
function isStrings(arg) {
    return Array.isArray(arg) && (arg.length === 0 || typeof arg[0] === 'string');
}
/**
 * Class for serializing and deserializing vectors of Hash256
 */
class Vector256 extends serialized_type_1.SerializedType {
    constructor(bytes) {
        super(bytes);
    }
    /**
     * Construct a Vector256 from a BinaryParser
     *
     * @param parser BinaryParser to
     * @param hint length of the vector, in bytes, optional
     * @returns a Vector256 object
     */
    static fromParser(parser, hint) {
        const bytesList = new binary_serializer_1.BytesList();
        const bytes = hint !== null && hint !== void 0 ? hint : parser.size();
        const hashes = bytes / 32;
        for (let i = 0; i < hashes; i++) {
            hash_256_1.Hash256.fromParser(parser).toBytesSink(bytesList);
        }
        return new Vector256(bytesList.toBytes());
    }
    /**
     * Construct a Vector256 object from an array of hashes
     *
     * @param value A Vector256 object or array of hex-strings representing Hash256's
     * @returns a Vector256 object
     */
    static from(value) {
        if (value instanceof Vector256) {
            return value;
        }
        if (isStrings(value)) {
            const bytesList = new binary_serializer_1.BytesList();
            value.forEach((hash) => {
                hash_256_1.Hash256.from(hash).toBytesSink(bytesList);
            });
            return new Vector256(bytesList.toBytes());
        }
        throw new Error('Cannot construct Vector256 from given value');
    }
    /**
     * Return an Array of hex-strings represented by this.bytes
     *
     * @returns An Array of strings representing the Hash256 objects
     */
    toJSON() {
        if (this.bytes.byteLength % 32 !== 0) {
            throw new Error('Invalid bytes for Vector256');
        }
        const result = [];
        for (let i = 0; i < this.bytes.byteLength; i += 32) {
            result.push(this.bytes
                .slice(i, i + 32)
                .toString('hex')
                .toUpperCase());
        }
        return result;
    }
}
exports.Vector256 = Vector256;
//# sourceMappingURL=vector-256.js.map

/***/ }),

/***/ 2457:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.XChainBridge = void 0;
const binary_parser_1 = __nccwpck_require__(8416);
const account_id_1 = __nccwpck_require__(4659);
const serialized_type_1 = __nccwpck_require__(2753);
const buffer_1 = __nccwpck_require__(3365);
const issue_1 = __nccwpck_require__(6427);
/**
 * Type guard for XChainBridgeObject
 */
function isXChainBridgeObject(arg) {
    const keys = Object.keys(arg).sort();
    return (keys.length === 4 &&
        keys[0] === 'IssuingChainDoor' &&
        keys[1] === 'IssuingChainIssue' &&
        keys[2] === 'LockingChainDoor' &&
        keys[3] === 'LockingChainIssue');
}
/**
 * Class for serializing/deserializing XChainBridges
 */
class XChainBridge extends serialized_type_1.SerializedType {
    constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : XChainBridge.ZERO_XCHAIN_BRIDGE.bytes);
    }
    /**
     * Construct a cross-chain bridge from a JSON
     *
     * @param value XChainBridge or JSON to parse into an XChainBridge
     * @returns An XChainBridge object
     */
    static from(value) {
        if (value instanceof XChainBridge) {
            return value;
        }
        if (!isXChainBridgeObject(value)) {
            throw new Error('Invalid type to construct an XChainBridge');
        }
        const bytes = [];
        this.TYPE_ORDER.forEach((item) => {
            const { name, type } = item;
            if (type === account_id_1.AccountID) {
                bytes.push(buffer_1.Buffer.from([0x14]));
            }
            const object = type.from(value[name]);
            bytes.push(object.toBytes());
        });
        return new XChainBridge(buffer_1.Buffer.concat(bytes));
    }
    /**
     * Read an XChainBridge from a BinaryParser
     *
     * @param parser BinaryParser to read the XChainBridge from
     * @returns An XChainBridge object
     */
    static fromParser(parser) {
        const bytes = [];
        this.TYPE_ORDER.forEach((item) => {
            const { type } = item;
            if (type === account_id_1.AccountID) {
                parser.skip(1);
                bytes.push(buffer_1.Buffer.from([0x14]));
            }
            const object = type.fromParser(parser);
            bytes.push(object.toBytes());
        });
        return new XChainBridge(buffer_1.Buffer.concat(bytes));
    }
    /**
     * Get the JSON representation of this XChainBridge
     *
     * @returns the JSON interpretation of this.bytes
     */
    toJSON() {
        const parser = new binary_parser_1.BinaryParser(this.toString());
        const json = {};
        XChainBridge.TYPE_ORDER.forEach((item) => {
            const { name, type } = item;
            if (type === account_id_1.AccountID) {
                parser.skip(1);
            }
            const object = type.fromParser(parser).toJSON();
            json[name] = object;
        });
        return json;
    }
}
exports.XChainBridge = XChainBridge;
XChainBridge.ZERO_XCHAIN_BRIDGE = new XChainBridge(buffer_1.Buffer.concat([
    buffer_1.Buffer.from([0x14]),
    buffer_1.Buffer.alloc(40),
    buffer_1.Buffer.from([0x14]),
    buffer_1.Buffer.alloc(40),
]));
XChainBridge.TYPE_ORDER = [
    { name: 'LockingChainDoor', type: account_id_1.AccountID },
    { name: 'LockingChainIssue', type: issue_1.Issue },
    { name: 'IssuingChainDoor', type: account_id_1.AccountID },
    { name: 'IssuingChainIssue', type: issue_1.Issue },
];
//# sourceMappingURL=xchain-bridge.js.map

/***/ }),

/***/ 2810:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HashPrefix = void 0;
var buffer_1 = __nccwpck_require__(4249);
/**
 * Write a 32 bit integer to a Buffer
 *
 * @param uint32 32 bit integer to write to buffer
 * @returns a buffer with the bytes representation of uint32
 */
function bytes(uint32) {
    var result = buffer_1.Buffer.alloc(4);
    result.writeUInt32BE(uint32, 0);
    return result;
}
/**
 * Maps HashPrefix names to their byte representation
 */
var HashPrefix = {
    transactionID: bytes(0x54584e00),
    // transaction plus metadata
    transaction: bytes(0x534e4400),
    // account state
    accountStateEntry: bytes(0x4d4c4e00),
    // inner node in tree
    innerNode: bytes(0x4d494e00),
    // ledger master data for signing
    ledgerHeader: bytes(0x4c575200),
    // inner transaction to sign
    transactionSig: bytes(0x53545800),
    // inner transaction to sign
    transactionMultiSig: bytes(0x534d5400),
    // validation for signing
    validation: bytes(0x56414c00),
    // proposal for signing
    proposal: bytes(0x50525000),
    // payment channel claim
    paymentChannelClaim: bytes(0x434c4d00),
};
exports.HashPrefix = HashPrefix;
//# sourceMappingURL=hash-prefixes.js.map

/***/ }),

/***/ 4010:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.transactionID = exports.sha512Half = exports.Sha512Half = void 0;
var hash_prefixes_1 = __nccwpck_require__(2810);
var createHash = __nccwpck_require__(3614);
var hash_256_1 = __nccwpck_require__(7801);
var binary_serializer_1 = __nccwpck_require__(5047);
var buffer_1 = __nccwpck_require__(4249);
/**
 * Class for hashing with SHA512
 * @extends BytesList So SerializedTypes can write bytes to a Sha512Half
 */
var Sha512Half = /** @class */ (function (_super) {
    __extends(Sha512Half, _super);
    function Sha512Half() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hash = createHash('sha512');
        return _this;
    }
    /**
     * Construct a new Sha512Hash and write bytes this.hash
     *
     * @param bytes bytes to write to this.hash
     * @returns the new Sha512Hash object
     */
    Sha512Half.put = function (bytes) {
        return new Sha512Half().put(bytes);
    };
    /**
     * Write bytes to an existing Sha512Hash
     *
     * @param bytes bytes to write to object
     * @returns the Sha512 object
     */
    Sha512Half.prototype.put = function (bytes) {
        this.hash.update(bytes);
        return this;
    };
    /**
     * Compute SHA512 hash and slice in half
     *
     * @returns half of a SHA512 hash
     */
    Sha512Half.prototype.finish256 = function () {
        return buffer_1.Buffer.from(this.hash.digest().slice(0, 32));
    };
    /**
     * Constructs a Hash256 from the Sha512Half object
     *
     * @returns a Hash256 object
     */
    Sha512Half.prototype.finish = function () {
        return new hash_256_1.Hash256(this.finish256());
    };
    return Sha512Half;
}(binary_serializer_1.BytesList));
exports.Sha512Half = Sha512Half;
/**
 * compute SHA512 hash of a list of bytes
 *
 * @param args zero or more arguments to hash
 * @returns the sha512half hash of the arguments.
 */
function sha512Half() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var hash = new Sha512Half();
    args.forEach(function (a) { return hash.put(a); });
    return hash.finish256();
}
exports.sha512Half = sha512Half;
/**
 * Construct a transactionID from a Serialized Transaction
 *
 * @param serialized bytes to hash
 * @returns a Hash256 object
 */
function transactionID(serialized) {
    return new hash_256_1.Hash256(sha512Half(hash_prefixes_1.HashPrefix.transactionID, serialized));
}
exports.transactionID = transactionID;
//# sourceMappingURL=hashes.js.map

/***/ }),

/***/ 5047:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BinarySerializer = exports.BytesList = void 0;
var assert = __nccwpck_require__(9491);
var buffer_1 = __nccwpck_require__(4249);
/**
 * Bytes list is a collection of buffer objects
 */
var BytesList = /** @class */ (function () {
    function BytesList() {
        this.bytesArray = [];
    }
    /**
     * Get the total number of bytes in the BytesList
     *
     * @return the number of bytes
     */
    BytesList.prototype.getLength = function () {
        return buffer_1.Buffer.concat(this.bytesArray).byteLength;
    };
    /**
     * Put bytes in the BytesList
     *
     * @param bytesArg A Buffer
     * @return this BytesList
     */
    BytesList.prototype.put = function (bytesArg) {
        var bytes = buffer_1.Buffer.from(bytesArg); // Temporary, to catch instances of Uint8Array being passed in
        this.bytesArray.push(bytes);
        return this;
    };
    /**
     * Write this BytesList to the back of another bytes list
     *
     *  @param list The BytesList to write to
     */
    BytesList.prototype.toBytesSink = function (list) {
        list.put(this.toBytes());
    };
    BytesList.prototype.toBytes = function () {
        return buffer_1.Buffer.concat(this.bytesArray);
    };
    BytesList.prototype.toHex = function () {
        return this.toBytes().toString('hex').toUpperCase();
    };
    return BytesList;
}());
exports.BytesList = BytesList;
/**
 * BinarySerializer is used to write fields and values to buffers
 */
var BinarySerializer = /** @class */ (function () {
    function BinarySerializer(sink) {
        this.sink = new BytesList();
        this.sink = sink;
    }
    /**
     * Write a value to this BinarySerializer
     *
     * @param value a SerializedType value
     */
    BinarySerializer.prototype.write = function (value) {
        value.toBytesSink(this.sink);
    };
    /**
     * Write bytes to this BinarySerializer
     *
     * @param bytes the bytes to write
     */
    BinarySerializer.prototype.put = function (bytes) {
        this.sink.put(bytes);
    };
    /**
     * Write a value of a given type to this BinarySerializer
     *
     * @param type the type to write
     * @param value a value of that type
     */
    BinarySerializer.prototype.writeType = function (type, value) {
        this.write(type.from(value));
    };
    /**
     * Write BytesList to this BinarySerializer
     *
     * @param bl BytesList to write to BinarySerializer
     */
    BinarySerializer.prototype.writeBytesList = function (bl) {
        bl.toBytesSink(this.sink);
    };
    /**
     * Calculate the header of Variable Length encoded bytes
     *
     * @param length the length of the bytes
     */
    BinarySerializer.prototype.encodeVariableLength = function (length) {
        var lenBytes = buffer_1.Buffer.alloc(3);
        if (length <= 192) {
            lenBytes[0] = length;
            return lenBytes.slice(0, 1);
        }
        else if (length <= 12480) {
            length -= 193;
            lenBytes[0] = 193 + (length >>> 8);
            lenBytes[1] = length & 0xff;
            return lenBytes.slice(0, 2);
        }
        else if (length <= 918744) {
            length -= 12481;
            lenBytes[0] = 241 + (length >>> 16);
            lenBytes[1] = (length >> 8) & 0xff;
            lenBytes[2] = length & 0xff;
            return lenBytes.slice(0, 3);
        }
        throw new Error('Overflow error');
    };
    /**
     * Write field and value to BinarySerializer
     *
     * @param field field to write to BinarySerializer
     * @param value value to write to BinarySerializer
     */
    BinarySerializer.prototype.writeFieldAndValue = function (field, value, isUnlModifyWorkaround) {
        if (isUnlModifyWorkaround === void 0) { isUnlModifyWorkaround = false; }
        var associatedValue = field.associatedType.from(value);
        assert.ok(associatedValue.toBytesSink !== undefined);
        assert.ok(field.name !== undefined);
        this.sink.put(field.header);
        if (field.isVariableLengthEncoded) {
            this.writeLengthEncoded(associatedValue, isUnlModifyWorkaround);
        }
        else {
            associatedValue.toBytesSink(this.sink);
        }
    };
    /**
     * Write a variable length encoded value to the BinarySerializer
     *
     * @param value length encoded value to write to BytesList
     */
    BinarySerializer.prototype.writeLengthEncoded = function (value, isUnlModifyWorkaround) {
        if (isUnlModifyWorkaround === void 0) { isUnlModifyWorkaround = false; }
        var bytes = new BytesList();
        if (!isUnlModifyWorkaround) {
            // this part doesn't happen for the Account field in a UNLModify transaction
            value.toBytesSink(bytes);
        }
        this.put(this.encodeVariableLength(bytes.getLength()));
        this.writeBytesList(bytes);
    };
    return BinarySerializer;
}());
exports.BinarySerializer = BinarySerializer;
//# sourceMappingURL=binary-serializer.js.map

/***/ }),

/***/ 7801:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Hash256 = void 0;
var hash_1 = __nccwpck_require__(9195);
var buffer_1 = __nccwpck_require__(4249);
/**
 * Hash with a width of 256 bits
 */
var Hash256 = /** @class */ (function (_super) {
    __extends(Hash256, _super);
    function Hash256(bytes) {
        return _super.call(this, bytes !== null && bytes !== void 0 ? bytes : Hash256.ZERO_256.bytes) || this;
    }
    Hash256.width = 32;
    Hash256.ZERO_256 = new Hash256(buffer_1.Buffer.alloc(Hash256.width));
    return Hash256;
}(hash_1.Hash));
exports.Hash256 = Hash256;
//# sourceMappingURL=hash-256.js.map

/***/ }),

/***/ 9195:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Hash = void 0;
var serialized_type_1 = __nccwpck_require__(2088);
var buffer_1 = __nccwpck_require__(4249);
/**
 * Base class defining how to encode and decode hashes
 */
var Hash = /** @class */ (function (_super) {
    __extends(Hash, _super);
    function Hash(bytes) {
        var _this = _super.call(this, bytes) || this;
        if (_this.bytes.byteLength !== _this.constructor.width) {
            throw new Error("Invalid Hash length " + _this.bytes.byteLength);
        }
        return _this;
    }
    /**
     * Construct a Hash object from an existing Hash object or a hex-string
     *
     * @param value A hash object or hex-string of a hash
     */
    Hash.from = function (value) {
        if (value instanceof this) {
            return value;
        }
        if (typeof value === 'string') {
            return new this(buffer_1.Buffer.from(value, 'hex'));
        }
        throw new Error('Cannot construct Hash from given value');
    };
    /**
     * Read a Hash object from a BinaryParser
     *
     * @param parser BinaryParser to read the hash from
     * @param hint length of the bytes to read, optional
     */
    Hash.fromParser = function (parser, hint) {
        return new this(parser.read(hint !== null && hint !== void 0 ? hint : this.width));
    };
    /**
     * Overloaded operator for comparing two hash objects
     *
     * @param other The Hash to compare this to
     */
    Hash.prototype.compareTo = function (other) {
        return this.bytes.compare(this.constructor.from(other).bytes);
    };
    /**
     * @returns the hex-string representation of this Hash
     */
    Hash.prototype.toString = function () {
        return this.toHex();
    };
    /**
     * Returns four bits at the specified depth within a hash
     *
     * @param depth The depth of the four bits
     * @returns The number represented by the four bits
     */
    Hash.prototype.nibblet = function (depth) {
        var byteIx = depth > 0 ? (depth / 2) | 0 : 0;
        var b = this.bytes[byteIx];
        if (depth % 2 === 0) {
            b = (b & 0xf0) >>> 4;
        }
        else {
            b = b & 0x0f;
        }
        return b;
    };
    return Hash;
}(serialized_type_1.Comparable));
exports.Hash = Hash;
//# sourceMappingURL=hash.js.map

/***/ }),

/***/ 2088:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Comparable = exports.SerializedType = void 0;
var binary_serializer_1 = __nccwpck_require__(5047);
var buffer_1 = __nccwpck_require__(4249);
/**
 * The base class for all binary-codec types
 */
var SerializedType = /** @class */ (function () {
    function SerializedType(bytes) {
        this.bytes = buffer_1.Buffer.alloc(0);
        this.bytes = bytes !== null && bytes !== void 0 ? bytes : buffer_1.Buffer.alloc(0);
    }
    SerializedType.fromParser = function (parser, hint) {
        throw new Error('fromParser not implemented');
        return this.fromParser(parser, hint);
    };
    SerializedType.from = function (value) {
        throw new Error('from not implemented');
        return this.from(value);
    };
    /**
     * Write the bytes representation of a SerializedType to a BytesList
     *
     * @param list The BytesList to write SerializedType bytes to
     */
    SerializedType.prototype.toBytesSink = function (list) {
        list.put(this.bytes);
    };
    /**
     * Get the hex representation of a SerializedType's bytes
     *
     * @returns hex String of this.bytes
     */
    SerializedType.prototype.toHex = function () {
        return this.toBytes().toString('hex').toUpperCase();
    };
    /**
     * Get the bytes representation of a SerializedType
     *
     * @returns A buffer of the bytes
     */
    SerializedType.prototype.toBytes = function () {
        if (this.bytes) {
            return this.bytes;
        }
        var bytes = new binary_serializer_1.BytesList();
        this.toBytesSink(bytes);
        return bytes.toBytes();
    };
    /**
     * Return the JSON representation of a SerializedType
     *
     * @returns any type, if not overloaded returns hexString representation of bytes
     */
    SerializedType.prototype.toJSON = function () {
        return this.toHex();
    };
    /**
     * @returns hexString representation of this.bytes
     */
    SerializedType.prototype.toString = function () {
        return this.toHex();
    };
    return SerializedType;
}());
exports.SerializedType = SerializedType;
/**
 * Base class for SerializedTypes that are comparable
 */
var Comparable = /** @class */ (function (_super) {
    __extends(Comparable, _super);
    function Comparable() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Comparable.prototype.lt = function (other) {
        return this.compareTo(other) < 0;
    };
    Comparable.prototype.eq = function (other) {
        return this.compareTo(other) === 0;
    };
    Comparable.prototype.gt = function (other) {
        return this.compareTo(other) > 0;
    };
    Comparable.prototype.gte = function (other) {
        return this.compareTo(other) > -1;
    };
    Comparable.prototype.lte = function (other) {
        return this.compareTo(other) < 1;
    };
    /**
     * Overload this method to define how two Comparable SerializedTypes are compared
     *
     * @param other The comparable object to compare this to
     * @returns A number denoting the relationship of this and other
     */
    Comparable.prototype.compareTo = function (other) {
        throw new Error("cannot compare " + this.toString() + " and " + other.toString());
    };
    return Comparable;
}(SerializedType));
exports.Comparable = Comparable;
//# sourceMappingURL=serialized-type.js.map

/***/ }),

/***/ 4249:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __nccwpck_require__(3325)
var ieee754 = __nccwpck_require__(2458)
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? Symbol.for('nodejs.util.inspect.custom')
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()


/***/ }),

/***/ 3907:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.XrplClient = exports.defaultEndpoints = void 0;
const assert_1 = __importDefault(__nccwpck_require__(9491));
const events_1 = __nccwpck_require__(2361);
const debug_1 = __nccwpck_require__(4085);
const websocket_1 = __nccwpck_require__(8590);
__exportStar(__nccwpck_require__(1192), exports);
const log = (0, debug_1.debug)("xrplclient");
const logWarning = log.extend("warning");
const logMessage = log.extend("message");
const logNodeInfo = log.extend("node");
const connectAttemptTimeoutSeconds = 3;
const assumeOfflineAfterSeconds = 15;
const maxConnectionAttempts = null;
const feeCushion = 1.2;
const feeDropsDefault = 12;
const feeDropsMax = 3600;
const tryAllNodes = false;
exports.defaultEndpoints = [
    "wss://xrplcluster.com",
    "wss://xrpl.link",
    "wss://s2.ripple.com",
];
const endpointParser = (endpoint) => {
    let endpoints = [];
    if (endpoint) {
        endpoints = [
            ...new Set(Array.isArray(endpoint) ? endpoint : [endpoint]),
        ]
            .map((uplink) => uplink.trim())
            .filter((uplink) => uplink.match(/^ws[s]{0,1}:\/\//));
    }
    if (endpoints.length < 1) {
        endpoints = exports.defaultEndpoints;
        logWarning("No valid WebSocket endpoint(s) specified, falling back to defaults", endpoints);
    }
    return endpoints;
};
class XrplClient extends events_1.EventEmitter {
    constructor(endpoint, options) {
        var _a;
        super();
        this.eventBus = new events_1.EventEmitter();
        this.closed = false;
        this.destroyed = false;
        this.uplinkReady = false;
        this.options = {
            connectAttemptTimeoutSeconds,
            assumeOfflineAfterSeconds,
            maxConnectionAttempts,
            feeDropsDefault,
            feeDropsMax,
            tryAllNodes,
        };
        this.callId = 0;
        this.pendingCalls = [];
        this.subscriptions = [];
        this.networkDefinitions = null;
        this.serverState = {
            validatedLedgers: "",
            reserveBase: null,
            reserveInc: null,
            latency: [],
            fee: [],
            connectAttempts: -1,
            networkId: 0,
        };
        if (options) {
            Object.assign(this.options, options);
        }
        this.endpoints = endpointParser(endpoint);
        /**
         * Alive timer
         */
        let livelinessCheck;
        const alive = () => {
            var _a;
            // log('Start alive timer')
            clearTimeout(livelinessCheck);
            const seconds = Number(((_a = this === null || this === void 0 ? void 0 : this.options) === null || _a === void 0 ? void 0 : _a.assumeOfflineAfterSeconds) || assumeOfflineAfterSeconds) * 1000;
            livelinessCheck = setTimeout(() => {
                var _a;
                // Only if the connection ever was online to begin with
                if (this.uplinkReady) {
                    logWarning(`Conn. TIMEOUT, no ledger for ${seconds} sec.`);
                    try {
                        log("Close #6");
                        (_a = this === null || this === void 0 ? void 0 : this.connection) === null || _a === void 0 ? void 0 : _a.close();
                    }
                    catch (e) { }
                }
            }, seconds);
        };
        alive();
        const reconnectTime = () => {
            var _a, _b;
            let factor = 1;
            const attempts = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.maxConnectionAttempts) || maxConnectionAttempts;
            if (attempts) {
                factor =
                    ((((_b = this.options) === null || _b === void 0 ? void 0 : _b.connectAttemptTimeoutSeconds) ||
                        connectAttemptTimeoutSeconds) -
                        1) /
                        (attempts - 1);
            }
            const reconnectSeconds = Math.max(1.5, (this.serverState.connectAttempts + 1) * factor);
            return reconnectSeconds;
        };
        this.endpoint = this.endpoints[0].trim();
        if (this.endpoints.length > 1 && !((_a = this.options) === null || _a === void 0 ? void 0 : _a.maxConnectionAttempts)) {
            log(`Multiple endpoints (${this.endpoints.length}) and no maxConnection attempts, set (3)`);
            Object.assign(this.options, { maxConnectionAttempts: 3 });
        }
        log(`Initialized xrpld WebSocket Client`);
        this.on("ledger", () => {
            connectionReady();
            alive();
        });
        const ignore = () => { };
        /**
         * Important one
         */
        const connectionReady = () => {
            if (!this.uplinkReady) {
                this.serverState.connectAttempts = 0;
                logNodeInfo("Connection ready, fire events");
                this.uplinkReady = true;
                this.eventBus.emit("flush");
                this.emit("online");
                this.emit("state", this.getState());
            }
        };
        /**
         * WebSocket client event handlers
         */
        const WsOpen = () => {
            var _a, _b, _c;
            /**
             * We're firing two commands when we're connected
             */
            if (!this.closed && ((_a = this === null || this === void 0 ? void 0 : this.connection) === null || _a === void 0 ? void 0 : _a.readyState) === websocket_1.w3cwebsocket.OPEN) {
                log("Connection opened :)");
                /**
                 * XRPL Cluster state
                 */
                if (this.endpoint.match(/^wss:\/\/(xrplcluster\.com|xrpl\.link|xrpl\.ws)/)) {
                    try {
                        (_b = this === null || this === void 0 ? void 0 : this.connection) === null || _b === void 0 ? void 0 : _b.send(JSON.stringify({ __api: "state", origin: "xrpl-client@js/ts" }));
                    }
                    catch (e) { }
                }
                /**
                 * Mandatory messages on connect
                 */
                this.send({
                    id: "_WsClient_Internal_Subscription",
                    command: "subscribe",
                    streams: ["ledger"],
                }, { sendIfNotReady: true, noReplayAfterReconnect: true }).then(ignore, ignore);
                this.send({
                    id: "_WsClient_Internal_ServerInfo@" + Number(new Date()),
                    command: "server_info",
                }, { sendIfNotReady: true, noReplayAfterReconnect: true }).then(() => {
                    connectionReady();
                }, ignore);
            }
            else {
                try {
                    log("Close #1");
                    (_c = this === null || this === void 0 ? void 0 : this.connection) === null || _c === void 0 ? void 0 : _c.close();
                }
                catch (e) {
                    // If timing: came online after close: kill
                }
            }
        };
        const WsClose = (event) => {
            this.emit("close");
            this.emit("state", this.getState());
            if (this.uplinkReady) {
                // Was online
                this.emit("offline");
                // Was online, so start a new cycle instead of trying the next node
                this.endpoint = this.endpoints[0];
            }
            this.uplinkReady = false;
            this.serverInfo = undefined;
            logWarning("Upstream/Websocket closed", event === null || event === void 0 ? void 0 : event.code, event === null || event === void 0 ? void 0 : event.reason);
            WsCleanup();
            if (!this.closed) {
                this.emit("retry");
                logWarning(`Not closed on purpose, reconnecting after ${reconnectTime()}...`);
                setTimeout(() => {
                    this.eventBus.emit("reconnect");
                }, reconnectTime() * 1000);
            }
            else {
                log("Closed on purpose, not reconnecting");
            }
        };
        const handleServerInfo = (message, returnOnly = false) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
            if ((_a = message === null || message === void 0 ? void 0 : message.result) === null || _a === void 0 ? void 0 : _a.info) {
                const serverState = returnOnly
                    ? Object.assign({}, this.serverState)
                    : this.serverState;
                const serverInfo = message;
                if (!this.serverInfo) {
                    if (!returnOnly) {
                        logNodeInfo("Connected, server_info:", {
                            pubkey_node: serverInfo.result.info.pubkey_node,
                            network_id: ((_b = serverInfo.result.info) === null || _b === void 0 ? void 0 : _b.network_id) || 0,
                            build_version: serverInfo.result.info.build_version,
                            complete_ledgers: serverInfo.result.info.complete_ledgers,
                        });
                    }
                }
                if ((_e = (_d = (_c = serverInfo === null || serverInfo === void 0 ? void 0 : serverInfo.result) === null || _c === void 0 ? void 0 : _c.info) === null || _d === void 0 ? void 0 : _d.validated_ledger) === null || _e === void 0 ? void 0 : _e.reserve_base_xrp) {
                    serverState.reserveBase =
                        Number(serverInfo.result.info.validated_ledger.reserve_base_xrp) ||
                            null;
                }
                if ((_h = (_g = (_f = serverInfo === null || serverInfo === void 0 ? void 0 : serverInfo.result) === null || _f === void 0 ? void 0 : _f.info) === null || _g === void 0 ? void 0 : _g.validated_ledger) === null || _h === void 0 ? void 0 : _h.reserve_inc_xrp) {
                    serverState.reserveInc =
                        Number(serverInfo.result.info.validated_ledger.reserve_inc_xrp) ||
                            null;
                }
                if ((_k = (_j = serverInfo === null || serverInfo === void 0 ? void 0 : serverInfo.result) === null || _j === void 0 ? void 0 : _j.info) === null || _k === void 0 ? void 0 : _k.complete_ledgers) {
                    serverState.validatedLedgers =
                        serverInfo.result.info.complete_ledgers;
                }
                if ((_l = serverInfo === null || serverInfo === void 0 ? void 0 : serverInfo.result) === null || _l === void 0 ? void 0 : _l.info) {
                    serverState.networkId = serverInfo.result.info.network_id || 0;
                }
                const msRoundTrip = Number(new Date()) -
                    Number(String((message === null || message === void 0 ? void 0 : message.id) || "")
                        .split("@")
                        .reverse()[0]);
                if (msRoundTrip) {
                    serverState.latency.push({
                        moment: new Date(),
                        value: msRoundTrip,
                    });
                    serverState.latency.splice(0, serverState.latency.length - 10);
                }
                const fee = Number(((_o = (_m = serverInfo.result.info) === null || _m === void 0 ? void 0 : _m.validated_ledger) === null || _o === void 0 ? void 0 : _o.base_fee_xrp) ||
                    (this.options.feeDropsDefault || feeDropsDefault) / 1000000) *
                    1000000 *
                    feeCushion;
                if (fee && fee <= (this.options.feeDropsMax || feeDropsMax)) {
                    serverState.fee.push({
                        moment: new Date(),
                        value: fee,
                    });
                    serverState.fee.splice(0, serverState.fee.length - 5);
                }
                if (!returnOnly) {
                    this.serverInfo = serverInfo;
                }
                else {
                    return { serverInfo, serverState };
                }
            }
        };
        const handleAsyncWsMessage = (message) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            if (((_a = message === null || message === void 0 ? void 0 : message.id) === null || _a === void 0 ? void 0 : _a._Request) !== "_WsClient_Internal_Subscription") {
                let matchingSubscription;
                if ((_b = message === null || message === void 0 ? void 0 : message.id) === null || _b === void 0 ? void 0 : _b._WsClient) {
                    const _matching = this.subscriptions.filter((s) => { var _a; return s.id === ((_a = message === null || message === void 0 ? void 0 : message.id) === null || _a === void 0 ? void 0 : _a._WsClient); });
                    if (_matching.length > 0) {
                        matchingSubscription = _matching[0];
                        matchingSubscription.promiseCallables.resolve(Object.assign(message, {
                            id: (_c = message === null || message === void 0 ? void 0 : message.id) === null || _c === void 0 ? void 0 : _c._Request,
                        }));
                    }
                }
                this.emit("message", message);
                if ((message === null || message === void 0 ? void 0 : message.type) === "ledgerClosed" &&
                    typeof (message === null || message === void 0 ? void 0 : message.validated_ledgers) === "string") {
                    logMessage("Async", message.type);
                    Object.assign(this.serverState, {
                        validatedLedgers: message.validated_ledgers,
                        reserveBase: Number(message === null || message === void 0 ? void 0 : message.reserve_base) / 1000000 || null,
                        reserveInc: Number(message === null || message === void 0 ? void 0 : message.reserve_inc) / 1000000 || null,
                    });
                    this.emit("ledger", message);
                    /**
                     * Always request a server_info for a received ledger as well
                     */
                    this.send({
                        id: "_WsClient_Internal_ServerInfo@" + Number(new Date()),
                        command: "server_info",
                    }).then(ignore, ignore);
                }
                else if ((message === null || message === void 0 ? void 0 : message.type) === "path_find") {
                    logMessage("Async", message.type);
                    this.emit("path", message);
                }
                else if ((message === null || message === void 0 ? void 0 : message.type) === "transaction") {
                    logMessage("Async", message.type);
                    this.emit("transaction", message);
                }
                else if (message === null || message === void 0 ? void 0 : message.validation_public_key) {
                    logMessage("Async", "validation");
                    this.emit("validation", message);
                }
                else {
                    if (((_d = matchingSubscription === null || matchingSubscription === void 0 ? void 0 : matchingSubscription.request) === null || _d === void 0 ? void 0 : _d.command) === "path_find") {
                        logMessage("Async", (_e = matchingSubscription === null || matchingSubscription === void 0 ? void 0 : matchingSubscription.request) === null || _e === void 0 ? void 0 : _e.command);
                        this.emit("path", message);
                    }
                    else if (((_f = matchingSubscription === null || matchingSubscription === void 0 ? void 0 : matchingSubscription.request) === null || _f === void 0 ? void 0 : _f.command) === "subscribe" &&
                        Array.isArray((_g = matchingSubscription === null || matchingSubscription === void 0 ? void 0 : matchingSubscription.request) === null || _g === void 0 ? void 0 : _g.streams) &&
                        ((_h = matchingSubscription === null || matchingSubscription === void 0 ? void 0 : matchingSubscription.request) === null || _h === void 0 ? void 0 : _h.streams.indexOf("ledger")) > -1) {
                        logMessage("Async", "subscription:ledger");
                        this.emit("ledger", (message === null || message === void 0 ? void 0 : message.result) ? message.result : message);
                    }
                    else if (matchingSubscription) {
                        // Don't log `Unknown` as we know this
                    }
                    else {
                        const isInternal = ((_j = message === null || message === void 0 ? void 0 : message.id) === null || _j === void 0 ? void 0 : _j._Request) &&
                            String(message.id._Request).match(/^_WsClient_Internal/);
                        if (!isInternal) {
                            try {
                                const clusterInfo = message;
                                if ((clusterInfo === null || clusterInfo === void 0 ? void 0 : clusterInfo.type) === "PROXY") {
                                    this.clusterInfo_ = clusterInfo;
                                    this.emit("clusterinfo", this.clusterInfo_);
                                    return;
                                }
                            }
                            catch (e) { }
                            logMessage(`Handle <UNKNOWN> Async Message`, {
                                internalId: (_k = message === null || message === void 0 ? void 0 : message.id) === null || _k === void 0 ? void 0 : _k._WsClient,
                                matchingSubscription,
                                type: message === null || message === void 0 ? void 0 : message.type,
                                message,
                            });
                        }
                    }
                }
            }
        };
        const WsMessage = (message) => {
            var _a, _b, _c, _d, _e, _f;
            try {
                (0, assert_1.default)(typeof message.data === "string", "Unexpected incoming WebSocket message data type");
                const messageJson = JSON.parse(message.data);
                this.lastContact = new Date();
                if ((_a = messageJson === null || messageJson === void 0 ? void 0 : messageJson.id) === null || _a === void 0 ? void 0 : _a._WsClient) {
                    // Got response on a command, process accordingly
                    const matchingSubscription = this.subscriptions.filter((call) => {
                        var _a;
                        return call.id === ((_a = messageJson === null || messageJson === void 0 ? void 0 : messageJson.id) === null || _a === void 0 ? void 0 : _a._WsClient);
                    });
                    const matchingCall = this.pendingCalls.filter((call) => {
                        var _a;
                        return call.id === ((_a = messageJson === null || messageJson === void 0 ? void 0 : messageJson.id) === null || _a === void 0 ? void 0 : _a._WsClient);
                    });
                    if (matchingSubscription.length === 1) {
                        handleAsyncWsMessage(messageJson);
                    }
                    else if (matchingCall.length === 1) {
                        const internalServerInfoCall = String(((_d = (_c = (_b = matchingCall[0]) === null || _b === void 0 ? void 0 : _b.request) === null || _c === void 0 ? void 0 : _c.id) === null || _d === void 0 ? void 0 : _d._Request) || "").split("@")[0] === "_WsClient_Internal_ServerInfo";
                        Object.assign(messageJson, {
                            id: (_e = messageJson === null || messageJson === void 0 ? void 0 : messageJson.id) === null || _e === void 0 ? void 0 : _e._Request,
                        });
                        if (((_f = matchingCall[0].sendOptions) === null || _f === void 0 ? void 0 : _f.timeoutSeconds) &&
                            matchingCall[0].timeout) {
                            clearTimeout(matchingCall[0].timeout);
                        }
                        matchingCall[0].promiseCallables.resolve((messageJson === null || messageJson === void 0 ? void 0 : messageJson.result) || messageJson);
                        this.pendingCalls.splice(this.pendingCalls.indexOf(matchingCall[0]), 1);
                        if (!internalServerInfoCall) {
                            log("» Pending Call Length", this.pendingCalls.length);
                        }
                        else {
                            handleServerInfo(messageJson);
                        }
                    }
                    else {
                        // Subscription/path finding ack
                        handleAsyncWsMessage(messageJson);
                    }
                }
                else {
                    // Subscription/path finding followup
                    handleAsyncWsMessage(messageJson);
                }
            }
            catch (e) {
                logWarning("Uplink response: parse error", e.message);
            }
        };
        const WsError = (error) => {
            logWarning("Upstream/Websocket error");
        };
        const applyCallTimeout = (call) => {
            var _a;
            if (((_a = call === null || call === void 0 ? void 0 : call.sendOptions) === null || _a === void 0 ? void 0 : _a.timeoutSeconds) && !(call === null || call === void 0 ? void 0 : call.timeout)) {
                Object.assign(call, {
                    timeout: setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                        var _b;
                        const didTimeout = (yield Promise.race([
                            call.promise,
                            Promise.resolve("_WsClient_Internal_CallResolved"),
                        ])) === "_WsClient_Internal_CallResolved";
                        if (didTimeout) {
                            call.promiseCallables.reject(new Error(`Call timeout after ${(_b = call.sendOptions) === null || _b === void 0 ? void 0 : _b.timeoutSeconds} seconds`));
                        }
                    }), Number(call.sendOptions.timeoutSeconds) * 1000),
                });
            }
        };
        const process = (call) => {
            var _a, _b, _c, _d;
            // const isSubscription = call.request.command === "subscribe";
            if (String(((_b = (_a = call === null || call === void 0 ? void 0 : call.request) === null || _a === void 0 ? void 0 : _a.id) === null || _b === void 0 ? void 0 : _b._Request) || "").split("@")[0] !==
                "_WsClient_Internal_ServerInfo") {
                log("  > Process call", call.id, call.request.command);
            }
            try {
                // log(call.request);
                (_c = this === null || this === void 0 ? void 0 : this.connection) === null || _c === void 0 ? void 0 : _c.send(JSON.stringify(call.request));
                if ((_d = call === null || call === void 0 ? void 0 : call.sendOptions) === null || _d === void 0 ? void 0 : _d.timeoutStartsWhenOnline) {
                    // logWarning("APPLY TIMEOUT ONLY AFTER GOING ONLINE");
                    applyCallTimeout(call);
                }
            }
            catch (e) {
                logWarning("Process (send to uplink) error", e.message);
            }
        };
        const call = (call) => {
            var _a, _b, _c, _d, _e;
            if (String(((_b = (_a = call === null || call === void 0 ? void 0 : call.request) === null || _a === void 0 ? void 0 : _a.id) === null || _b === void 0 ? void 0 : _b._Request) || "").split("@")[0] !==
                "_WsClient_Internal_ServerInfo") {
                log(`Call ${call.id}: ${call.request.command}\n   > `, this.uplinkReady
                    ? "Uplink ready, pass immediately"
                    : ((_c = call === null || call === void 0 ? void 0 : call.sendOptions) === null || _c === void 0 ? void 0 : _c.sendIfNotReady)
                        ? "Uplink not flagged as ready yet, but `sendIfNotReady` = true, so go ahead"
                        : "Uplink not ready, wait for flush");
            }
            if (!((_d = call === null || call === void 0 ? void 0 : call.sendOptions) === null || _d === void 0 ? void 0 : _d.timeoutStartsWhenOnline)) {
                // logWarning("APPLY TIMEOUT NO MATTER ONLINE/OFFLINE STATE");
                applyCallTimeout(call);
            }
            if (this.uplinkReady || ((_e = call === null || call === void 0 ? void 0 : call.sendOptions) === null || _e === void 0 ? void 0 : _e.sendIfNotReady)) {
                process(call);
            }
        };
        const flush = () => {
            /**
             * Flush all pending calls & subscriptions
             * to new uplink.
             */
            log("Connected, flushing pending calls & subscriptions");
            this.pendingCalls.forEach((call) => {
                process(call);
            });
            this.subscriptions.forEach((call) => {
                process(call);
            });
        };
        const reinstate = (options) => {
            (0, assert_1.default)(!this.destroyed, "Object is in destroyed state");
            log("Reinstating..., options:", options || {});
            if (options === null || options === void 0 ? void 0 : options.forceNextUplink) {
                this.uplinkReady = false; // Prevents going back to endpoint[0]
                clearTimeout(livelinessCheck);
                selectNextUplink();
            }
            else {
                this.closed = false;
                alive();
            }
            connect();
        };
        const close = (error) => {
            var _a;
            log("Closing connection");
            this.emit("close");
            this.closed = true;
            try {
                log("Close #2");
                (_a = this === null || this === void 0 ? void 0 : this.connection) === null || _a === void 0 ? void 0 : _a.close();
            }
            catch (e) {
                //
            }
            clearTimeout(livelinessCheck);
            if (error) {
                this.emit("error", error);
            }
        };
        const destroy = (error) => {
            this.destroyed = true;
            close(error);
            WsCleanup();
            this.subscriptions.forEach((subscription) => {
                subscription.promiseCallables.reject(new Error("Class (connection) hard close requested"));
            });
            this.pendingCalls.forEach((call) => {
                call.promiseCallables.reject(new Error("Class (connection) hard close requested"));
            });
            this.eventBus.off("__WsClient_call", call);
            this.eventBus.off("__WsClient_destroy", destroy);
            this.eventBus.off("__WsClient_close", close);
            this.eventBus.off("__WsClient_reinstate", reinstate);
            this.eventBus.off("flush", flush);
            this.eventBus.off("reconnect", connect);
        };
        const WsCleanup = () => {
            var _a, _b, _c, _d;
            log("Cleanup");
            (_a = this === null || this === void 0 ? void 0 : this.connection) === null || _a === void 0 ? void 0 : _a.removeEventListener("open", WsOpen);
            (_b = this === null || this === void 0 ? void 0 : this.connection) === null || _b === void 0 ? void 0 : _b.removeEventListener("message", WsMessage);
            (_c = this === null || this === void 0 ? void 0 : this.connection) === null || _c === void 0 ? void 0 : _c.removeEventListener("error", WsError);
            (_d = this === null || this === void 0 ? void 0 : this.connection) === null || _d === void 0 ? void 0 : _d.removeEventListener("close", WsClose);
        };
        const selectNextUplink = () => {
            const nextEndpointIndex = this.endpoints.indexOf(this.endpoint) + 1;
            logWarning("--- Current endpoint", this.endpoint);
            this.endpoint =
                this.endpoints[nextEndpointIndex >= this.endpoints.length ? 0 : nextEndpointIndex];
            logWarning("--- New endpoint", this.endpoint);
            this.serverState.connectAttempts = 0;
            this.emit("nodeswitch", this.endpoint);
            if (nextEndpointIndex >= this.endpoints.length) {
                this.emit("round");
            }
        };
        const connect = () => {
            var _a, _b, _c, _d;
            try {
                log("Close #3");
                WsCleanup();
                (_a = this === null || this === void 0 ? void 0 : this.connection) === null || _a === void 0 ? void 0 : _a.close();
            }
            catch (e) {
                //
            }
            log("connect()", this.endpoint);
            this.serverState.connectAttempts++;
            if (this.options.maxConnectionAttempts &&
                Number(((_b = this.options) === null || _b === void 0 ? void 0 : _b.maxConnectionAttempts) || 1) > 1 &&
                this.serverState.connectAttempts >=
                    Number(((_c = this.options) === null || _c === void 0 ? void 0 : _c.maxConnectionAttempts) || 1)) {
                logNodeInfo("Too many connection attempts", this.serverState.connectAttempts, (_d = this.options) === null || _d === void 0 ? void 0 : _d.maxConnectionAttempts);
                log(this.endpoint, this.endpoints, this.endpoints.length, this.endpoints.indexOf(this.endpoint));
                if (this.endpoints.length > 1 &&
                    this.endpoints.indexOf(this.endpoint) > -1) {
                    logWarning("Multiple endpoints, max. connection attempts exceeded. Switch endpoint.");
                    selectNextUplink();
                }
                else {
                    logWarning("Only one valid endpoint, after the max. connection attempts: game over");
                    close(new Error("Max. connection attempts exceeded"));
                }
            }
            if (!this.closed) {
                if (this.options.tryAllNodes) {
                    logWarning("!!!".repeat(30) +
                        "\n!!!\n!!!    Trying all nodes. WARNING! IF YOU DO NOT EXPLICITLY NEED THIS,\n!!!    DO NOT USE THE `tryAllNodes` OPTION (to prevent wasting resources)\n!!!\n" +
                        "!!!".repeat(30) +
                        "\n");
                }
                const allEndpoints = (this.options.tryAllNodes ? this.endpoints : [this.endpoint]).map((endpoint) => {
                    var _a, _b;
                    log("Connecting", endpoint);
                    /**
                     * Alternative WebSocket implementation here for Bun:
                     * Postprocessed in npm build cli
                     */
                    let WssClient = typeof WebSocket !== 'undefined' ? WebSocket : websocket_1.w3cwebsocket
                    if (true) {
                      try {
                        WssClient = (__nccwpck_require__(6036)["default"])
                      } catch (e) {}
                    }
                    const connection = new (typeof WssClient !== typeof _NA_ ? WssClient : websocket_1.w3cwebsocket)(endpoint, // url
                    [], // protocols - must be array instead of undefined to make Chrome+Caddy work
                    undefined, // origin
                    Object.assign(((_a = this.options) === null || _a === void 0 ? void 0 : _a.httpHeaders) || {}, {
                        "user-agent": "xrpl-client@js/ts",
                    }), // headers
                    ((_b = this.options) === null || _b === void 0 ? void 0 : _b.httpRequestOptions) || {}, // requestOptions
                    {
                        maxReceivedFrameSize: 0x80000000,
                        maxReceivedMessageSize: 0x200000000, // 8GB
                    } // IClientConfig
                    );
                    // Prevent possible DNS resolve hang, and a custom
                    // resolver sucks
                    setTimeout(() => {
                        var _a;
                        if (connection.readyState !== websocket_1.w3cwebsocket.OPEN &&
                            ((_a = this.connection) === null || _a === void 0 ? void 0 : _a.readyState) !== websocket_1.w3cwebsocket.OPEN) {
                            log("Close #4 -- FORCED, inner connection timeout");
                            connection.close();
                            if (this.options.tryAllNodes) {
                                /**
                                 * Just do this once per X interval, instead of per connection.
                                 * We don't want all simultaneous connections to fire this and
                                 * kick off a fork (connection) bomb, so assuming they all
                                 * got tried if we're here, only fire reconnet for the very first
                                 * endpoint (as it'll make them all reconnect).
                                 */
                                if (this.endpoints.indexOf(endpoint) === 0) {
                                    this.eventBus.emit("reconnect");
                                }
                            }
                            else {
                                this.eventBus.emit("reconnect");
                            }
                        }
                    }, reconnectTime() * 1000 - 1);
                    const raceOpenHandler = () => {
                        log("OPEN", endpoint);
                        connection.send(JSON.stringify({ command: "server_info" }));
                    };
                    const raceMessageHandler = (message) => {
                        var _a;
                        (0, assert_1.default)(typeof message.data === "string", "Unexpected incoming WebSocket message data type");
                        const messageJson = JSON.parse(message.data);
                        const handledServerInfo = handleServerInfo(messageJson, true);
                        if (handledServerInfo) {
                            const serverState = this.getState(handledServerInfo.serverState);
                            if (typeof serverState.ledger.last === "number" &&
                                (Number(serverState.ledger.count || 0) || 0) > 0) {
                                // This one is first & sane
                                logNodeInfo("Race won by endpoint:", {
                                    endpoint,
                                    build_version: handledServerInfo.serverInfo.result.info.build_version,
                                    complete_ledgers: handledServerInfo.serverInfo.result.info.complete_ledgers,
                                    pubkey_node: handledServerInfo.serverInfo.result.info.pubkey_node,
                                    network_id: ((_a = handledServerInfo.serverInfo.result.info) === null || _a === void 0 ? void 0 : _a.network_id) || 0,
                                });
                                // this.options.tryAllNodes = false;
                                this.connection = connection;
                                this.endpoint = endpoint;
                                WsOpen();
                                WsMessage(message);
                                allEndpoints.forEach((iConnection) => {
                                    iConnection === null || iConnection === void 0 ? void 0 : iConnection.removeEventListener("open", raceOpenHandler);
                                    iConnection === null || iConnection === void 0 ? void 0 : iConnection.removeEventListener("message", raceMessageHandler);
                                    if (iConnection != connection) {
                                        log("Close #5");
                                        iConnection.close();
                                        logNodeInfo("Cleanup: closing connection & clearing event listeners for lost race connection", iConnection.url);
                                    }
                                    else {
                                        logNodeInfo("Cleanup: cleared event listeners for winning node", iConnection.url);
                                    }
                                });
                                if (!this.destroyed) {
                                    connection === null || connection === void 0 ? void 0 : connection.addEventListener("open", WsOpen);
                                    connection === null || connection === void 0 ? void 0 : connection.addEventListener("message", WsMessage);
                                    connection === null || connection === void 0 ? void 0 : connection.addEventListener("error", WsError);
                                    connection === null || connection === void 0 ? void 0 : connection.addEventListener("close", WsClose);
                                }
                            }
                        }
                    };
                    if (!this.destroyed) {
                        connection === null || connection === void 0 ? void 0 : connection.addEventListener("open", raceOpenHandler);
                        connection === null || connection === void 0 ? void 0 : connection.addEventListener("message", raceMessageHandler);
                    }
                    return connection;
                });
            }
            return this === null || this === void 0 ? void 0 : this.connection;
        };
        this.eventBus.on("__WsClient_call", call);
        this.eventBus.on("__WsClient_destroy", destroy);
        this.eventBus.on("__WsClient_close", close);
        this.eventBus.on("__WsClient_reinstate", reinstate);
        this.eventBus.on("flush", flush);
        this.eventBus.on("reconnect", connect);
        connect();
    }
    ready() {
        return new Promise((resolve, reject) => {
            const state = this.getState();
            if (state.online &&
                state.secLastContact &&
                state.secLastContact < 10 &&
                state.ledger.last) {
                // We're good
                return resolve(this);
            }
            else {
                // Let's wait to make sure we're really connected
                this.on("ledger", () => {
                    resolve(this);
                });
            }
        });
    }
    definitions() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // null if not checked before
            if (this.networkDefinitions === null) {
                yield this.ready();
                const definitions = yield this.send({ command: "server_definitions" });
                if (typeof (definitions === null || definitions === void 0 ? void 0 : definitions.FIELDS) === "object") {
                    this.networkDefinitions = definitions;
                    return this.networkDefinitions;
                }
                // Error, no definitions command, fallback to defaults
                if ((typeof (definitions === null || definitions === void 0 ? void 0 : definitions.status) === "string" &&
                    definitions.status.match(/error/i)) ||
                    (typeof (definitions === null || definitions === void 0 ? void 0 : definitions.error) === "string" &&
                        definitions.error.match(/unknown/i))) {
                    this.networkDefinitions = {};
                }
            }
            // return null if {} (empty object) to fall back to defaults;
            // null internally (property) means unfetched, null externally
            // means fall back to defaults.
            return typeof ((_a = this.networkDefinitions) === null || _a === void 0 ? void 0 : _a.FIELDS) === "object"
                ? this.networkDefinitions
                : null;
        });
    }
    send(call, sendOptions = {}) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const _call = Object.assign({}, call);
            (0, assert_1.default)(typeof _call === "object" && _call, "`send()`: expecting object containing `command`");
            (0, assert_1.default)(typeof _call.command === "string", "`command` must be typeof string");
            this.callId++;
            const promiseCallables = {
                resolve: (arg) => { },
                reject: (arg) => { },
            };
            const promise = new Promise((resolve, reject) => {
                Object.assign(promiseCallables, {
                    resolve: (arg) => {
                        Object.defineProperty(arg, 'id', {
                            enumerable: false,
                            writable: false,
                            value: call === null || call === void 0 ? void 0 : call.id,
                        });
                        return resolve(arg);
                    },
                    reject,
                });
            });
            const pendingCall = {
                id: this.callId,
                request: Object.assign(_call, {
                    id: {
                        _WsClient: this.callId,
                        _Request: _call === null || _call === void 0 ? void 0 : _call.id,
                    },
                    command: _call.command.toLowerCase().trim(),
                }),
                promise,
                promiseCallables,
                sendOptions,
            };
            if (this.destroyed) {
                promiseCallables.reject(new Error("Client in destroyed state"));
                return promise;
            }
            const isSubscription = (pendingCall.request.command === "subscribe" ||
                pendingCall.request.command === "unsubscribe" ||
                pendingCall.request.command === "path_find") &&
                !(sendOptions === null || sendOptions === void 0 ? void 0 : sendOptions.noReplayAfterReconnect);
            if (((_a = pendingCall.request) === null || _a === void 0 ? void 0 : _a.command) === "unsubscribe" &&
                Array.isArray((_b = pendingCall.request) === null || _b === void 0 ? void 0 : _b.streams) &&
                ((_c = pendingCall.request) === null || _c === void 0 ? void 0 : _c.streams.indexOf("ledger")) > -1) {
                pendingCall.request.streams.splice(pendingCall.request.streams.indexOf("ledger"), 1);
                if (pendingCall.request.streams.length === 0 &&
                    Object.keys(pendingCall.request).filter((key) => key !== "id" && key !== "streams" && key !== "command").length === 0) {
                    // Unsubscribing (just) streams
                    return Promise.reject(new Error("Unsubscribing from (just) the ledger stream is not allowed"));
                }
            }
            if (String((_call === null || _call === void 0 ? void 0 : _call.id) || "").split("@")[0] !== "_WsClient_Internal_ServerInfo") {
                this[isSubscription ? "subscriptions" : "pendingCalls"].push(pendingCall);
            }
            this.eventBus.emit("__WsClient_call", pendingCall);
            return promise;
        });
    }
    getState(forcedServerState) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const serverState = forcedServerState
            ? forcedServerState
            : this.serverState;
        const ledgerCount = serverState.validatedLedgers
            .split(",")
            .map((m) => {
            const Range = m.split("-");
            return Range.length > 1 ? parseInt(Range[1]) - parseInt(Range[0]) : 1;
        })
            .reduce((a, b) => a + b, 0);
        return {
            online: this.uplinkReady &&
                !this.closed &&
                ((_a = this === null || this === void 0 ? void 0 : this.connection) === null || _a === void 0 ? void 0 : _a.readyState) === websocket_1.w3cwebsocket.OPEN,
            latencyMs: {
                last: serverState.latency
                    .slice(-1)
                    .map((latencyRecord) => latencyRecord.value)[0] || null,
                avg: serverState.latency
                    .map((latencyRecord) => latencyRecord.value)
                    .reduce((a, b) => a + b, 0) / serverState.latency.length || null,
                secAgo: Number(new Date()) / 1000 -
                    serverState.latency
                        .slice(-1)
                        .map((latencyRecord) => Number(latencyRecord.moment) / 1000)[0] ||
                    null,
            },
            server: {
                version: ((_d = (_c = (_b = this.serverInfo) === null || _b === void 0 ? void 0 : _b.result) === null || _c === void 0 ? void 0 : _c.info) === null || _d === void 0 ? void 0 : _d.build_version) || "",
                uptime: ((_g = (_f = (_e = this.serverInfo) === null || _e === void 0 ? void 0 : _e.result) === null || _f === void 0 ? void 0 : _f.info) === null || _g === void 0 ? void 0 : _g.uptime) || 0,
                publicKey: ((_k = (_j = (_h = this.serverInfo) === null || _h === void 0 ? void 0 : _h.result) === null || _j === void 0 ? void 0 : _j.info) === null || _k === void 0 ? void 0 : _k.pubkey_node) || "",
                networkId: ((_o = (_m = (_l = this.serverInfo) === null || _l === void 0 ? void 0 : _l.result) === null || _m === void 0 ? void 0 : _m.info) === null || _o === void 0 ? void 0 : _o.network_id) || 0,
                uri: this.endpoint,
            },
            ledger: {
                last: Number(serverState.validatedLedgers
                    .split(",")
                    .reverse()[0]
                    .split("-")
                    .reverse()[0]),
                validated: serverState.validatedLedgers,
                count: serverState.validatedLedgers === "" ? 0 : ledgerCount,
            },
            fee: {
                last: serverState.fee.slice(-1).map((feeRecord) => feeRecord.value)[0] ||
                    this.options.feeDropsDefault ||
                    feeDropsDefault,
                avg: serverState.fee
                    .map((feeRecord) => feeRecord.value)
                    .reduce((a, b) => a + b, 0) / serverState.fee.length ||
                    this.options.feeDropsDefault ||
                    feeDropsDefault,
                secAgo: Number(new Date()) / 1000 -
                    serverState.fee
                        .slice(-1)
                        .map((feeRecord) => Number(feeRecord.moment) / 1000)[0] || null,
            },
            reserve: {
                base: serverState.reserveBase,
                owner: serverState.reserveInc,
            },
            secLastContact: this.lastContact
                ? Number(new Date()) / 1000 - Number(this.lastContact) / 1000
                : null,
        };
    }
    close() {
        // assert(!this.closed, "Object already in closed state");
        log(`> CLOSE`);
        this.eventBus.emit("__WsClient_close");
    }
    reinstate(options) {
        // assert(!this.closed, "Object already reinstated state");
        log(`> REINSTATE`);
        this.eventBus.emit("__WsClient_reinstate", options);
    }
    destroy() {
        // assert(!this.closed, "Object already in destroyed state");
        log(`> DESTROY`);
        this.eventBus.emit("__WsClient_destroy");
    }
    clusterInfo() {
        return new Promise((resolve, reject) => {
            if (this.clusterInfo_) {
                // We're good
                return resolve(this.clusterInfo_);
            }
            else {
                // Let's wait to make sure we're really connected
                this.on("clusterinfo", (info) => {
                    resolve(info);
                });
            }
        });
    }
}
exports.XrplClient = XrplClient;


/***/ }),

/***/ 1192:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 8030:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Utils = exports.Account = void 0;
/* Methods  ==================================================================== */
var Utils = __importStar(__nccwpck_require__(1401));
exports.Utils = Utils;
/* Types ==================================================================== */
var Account_1 = __importDefault(__nccwpck_require__(8548));
exports.Account = Account_1.default;


/***/ }),

/***/ 8548:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var assert_1 = __importDefault(__nccwpck_require__(9491));
var keypairs = __importStar(__nccwpck_require__(8150));
var utils = __importStar(__nccwpck_require__(1401));
/* Class ==================================================================== */
var Account = /** @class */ (function () {
    function Account(SecretNumbers) {
        var _this = this;
        this.account = {
            familySeed: '',
            address: '',
            keypair: {
                publicKey: '',
                privateKey: ''
            }
        };
        var asserts = function () {
            assert_1.default.strictEqual(_this.secret.length, 8);
            _this.secret.forEach(function (r, i) {
                assert_1.default.strictEqual(r.length, 6);
            });
        };
        var derive = function () {
            try {
                var entropy = utils.secretToEntropy(_this.secret);
                _this.account.familySeed = keypairs.generateSeed({ entropy: entropy });
                _this.account.keypair = keypairs.deriveKeypair(_this.account.familySeed);
                _this.account.address = keypairs.deriveAddress(_this.account.keypair.publicKey);
            }
            catch (e) {
                throw e.message;
            }
        };
        if (typeof SecretNumbers === 'string') {
            this.secret = utils.parseSecretString(SecretNumbers);
        }
        else if (Array.isArray(SecretNumbers)) {
            this.secret = SecretNumbers;
        }
        else if (Buffer.isBuffer(SecretNumbers)) {
            this.secret = utils.entropyToSecret(SecretNumbers);
        }
        else {
            this.secret = utils.randomSecret();
        }
        asserts();
        derive();
    }
    Account.prototype.getSecret = function () {
        return this.secret;
    };
    Account.prototype.getSecretString = function () {
        return this.secret.join(' ');
    };
    Account.prototype.getAddress = function () {
        return this.account.address;
    };
    Account.prototype.getFamilySeed = function () {
        return this.account.familySeed;
    };
    Account.prototype.getKeypair = function () {
        return this.account.keypair;
    };
    Account.prototype.toString = function () {
        return this.getSecretString();
    };
    return Account;
}());
exports["default"] = Account;


/***/ }),

/***/ 1401:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseSecretString = exports.checkChecksum = exports.calculateChecksum = exports.secretToEntropy = exports.entropyToSecret = exports.randomSecret = exports.randomEntropy = void 0;
var assert_1 = __importDefault(__nccwpck_require__(9491));
var brorand_1 = __importDefault(__nccwpck_require__(3803));
function randomEntropy() {
    return Buffer.from(brorand_1.default(16));
}
exports.randomEntropy = randomEntropy;
function calculateChecksum(position, value) {
    return value * (position * 2 + 1) % 9;
}
exports.calculateChecksum = calculateChecksum;
function checkChecksum(position, value, checksum) {
    if (typeof value === 'string') {
        assert_1.default.strictEqual(value.length, 6);
        checksum = parseInt(value.slice(5), 10);
        value = parseInt(value.slice(0, 5), 10);
    }
    return value * (position * 2 + 1) % 9 === checksum;
}
exports.checkChecksum = checkChecksum;
function entropyToSecret(entropy) {
    var length = Array(Math.ceil(entropy.length / 2));
    var chunks = Array.apply(null, length).map(function (a, b) {
        return entropy.slice(b * 2, ++b * 2);
    }).map(function (r, i) {
        var no = parseInt(r.toString('hex'), 16);
        var fill = '0'.repeat(5 - String(no).length);
        return fill + String(no) + String(calculateChecksum(i, no));
    });
    assert_1.default.equal(chunks.length, 8);
    return chunks;
}
exports.entropyToSecret = entropyToSecret;
function randomSecret() {
    return entropyToSecret(randomEntropy());
}
exports.randomSecret = randomSecret;
function secretToEntropy(secret) {
    return Buffer.concat(secret.map(function (r, i) {
        var no = Number(r.slice(0, 5));
        var checksum = Number(r.slice(5));
        try {
            assert_1.default.strictEqual(r.length, 6);
        }
        catch (e) {
            throw new Error('Invalid secret: number invalid');
        }
        try {
            assert_1.default.strictEqual(checkChecksum(i, no, checksum), true);
        }
        catch (e) {
            throw new Error('Invalid secret part: checksum invalid');
        }
        var hex = ('0000' + no.toString(16)).slice(-4);
        return Buffer.from(hex, 'hex');
    }));
}
exports.secretToEntropy = secretToEntropy;
function parseSecretString(secret) {
    secret = secret.replace(/[^0-9]/g, '');
    if (secret.length !== 48) {
        throw new Error('Invalid secret string (should contain 8 blocks of 6 digits');
    }
    return Array.apply(null, Array(8)).map(function (a, i) {
        return secret.slice(i * 6, (i + 1) * 6);
    });
}
exports.parseSecretString = parseSecretString;


/***/ }),

/***/ 2481:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
 // eslint-disable-line strict

module.exports = __nccwpck_require__(1883)


/***/ }),

/***/ 1883:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const keypairs = __nccwpck_require__(8150)
const {
  encodeForMultisigning,
  encodeForSigning,
  encode,
} = __nccwpck_require__(305)
const hashes = __nccwpck_require__(9698)
const hashprefixes = __nccwpck_require__(745)
const sortSigners = __nccwpck_require__(4481)

const computeBinaryTransactionHash = txBlobHex => {
  const prefix = hashprefixes.HashPrefix.transactionID.toString('hex').toUpperCase()
  return hashes.sha512Half(Buffer.from(prefix + txBlobHex, 'hex')).toString('hex').toUpperCase()
}

const computeSignature = (tx, privateKey, signAs, definitions) => {
  var signingData = signAs ? encodeForMultisigning(tx, signAs, definitions) : encodeForSigning(tx, definitions)
  return keypairs.sign(signingData, privateKey)
}

function sign_keypair (txJSON, keypair) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}

  var tx = JSON.parse(txJSON);

  tx.SigningPubKey = options.signAs ? '' : keypair.publicKey
  const definitions = options.definitions ? options.definitions : undefined

  if (options.signAs) {
    var signer = {
      Account: options.signAs,
      SigningPubKey: keypair.publicKey,
      TxnSignature: computeSignature(tx, keypair.privateKey, options.signAs, definitions)
    };
    if (!tx.Signers) tx.Signers = []
    tx.Signers.push({ Signer: signer })
    tx.Signers = sortSigners(tx.Signers)
  } else {
    tx.TxnSignature = computeSignature(tx, keypair.privateKey, undefined, definitions)
  }

  const serialized = encode(tx, definitions)
  
  return {
    id: computeBinaryTransactionHash(serialized),
    signedTransaction: serialized,
    txJson: tx,
  }
}

module.exports = sign_keypair


/***/ }),

/***/ 4481:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const addresscodec = __nccwpck_require__(597)
const BigInteger = __nccwpck_require__(4922)

function sortSigners(signers) {
  if (signers.length === 1) return signers
  var hashInts = signers.map(function(signer) {
    return BigInteger('00' + addresscodec.decodeAccountID(signer.Signer.Account).toString('hex'), 16)
  })
  for (var i = 1; i < hashInts.length; i++) {
    if (hashInts[0].greaterOrEquals(hashInts[i])) {
      hashInts = [hashInts[i]].concat(hashInts.slice(0,i)).concat(hashInts.slice(i+1))
      signers = [signers[i]].concat(signers.slice(0,i)).concat(signers.slice(i+1))
    }
  }
  return signers
}

module.exports = sortSigners


/***/ }),

/***/ 8707:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = {
	EventTarget : __nccwpck_require__(7782),
	Event       : __nccwpck_require__(8483)
};


/***/ }),

/***/ 8483:
/***/ ((module) => {

/**
 * Expose the Event class.
 */
module.exports = _Event;


function _Event(type) {
	this.type = type;
	this.isTrusted = false;

	// Set a flag indicating this is not a DOM Event object
	this._yaeti = true;
}


/***/ }),

/***/ 7782:
/***/ ((module) => {

/**
 * Expose the _EventTarget class.
 */
module.exports = _EventTarget;

function _EventTarget() {
	// Do nothing if called for a native EventTarget object..
	if (typeof this.addEventListener === 'function') {
		return;
	}

	this._listeners = {};

	this.addEventListener = _addEventListener;
	this.removeEventListener = _removeEventListener;
	this.dispatchEvent = _dispatchEvent;
}

Object.defineProperties(_EventTarget.prototype, {
	listeners: {
		get: function () {
			return this._listeners;
		}
	}
});

function _addEventListener(type, newListener) {
	var
		listenersType,
		i, listener;

	if (!type || !newListener) {
		return;
	}

	listenersType = this._listeners[type];
	if (listenersType === undefined) {
		this._listeners[type] = listenersType = [];
	}

	for (i = 0; !!(listener = listenersType[i]); i++) {
		if (listener === newListener) {
			return;
		}
	}

	listenersType.push(newListener);
}

function _removeEventListener(type, oldListener) {
	var
		listenersType,
		i, listener;

	if (!type || !oldListener) {
		return;
	}

	listenersType = this._listeners[type];
	if (listenersType === undefined) {
		return;
	}

	for (i = 0; !!(listener = listenersType[i]); i++) {
		if (listener === oldListener) {
			listenersType.splice(i, 1);
			break;
		}
	}

	if (listenersType.length === 0) {
		delete this._listeners[type];
	}
}

function _dispatchEvent(event) {
	var
		type,
		listenersType,
		dummyListener,
		stopImmediatePropagation = false,
		i, listener;

	if (!event || typeof event.type !== 'string') {
		throw new Error('`event` must have a valid `type` property');
	}

	// Do some stuff to emulate DOM Event behavior (just if this is not a
	// DOM Event object)
	if (event._yaeti) {
		event.target = this;
		event.cancelable = true;
	}

	// Attempt to override the stopImmediatePropagation() method
	try {
		event.stopImmediatePropagation = function () {
			stopImmediatePropagation = true;
		};
	} catch (error) {}

	type = event.type;
	listenersType = (this._listeners[type] || []);

	dummyListener = this['on' + type];
	if (typeof dummyListener === 'function') {
		dummyListener.call(this, event);
	}

	for (i = 0; !!(listener = listenersType[i]); i++) {
		if (stopImmediatePropagation) {
			break;
		}

		listener.call(this, event);
	}

	return !event.defaultPrevented;
}


/***/ }),

/***/ 6263:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const codec = __nccwpck_require__(597);
const { Buffer } = __nccwpck_require__(4300);
const { XrplApi } = __nccwpck_require__(1850);
const { XrplAccount } = __nccwpck_require__(9329);
const { XrplApiEvents, XrplConstants } = __nccwpck_require__(3307);
const { EvernodeEvents, EventTypes, MemoFormats, EvernodeConstants, HookStateKeys, HookParamKeys, RegExp } = __nccwpck_require__(9849);
const { Defaults } = __nccwpck_require__(8262);
const { EncryptionHelper } = __nccwpck_require__(4832);
const { EventEmitter } = __nccwpck_require__(6170);
const { UtilHelpers } = __nccwpck_require__(6687);
const { StateHelpers } = __nccwpck_require__(3860);
const { EvernodeHelpers } = __nccwpck_require__(2523);
const { HookHelpers } = __nccwpck_require__(4675);
const xrpl = __nccwpck_require__(4666);

const CANDIDATE_PROPOSE_HASHES_PARAM_OFFSET = 0;
const CANDIDATE_PROPOSE_KEYLETS_PARAM_OFFSET = 96;
const CANDIDATE_PROPOSE_UNIQUE_ID_PARAM_OFFSET = 198;
const CANDIDATE_PROPOSE_SHORT_NAME_PARAM_OFFSET = 230;
const CANDIDATE_PROPOSE_PARAM_SIZE = 250;

const DUD_HOST_CANDID_ADDRESS_OFFSET = 12;

const REPUTATION_HOST_ADDRESS_PARAM_OFFSET = 0;
const REPUTATION_VALUE_PARAM_OFFSET = 20;

class BaseEvernodeClient {

    #watchEvents;
    #autoSubscribe;
    #ownsXrplApi = false;

    constructor(xrpAddress, xrpSecret, watchEvents, autoSubscribe = false, options = {}) {

        this.connected = false;
        this.governorAddress = options.governorAddress || Defaults.values.governorAddress;

        this.xrplApi = options.xrplApi || Defaults.values.xrplApi || new XrplApi(options.rippledServer);
        if (!options.xrplApi && !Defaults.values.xrplApi)
            this.#ownsXrplApi = true;

        this.xrplAcc = new XrplAccount(xrpAddress, xrpSecret, { xrplApi: this.xrplApi });
        this.accKeyPair = xrpSecret && this.xrplAcc.deriveKeypair();
        this.messagePrivateKey = options.messagePrivateKey || (this.accKeyPair ? this.accKeyPair.privateKey : null);
        if (this.messagePrivateKey && !RegExp.PublicPrivateKey.test(this.messagePrivateKey))
            throw "Message private key is not valid.";
        this.#watchEvents = watchEvents;
        this.#autoSubscribe = autoSubscribe;
        this.events = new EventEmitter();

        this.xrplAcc.on(XrplApiEvents.PAYMENT, (tx, error) => this.#handleEvernodeEvent(tx, error));
        this.xrplAcc.on(XrplApiEvents.URI_TOKEN_BUY, (tx, error) => this.#handleEvernodeEvent(tx, error));
        this.xrplAcc.on(XrplApiEvents.URI_TOKEN_CREATE_SELL_OFFER, (tx, error) => this.#handleEvernodeEvent(tx, error));
    }

    /**
     * Listens to the subscribed events. This will listen for the event without detaching the handler until it's 'off'.
     * @param {string} event Event name.
     * @param {function(event)} handler Callback function to handle the event.
     */
    on(event, handler) {
        this.events.on(event, handler);
    }

    /**
    * Listens to the subscribed events. This will listen only once and detach the handler.
    * @param {string} event Event name.
    * @param {function(event)} handler Callback function to handle the event.
    */
    once(event, handler) {
        this.events.once(event, handler);
    }

    /**
     * Detach the listener event.
     * @param {string} event Event name.
     * @param {function(event)} handler (optional) Can be sent if a specific handler need to be detached. All the handlers will be detached if not specified.
     */
    off(event, handler = null) {
        this.events.off(event, handler);
    }

    /**
     * Connects the client to xrpl server and do the config loading and subscriptions. 'subscribe' is called inside this.
     * @returns boolean value, 'true' if success.
     */
    async connect() {
        if (this.connected)
            return true;

        await this.xrplApi.connect();

        // Invoking the info command to check the account existence. This is important to 
        // identify a network reset from XRPL. 
        await this.xrplAcc.getInfo();

        this.config = await this.#getEvernodeConfig();
        this.connected = true;

        if (this.#autoSubscribe)
            await this.subscribe();

        return true;
    }

    /**
     * Disconnects the client to xrpl server and do the un-subscriptions. 'unsubscribe' is called inside this.
     */
    async disconnect() {
        await this.unsubscribe();

        if (this.#ownsXrplApi)
            await this.xrplApi.disconnect();
    }

    /**
     * Subscribes to the client events.
     */
    async subscribe() {
        await this.xrplAcc.subscribe();
    }

    /**
     * Unsubscribes from the client events.
     */
    async unsubscribe() {
        await this.xrplAcc.unsubscribe();
    }

    /**
     * Get the EVR balance in the account.
     * @returns The available EVR amount as a 'string'.
     */
    async getEVRBalance() {
        const lines = await this.xrplAcc.getTrustLines(EvernodeConstants.EVR, this.config.evrIssuerAddress);
        if (lines.length > 0)
            return lines[0].balance;
        else
            return '0';
    }

    /**
     * Get all XRPL hook states in the registry account.
     * @returns The list of hook states including Evernode configuration and hosts.
     */
    async getHookStates() {
        const regAcc = new XrplAccount(this.governorAddress, null, { xrplApi: this.xrplApi });
        const configs = await regAcc.getNamespaceEntries(EvernodeConstants.HOOK_NAMESPACE);

        if (configs)
            return configs.filter(c => c.LedgerEntryType === 'HookState').map(c => { return { key: c.HookStateKey, data: c.HookStateData } });
        return [];
    }

    /**
     * Get the moment from the given index (timestamp).
     * @param {number} index [Optional] Index (timestamp) to get the moment value.
     * @returns The moment of the given index (timestamp) as 'number'. Returns current moment if index (timestamp) is not given.
     */
    async getMoment(index = null) {
        const i = index || UtilHelpers.getCurrentUnixTime();
        const m = this.config.momentBaseInfo.baseTransitionMoment + Math.floor((i - this.config.momentBaseInfo.baseIdx) / this.config.momentSize);
        await Promise.resolve();
        return m;
    }

    /**
     * Get start index (timestamp) of the moment.
     * @param {number} index [Optional] Index (timestamp) to get the moment start index.
     * @returns The index (timestamp) of the moment as a 'number'. Returns the current moment's start index (timestamp) if ledger index parameter is not given.
     */
    async getMomentStartIndex(index = null) {
        const i = index || UtilHelpers.getCurrentUnixTime();

        const m = Math.floor((i - this.config.momentBaseInfo.baseIdx) / this.config.momentSize);

        await Promise.resolve(); // Awaiter placeholder for future async requirements.
        return this.config.momentBaseInfo.baseIdx + (m * this.config.momentSize);
    }

    /**
     * Get Evernode configuration
     * @returns An object with all the configuration and their values.
     */
    async #getEvernodeConfig() {
        let states = await this.getHookStates();
        const configStateKeys = {
            registryAddress: HookStateKeys.REGISTRY_ADDR,
            heartbeatAddress: HookStateKeys.HEARTBEAT_ADDR,
            evrIssuerAddress: HookStateKeys.EVR_ISSUER_ADDR,
            foundationAddress: HookStateKeys.FOUNDATION_ADDR,
            hostRegFee: HookStateKeys.HOST_REG_FEE,
            momentSize: HookStateKeys.MOMENT_SIZE,
            hostHeartbeatFreq: HookStateKeys.HOST_HEARTBEAT_FREQ,
            momentBaseInfo: HookStateKeys.MOMENT_BASE_INFO,
            leaseAcquireWindow: HookStateKeys.LEASE_ACQUIRE_WINDOW,
            rewardInfo: HookStateKeys.REWARD_INFO,
            rewardConfiguration: HookStateKeys.REWARD_CONFIGURATION,
            hostCount: HookStateKeys.HOST_COUNT,
            momentTransitInfo: HookStateKeys.MOMENT_TRANSIT_INFO,
            registryMaxTrxEmitFee: HookStateKeys.MAX_TRX_EMISSION_FEE,
            governanceConfiguration: HookStateKeys.GOVERNANCE_CONFIGURATION,
            governanceInfo: HookStateKeys.GOVERNANCE_INFO,
            transactionFeeBaseInfo: HookStateKeys.TRX_FEE_BASE_INFO,
            networkConfiguration: HookStateKeys.NETWORK_CONFIGURATION,
        }
        let config = {};
        for (const [key, value] of Object.entries(configStateKeys)) {
            const stateKey = Buffer.from(value, 'hex');
            const stateDataBin = StateHelpers.getStateData(states, value);
            if (stateDataBin) {
                const stateData = Buffer.from(StateHelpers.getStateData(states, value), 'hex');
                const decoded = StateHelpers.decodeStateData(stateKey, stateData);
                config[key] = decoded.value;
            }
        }
        return config;
    }

    /**
     * Loads the configs from XRPL hook and updates the in-memory config.
     */
    async refreshConfig() {
        this.config = await this.#getEvernodeConfig();
    }

    /**
     * Extracts transaction info and emits the Evernode event.
     * @param {object} tx XRPL transaction to be handled.
     * @param {any} error Error if there's any.
     */
    async #handleEvernodeEvent(tx, error) {
        if (error)
            console.error(error);
        else if (!tx)
            console.log('handleEvernodeEvent: Invalid transaction.');
        else {
            try {
                const ev = await this.extractEvernodeEvent(tx);
                if (ev && this.#watchEvents.find(e => e === ev.name))
                    this.events.emit(ev.name, ev.data);
            } catch (e) {
                console.log("Error occurred while handling Evernode events", e)
            }
        }
    }

    /**
     * Extracts the transaction info from a given transaction..
     * @param {object} tx Transaction to be deserialized and extracted.
     * @returns The event object in the format {name: '', data: {}}. Returns null if not handled. Note: You need to deserialize HookParameters before passing the transaction to this function.
     */
    async extractEvernodeEvent(tx) {
        let eventType;
        let eventData;
        if (tx.HookParameters.length) {
            eventType = tx.HookParameters.find(p => p.name === HookParamKeys.PARAM_EVENT_TYPE_KEY)?.value;
            eventData = tx.HookParameters.find(p => p.name === HookParamKeys.PARAM_EVENT_DATA_KEY)?.value ?? '';
        }
        if (tx.TransactionType === 'URITokenBuy' && eventType === EventTypes.ACQUIRE_LEASE && tx.Memos.length &&
            tx.Memos[0].type === EventTypes.ACQUIRE_LEASE && tx.Memos[0].format === MemoFormats.BASE64 && tx.Memos[0].data) {

            // If our account is the destination host account, then decrypt the payload if it is encrypted.
            let payload = tx.Memos[0].data;
            if (tx.Memos[0].format === MemoFormats.BASE64 && tx.Destination === this.xrplAcc.address) {
                const prefixBuf = (Buffer.from(payload, 'base64')).slice(0, 1);
                if (prefixBuf.readInt8() == 1) { // 1 denoted the data is encrypted
                    payload = Buffer.from(payload, 'base64').slice(1).toString('base64');
                    const decrypted = this.messagePrivateKey && await EncryptionHelper.decrypt(this.messagePrivateKey, payload);
                    if (decrypted)
                        payload = decrypted;
                    else
                        console.log('Failed to decrypt acquire data.');
                }
                else {
                    payload = JSON.parse(Buffer.from(payload, 'base64').slice(1).toString());
                }
            }

            return {
                name: EvernodeEvents.AcquireLease,
                data: {
                    transaction: tx,
                    host: tx.Destination,
                    uriTokenId: tx.URITokenSellOffer?.index,
                    leaseAmount: tx.URITokenSellOffer?.Amount?.value,
                    acquireRefId: tx.hash,
                    tenant: tx.Account,
                    payload: payload
                }
            }
        }

        else if (eventType === EventTypes.ACQUIRE_SUCCESS && eventData && tx.Memos.length &&
            tx.Memos[0].type === EventTypes.ACQUIRE_SUCCESS && tx.Memos[0].data) {

            let payload = tx.Memos[0].data;
            const acquireRefId = eventData;

            // If our account is the destination user account, then decrypt the payload if it is encrypted.
            if (tx.Memos[0].format === MemoFormats.BASE64 && tx.Destination === this.xrplAcc.address) {
                const prefixBuf = (Buffer.from(payload, 'base64')).slice(0, 1);
                if (prefixBuf.readInt8() == 1) { // 1 denoted the data is encrypted
                    payload = Buffer.from(payload, 'base64').slice(1).toString('base64');
                    const decrypted = this.messagePrivateKey && await EncryptionHelper.decrypt(this.messagePrivateKey, payload);
                    if (decrypted)
                        payload = decrypted;
                    else
                        console.log('Failed to decrypt instance data.');
                }
                else {
                    payload = JSON.parse(Buffer.from(payload, 'base64').slice(1).toString());
                }
            }

            return {
                name: EvernodeEvents.AcquireSuccess,
                data: {
                    transaction: tx,
                    acquireRefId: acquireRefId,
                    payload: payload
                }
            }

        }
        else if (eventType === EventTypes.ACQUIRE_ERROR && eventData && tx.Memos.length &&
            tx.Memos[0].type === EventTypes.ACQUIRE_ERROR && tx.Memos[0].data) {

            let error = tx.Memos[0].data;
            const acquireRefId = eventData;

            if (tx.Memos[0].format === MemoFormats.JSON)
                error = JSON.parse(error).reason;

            return {
                name: EvernodeEvents.AcquireError,
                data: {
                    transaction: tx,
                    acquireRefId: acquireRefId,
                    reason: error
                }
            }
        }
        else if (eventType === EventTypes.HOST_REG && eventData) {

            return {
                name: EvernodeEvents.HostRegistered,
                data: {
                    transaction: tx,
                    host: tx.Account
                }
            }
        }
        else if (eventType === EventTypes.HOST_DEREG && eventData) {
            return {
                name: EvernodeEvents.HostDeregistered,
                data: {
                    transaction: tx,
                    host: tx.Account
                }
            }
        }
        else if (eventType === EventTypes.HEARTBEAT) {

            const voteInfo = (eventData && eventData.length) ?
                {
                    voteInfo: {
                        candidateId: eventData.substr(0, 64),
                        vote: Buffer.from(eventData, 'hex').slice(32, 33).readUInt8()
                    }
                } : {};

            return {
                name: EvernodeEvents.Heartbeat,
                data: {
                    transaction: tx,
                    host: tx.Account,
                    ...voteInfo
                }
            }
        }
        else if (eventType === EventTypes.EXTEND_LEASE && eventData) {

            let uriTokenId = eventData;

            return {
                name: EvernodeEvents.ExtendLease,
                data: {
                    transaction: tx,
                    extendRefId: tx.hash,
                    tenant: tx.Account,
                    currency: tx.Amount.currency,
                    payment: (tx.Flags & xrpl.PaymentFlags.tfPartialPayment) ? parseFloat(tx.DeliveredAmount.value) : parseFloat(tx.Amount.value),
                    uriTokenId: uriTokenId
                }
            }
        }
        else if (eventType === EventTypes.EXTEND_SUCCESS && eventData && tx.Memos.length &&
            tx.Memos[0].type === EventTypes.EXTEND_SUCCESS && tx.Memos[0].format === MemoFormats.HEX && tx.Memos[0].data) {

            const extendResBuf = Buffer.from(tx.Memos[0].data, 'hex');
            const extendRefId = eventData;

            return {
                name: EvernodeEvents.ExtendSuccess,
                data: {
                    transaction: tx,
                    extendRefId: extendRefId,
                    expiryMoment: extendResBuf.readUInt32BE()
                }
            }

        }
        else if (eventType === EventTypes.EXTEND_ERROR && eventData && tx.Memos.length &&
            tx.Memos[0].type === EventTypes.EXTEND_ERROR && tx.Memos[0].data) {

            let error = tx.Memos[0].data;
            const extendRefId = eventData;

            if (tx.Memos[0].format === MemoFormats.JSON)
                error = JSON.parse(error).reason;

            return {
                name: EvernodeEvents.ExtendError,
                data: {
                    transaction: tx,
                    extendRefId: extendRefId,
                    reason: error
                }
            }
        }
        else if (eventType === EventTypes.INIT && eventData) {

            return {
                name: EvernodeEvents.Initialized,
                data: {
                    transaction: tx
                }
            }
        }
        else if (eventType === EventTypes.HOST_UPDATE_INFO && eventData) {

            return {
                name: EvernodeEvents.HostRegUpdated,
                data: {
                    transaction: tx,
                    host: tx.Account
                }
            }
        }
        else if (eventType === EventTypes.DEAD_HOST_PRUNE && eventData) {

            const addrsBuf = Buffer.from(eventData, 'hex');

            return {
                name: EvernodeEvents.DeadHostPrune,
                data: {
                    transaction: tx,
                    host: codec.encodeAccountID(addrsBuf)
                }
            }
        }
        else if (eventType === EventTypes.HOST_REBATE) {

            return {
                name: EvernodeEvents.HostRebate,
                data: {
                    transaction: tx,
                    host: tx.Account
                }
            }
        }
        else if (eventType === EventTypes.HOST_TRANSFER && eventData) {

            const addrsBuf = Buffer.from(eventData, 'hex');

            return {
                name: EvernodeEvents.HostTransfer,
                data: {
                    transaction: tx,
                    transferee: codec.encodeAccountID(addrsBuf)
                }
            }
        }
        else if (eventType === EventTypes.CANDIDATE_PROPOSE && eventData) {

            return {
                name: EvernodeEvents.CandidateProposed,
                data: {
                    transaction: tx,
                    owner: tx.Account,
                    candidateId: eventData.substr(CANDIDATE_PROPOSE_UNIQUE_ID_PARAM_OFFSET * 2, 64)
                }
            }
        }
        else if (eventType === EventTypes.CANDIDATE_WITHDRAW && eventData) {
            return {
                name: EvernodeEvents.CandidateWithdrawn,
                data: {
                    transaction: tx,
                    owner: tx.Account,
                    candidateId: eventData.substr(0, 64)
                }
            }
        }
        else if (eventType === EventTypes.CANDIDATE_STATUS_CHANGE && eventData) {
            const eventDataBuf = Buffer.from(eventData, 'hex');
            const candidateId = eventDataBuf.slice(0, 32).toString('hex');
            const candidateType = StateHelpers.getCandidateType(candidateId);

            switch (candidateType) {
                case (EvernodeConstants.CandidateTypes.DudHost):
                    return {
                        name: eventDataBuf.readUInt8(32) === EvernodeConstants.CandidateStatuses.CANDIDATE_ELECTED ? EvernodeEvents.DudHostRemoved : EvernodeEvents.DudHostStatusChanged,
                        data: {
                            transaction: tx,
                            candidateId: candidateId,
                            host: codec.encodeAccountID(Buffer.from(candidateId, 'hex').slice(DUD_HOST_CANDID_ADDRESS_OFFSET, 32))
                        }
                    }
                case (EvernodeConstants.CandidateTypes.PilotedMode):
                    return {
                        name: EvernodeEvents.FallbackToPiloted,
                        data: {
                            transaction: tx,
                            candidateId: candidateId,
                        }
                    }
                case (EvernodeConstants.CandidateTypes.NewHook):
                    return {
                        name: EvernodeEvents.NewHookStatusChanged,
                        data: {
                            transaction: tx,
                            candidateId: candidateId,
                        }
                    }
                default:
                    return null;
            }

        }
        else if (eventType === EventTypes.LINKED_CANDIDATE_REMOVE && eventData) {
            const eventDataBuf = Buffer.from(eventData, 'hex');
            const candidateId = eventDataBuf.slice(0, 32).toString('hex');
            const candidateType = StateHelpers.getCandidateType(candidateId);

            if (candidateType === EvernodeConstants.CandidateTypes.DudHost) {
                return {
                    name: EvernodeEvents.LinkedDudHostCandidateRemoved,
                    data: {
                        transaction: tx,
                        candidateId: candidateId,
                        host: codec.encodeAccountID(Buffer.from(candidateId, 'hex').slice(DUD_HOST_CANDID_ADDRESS_OFFSET, 32))
                    }
                }
            }
        }
        else if (eventType === EventTypes.HOOK_UPDATE_RES && eventData) {
            return {
                name: EvernodeEvents.ChildHookUpdated,
                data: {
                    transaction: tx,
                    account: tx.Account,
                    candidateId: eventData.substr(0, 64)
                }
            }
        }
        else if (eventType === EventTypes.GOVERNANCE_MODE_CHANGE && eventData) {
            const mode = Buffer.from(eventData, 'hex').slice(0, 1).readUInt8();

            return {
                name: EvernodeEvents.GovernanceModeChanged,
                data: {
                    transaction: tx,
                    mode: mode
                }
            }
        }
        else if (eventType === EventTypes.CANDIDATE_VOTE && eventData) {
            const vote = Buffer.from(eventData, 'hex').slice(32, 33).readUInt8();

            return {
                name: EvernodeEvents.FoundationVoted,
                data: {
                    transaction: tx,
                    candidateId: eventData.substr(0, 64),
                    vote: vote
                }
            }
        }
        else if (eventType === EventTypes.DUD_HOST_REPORT && eventData) {
            const candidateId = eventData.substr(0, 64);

            return {
                name: EvernodeEvents.DudHostReported,
                data: {
                    transaction: tx,
                    candidateId: candidateId,
                    host: codec.encodeAccountID(Buffer.from(candidateId, 'hex').slice(DUD_HOST_CANDID_ADDRESS_OFFSET, 32))
                }
            }
        }
        else if (eventType === EventTypes.HOST_UPDATE_REPUTATION && eventData) {
            const dataBuf = Buffer.from(eventData, 'hex');

            return {
                name: EvernodeEvents.HostReputationUpdated,
                data: {
                    transaction: tx,
                    host: codec.encodeAccountID(dataBuf.slice(REPUTATION_HOST_ADDRESS_PARAM_OFFSET, 20)),
                    reputation: dataBuf.readUInt8(REPUTATION_VALUE_PARAM_OFFSET)
                }
            }
        }

        return null;
    }

    /**
     * Get the registered host information.
     * @param {string} hostAddress [Optional] Address of the host.
     * @returns The registered host information object. Returns null if not registered.
     */
    async getHostInfo(hostAddress = this.xrplAcc.address) {
        try {
            const addrStateKey = StateHelpers.generateHostAddrStateKey(hostAddress);
            const addrStateIndex = StateHelpers.getHookStateIndex(this.governorAddress, addrStateKey);
            const addrLedgerEntry = await this.xrplApi.getLedgerEntry(addrStateIndex);
            const addrStateData = addrLedgerEntry?.HookStateData;
            if (addrStateData) {
                const addrStateDecoded = StateHelpers.decodeHostAddressState(Buffer.from(addrStateKey, 'hex'), Buffer.from(addrStateData, 'hex'));
                const curMomentStartIdx = await this.getMomentStartIndex();
                addrStateDecoded.active = (addrStateDecoded.lastHeartbeatIndex > (this.config.hostHeartbeatFreq * this.config.momentSize) ?
                    (addrStateDecoded.lastHeartbeatIndex >= (curMomentStartIdx - (this.config.hostHeartbeatFreq * this.config.momentSize))) :
                    (addrStateDecoded.lastHeartbeatIndex > 0))

                const tokenIdStatekey = StateHelpers.generateTokenIdStateKey(addrStateDecoded.uriTokenId);
                const tokenIdStateIndex = StateHelpers.getHookStateIndex(this.governorAddress, tokenIdStatekey);
                const tokenIdLedgerEntry = await this.xrplApi.getLedgerEntry(tokenIdStateIndex);

                const hostAcc = new XrplAccount(hostAddress, null, { xrplApi: this.xrplApi });
                addrStateDecoded.domain = await hostAcc.getDomain();

                const tokenIdStateData = tokenIdLedgerEntry?.HookStateData;
                if (tokenIdStateData) {
                    const tokenIdStateDecoded = StateHelpers.decodeTokenIdState(Buffer.from(tokenIdStateData, 'hex'));
                    return { ...addrStateDecoded, ...tokenIdStateDecoded };
                }
            }
        }
        catch (e) {
            // If the exception is entryNotFound from Rippled there's no entry for the host, So return null.
            if (e?.data?.error !== 'entryNotFound')
                throw e;
        }

        return null;
    }

    /**
     * Get the hosts registered in Evernode.
     * @returns The list of hosts. 
     */
    async getAllHostsFromLedger(getDomain = true) {
        const states = await this.getHookStates();
        let hosts = {};

        for (const state of states) {
            const stateKey = Buffer.from(state.key, 'hex');
            if (state.data) {
                const stateData = Buffer.from(state.data, 'hex');
                const decoded = StateHelpers.decodeStateData(stateKey, stateData);
                if (decoded.type == StateHelpers.StateTypes.HOST_ADDR || decoded.type == StateHelpers.StateTypes.TOKEN_ID) {
                    hosts[decoded.address] = { ...(hosts[decoded.address] ?? {}), ...decoded };
                }
            }
        }

        const hostList = Object.values(hosts);

        const curMomentStartIdx = await this.getMomentStartIndex();
        await Promise.all((hostList).map(async host => {
            const hostAcc = new XrplAccount(host.address, null, { xrplApi: this.xrplApi });
            if (getDomain) {
                host.domain = await hostAcc.getDomain();
            }
            host.active = (host.lastHeartbeatIndex > (this.config.hostHeartbeatFreq * this.config.momentSize) ?
                (host.lastHeartbeatIndex >= (curMomentStartIdx - (this.config.hostHeartbeatFreq * this.config.momentSize))) :
                (host.lastHeartbeatIndex > 0));
            return host;
        }));

        return hostList;
    }

    /**
     * Get the governor in Evernode.
     * @returns The list of candidates. 
     */
    async getAllCandidatesFromLedger() {
        const states = await this.getHookStates();
        let candidates = [];

        for (const state of states) {
            const stateKey = Buffer.from(state.key, 'hex');
            if (state.data) {
                const stateData = Buffer.from(state.data, 'hex');
                const decoded = StateHelpers.decodeStateData(stateKey, stateData);
                if (decoded.type == StateHelpers.StateTypes.CANDIDATE_ID) {
                    candidates.push(decoded);
                }
            }
        }

        return candidates;
    }

    /**
     * Remove a host which is inactive for a long period. The inactivity is checked by Evernode it self and only pruned if inactive thresholds are met.
     * @param {string} hostAddress XRPL address of the host to be pruned.
     */
    async pruneDeadHost(hostAddress) {
        if (this.xrplAcc.address === this.config.registryAddress)
            throw 'Invalid function call';

        let paramData = Buffer.alloc(20, 0);
        codec.decodeAccountID(hostAddress).copy(paramData);

        const hostInfo = await this.getHostInfo(hostAddress);

        let validPrune = false;
        // If this host is a transferer, it does not own a registration token
        if (!hostInfo.isATransferer) {
            const hostAcc = new XrplAccount(hostAddress, null, { xrplApi: this.xrplApi });
            const regUriToken = (await hostAcc.getURITokens()).find(n => n.URI.startsWith(EvernodeConstants.TOKEN_PREFIX_HEX) && n.Issuer === this.config.registryAddress);
            validPrune = !!regUriToken;
        }
        else
            validPrune = true;


        if (validPrune) {
            await this.xrplAcc.makePayment(this.config.registryAddress,
                XrplConstants.MIN_DROPS,
                null,
                null,
                null,
                {
                    hookParams: [
                        { name: HookParamKeys.PARAM_EVENT_TYPE_KEY, value: EventTypes.DEAD_HOST_PRUNE },
                        { name: HookParamKeys.PARAM_EVENT_DATA_KEY, value: paramData.toString('hex') }
                    ]
                });
        } else
            throw "No Registration URI token was found for the Host account."

    }

    /**
     * Get proposed new hook candidate info.
     * @param {string} ownerAddress [Optional] Address of the owner.
     * @returns The candidate information. Returns null if no candidate.
     */
    async getCandidateByOwner(ownerAddress = this.xrplAcc.address) {
        try {
            const ownerStateKey = StateHelpers.generateCandidateOwnerStateKey(ownerAddress);
            const ownerStateIndex = StateHelpers.getHookStateIndex(this.governorAddress, ownerStateKey);
            const ownerLedgerEntry = await this.xrplApi.getLedgerEntry(ownerStateIndex);
            const ownerStateData = ownerLedgerEntry?.HookStateData;
            if (ownerStateData) {
                const ownerStateDecoded = StateHelpers.decodeCandidateOwnerState(Buffer.from(ownerStateKey, 'hex'), Buffer.from(ownerStateData, 'hex'));

                const idStateKey = StateHelpers.generateCandidateIdStateKey(ownerStateDecoded.uniqueId);
                const idStateIndex = StateHelpers.getHookStateIndex(this.governorAddress, idStateKey);
                const idLedgerEntry = await this.xrplApi.getLedgerEntry(idStateIndex);

                const idStateData = idLedgerEntry?.HookStateData;
                if (idStateData) {
                    const idStateDecoded = StateHelpers.decodeCandidateIdState(Buffer.from(idStateData, 'hex'));
                    return { ...ownerStateDecoded, ...idStateDecoded };
                }
            }
        }
        catch (e) {
            // If the exception is entryNotFound from Rippled there's no entry for the host, So return null.
            if (e?.data?.error !== 'entryNotFound')
                throw e;
        }

        return null;
    }

    /**
     * Get proposed dud host candidates.
     * @param {string} ownerAddress | Address of the owner
     * @returns An array of candidate information. Returns empty array if no candidates.
     */
    async getDudHostCandidatesByOwner(ownerAddress = this.xrplAcc.address) {
        try {
            const candidates = await this.getAllCandidatesFromLedger();
            let filteredCandidates = candidates.filter(c => c.ownerAddress === ownerAddress);
            if (filteredCandidates && filteredCandidates.length > 0) {
                filteredCandidates = filteredCandidates.filter(c => StateHelpers.getCandidateType(c.uniqueId) == EvernodeConstants.CandidateTypes.DudHost);
                return filteredCandidates;
            }
        } catch (error) {
            console.log(error)
        }
        return [];
    }

    /**
     * Get candidate info.
     * @param {string} candidateId Id of the candidate.
     * @returns The candidate information. Returns null if no candidate.
     */
    async getCandidateById(candidateId) {
        try {
            const idStateKey = StateHelpers.generateCandidateIdStateKey(candidateId);
            const idStateIndex = StateHelpers.getHookStateIndex(this.governorAddress, idStateKey);
            const idLedgerEntry = await this.xrplApi.getLedgerEntry(idStateIndex);
            const idStateData = idLedgerEntry?.HookStateData;
            if (idStateData) {
                let idStateDecoded = StateHelpers.decodeCandidateIdState(Buffer.from(idStateData, 'hex'));
                const candidateType = StateHelpers.getCandidateType(candidateId);
                if (candidateType === EvernodeConstants.CandidateTypes.NewHook) {
                    const ownerStateKey = StateHelpers.generateCandidateOwnerStateKey(idStateDecoded.ownerAddress);
                    const ownerStateIndex = StateHelpers.getHookStateIndex(this.governorAddress, ownerStateKey);
                    const ownerLedgerEntry = await this.xrplApi.getLedgerEntry(ownerStateIndex);

                    const ownerStateData = ownerLedgerEntry?.HookStateData;
                    if (ownerStateData) {
                        const ownerStateDecoded = StateHelpers.decodeCandidateOwnerState(Buffer.from(ownerStateKey, 'hex'), Buffer.from(ownerStateData, 'hex'));
                        return { ...ownerStateDecoded, ...idStateDecoded };
                    }
                }
                else if (candidateType === EvernodeConstants.CandidateTypes.DudHost) {
                    idStateDecoded.dudHostAddress = codec.encodeAccountID(Buffer.from(idStateKey, 'hex').slice(12, 32));
                }

                return { ...idStateDecoded, uniqueId: candidateId };
            }
        }
        catch (e) {
            // If the exception is entryNotFound from Rippled there's no entry for the host, So return null.
            if (e?.data?.error !== 'entryNotFound')
                throw e;
        }

        return null;
    }

    /**
     * Get reported dud host info.
     * @param {string} hostAddress [Optional] Address of the dud host.
     * @returns The dud host candidate information. Returns null if no candidate.
     */
    async getDudHostVoteInfo(hostAddress = this.xrplAcc.address) {
        try {
            const candidateId = StateHelpers.getDudHostCandidateId(hostAddress);
            const idStateKey = StateHelpers.generateCandidateIdStateKey(candidateId);
            const idStateIndex = StateHelpers.getHookStateIndex(this.governorAddress, idStateKey);
            const idLedgerEntry = await this.xrplApi.getLedgerEntry(idStateIndex);

            const idStateData = idLedgerEntry?.HookStateData;
            if (idStateData) {
                const idStateDecoded = StateHelpers.decodeCandidateIdState(Buffer.from(idStateData, 'hex'));
                return idStateDecoded;
            }
        }
        catch (e) {
            // If the exception is entryNotFound from Rippled there's no entry for the host, So return null.
            if (e?.data?.error !== 'entryNotFound')
                throw e;
        }

        return null;
    }

    /**
     * Get piloted mode vote info.
     * @returns The piloted mode candidate information. Returns null if no candidate.
     */
    async getPilotedModeVoteInfo() {
        try {
            const candidateId = StateHelpers.getPilotedModeCandidateId();
            const idStateKey = StateHelpers.generateCandidateIdStateKey(candidateId);
            const idStateIndex = StateHelpers.getHookStateIndex(this.governorAddress, idStateKey);
            const idLedgerEntry = await this.xrplApi.getLedgerEntry(idStateIndex);

            const idStateData = idLedgerEntry?.HookStateData;
            if (idStateData) {
                const idStateDecoded = StateHelpers.decodeCandidateIdState(Buffer.from(idStateData, 'hex'));
                return idStateDecoded;
            }
        }
        catch (e) {
            // If the exception is entryNotFound from Rippled there's no entry for the host, So return null.
            if (e?.data?.error !== 'entryNotFound')
                throw e;
        }

        return null;
    }

    /**
     * Propose a new hook candidate.
     * @param {string} hashes Hook candidate hashes in hex format, <GOVERNOR_HASH(32)><REGISTRY_HASH(32)><HEARTBEAT_HASH(32)>.
     * @param {string} shortName Short name for the proposal candidate.
     * @param {*} options [Optional] transaction options.
     * @returns Proposed candidate id.
     */
    async _propose(hashes, shortName, options = {}) {
        const hashesBuf = Buffer.from(hashes, 'hex');
        if (!hashesBuf || hashesBuf.length != 96)
            throw 'Invalid hashes: Hashes should contain all three Governor, Registry, Heartbeat hook hashes.';

        // Check whether hook hashes exist in the definition.
        let keylets = [];
        for (const [i, hook] of EvernodeConstants.HOOKS.entries()) {
            const index = HookHelpers.getHookDefinitionIndex(hashes.substr(i * 64, 64));
            const ledgerEntry = await this.xrplApi.getLedgerEntry(index);
            if (!ledgerEntry)
                throw `No hook exists with the specified ${hook} hook hash.`;
            else
                keylets.push(HookHelpers.getHookDefinitionKeylet(index));
        }

        const uniqueId = StateHelpers.getNewHookCandidateId(hashesBuf);
        const paramBuf = Buffer.alloc(CANDIDATE_PROPOSE_PARAM_SIZE);
        hashesBuf.copy(paramBuf, CANDIDATE_PROPOSE_HASHES_PARAM_OFFSET);
        Buffer.from(keylets.join(''), 'hex').copy(paramBuf, CANDIDATE_PROPOSE_KEYLETS_PARAM_OFFSET);
        Buffer.from(uniqueId, 'hex').copy(paramBuf, CANDIDATE_PROPOSE_UNIQUE_ID_PARAM_OFFSET);
        Buffer.from(shortName.substr(0, 20), "utf-8").copy(paramBuf, CANDIDATE_PROPOSE_SHORT_NAME_PARAM_OFFSET);

        // Get the proposal fee. Proposal fee is current epochs moment worth of rewards.
        const proposalFee = EvernodeHelpers.getEpochRewardQuota(this.config.rewardInfo.epoch, this.config.rewardConfiguration.firstEpochRewardQuota);

        await this.xrplAcc.makePayment(this.governorAddress,
            proposalFee.toString(),
            EvernodeConstants.EVR,
            this.config.evrIssuerAddress,
            null,
            {
                hookParams: [
                    { name: HookParamKeys.PARAM_EVENT_TYPE_KEY, value: EventTypes.CANDIDATE_PROPOSE },
                    { name: HookParamKeys.PARAM_EVENT_DATA_KEY, value: paramBuf.toString('hex').toUpperCase() }
                ],
                ...options.transactionOptions
            });

        return uniqueId;
    }

    /**
     * Withdraw a hook candidate.
     * @param {string} candidateId Id of the candidate in hex format.
     * @param {*} options [Optional] transaction options.
     * @returns Transaction result.
     */
    async _withdraw(candidateId, options = {}) {
        const candidateIdBuf = Buffer.from(candidateId, 'hex');
        return await this.xrplAcc.makePayment(this.governorAddress,
            XrplConstants.MIN_DROPS,
            null,
            null,
            null,
            {
                hookParams: [
                    { name: HookParamKeys.PARAM_EVENT_TYPE_KEY, value: EventTypes.CANDIDATE_WITHDRAW },
                    { name: HookParamKeys.PARAM_EVENT_DATA_KEY, value: candidateIdBuf.toString('hex').toUpperCase() }
                ],
                ...options.transactionOptions
            });
    }

    /**
     * Report dud host for removal.
     * @param {string} hostAddress Address of the dud host.
     * @param {*} options [Optional] transaction options.
     * @returns Transaction result.
     */
    async _reportDudHost(hostAddress, options = {}) {
        const candidateId = StateHelpers.getDudHostCandidateId(hostAddress);

        // Get the proposal fee. Proposal fee is 25% of current epochs moment worth of rewards.
        const proposalFee = (EvernodeHelpers.getEpochRewardQuota(this.config.rewardInfo.epoch, this.config.rewardConfiguration.firstEpochRewardQuota) / 4);

        return await this.xrplAcc.makePayment(this.governorAddress,
            proposalFee.toString(),
            EvernodeConstants.EVR,
            this.config.evrIssuerAddress,
            null,
            {
                hookParams: [
                    { name: HookParamKeys.PARAM_EVENT_TYPE_KEY, value: EventTypes.DUD_HOST_REPORT },
                    { name: HookParamKeys.PARAM_EVENT_DATA_KEY, value: candidateId }
                ],
                ...options.transactionOptions
            });
    }
}

module.exports = {
    BaseEvernodeClient
}


/***/ }),

/***/ 2466:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const codec = __nccwpck_require__(597);
const { Buffer } = __nccwpck_require__(4300);
const { EventTypes, HookParamKeys } = __nccwpck_require__(9849);
const { StateHelpers } = __nccwpck_require__(3860);
const { XrplConstants } = __nccwpck_require__(3307);
const { BaseEvernodeClient } = __nccwpck_require__(6263);

const CANDIDATE_VOTE_UNIQUE_ID_PARAM_OFFSET = 0;
const CANDIDATE_VOTE_VALUE_PARAM_OFFSET = 32;
const CANDIDATE_VOTE_PARAM_SIZE = 33;

const REPUTATION_HOST_ADDRESS_PARAM_OFFSET = 0;
const REPUTATION_VALUE_PARAM_OFFSET = 20;
const REPUTATION_PARAM_SIZE = 21;

const FoundationEvents = {}

class FoundationClient extends BaseEvernodeClient {

    constructor(xrpAddress, xrpSecret, options = {}) {
        super(xrpAddress, xrpSecret, Object.values(FoundationEvents), false, options);
    }

    /**
     * Propose a new hook candidate.
     * @param {string} hashes Hook candidate hashes in hex format, <GOVERNOR_HASH(32)><REGISTRY_HASH(32)><HEARTBEAT_HASH(32)>.
     * @param {string} shortName Short name for the proposal candidate.
     * @param {*} options [Optional] transaction options.
     * @returns Proposed candidate id.
     */
    async propose(hashes, shortName, options = {}) {
        if (this.xrplAcc.address !== this.config.foundationAddress)
            throw `Invalid foundation address ${this.xrplAcc.address}.`;

        return await super._propose(hashes, shortName, options);
    }

    /**
     * Withdraw a hook candidate.
     * @param {string} candidateId Id of the candidate in hex format.
     * @param {*} options [Optional] transaction options.
     * @returns Transaction result.
     */
    async withdraw(candidateId, options = {}) {
        if (this.xrplAcc.address !== this.config.foundationAddress)
            throw `Invalid foundation address ${this.xrplAcc.address}.`;

        return await super._withdraw(candidateId, options);
    }

    /**
     * Vote for a hook candidate.
     * @param {string} candidateId Id of the candidate in hex format.
     * @param {int} vote Vote value CandidateVote (0 - Reject, 1 - Support).
     * @param {*} options [Optional] transaction options.
     * @returns Transaction result.
     */
    async vote(candidateId, vote, options = {}) {
        if (this.xrplAcc.address !== this.config.foundationAddress)
            throw `Invalid foundation address ${this.xrplAcc.address}.`;

        const voteBuf = Buffer.alloc(CANDIDATE_VOTE_PARAM_SIZE);
        Buffer.from(candidateId, 'hex').copy(voteBuf, CANDIDATE_VOTE_UNIQUE_ID_PARAM_OFFSET);
        voteBuf.writeUInt8(vote, CANDIDATE_VOTE_VALUE_PARAM_OFFSET);

        return await this.xrplAcc.makePayment(this.config.heartbeatAddress,
            XrplConstants.MIN_DROPS,
            null,
            null,
            null,
            {
                hookParams: [
                    { name: HookParamKeys.PARAM_EVENT_TYPE_KEY, value: EventTypes.CANDIDATE_VOTE },
                    { name: HookParamKeys.PARAM_EVENT_DATA_KEY, value: voteBuf.toString('hex').toUpperCase() }
                ],
                ...options.transactionOptions
            });
    }

    /**
     * Report dud host for removal.
     * @param {string} hostAddress Address of the dud host.
     * @param {*} options [Optional] transaction options.
     * @returns Transaction result.
     */
    async reportDudHost(hostAddress, options = {}) {
        if (this.xrplAcc.address !== this.config.foundationAddress)
            throw `Invalid foundation address ${this.xrplAcc.address}.`;

        return await this._reportDudHost(hostAddress, options);
    }

    /**
     * Vote for a dud host.
     * @param {string} hostAddress Address of the dud host.
     * @param {int} vote Vote value CandidateVote (0 - Reject, 1 - Support).
     * @param {*} options [Optional] transaction options.
     * @returns Transaction result.
     */
    async voteDudHost(hostAddress, vote, options = {}) {
        if (this.xrplAcc.address !== this.config.foundationAddress)
            throw `Invalid foundation address ${this.xrplAcc.address}.`;

        const candidateId = StateHelpers.getDudHostCandidateId(hostAddress);
        return await this.vote(candidateId, vote, options);
    }

    /**
     * Vote for a piloted mode.
     * @param {int} vote Vote value CandidateVote (0 - Reject, 1 - Support).
     * @param {*} options [Optional] transaction options.
     * @returns Transaction result.
     */
    async votePilotedMode(vote, options = {}) {
        if (this.xrplAcc.address !== this.config.foundationAddress)
            throw `Invalid foundation address ${this.xrplAcc.address}.`;

        const candidateId = StateHelpers.getPilotedModeCandidateId();
        return await this.vote(candidateId, vote, options);
    }

    /**
     * Change the governance mode.
     * @param {int} mode Mode  (1 - Piloted, 2 - CoPiloted, 3 - AutoPiloted).
     * @param {*} options [Optional] transaction options.
     * @returns Transaction result.
     */
    async changeGovernanceMode(mode, options = {}) {
        if (this.xrplAcc.address !== this.config.foundationAddress)
            throw `Invalid foundation address ${this.xrplAcc.address}.`;

        const modeBuf = Buffer.alloc(1);
        modeBuf.writeUInt8(mode);

        return await this.xrplAcc.makePayment(this.governorAddress,
            XrplConstants.MIN_DROPS,
            null,
            null,
            null,
            {
                hookParams: [
                    { name: HookParamKeys.PARAM_EVENT_TYPE_KEY, value: EventTypes.GOVERNANCE_MODE_CHANGE },
                    { name: HookParamKeys.PARAM_EVENT_DATA_KEY, value: modeBuf.toString('hex').toUpperCase() }
                ],
                ...options.transactionOptions
            });
    }

    /**
     * Update the reputation of the host.
     * @param {string} hostAddress Address of the dud host.
     * @param {number} reputation Host reputation value.
     * @param {*} options [Optional] transaction options.
     * @returns Transaction result.
     */
    async updateHostReputation(hostAddress, reputation, options = {}) {
        if (this.xrplAcc.address !== this.config.foundationAddress)
            throw `Invalid foundation address ${this.xrplAcc.address}.`;

        const reputationBuf = Buffer.alloc(REPUTATION_PARAM_SIZE);
        codec.decodeAccountID(hostAddress).copy(reputationBuf, REPUTATION_HOST_ADDRESS_PARAM_OFFSET);
        reputationBuf.writeUInt8(reputation, REPUTATION_VALUE_PARAM_OFFSET)

        return await this.xrplAcc.makePayment(this.config.registryAddress,
            XrplConstants.MIN_DROPS,
            null,
            null,
            null,
            {
                hookParams: [
                    { name: HookParamKeys.PARAM_EVENT_TYPE_KEY, value: EventTypes.HOST_UPDATE_REPUTATION },
                    { name: HookParamKeys.PARAM_EVENT_DATA_KEY, value: reputationBuf.toString('hex').toUpperCase() }
                ],
                ...options.transactionOptions
            });
    }
}

module.exports = {
    FoundationEvents,
    FoundationClient
}

/***/ }),

/***/ 335:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { BaseEvernodeClient } = __nccwpck_require__(6263);
const { Defaults } = __nccwpck_require__(8262);
const { EvernodeEvents } = __nccwpck_require__(9849);

const GovernorEvents = {
    Initialized: EvernodeEvents.Initialized,
    CandidateProposed: EvernodeEvents.CandidateProposed,
    CandidateWithdrawn: EvernodeEvents.CandidateWithdrawn,
    ChildHookUpdated: EvernodeEvents.ChildHookUpdated,
    GovernanceModeChanged: EvernodeEvents.GovernanceModeChanged,
    DudHostReported: EvernodeEvents.DudHostReported,
    DudHostRemoved: EvernodeEvents.DudHostRemoved,
    DudHostStatusChanged: EvernodeEvents.DudHostStatusChanged,
    FallbackToPiloted: EvernodeEvents.FallbackToPiloted,
    NewHookStatusChanged: EvernodeEvents.NewHookStatusChanged,
    LinkedDudHostCandidateRemoved: EvernodeEvents.LinkedDudHostCandidateRemoved
}

class GovernorClient extends BaseEvernodeClient {
    constructor(options = {}) {
        super((options.governorAddress || Defaults.values.governorAddress), null, Object.values(GovernorEvents), false, options);
    }
}

module.exports = {
    GovernorClient,
    GovernorEvents
}

/***/ }),

/***/ 6510:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { BaseEvernodeClient } = __nccwpck_require__(6263);
const { EvernodeEvents } = __nccwpck_require__(9849);

const HeartbeatEvents = {
    Heartbeat: EvernodeEvents.Heartbeat,
    FoundationVoted: EvernodeEvents.FoundationVoted
}

class HeartbeatClient extends BaseEvernodeClient {
    constructor(options = {}) {
        super(options.heartbeatAddress, null, Object.values(HeartbeatEvents), false, options);
    }
}

module.exports = {
    HeartbeatClient,
    HeartbeatEvents
}

/***/ }),

/***/ 2344:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { HookTypes } = __nccwpck_require__(8262);
const { RegistryClient } = __nccwpck_require__(8074);
const { GovernorClient } = __nccwpck_require__(335);
const { HeartbeatClient } = __nccwpck_require__(6510);

class HookClientFactory {
    /**
     * Creates a hook client from given type.
     * @param {string} hookType Type of the Required Hook. (Supported Hook types 'GOVERNOR', 'REGISTRY' and 'HEARTBEAT')
     * @returns Instance of requested HookClient type.
     */
    static async create(hookType) {
        let hookClient;
        switch (hookType) {
            case HookTypes.governor: {
                hookClient = new GovernorClient();
                break;
            }
            case HookTypes.registry: {
                const registryAddress = await HookClientFactory.#getAccountAddress(hookType);
                hookClient = new RegistryClient({ registryAddress: registryAddress });
                break;
            }
            case HookTypes.heartbeat: {
                const heartbeatAddress = await HookClientFactory.#getAccountAddress(hookType);
                hookClient = new HeartbeatClient({ heartbeatAddress: heartbeatAddress });
                break;
            }
            default: {
                hookClient = null;
                break;
            }
        }

        return hookClient;
    }

    static async #getAccountAddress(hookType) {
        const governorHook = await HookClientFactory.create(HookTypes.governor);

        let configs;
        try {
            await governorHook.connect();
            configs = governorHook.config;
        } catch (error) {
            throw (error)
        } finally {
            await governorHook.disconnect();
        }

        if (hookType == HookTypes.registry)
            return configs.registryAddress;
        else if (hookType == HookTypes.heartbeat)
            return configs.heartbeatAddress;

    }
}

module.exports = {
    HookClientFactory
}

/***/ }),

/***/ 8074:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { BaseEvernodeClient } = __nccwpck_require__(6263);
const { EvernodeEvents } = __nccwpck_require__(9849);

const RegistryEvents = {
    HostRegistered: EvernodeEvents.HostRegistered,
    HostDeregistered: EvernodeEvents.HostDeregistered,
    HostRegUpdated: EvernodeEvents.HostRegUpdated,
    DeadHostPrune: EvernodeEvents.DeadHostPrune,
    HostTransfer: EvernodeEvents.HostTransfer,
    HostRebate: EvernodeEvents.HostRebate,
    HostReputationUpdated: EvernodeEvents.HostReputationUpdated
}

class RegistryClient extends BaseEvernodeClient {

    constructor(options = {}) {
        super(options.registryAddress, null, Object.values(RegistryEvents), false, options);
    }

    /**
     * Gets all the active hosts registered in ledger.
     * @returns The list of active hosts.
     */
    async getActiveHostsFromLedger() {
        const hosts = await this.getAllHostsFromLedger();
        // Filter only active hosts.
        return hosts.filter(h => h.active);
    }
}

module.exports = {
    RegistryClient,
    RegistryEvents
}

/***/ }),

/***/ 1437:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { XrplConstants } = __nccwpck_require__(3307);
const { BaseEvernodeClient } = __nccwpck_require__(6263);
const { EvernodeEvents, EvernodeConstants, MemoFormats, EventTypes, ErrorCodes, HookParamKeys, RegExp } = __nccwpck_require__(9849);
const { XrplAccount } = __nccwpck_require__(9329);
const { EncryptionHelper } = __nccwpck_require__(4832);
const { Buffer } = __nccwpck_require__(4300);
const codec = __nccwpck_require__(597);
const { XflHelpers } = __nccwpck_require__(3243);
const { EvernodeHelpers } = __nccwpck_require__(2523);
const { StateHelpers } = __nccwpck_require__(3860);
const { TransactionHelper } = __nccwpck_require__(7071);

const OFFER_WAIT_TIMEOUT = 60;

const HostEvents = {
    AcquireLease: EvernodeEvents.AcquireLease,
    ExtendLease: EvernodeEvents.ExtendLease
}

const HOST_COUNTRY_CODE_PARAM_OFFSET = 0;
const HOST_CPU_MICROSEC_PARAM_OFFSET = 2;
const HOST_RAM_MB_PARAM_OFFSET = 6;
const HOST_DISK_MB_PARAM_OFFSET = 10;
const HOST_TOT_INS_COUNT_PARAM_OFFSET = 14;
const HOST_CPU_MODEL_NAME_PARAM_OFFSET = 18;
const HOST_CPU_COUNT_PARAM_OFFSET = 58;
const HOST_CPU_SPEED_PARAM_OFFSET = 60;
const HOST_DESCRIPTION_PARAM_OFFSET = 62;
const HOST_EMAIL_ADDRESS_PARAM_OFFSET = 88;
const HOST_LEASE_AMOUNT_PARAM_OFFSET = 128;
const HOST_REG_PARAM_SIZE = 136;

const HOST_UPDATE_TOKEN_ID_PARAM_OFFSET = 0;
const HOST_UPDATE_COUNTRY_CODE_PARAM_OFFSET = 32;
const HOST_UPDATE_CPU_MICROSEC_PARAM_OFFSET = 34;
const HOST_UPDATE_RAM_MB_PARAM_OFFSET = 38;
const HOST_UPDATE_DISK_MB_PARAM_OFFSET = 42;
const HOST_UPDATE_TOT_INS_COUNT_PARAM_OFFSET = 46;
const HOST_UPDATE_ACT_INS_COUNT_PARAM_OFFSET = 50;
const HOST_UPDATE_DESCRIPTION_PARAM_OFFSET = 54;
const HOST_UPDATE_VERSION_PARAM_OFFSET = 80;
const HOST_UPDATE_EMAIL_ADDRESS_PARAM_OFFSET = 83;
const HOST_UPDATE_LEASE_AMOUNT_PARAM_OFFSET = 123;
const HOST_UPDATE_PARAM_SIZE = 131;

const VOTE_VALIDATION_ERR = "VOTE_VALIDATION_ERR";

const IPV6_FAMILY = 6;

const MAX_HOST_LEDGER_OFFSET = 30;
const TX_RETRY_INTERVAL = 10000;

class HostClient extends BaseEvernodeClient {

    constructor(xrpAddress, xrpSecret, options = {}) {
        super(xrpAddress, xrpSecret, Object.values(HostEvents), true, options);
    }

    /**
     * Get max ledger sequence for host client.
     * @returns Max ledger sequence number.
     */
    #getMaxLedgerSequence() {
        return (this.xrplApi.ledgerIndex + MAX_HOST_LEDGER_OFFSET);
    }

    /**
     * Get registration URI token info.
     * @returns The registration URI token object.
     */
    async getRegistrationUriToken() {
        // Find an owned NFT with matching Evernode host NFT prefix.
        const uriToken = (await this.xrplAcc.getURITokens()).find(n => n.URI.startsWith(EvernodeConstants.TOKEN_PREFIX_HEX) && n.Issuer === this.config.registryAddress);
        return uriToken ?? null;
    }

    /**
     * Get host info if registered.
     * @returns Host info object if registered, Otherwise null.
     */
    async getRegistration() {
        // Check whether we own an evernode host token.
        const regUriToken = await this.getRegistrationUriToken();
        if (regUriToken) {
            const host = await this.getHostInfo();
            return (host?.uriTokenId == regUriToken.index) ? host : null;
        }

        return null;
    }

    /**
     * Get offered and unoffered leases created by the host.
     * @returns Array of lease offer objects.
     */
    async getLeases() {
        return await EvernodeHelpers.getLeases(this.xrplAcc);
    }

    /**
     * Get lease offers created by the host.
     * @returns Array of lease offer objects.
     */
    async getLeaseOffers() {
        return await EvernodeHelpers.getLeaseOffers(this.xrplAcc);
    }

    /**
     * Get unoffered leases created by the host.
     * @returns Array of lease objects.
     */
    async getUnofferedLeases() {
        return await EvernodeHelpers.getUnofferedLeases(this.xrplAcc);
    }

    /**
     * Check wether the host is registered.
     * @returns Boolean if the host is registered or not.
     */
    async isRegistered() {
        return (await this.getRegistration()) !== null;
    }

    async #submitWithRetry(callback, options = {}) {
        let attempt = 0;
        let feeUplift = 0;
        const maxAttempts = (options?.maxRetryAttempts || 10);
        let submissionRef = options.submissionRef || {};
        while (attempt <= maxAttempts) {
            attempt++;
            try {
                return await callback(feeUplift, submissionRef);
            }
            catch (e) {
                if (attempt == maxAttempts || e.code === "tecDUPLICATE" || e.code === "tefPAST_SEQ" || e.code === "tefALREADY")
                    throw e;
                else if (e.status === "TOOK_LONG") {
                    feeUplift += (options?.feeUplift || 0);
                }
                console.error(e);
                console.error(`Submission attempt ${attempt} failed. Retrying...`);
                await new Promise(resolve => setTimeout(resolve, TX_RETRY_INTERVAL));

                // Check again wether the transaction is validated before retry.
                const txHash = submissionRef?.submissionResult?.result?.tx_json?.hash;
                if (txHash) {
                    const txResponse = await this.xrplApi.getTransactionValidatedResults(txHash);
                    if (txResponse && txResponse.code === "tesSUCCESS") {
                        console.log('Transaction is validated and success, Retry skipped!')
                        return txResponse;
                    }
                }
            }
        }
    }

    /**
     * Prepare the host account with account fields and trust lines.
     * @param {string} domain Domain which the host machine is reachable.
     */
    async prepareAccount(domain, options = {}) {
        const [flags, trustLines, msgKey, curDomain] = await Promise.all([
            this.xrplAcc.getFlags(),
            this.xrplAcc.getTrustLines(EvernodeConstants.EVR, this.config.evrIssuerAddress),
            this.xrplAcc.getMessageKey(),
            this.xrplAcc.getDomain()]);

        let accountSetFields = {};
        accountSetFields = (flags.lsfDefaultRipple) ? { ...accountSetFields, Flags: { asfDefaultRipple: false } } : accountSetFields;
        accountSetFields = (!msgKey) ? { ...accountSetFields, MessageKey: this.accKeyPair.publicKey } : accountSetFields;

        domain = domain.toLowerCase();
        accountSetFields = (!curDomain || curDomain !== domain) ?
            { ...accountSetFields, Domain: domain } : accountSetFields;

        if (Object.keys(accountSetFields).length !== 0) {
            await this.#submitWithRetry(async (feeUplift, submissionRef) => {
                await this.xrplAcc.setAccountFields(accountSetFields, { maxLedgerIndex: this.#getMaxLedgerSequence(), feeUplift: feeUplift, submissionRef: submissionRef });
            }, { ...(options.retryOptions ? options.retryOptions : {}), submissionRef: options.submissionRef });
        }

        if (trustLines.length === 0) {
            await this.#submitWithRetry(async (feeUplift, submissionRef) => {
                await this.xrplAcc.setTrustLine(EvernodeConstants.EVR, this.config.evrIssuerAddress, "99999999999999", null, null, { maxLedgerIndex: this.#getMaxLedgerSequence(), feeUplift: feeUplift, submissionRef: submissionRef });
            }, { ...(options.retryOptions ? options.retryOptions : {}), submissionRef: options.submissionRef });
        }
    }

    /**
     * Create a lease offer.
     * @param {number} leaseIndex Index number for the lease.
     * @param {number} leaseAmount Amount (EVRs) of the lease offer.
     * @param {string} tosHash Hex hash of the Terms Of Service text.
     * @param {string} outboundIPAddress Assigned IP Address.
     */
    async offerLease(leaseIndex, leaseAmount, tosHash, outboundIPAddress = null, options = {}) {

        // <prefix><version tag ("LTV"+uint8)><lease index (uint16)><half of tos hash><lease amount (int64)><identifier (uint32)><ip data>
        // Lengths of sub sections.
        const prefixLen = EvernodeConstants.LEASE_TOKEN_PREFIX_HEX.length / 2;
        const versionPrefixLen = EvernodeConstants.LEASE_TOKEN_VERSION_PREFIX_HEX.length / 2;
        const versionLen = versionPrefixLen + 2; // ("LTV"<Version Number>)
        const indexLen = 2;
        const halfToSLen = tosHash.length / 4;
        const leaseAmountLen = 8;
        const identifierLen = 4;
        const ipDataLen = 17;

        // Offsets of sub sections
        const versionPrefixOffset = prefixLen;
        const versionOffset = prefixLen + versionPrefixLen;
        const indexOffset = prefixLen + versionLen;
        const halfTosHashOffset = prefixLen + versionLen + indexLen;
        const leaseAmountOffset = prefixLen + versionLen + indexLen + halfToSLen;
        const identifierOffset = prefixLen + versionLen + indexLen + halfToSLen + leaseAmountLen;
        const ipDataOffset = prefixLen + versionLen + indexLen + halfToSLen + leaseAmountLen + identifierLen;

        const uriBuf = Buffer.alloc((prefixLen + versionLen + indexLen + halfToSLen + leaseAmountLen + identifierLen + ipDataLen));

        Buffer.from(EvernodeConstants.LEASE_TOKEN_PREFIX_HEX, 'hex').copy(uriBuf);
        Buffer.from(EvernodeConstants.LEASE_TOKEN_VERSION_PREFIX_HEX, 'hex').copy(uriBuf, versionPrefixOffset, 0, versionPrefixLen);
        uriBuf.writeUInt16BE(EvernodeConstants.LEASE_TOKEN_VERSION, versionOffset);
        uriBuf.writeUInt16BE(leaseIndex, indexOffset);
        Buffer.from(tosHash, 'hex').copy(uriBuf, halfTosHashOffset, 0, halfToSLen);
        uriBuf.writeBigInt64BE(XflHelpers.getXfl(leaseAmount.toString()), leaseAmountOffset);
        uriBuf.writeUInt32BE((await this.xrplAcc.getSequence()), identifierOffset);

        if (outboundIPAddress) {
            if (outboundIPAddress.includes(":")) {
                uriBuf.writeUInt8(IPV6_FAMILY, ipDataOffset);
                const ipBuf = Buffer.from(outboundIPAddress.split(':').map(v => {
                    const bytes = [];
                    for (let i = 0; i < v.length; i += 2) {
                        bytes.push(parseInt(v.substr(i, 2), 16));
                    }
                    return bytes;
                }).flat());

                ipBuf.copy(uriBuf, ipDataOffset + 1, 0, ipDataLen);
            } else {
                throw "Invalid outbound IP address was provided";
            }
        }

        const uri = uriBuf.toString('base64');

        try {
            await this.#submitWithRetry(async (feeUplift, submissionRef) => {
                await this.xrplAcc.mintURIToken(uri, null, { isBurnable: true, isHexUri: false }, { maxLedgerIndex: this.#getMaxLedgerSequence(), feeUplift: feeUplift, submissionRef: submissionRef });
            }, { ...(options.retryOptions ? options.retryOptions : {}), submissionRef: options.submissionRef });
        } catch (e) {
            // Re-minting the URIToken after burning that sold URIToken.
            if (e.code === "tecDUPLICATE") {
                const uriTokenId = this.xrplAcc.generateIssuedURITokenId(uri);
                console.log(`Burning URIToken related to a previously sold lease.`);
                await this.xrplAcc.burnURIToken(uriTokenId, { maxLedgerIndex: this.#getMaxLedgerSequence() });
                console.log("Re-mint the URIToken for the new lease offer.")
                await this.xrplAcc.mintURIToken(uri, null, { isBurnable: true, isHexUri: false }, { maxLedgerIndex: this.#getMaxLedgerSequence() });
            }
        }

        const uriToken = await this.xrplAcc.getURITokenByUri(uri);
        if (!uriToken)
            throw "Offer lease NFT creation error.";

        await this.#submitWithRetry(async (feeUplift, submissionRef) => {
            await this.xrplAcc.sellURIToken(uriToken.index,
                leaseAmount.toString(),
                EvernodeConstants.EVR,
                this.config.evrIssuerAddress, null, null, { maxLedgerIndex: this.#getMaxLedgerSequence(), feeUplift: feeUplift, submissionRef: submissionRef });
        }, { ...(options.retryOptions ? options.retryOptions : {}), submissionRef: options.submissionRef });
    }

    /**
     * Mint a lease offer.
     * @param {number} leaseIndex Index number for the lease.
     * @param {number} leaseAmount Amount (EVRs) of the lease offer.
     * @param {string} tosHash Hex hash of the Terms Of Service text.
     * @param {string} outboundIPAddress Assigned IP Address.
     */
    async mintLease(leaseIndex, leaseAmount, tosHash, outboundIPAddress = null, options = {}) {

        // <prefix><version tag ("LTV"+uint8)><lease index (uint16)><half of tos hash><lease amount (int64)><identifier (uint32)><ip data>
        // Lengths of sub sections.
        const prefixLen = EvernodeConstants.LEASE_TOKEN_PREFIX_HEX.length / 2;
        const versionPrefixLen = EvernodeConstants.LEASE_TOKEN_VERSION_PREFIX_HEX.length / 2;
        const versionLen = versionPrefixLen + 2; // ("LTV"<Version Number>)
        const indexLen = 2;
        const halfToSLen = tosHash.length / 4;
        const leaseAmountLen = 8;
        const identifierLen = 4;
        const ipDataLen = 17;

        // Offsets of sub sections
        const versionPrefixOffset = prefixLen;
        const versionOffset = prefixLen + versionPrefixLen;
        const indexOffset = prefixLen + versionLen;
        const halfTosHashOffset = prefixLen + versionLen + indexLen;
        const leaseAmountOffset = prefixLen + versionLen + indexLen + halfToSLen;
        const identifierOffset = prefixLen + versionLen + indexLen + halfToSLen + leaseAmountLen;
        const ipDataOffset = prefixLen + versionLen + indexLen + halfToSLen + leaseAmountLen + identifierLen;

        const uriBuf = Buffer.alloc((prefixLen + versionLen + indexLen + halfToSLen + leaseAmountLen + identifierLen + ipDataLen));

        Buffer.from(EvernodeConstants.LEASE_TOKEN_PREFIX_HEX, 'hex').copy(uriBuf);
        Buffer.from(EvernodeConstants.LEASE_TOKEN_VERSION_PREFIX_HEX, 'hex').copy(uriBuf, versionPrefixOffset, 0, versionPrefixLen);
        uriBuf.writeUInt16BE(EvernodeConstants.LEASE_TOKEN_VERSION, versionOffset);
        uriBuf.writeUInt16BE(leaseIndex, indexOffset);
        Buffer.from(tosHash, 'hex').copy(uriBuf, halfTosHashOffset, 0, halfToSLen);
        uriBuf.writeBigInt64BE(XflHelpers.getXfl(leaseAmount.toString()), leaseAmountOffset);
        uriBuf.writeUInt32BE((await this.xrplAcc.getSequence()), identifierOffset);

        if (outboundIPAddress) {
            if (outboundIPAddress.includes(":")) {
                uriBuf.writeUInt8(IPV6_FAMILY, ipDataOffset);
                const ipBuf = Buffer.from(outboundIPAddress.split(':').map(v => {
                    const bytes = [];
                    for (let i = 0; i < v.length; i += 2) {
                        bytes.push(parseInt(v.substr(i, 2), 16));
                    }
                    return bytes;
                }).flat());

                ipBuf.copy(uriBuf, ipDataOffset + 1, 0, ipDataLen);
            } else {
                throw "Invalid outbound IP address was provided";
            }
        }

        const uri = uriBuf.toString('base64');

        try {
            await this.#submitWithRetry(async (feeUplift, submissionRef) => {
                await this.xrplAcc.mintURIToken(uri, null, { isBurnable: true, isHexUri: false }, { maxLedgerIndex: this.#getMaxLedgerSequence(), feeUplift: feeUplift, submissionRef: submissionRef });
            }, { ...(options.retryOptions ? options.retryOptions : {}), submissionRef: options.submissionRef });
        } catch (e) {
            // Re-minting the URIToken after burning that sold URIToken.
            if (e.code === "tecDUPLICATE") {
                const uriTokenId = this.xrplAcc.generateIssuedURITokenId(uri);
                console.log(`Burning URIToken related to a previously sold lease.`);
                await this.xrplAcc.burnURIToken(uriTokenId, { maxLedgerIndex: this.#getMaxLedgerSequence() });
                console.log("Re-mint the URIToken for the new lease offer.")
                await this.xrplAcc.mintURIToken(uri, null, { isBurnable: true, isHexUri: false }, { maxLedgerIndex: this.#getMaxLedgerSequence() });
            }
        }
    }

    /**
     * Create a lease offer.
     * @param {number} uriTokenId Id of the token.
     * @param {number} leaseAmount Amount (EVRs) of the lease offer.
     */
    async offerMintedLease(uriTokenId, leaseAmount, options = {}) {
        await this.#submitWithRetry(async (feeUplift, submissionRef) => {
            await this.xrplAcc.sellURIToken(uriTokenId, leaseAmount.toString(),
                EvernodeConstants.EVR,
                this.config.evrIssuerAddress, null, null, { maxLedgerIndex: this.#getMaxLedgerSequence(), feeUplift: feeUplift, submissionRef: submissionRef });
        }, { ...(options.retryOptions ? options.retryOptions : {}), submissionRef: options.submissionRef });
    }

    /**
     * Expire the lease offer.
     * @param {string} uriTokenId Hex URI token id of the lease.
     */
    async expireLease(uriTokenId, options = {}) {
        await this.#submitWithRetry(async (feeUplift, submissionRef) => {
            await this.xrplAcc.burnURIToken(uriTokenId, { maxLedgerIndex: this.#getMaxLedgerSequence(), feeUplift: feeUplift, submissionRef: submissionRef });
        }, { ...(options.retryOptions ? options.retryOptions : {}), submissionRef: options.submissionRef });
    }

    /**
     * Accepts if there's an available reg token.
     * @param {*} options [Optional] transaction options.
     * @returns True if there were reg token and it's accepted, Otherwise false.
     */
    async acceptRegToken(options = {}) {
        // Check whether is there any missed NFT sell offer that needs to be accepted
        // from the client-side in order to complete the registration.
        const registryAcc = new XrplAccount(this.config.registryAddress, null, { xrplApi: this.xrplApi });
        const regUriToken = await this.getRegistrationUriToken();

        if (!regUriToken) {
            const regInfo = await this.getHostInfo(this.xrplAcc.address);
            if (regInfo) {
                const sellOffer = (await registryAcc.getURITokens()).find(o => o.index == regInfo.uriTokenId && o.Amount);
                console.log('Pending sell offer found.')
                if (sellOffer) {
                    await this.#submitWithRetry(async (feeUplift, submissionRef) => {
                        await this.xrplAcc.buyURIToken(sellOffer, null, { maxLedgerIndex: this.#getMaxLedgerSequence(), feeUplift: feeUplift, submissionRef: submissionRef });
                    }, { ...(options.retryOptions ? options.retryOptions : {}), submissionRef: options.submissionRef });
                    console.log("Registration was successfully completed after acquiring the NFT.");
                    return await this.isRegistered();
                }
            }
        }

        return false;
    }

    /**
     * Register the host in the Evernode network.
     * @param {string} countryCode Upper case country code with two letters.
     * @param {number} cpuMicroSec CPU cycle in micro seconds of the host.
     * @param {number} ramMb Ram size in mega bytes.
     * @param {number} diskMb Disk size in mega bytes.
     * @param {number} totalInstanceCount Total number of instance slots in the host.
     * @param {string} cpuModel Model of the host CPU.
     * @param {number} cpuCount Number of CPUs in the host.
     * @param {number} cpuSpeed CPU MHz.
     * @param {string} description Description about the host.
     * @param {string} emailAddress Email address of the host.
     * @param {number} leaseAmount Lease fee of the host.
     * @param {*} options [Optional] transaction options.
     * @returns Transaction result.
     */
    async register(countryCode, cpuMicroSec, ramMb, diskMb, totalInstanceCount, cpuModel, cpuCount, cpuSpeed, description, emailAddress, leaseAmount, options = {}) {
        if (!/^([A-Z]{2})$/.test(countryCode))
            throw "countryCode should consist of 2 uppercase alphabetical characters";
        else if (!cpuMicroSec || isNaN(cpuMicroSec) || cpuMicroSec % 1 != 0 || cpuMicroSec < 0)
            throw "cpuMicroSec should be a positive integer";
        else if (!ramMb || isNaN(ramMb) || ramMb % 1 != 0 || ramMb < 0)
            throw "ramMb should be a positive integer";
        else if (!diskMb || isNaN(diskMb) || diskMb % 1 != 0 || diskMb < 0)
            throw "diskMb should be a positive integer";
        else if (!totalInstanceCount || isNaN(totalInstanceCount) || totalInstanceCount % 1 != 0 || totalInstanceCount < 0)
            throw "totalInstanceCount should be a positive integer";
        else if (!cpuCount || isNaN(cpuCount) || cpuCount % 1 != 0 || cpuCount < 0)
            throw "CPU count should be a positive integer";
        else if (!cpuSpeed || isNaN(cpuSpeed) || cpuSpeed % 1 != 0 || cpuSpeed < 0)
            throw "CPU speed should be a positive integer";
        else if (!cpuModel)
            throw "cpu model cannot be empty";
        else if (!leaseAmount || isNaN(leaseAmount) || diskMb < 0)
            throw "leaseAmount should be a positive float";

        // Need to use control characters inside this regex to match ascii characters.
        // Here we allow all the characters in ascii range except ";" for the description.
        // no-control-regex is enabled default by eslint:recommended, So we disable it only for next line.
        // eslint-disable-next-line no-control-regex
        else if (!/^((?![;])[\x00-\x7F]){0,26}$/.test(description))
            throw "description should consist of 0-26 ascii characters except ';'";

        else if (!emailAddress || !(/.+@.+/.test(emailAddress)) || (emailAddress.length > 40))
            throw "Email address should be valid and can not have more than 40 characters.";

        if (await this.isRegistered())
            throw "Host already registered.";

        // Check whether are there lease offers in for the host due to a previous registration.
        const existingLeaseURITokens = (await this.xrplAcc.getURITokens()).filter(n => n.Issuer == this.xrplAcc.address && EvernodeHelpers.isValidURI(n.URI, EvernodeConstants.LEASE_TOKEN_PREFIX_HEX));
        if (existingLeaseURITokens) {
            console.log("Burning unsold URITokens related to the previous leases.");
            for (const uriToken of existingLeaseURITokens) {
                await this.#submitWithRetry(async (feeUplift, submissionRef) => {
                    await this.xrplAcc.burnURIToken(uriToken.index, { maxLedgerIndex: this.#getMaxLedgerSequence(), feeUplift: feeUplift, submissionRef: submissionRef });
                }, { ...(options.retryOptions ? options.retryOptions : {}), submissionRef: options.submissionRef });
            }
        }

        if (await this.acceptRegToken())
            return true;

        // Check the availability of an initiated transfer.
        // Need to modify the amount accordingly.
        const stateTransfereeAddrKey = StateHelpers.generateTransfereeAddrStateKey(this.xrplAcc.address);
        const stateTransfereeAddrIndex = StateHelpers.getHookStateIndex(this.governorAddress, stateTransfereeAddrKey);
        let transfereeAddrLedgerEntry = {};
        let transfereeAddrStateData = {};
        let transferredNFTokenId = null;

        try {
            const res = await this.xrplApi.getLedgerEntry(stateTransfereeAddrIndex);
            transfereeAddrLedgerEntry = { ...transfereeAddrLedgerEntry, ...res };
            transfereeAddrStateData = transfereeAddrLedgerEntry?.HookStateData;
            const transfereeAddrStateDecoded = StateHelpers.decodeTransfereeAddrState(Buffer.from(stateTransfereeAddrKey, 'hex'), Buffer.from(transfereeAddrStateData, 'hex'));
            transferredNFTokenId = transfereeAddrStateDecoded?.transferredNfTokenId;

        }
        catch (e) {
            console.log("No initiated transfers were found.");
        }

        // <country_code(2)><cpu_microsec(4)><ram_mb(4)><disk_mb(4)><no_of_total_instances(4)><cpu_model(40)><cpu_count(2)><cpu_speed(2)><description(26)><email_address(40)><host_lease_amount(8,xfl)>
        const paramBuf = Buffer.alloc(HOST_REG_PARAM_SIZE, 0);
        Buffer.from(countryCode.substr(0, 2), "utf-8").copy(paramBuf, HOST_COUNTRY_CODE_PARAM_OFFSET);
        paramBuf.writeUInt32LE(cpuMicroSec, HOST_CPU_MICROSEC_PARAM_OFFSET);
        paramBuf.writeUInt32LE(ramMb, HOST_RAM_MB_PARAM_OFFSET);
        paramBuf.writeUInt32LE(diskMb, HOST_DISK_MB_PARAM_OFFSET);
        paramBuf.writeUInt32LE(totalInstanceCount, HOST_TOT_INS_COUNT_PARAM_OFFSET);
        Buffer.from(cpuModel.substr(0, 40), "utf-8").copy(paramBuf, HOST_CPU_MODEL_NAME_PARAM_OFFSET);
        paramBuf.writeUInt16LE(cpuCount, HOST_CPU_COUNT_PARAM_OFFSET);
        paramBuf.writeUInt16LE(cpuSpeed, HOST_CPU_SPEED_PARAM_OFFSET);
        Buffer.from(description.substr(0, 26), "utf-8").copy(paramBuf, HOST_DESCRIPTION_PARAM_OFFSET);
        Buffer.from(emailAddress.substr(0, 40), "utf-8").copy(paramBuf, HOST_EMAIL_ADDRESS_PARAM_OFFSET);
        paramBuf.writeBigInt64LE(XflHelpers.getXfl(leaseAmount.toString()), HOST_LEASE_AMOUNT_PARAM_OFFSET);

        const tx = await this.#submitWithRetry(async (feeUplift, submissionRef) => {
            return await this.xrplAcc.makePayment(this.config.registryAddress,
                (transferredNFTokenId) ? EvernodeConstants.NOW_IN_EVRS : this.config.hostRegFee.toString(),
                EvernodeConstants.EVR,
                this.config.evrIssuerAddress,
                null,
                {
                    hookParams: [
                        { name: HookParamKeys.PARAM_EVENT_TYPE_KEY, value: EventTypes.HOST_REG },
                        { name: HookParamKeys.PARAM_EVENT_DATA_KEY, value: paramBuf.toString('hex').toUpperCase() }
                    ],
                    maxLedgerIndex: this.#getMaxLedgerSequence(),
                    feeUplift: feeUplift, submissionRef: submissionRef,
                    ...options.transactionOptions
                });
        }, { ...(options.retryOptions ? options.retryOptions : {}), submissionRef: options.submissionRef });

        console.log('Waiting for the sell offer', tx.id)
        const registryAcc = new XrplAccount(this.config.registryAddress, null, { xrplApi: this.xrplApi });
        let sellOffer = null;
        let attempts = 0;
        let offerLedgerIndex = 0;
        const firstPart = tx.id.substring(0, 8);
        const lastPart = tx.id.substring(tx.id.length - 8);
        const trxRef = TransactionHelper.asciiToHex(firstPart + lastPart);
        while (attempts < OFFER_WAIT_TIMEOUT) {
            sellOffer = (await registryAcc.getURITokens()).find(n => (
                n.Amount &&
                n.Destination === this.xrplAcc.address &&
                (!transferredNFTokenId ?
                    (n.URI === `${EvernodeConstants.TOKEN_PREFIX_HEX}${trxRef}`) :
                    (n.index === transferredNFTokenId))));

            offerLedgerIndex = this.xrplApi.ledgerIndex;
            if (sellOffer)
                break;
            await new Promise(resolve => setTimeout(resolve, 1000));
            attempts++;
        }
        if (!sellOffer)
            throw 'No sell offer found within timeout.';

        console.log('Accepting the sell offer..');

        // Wait until the next ledger after the offer is created.
        // Otherwise if the offer accepted in the same legder which it's been created,
        // We cannot fetch the offer from registry contract event handler since it's getting deleted immediately.
        await new Promise(async resolve => {
            while (this.xrplApi.ledgerIndex <= offerLedgerIndex)
                await new Promise(resolve2 => setTimeout(resolve2, 1000));
            resolve();
        });

        await this.#submitWithRetry(async (feeUplift, submissionRef) => {
            await this.xrplAcc.buyURIToken(sellOffer, null, { maxLedgerIndex: this.#getMaxLedgerSequence(), feeUplift: feeUplift, submissionRef: submissionRef });
        }, { ...(options.retryOptions ? options.retryOptions : {}), submissionRef: options.submissionRef });
        return await this.isRegistered();
    }

    /**
     * Deregister a host from the Evernode network.
     * @param {string} error [Optional] Error.
     * @param {*} options [Optional] transaction options.
     * @returns Boolean whether host is registered or not.
     */
    async deregister(error = null, options = {}) {

        if (!(await this.isRegistered()))
            throw "Host not registered."

        const regUriToken = await this.getRegistrationUriToken();
        const paramBuf = Buffer.alloc(33, 0);
        Buffer.from(regUriToken.index, "hex").copy(paramBuf, 0);
        if (error) {
            // <token_id(32)><error(1)>
            paramBuf.writeUInt8(1, 32);
        }

        await this.#submitWithRetry(async (feeUplift, submissionRef) => {
            await this.xrplAcc.makePayment(this.config.registryAddress,
                XrplConstants.MIN_DROPS,
                null,
                null,
                null,
                {
                    hookParams: [
                        { name: HookParamKeys.PARAM_EVENT_TYPE_KEY, value: EventTypes.HOST_DEREG },
                        { name: HookParamKeys.PARAM_EVENT_DATA_KEY, value: paramBuf.toString('hex').toUpperCase() }
                    ],
                    maxLedgerIndex: this.#getMaxLedgerSequence(),
                    feeUplift: feeUplift, submissionRef: submissionRef,
                    ...options.transactionOptions
                });
        }, { ...(options.retryOptions ? options.retryOptions : {}), submissionRef: options.submissionRef });

        return await this.isRegistered();
    }

    /**
     * Update the host registration in the Evernode network.
     * @param {number} activeInstanceCount Currently active instance count in the host.
     * @param {string} version Sashimono version installed on the host
     * @param {number} totalInstanceCount Total number of instance slots in the host.
     * @param {string} tokenID Registration Token Id of the host.
     * @param {string} countryCode Upper case country code with two letters.
     * @param {number} cpuMicroSec 
     * @param {number} ramMb Ram size in mega bytes.
     * @param {number} diskMb Disk size in mega bytes.
     * @param {string} description Description about the host.
     * @param {string} emailAddress Email address of the host.
     * @param {number} leaseAmount Lease fee of the host.
     * @param {*} options [Optional] transaction options.
     * @returns Transaction result.
     */
    async updateRegInfo(activeInstanceCount = null, version = null, totalInstanceCount = null, tokenID = null, countryCode = null, cpuMicroSec = null, ramMb = null, diskMb = null, description = null, emailAddress = null, leaseAmount = null, options = {}) {
        // <token_id(32)><country_code(2)><cpu_microsec(4)><ram_mb(4)><disk_mb(4)><total_instance_count(4)><active_instances(4)><description(26)><version(3)><email(40)>
        const paramBuf = Buffer.alloc(HOST_UPDATE_PARAM_SIZE, 0);
        if (tokenID)
            Buffer.from(tokenID.substr(0, 32), "hex").copy(paramBuf, HOST_UPDATE_TOKEN_ID_PARAM_OFFSET);
        if (countryCode)
            Buffer.from(countryCode.substr(0, 2), "utf-8").copy(paramBuf, HOST_UPDATE_COUNTRY_CODE_PARAM_OFFSET);
        if (cpuMicroSec)
            paramBuf.writeUInt32LE(cpuMicroSec, HOST_UPDATE_CPU_MICROSEC_PARAM_OFFSET);
        if (ramMb)
            paramBuf.writeUInt32LE(ramMb, HOST_UPDATE_RAM_MB_PARAM_OFFSET);
        if (diskMb)
            paramBuf.writeUInt32LE(diskMb, HOST_UPDATE_DISK_MB_PARAM_OFFSET);
        if (totalInstanceCount)
            paramBuf.writeUInt32LE(totalInstanceCount, HOST_UPDATE_TOT_INS_COUNT_PARAM_OFFSET);
        if (activeInstanceCount)
            paramBuf.writeUInt32LE(activeInstanceCount, HOST_UPDATE_ACT_INS_COUNT_PARAM_OFFSET);
        if (description)
            Buffer.from(description.substr(0, 26), "utf-8").copy(paramBuf, HOST_UPDATE_DESCRIPTION_PARAM_OFFSET);
        if (emailAddress)
            Buffer.from(emailAddress.substr(0, 40), "utf-8").copy(paramBuf, HOST_UPDATE_EMAIL_ADDRESS_PARAM_OFFSET);
        if (version) {
            const components = version.split('.').map(v => parseInt(v));
            if (components.length != 3)
                throw 'Invalid version format.';
            paramBuf.writeUInt8(components[0], HOST_UPDATE_VERSION_PARAM_OFFSET);
            paramBuf.writeUInt8(components[1], HOST_UPDATE_VERSION_PARAM_OFFSET + 1);
            paramBuf.writeUInt8(components[2], HOST_UPDATE_VERSION_PARAM_OFFSET + 2);
        }
        if (leaseAmount)
            paramBuf.writeBigInt64LE(XflHelpers.getXfl(leaseAmount.toString()), HOST_UPDATE_LEASE_AMOUNT_PARAM_OFFSET);

        return await this.#submitWithRetry(async (feeUplift, submissionRef) => {
            return await this.xrplAcc.makePayment(this.config.registryAddress,
                XrplConstants.MIN_DROPS,
                null,
                null,
                null,
                {
                    hookParams: [
                        { name: HookParamKeys.PARAM_EVENT_TYPE_KEY, value: EventTypes.HOST_UPDATE_INFO },
                        { name: HookParamKeys.PARAM_EVENT_DATA_KEY, value: paramBuf.toString('hex') }
                    ],
                    maxLedgerIndex: this.#getMaxLedgerSequence(),
                    feeUplift: feeUplift, submissionRef: submissionRef,
                    ...options.transactionOptions
                });
        }, { ...(options.retryOptions ? options.retryOptions : {}), submissionRef: options.submissionRef });

    }

    /**
     * Send a heartbeat from the host.
     * @param {*} voteInfo [Optional] Candidate votes if there's any `{ '<candidateId>': '{number 0|1} vote', ... }`
     * @param {*} options [Optional] transaction options.
     * @returns Transaction result.
     */
    async heartbeat(voteInfo = {}, options = {}) {
        let unofferedLeases = await this.getUnofferedLeases();
        if (unofferedLeases.length > 0) {
            console.log("Unoffered leases detected. Heartbeat was not sent.");
            return;
        }

        let data;
        // Prepare voteInfo
        if (Object.keys(voteInfo).length > 1) {
            let voteBuf = Buffer.alloc(33);
            Buffer.from(voteInfo.candidate, 'hex').copy(voteBuf, 0);
            voteBuf.writeUInt8(voteInfo.vote, 32);
            data = voteBuf.toString('hex').toUpperCase();
        }

        try {
            const res = await this.xrplAcc.makePayment(this.config.heartbeatAddress,
                XrplConstants.MIN_DROPS,
                null,
                null,
                null,
                {
                    hookParams: [
                        { name: HookParamKeys.PARAM_EVENT_TYPE_KEY, value: EventTypes.HEARTBEAT },
                        ...(data ? [{ name: HookParamKeys.PARAM_EVENT_DATA_KEY, value: data }] : [])
                    ],
                    maxLedgerIndex: this.#getMaxLedgerSequence(),
                    ...options.transactionOptions,
                    submissionRef: options.submissionRef
                });
            return res;
        }
        catch (e) {
            const validationErr = e?.hookExecutionResult?.find(r => r.message.includes(VOTE_VALIDATION_ERR));
            if (validationErr) {
                console.log('Vote validation error occurred.')
                throw {
                    code: VOTE_VALIDATION_ERR,
                    error: validationErr.message
                }
            }
            throw e;
        }
    }

    /**
     * Send acquire success response to the tenant.
     * @param {string} txHash Acquire lease transaction hash in hex.
     * @param {string} tenantAddress XRPL address of the tenant.
     * @param {string} instanceInfo Created instance info.
     * @param {*} options [Optional] transaction options.
     * @returns Transaction result.
     */
    async acquireSuccess(txHash, tenantAddress, instanceInfo, options = {}) {

        // Encrypt the instance info with the tenant's encryption key (Specified in MessageKey field of the tenant account).
        const tenantAcc = new XrplAccount(tenantAddress, null, { xrplApi: this.xrplApi });

        let encKey = null;
        let doEncrypt = true;
        // Initialize with not-encrypted prefix flag and the data.
        let data = Buffer.concat([Buffer.from([0x00]), Buffer.from(JSON.stringify(instanceInfo))]).toString('base64');

        if ('messageKey' in options) {
            if (options.messageKey !== 'none' && RegExp.PublicPrivateKey.test(options.messageKey)) {
                encKey = options.messageKey;
            } else if (options.messageKey === 'none') {
                doEncrypt = false;
            } else
                throw "Tenant encryption key not valid.";
        } else {
            encKey = await tenantAcc.getMessageKey();
        }

        if (doEncrypt) {
            if (!encKey)
                throw "Tenant encryption key not set.";
            const encrypted = await EncryptionHelper.encrypt(encKey, instanceInfo);
            // Override encrypted prefix flag and the data.
            data = Buffer.concat([Buffer.from([0x01]), Buffer.from(encrypted, 'base64')]).toString('base64');
        }

        return this.xrplAcc.makePayment(tenantAddress,
            XrplConstants.MIN_DROPS,
            null,
            null,
            [
                { type: EventTypes.ACQUIRE_SUCCESS, format: MemoFormats.BASE64, data: data }
            ],
            {
                hookParams: [
                    { name: HookParamKeys.PARAM_EVENT_TYPE_KEY, value: EventTypes.ACQUIRE_SUCCESS },
                    { name: HookParamKeys.PARAM_EVENT_DATA_KEY, value: txHash }
                ],
                maxLedgerIndex: this.#getMaxLedgerSequence(),
                ...options.transactionOptions,
                submissionRef: options.submissionRef
            });
    }

    /**
     * Send acquire error response to the tenant.
     * @param {string} txHash Acquire lease transaction hash in hex.
     * @param {string} tenantAddress Xrpl address of the tenant.
     * @param {number} leaseAmount Lease amount to be refunded.
     * @param {string} reason Reason for the error.
     * @param {*} options [Optional] transaction options.
     * @returns Transaction result.
     */
    async acquireError(txHash, tenantAddress, leaseAmount, reason, options = {}) {

        return this.xrplAcc.makePayment(tenantAddress,
            leaseAmount.toString(),
            EvernodeConstants.EVR,
            this.config.evrIssuerAddress,
            [
                { type: EventTypes.ACQUIRE_ERROR, format: MemoFormats.JSON, data: { type: ErrorCodes.ACQUIRE_ERR, reason: reason } }
            ],
            {
                hookParams: [
                    { name: HookParamKeys.PARAM_EVENT_TYPE_KEY, value: EventTypes.ACQUIRE_ERROR },
                    { name: HookParamKeys.PARAM_EVENT_DATA_KEY, value: txHash }
                ],
                maxLedgerIndex: this.#getMaxLedgerSequence(),
                ...options.transactionOptions,
                submissionRef: options.submissionRef
            });
    }

    /**
     * Send extend success response to the tenant.
     * @param {string} txHash Extend lease transaction hash in hex.
     * @param {string} tenantAddress XRPL address of the tenant.
     * @param {number} expiryMoment Moment which the instance will expire.
     * @param {*} options [Optional] transaction options.
     * @returns Transaction result.
     */
    async extendSuccess(txHash, tenantAddress, expiryMoment, options = {}) {
        let buf = Buffer.alloc(4, 0);
        buf.writeUInt32BE(expiryMoment);

        return this.xrplAcc.makePayment(tenantAddress,
            XrplConstants.MIN_DROPS,
            null,
            null,
            [
                { type: EventTypes.EXTEND_SUCCESS, format: MemoFormats.HEX, data: buf.toString('hex') }
            ],
            {
                hookParams: [
                    { name: HookParamKeys.PARAM_EVENT_TYPE_KEY, value: EventTypes.EXTEND_SUCCESS },
                    { name: HookParamKeys.PARAM_EVENT_DATA_KEY, value: txHash }
                ],
                maxLedgerIndex: this.#getMaxLedgerSequence(),
                ...options.transactionOptions,
                submissionRef: options.submissionRef
            });
    }

    /**
     * Send extend error response to the tenant.
     * @param {string} txHash Extend lease transaction hash in hex.
     * @param {string} tenantAddress Xrpl address of the tenant.
     * @param {string} reason Reason for the error.
     * @param {number} refund Amount to be refunded.
     * @param {*} options [Optional] transaction options.
     * @returns Transaction result.
     */
    async extendError(txHash, tenantAddress, reason, refund, options = {}) {

        // Required to refund the paid EVR amount as the offer extention is not successfull.
        return this.xrplAcc.makePayment(tenantAddress,
            refund.toString(),
            EvernodeConstants.EVR,
            this.config.evrIssuerAddress,
            [
                { type: EventTypes.EXTEND_ERROR, format: MemoFormats.JSON, data: { type: ErrorCodes.EXTEND_ERR, reason: reason } }
            ],
            {
                hookParams: [
                    { name: HookParamKeys.PARAM_EVENT_TYPE_KEY, value: EventTypes.EXTEND_ERROR },
                    { name: HookParamKeys.PARAM_EVENT_DATA_KEY, value: txHash }
                ],
                maxLedgerIndex: this.#getMaxLedgerSequence(),
                ...options.transactionOptions,
                submissionRef: options.submissionRef
            });
    }

    /**
     * Send refunds to the tenant.
     * @param {string} txHash Request transaction hash in hex.
     * @param {string} tenantAddress Xrpl address of the tenant.
     * @param {number} refundAmount Amount to be refunded.
     * @param {*} options [Optional] transaction options.
     * @returns Transaction result.
     */
    async refundTenant(txHash, tenantAddress, refundAmount, options = {}) {
        return this.xrplAcc.makePayment(tenantAddress,
            refundAmount.toString(),
            EvernodeConstants.EVR,
            this.config.evrIssuerAddress,
            [
                { type: EventTypes.REFUND, format: '', data: '' }
            ],
            {
                hookParams: [
                    { name: HookParamKeys.PARAM_EVENT_TYPE_KEY, value: EventTypes.REFUND },
                    { name: HookParamKeys.PARAM_EVENT_DATA_KEY, value: txHash }
                ],
                maxLedgerIndex: this.#getMaxLedgerSequence(),
                ...options.transactionOptions,
                submissionRef: options.submissionRef
            });
    }

    /**
     * Request registration rebates from the registry.
     * @param {*} options [Optional] transaction options.
     * @returns Transaction result.
     */
    async requestRebate(options = {}) {
        return this.xrplAcc.makePayment(this.config.registryAddress,
            XrplConstants.MIN_DROPS,
            null,
            null,
            [
                { type: EventTypes.HOST_REBATE, format: "", data: "" }
            ],
            {
                hookParams: [
                    { name: HookParamKeys.PARAM_EVENT_TYPE_KEY, value: EventTypes.HOST_REBATE }
                ],
                maxLedgerIndex: this.#getMaxLedgerSequence(),
                ...options.transactionOptions,
                submissionRef: options.submissionRef
            });
    }

    /**
     * Initiate a host transfer.
     * @param {string} transfereeAddress [Optional] Xrpl account address to host registration to be transferred.
     * @param {*} options [Optional] transaction options.
     */
    async transfer(transfereeAddress = this.xrplAcc.address, options = {}) {
        if (!(await this.isRegistered()))
            throw "Host is not registered.";

        const transfereeAcc = new XrplAccount(transfereeAddress, null, { xrplApi: this.xrplApi });

        if (this.xrplAcc.address !== transfereeAddress) {
            // Find the new transferee also owns an Evernode Host Registration token.
            const token = (await transfereeAcc.getURITokens()).find(n => n.URI.startsWith(EvernodeConstants.TOKEN_PREFIX_HEX) && n.Issuer === this.config.registryAddress);
            if (token)
                throw "The transferee is already registered in Evernode.";
        }

        const paramData = codec.decodeAccountID(transfereeAddress);

        const regUriToken = await this.getRegistrationUriToken();

        await this.#submitWithRetry(async (feeUplift, submissionRef) => {
            await this.xrplAcc.sellURIToken(regUriToken.index,
                XrplConstants.MIN_DROPS,
                null,
                null,
                this.config.registryAddress,
                null,
                {
                    hookParams: [
                        { name: HookParamKeys.PARAM_EVENT_TYPE_KEY, value: EventTypes.HOST_TRANSFER },
                        { name: HookParamKeys.PARAM_EVENT_DATA_KEY, value: paramData.toString('hex') }
                    ],
                    maxLedgerIndex: this.#getMaxLedgerSequence(),
                    feeUplift: feeUplift, submissionRef: submissionRef,
                    ...options.transactionOptions
                });
        }, { ...(options.retryOptions ? options.retryOptions : {}), submissionRef: options.submissionRef });

        let token = null;
        let attempts = 0;
        const regAcc = new XrplAccount(this.config.registryAddress, null, { xrplApi: this.xrplApi });

        while (attempts < OFFER_WAIT_TIMEOUT) {
            token = (await regAcc.getURITokens()).find(o => o.index == regUriToken.index);
            if (token)
                break;
            await new Promise(resolve => setTimeout(resolve, 1000));
            attempts++;
        }
        if (!token)
            throw 'Token hasn\'t transferred within timeout.';
    }

    /**
     * Check whether this host is a transferee.
     * @returns Boolean wether the host is a transferee or not.
     */
    async isTransferee() {

        // Check the availability of TRANSFEREE state for this host address.
        const stateTransfereeAddrKey = StateHelpers.generateTransfereeAddrStateKey(this.xrplAcc.address);
        const stateTransfereeAddrIndex = StateHelpers.getHookStateIndex(this.governorAddress, stateTransfereeAddrKey);
        const res = await this.xrplApi.getLedgerEntry(stateTransfereeAddrIndex);

        if (res && res?.HookStateData)
            return true;

        return false;
    }

    /**
     * Propose a new hook candidate.
     * @param {string} hashes Hook candidate hashes in hex format, <GOVERNOR_HASH(32)><REGISTRY_HASH(32)><HEARTBEAT_HASH(32)>.
     * @param {string} shortName Short name for the proposal candidate.
     * @param {*} options [Optional] transaction options.
     * @returns Proposed candidate id.
     */
    async propose(hashes, shortName, options = {}) {
        if (!(await this.isRegistered()))
            throw 'Host should be registered to propose candidates.';

        options.transactionOptions = { maxLedgerIndex: this.#getMaxLedgerSequence(), ...(options.transactionOptions || {}) }
        return await super._propose(hashes, shortName, options);
    }

    /**
     * Withdraw a hook candidate.
     * @param {string} candidateId Id of the candidate in hex format.
     * @param {*} options [Optional] transaction options.
     * @returns Transaction result.
     */
    async withdraw(candidateId, options = {}) {
        if (!(await this.isRegistered()))
            throw 'Host should be registered to withdraw candidates.';

        options.transactionOptions = { maxLedgerIndex: this.#getMaxLedgerSequence(), ...(options.transactionOptions || {}) }
        return await super._withdraw(candidateId, options);
    }

    /**
     * Report dud host for removal.
     * @param {string} hostAddress Address of the dud host.
     * @param {*} options [Optional] transaction options.
     * @returns Transaction result.
     */
    async reportDudHost(hostAddress, options = {}) {
        if (!(await this.isRegistered()))
            throw 'Host should be registered to report dud hosts.';

        options.transactionOptions = { maxLedgerIndex: this.#getMaxLedgerSequence(), ...(options.transactionOptions || {}) }
        return await this._reportDudHost(hostAddress, options);
    }
}

module.exports = {
    HostEvents,
    HostClient
}


/***/ }),

/***/ 6449:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { BaseEvernodeClient } = __nccwpck_require__(6263);
const { EvernodeEvents, MemoFormats, EventTypes, ErrorCodes, ErrorReasons, EvernodeConstants, HookParamKeys, RegExp } = __nccwpck_require__(9849);
const { EncryptionHelper } = __nccwpck_require__(4832);
const { Buffer } = __nccwpck_require__(4300);
const { XrplAccount } = __nccwpck_require__(9329);
const { UtilHelpers } = __nccwpck_require__(6687);
const { EvernodeHelpers } = __nccwpck_require__(2523);
const { TransactionHelper } = __nccwpck_require__(7071);

const DEFAULT_WAIT_TIMEOUT = 300000;

const TenantEvents = {
    AcquireSuccess: EvernodeEvents.AcquireSuccess,
    AcquireError: EvernodeEvents.AcquireError,
    ExtendSuccess: EvernodeEvents.ExtendSuccess,
    ExtendError: EvernodeEvents.ExtendError,
}

class TenantClient extends BaseEvernodeClient {

    constructor(xrpAddress, xrpSecret, options = {}) {
        super(xrpAddress, xrpSecret, Object.values(TenantEvents), false, options);
    }

    async prepareAccount() {
        try {
            if (!await this.xrplAcc.getMessageKey())
                await this.xrplAcc.setAccountFields({ MessageKey: this.accKeyPair.publicKey });
        }
        catch (err) {
            console.log("Error in preparing user xrpl account for Evernode.", err);
        }
    }

    async getLeaseHost(hostAddress) {
        const host = new XrplAccount(hostAddress, null, { xrplApi: this.xrplApi });
        // Find an owned URI token with matching Evernode host NFT prefix.
        const uriToken = (await host.getURITokens()).find(n => n.URI.startsWith(EvernodeConstants.TOKEN_PREFIX_HEX) && n.Issuer === this.config.registryAddress);
        if (!uriToken)
            throw { reason: ErrorReasons.HOST_INVALID, error: "Host is not registered." };

        // Check whether the token was actually issued from Evernode registry contract.
        if (uriToken.Issuer != this.config.registryAddress)
            throw { reason: ErrorReasons.HOST_INVALID, error: "Host is not registered." };

        // Check whether active.
        const hostInfo = await this.getHostInfo(host.address);
        if (!hostInfo)
            throw { reason: ErrorReasons.HOST_INVALID, error: "Host is not registered." };
        else if (!hostInfo.active)
            throw { reason: ErrorReasons.HOST_INACTIVE, error: "Host is not active." };

        return host;
    }

    /**
     * Prepare and submit acquire transaction.(Single signed scenario)
     * @param {string} hostAddress XRPL address of the host to acquire the lease.
     * @param {object} requirement The instance requirements and configuration.
     * @param {object} options [Optional] Options for the XRPL transaction.
     * @returns The transaction result.
     */
    async acquireLeaseSubmit(hostAddress, requirement, options = {}) {

        const preparedAcquireTxn = await this.prepareAcquireLeaseTransaction(hostAddress, requirement, options);
        return await this.xrplAcc.signAndSubmit(preparedAcquireTxn);
    }

    /**
     * Prepare the Acquire transaction.
     * @param {string} hostAddress XRPL address of the host to acquire the lease.
     * @param {object} requirement The instance requirements and configuration.
     * @param {object} options [Optional] Options for the XRPL transaction.
     * @returns Prepared Acquire transaction.
     */
    async prepareAcquireLeaseTransaction(hostAddress, requirement, options = {}) {

        const hostAcc = await this.getLeaseHost(hostAddress);
        let selectedOfferIndex = options.leaseOfferIndex;

        let buyUriOffer = null;
        const uriTokenOffers = await EvernodeHelpers.getLeaseOffers(hostAcc);

        if (!selectedOfferIndex) {
            // Attempt to get first available offer, if offer is not specified in options.
            buyUriOffer = uriTokenOffers && uriTokenOffers[0];
        }
        else {
            // Attempt to get relevant available offer using selectedOfferIndex.
            buyUriOffer = uriTokenOffers && uriTokenOffers.find(uriOffer => (uriOffer.index === selectedOfferIndex));
        }

        if (!buyUriOffer)
            throw { reason: ErrorReasons.NO_OFFER, error: "No offers available." };

        let encKey = null;
        let doEncrypt = true;
        // Initialize with not-encrypted prefix flag and the data.
        let data = Buffer.concat([Buffer.from([0x00]), Buffer.from(JSON.stringify(requirement))]).toString('base64');

        if ('messageKey' in options) {
            if (options.messageKey !== 'none' && RegExp.PublicPrivateKey.test(options.messageKey)) {
                encKey = options.messageKey;
            } else if (options.messageKey === 'none') {
                doEncrypt = false;
            } else
                throw { reason: ErrorReasons.INTERNAL_ERR, error: "Host encryption key not valid." };
        } else {
            encKey = await hostAcc.getMessageKey();
        }

        if (doEncrypt) {
            if (!encKey)
                throw { reason: ErrorReasons.INTERNAL_ERR, error: "Host encryption key not set." };
            const encrypted = await EncryptionHelper.encrypt(encKey, requirement, {
                iv: options.iv, // Must be null or 16 bytes.
                ephemPrivateKey: options.ephemPrivateKey // Must be null or 32 bytes.
            });
            // Override encrypted prefix flag and the data.
            data = Buffer.concat([Buffer.from([0x01]), Buffer.from(encrypted, 'base64')]).toString('base64');
        }

        return await this.xrplAcc.prepareBuyURIToken(
            buyUriOffer,
            [
                { type: EventTypes.ACQUIRE_LEASE, format: MemoFormats.BASE64, data: data }
            ],
            {
                hookParams: [
                    { name: HookParamKeys.PARAM_EVENT_TYPE_KEY, value: EventTypes.ACQUIRE_LEASE }
                ],
                ...options.transactionOptions
            });
    }

    /**
     * Watch for the acquire-success response after the acquire request is made.
     * @param {object} tx The transaction returned by the acquireLeaseSubmit function.
     * @param {object} options [Optional] Options for the XRPL transaction.
     * @returns An object including transaction details,instance info, and acquireReference Id.
     */
    async watchAcquireResponse(tx, options = {}) {
        console.log(`Waiting for acquire response... (txHash: ${tx.id})`);

        return new Promise(async (resolve, reject) => {
            let rejected = false;
            const failTimeout = setTimeout(() => {
                rejected = true;
                reject({ error: ErrorCodes.ACQUIRE_ERR, reason: ErrorReasons.TIMEOUT });
            }, options.timeout || DEFAULT_WAIT_TIMEOUT);

            let relevantTx = null;
            while (!rejected && !relevantTx) {
                const txList = await this.xrplAcc.getAccountTrx(tx.details.ledger_index);
                for (let t of txList) {
                    t.tx.Memos = TransactionHelper.deserializeMemos(t.tx?.Memos);
                    t.tx.HookParameters = TransactionHelper.deserializeHookParams(t.tx?.HookParameters);

                    if (t.meta?.delivered_amount)
                        t.tx.DeliveredAmount = t.meta.delivered_amount;

                    const res = await this.extractEvernodeEvent(t.tx);
                    if ((res?.name === EvernodeEvents.AcquireSuccess || res?.name === EvernodeEvents.AcquireError) && res?.data?.acquireRefId === tx.id) {
                        clearTimeout(failTimeout);
                        relevantTx = res;
                        break;
                    }
                }
                await new Promise(resolveSleep => setTimeout(resolveSleep, 2000));
            }

            if (!rejected) {
                if (relevantTx?.name === TenantEvents.AcquireSuccess) {
                    resolve({
                        transaction: relevantTx?.data.transaction,
                        instance: relevantTx?.data.payload.content,
                        acquireRefId: relevantTx?.data.acquireRefId
                    });
                } else if (relevantTx?.name === TenantEvents.AcquireError) {
                    reject({
                        error: ErrorCodes.ACQUIRE_ERR,
                        transaction: relevantTx?.data.transaction,
                        reason: relevantTx?.data.reason,
                        acquireRefId: relevantTx?.data.acquireRefId
                    });
                }
            }
        });
    }

    /**
     * Acquire an instance from a host
     * @param {string} hostAddress XRPL address of the host to acquire the lease.
     * @param {object} requirement The instance requirements and configuration.
     * @param {object} options [Optional] Options for the XRPL transaction.
     * @returns An object including transaction details,instance info, and acquireReference Id.
     */
    acquireLease(hostAddress, requirement, options = {}) {
        return new Promise(async (resolve, reject) => {
            const tx = await this.acquireLeaseSubmit(hostAddress, requirement, options).catch(error => {
                reject({ error: ErrorCodes.ACQUIRE_ERR, reason: error.reason || ErrorReasons.TRANSACTION_FAILURE, content: error.error || error });
            });
            if (tx) {
                try {
                    const response = await this.watchAcquireResponse(tx, options);
                    resolve(response);
                } catch (error) {
                    reject(error);
                }
            }
        });
    }

    /**
     * This function is called by a tenant client to submit the extend lease transaction in certain host. This function will be called inside extendLease function. This function can take four parameters as follows.
     * @param {string} hostAddress XRPL account address of the host.
     * @param {number} amount Cost for the extended moments , in EVRs.
     * @param {string} tokenID Tenant received instance name. this name can be retrieve by performing acquire Lease.
     * @param {object} options This is an optional field and contains necessary details for the transactions.
     * @returns The transaction result.
     */
    async extendLeaseSubmit(hostAddress, amount, tokenID, options = {}) {
        const preparedExtendTxn = await this.prepareExtendLeaseTransaction(hostAddress, amount, tokenID, options);
        return await this.xrplAcc.signAndSubmit(preparedExtendTxn);
    }

    /**
     * This function is called to prepare an instance extension transaction for a particular host.
     * @param {string} hostAddress XRPL account address of the host.
     * @param {number} amount Cost for the extended moments , in EVRs.
     * @param {string} tokenID Tenant received instance name. this name can be retrieve by performing acquire Lease.
     * @param {object} options This is an optional field and contains necessary details for the transactions.
     * @returns The prepared transaction.
     */
    async prepareExtendLeaseTransaction(hostAddress, amount, tokenID, options = {}) {
        const host = await this.getLeaseHost(hostAddress);
        return await this.xrplAcc.prepareMakePayment(
            host.address, amount.toString(),
            EvernodeConstants.EVR,
            this.config.evrIssuerAddress,
            null,
            {
                hookParams: [
                    { name: HookParamKeys.PARAM_EVENT_TYPE_KEY, value: EventTypes.EXTEND_LEASE },
                    { name: HookParamKeys.PARAM_EVENT_DATA_KEY, value: tokenID }
                ],
                ...options.transactionOptions
            });
    }

    /**
     * This function watches for an extendlease-success response(transaction) and returns the response or throws the error response on extendlease-error response from the host XRPL account. This function is called within the extendLease function.
     * @param {object} tx Response of extendLeaseSubmit.
     * @param {object} options This is an optional field and contains necessary details for the transactions.
     * @returns An object including transaction details.
     */
    async watchExtendResponse(tx, options = {}) {
        console.log(`Waiting for extend lease response... (txHash: ${tx.id})`);

        return new Promise(async (resolve, reject) => {
            let rejected = false;
            const failTimeout = setTimeout(() => {
                rejected = true;
                reject({ error: ErrorCodes.EXTEND_ERR, reason: ErrorReasons.TIMEOUT });
            }, options.timeout || DEFAULT_WAIT_TIMEOUT);

            let relevantTx = null;
            while (!rejected && !relevantTx) {
                const txList = await this.xrplAcc.getAccountTrx(tx.details.ledger_index);
                for (let t of txList) {
                    t.tx.Memos = TransactionHelper.deserializeMemos(t.tx.Memos);
                    t.tx.HookParameters = TransactionHelper.deserializeHookParams(t.tx?.HookParameters);

                    if (t.meta?.delivered_amount)
                        t.tx.DeliveredAmount = t.meta.delivered_amount;

                    const res = await this.extractEvernodeEvent(t.tx);
                    if ((res?.name === TenantEvents.ExtendSuccess || res?.name === TenantEvents.ExtendError) && res?.data?.extendRefId === tx.id) {
                        clearTimeout(failTimeout);
                        relevantTx = res;
                        break;
                    }
                }
                await new Promise(resolveSleep => setTimeout(resolveSleep, 1000));
            }

            if (!rejected) {
                if (relevantTx?.name === TenantEvents.ExtendSuccess) {
                    resolve({
                        transaction: relevantTx?.data.transaction,
                        expiryMoment: relevantTx?.data.expiryMoment,
                        extendRefId: relevantTx?.data.extendRefId
                    });
                } else if (relevantTx?.name === TenantEvents.ExtendError) {
                    reject({
                        error: ErrorCodes.EXTEND_ERR,
                        transaction: relevantTx?.data.transaction,
                        reason: relevantTx?.data.reason
                    });
                }
            }
        });
    }

    /**
     * This function is called by a tenant client to extend an available instance in certain host. This function can take four parameters as follows.
     * @param {string} hostAddress XRPL account address of the host.
     * @param {number} moments 1190 ledgers (est. 1 hour).
     * @param {string} instanceName Tenant received instance name. this name can be retrieve by performing acquire Lease.
     * @param {object} options This is an optional field and contains necessary details for the transactions.
     * @returns An object including transaction details.
     */
    extendLease(hostAddress, moments, instanceName, options = {}) {
        return new Promise(async (resolve, reject) => {
            const tokenID = instanceName;
            const uriToken = (await this.xrplAcc.getURITokens())?.find(n => n.index == tokenID);

            if (!uriToken) {
                reject({ error: ErrorCodes.EXTEND_ERR, reason: ErrorReasons.NO_TOKEN, content: 'Could not find the uri token for lease extend request.' });
                return;
            }

            let minLedgerIndex = this.xrplApi.ledgerIndex;

            // Get the agreement lease amount from the nft and calculate EVR amount to be sent.
            const uriInfo = UtilHelpers.decodeLeaseTokenUri(uriToken.URI);
            const tx = await this.extendLeaseSubmit(hostAddress, moments * uriInfo.leaseAmount, tokenID, options).catch(error => {
                reject({ error: ErrorCodes.EXTEND_ERR, reason: error.reason || ErrorReasons.TRANSACTION_FAILURE, content: error.error || error });
            });

            if (tx) {
                try {
                    const response = await this.watchExtendResponse(tx, minLedgerIndex, options)
                    resolve(response);
                } catch (error) {
                    reject(error);
                }
            }
        });
    }
}

module.exports = {
    TenantEvents,
    TenantClient
}


/***/ }),

/***/ 8262:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const https = __nccwpck_require__(5687);

const DefinitionsUrl = 'https://raw.githubusercontent.com/EvernodeXRPL/evernode-resources/main/definitions/definitions.json';

const DefaultValues = {
    xrplApi: null
}

const HookTypes = {
    governor: 'GOVERNOR',
    registry: 'REGISTRY',
    heartbeat: 'HEARTBEAT'
}

const getDefinitions = async () => {
    return new Promise((resolve, reject) => {
        https.get(DefinitionsUrl, res => {
            let data = [];
            if (res.statusCode != 200)
                reject(`Error: ${res.statusMessage}`);
            res.on('data', chunk => {
                data.push(chunk);
            });
            res.on('end', () => {
                resolve(JSON.parse(data));
            });
        }).on('error', err => {
            reject(`Error: ${err.message}`);
        });
    });
}

class Defaults {
    /**
     * Load defaults from the public definitions json.
     * @param {string} network Network to choose the info.
     */
    static async useNetwork(network) {
        const definitions = await getDefinitions();

        if (!definitions[network])
            throw `Invalid network: ${network}`;

        this.set(definitions[network]);
    }

    /**
     * Override Evernode default configs.
     * @param {object} newDefaults Configurations to override `{ governorAddress: '{string} governor xrpl address', rippledServer: '{string} rippled server url', xrplApi: '{XrplApi} xrpl instance', stateIndexId: '{string} firestore index', networkID: '{number} rippled network id' }`
     */
    static set(newDefaults) {
        Object.assign(DefaultValues, newDefaults)
    }

    /**
     * Read Evernode default configs.
     * @returns The Object of Evernode configs
     */
    static get values() {
        return { ...DefaultValues };
    }
}

module.exports = {
    Defaults,
    HookTypes
}

/***/ }),

/***/ 4776:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

// Code taken from https://github.com/bitchan/eccrypto/blob/master/browser.js
// We are using this code file directly because the full eccrypto library causes a conflict with
// tiny-secp256k1 used by xrpl libs during ncc/webpack build.

var EC = (__nccwpck_require__(1517).ec);
var ec = new EC("secp256k1");
var browserCrypto = global.crypto || global.msCrypto || {};
var subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;

var nodeCrypto = __nccwpck_require__(6113);

const EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex');
const ZERO32 = Buffer.alloc(32, 0);

function assert(condition, message) {
    if (!condition) {
        throw new Error(message || "Assertion failed");
    }
}

function isScalar(x) {
    return Buffer.isBuffer(x) && x.length === 32;
}

function isValidPrivateKey(privateKey) {
    if (!isScalar(privateKey)) {
        return false;
    }
    return privateKey.compare(ZERO32) > 0 && // > 0
        privateKey.compare(EC_GROUP_ORDER) < 0; // < G
}

// Compare two buffers in constant time to prevent timing attacks.
function equalConstTime(b1, b2) {
    if (b1.length !== b2.length) {
        return false;
    }
    var res = 0;
    for (var i = 0; i < b1.length; i++) {
        res |= b1[i] ^ b2[i];  // jshint ignore:line
    }
    return res === 0;
}

/* This must check if we're in the browser or
not, since the functions are different and does
not convert using browserify */
function randomBytes(size) {
    var arr = new Uint8Array(size);
    if (typeof browserCrypto.getRandomValues === 'undefined') {
        return Buffer.from(nodeCrypto.randomBytes(size));
    } else {
        browserCrypto.getRandomValues(arr);
    }
    return Buffer.from(arr);
}

function sha512(msg) {
    return new Promise(function (resolve) {
        var hash = nodeCrypto.createHash('sha512');
        var result = hash.update(msg).digest();
        resolve(new Uint8Array(result));
    });
}

function getAes(op) {
    return function (iv, key, data) {
        return new Promise(function (resolve) {
            if (subtle) {
                var importAlgorithm = { name: "AES-CBC" };
                var keyp = subtle.importKey("raw", key, importAlgorithm, false, [op]);
                return keyp.then(function (cryptoKey) {
                    var encAlgorithm = { name: "AES-CBC", iv: iv };
                    return subtle[op](encAlgorithm, cryptoKey, data);
                }).then(function (result) {
                    resolve(Buffer.from(new Uint8Array(result)));
                });
            } else {
                if (op === 'encrypt') {
                    var cipher = nodeCrypto.createCipheriv('aes-256-cbc', key, iv);
                    let firstChunk = cipher.update(data);
                    let secondChunk = cipher.final();
                    resolve(Buffer.concat([firstChunk, secondChunk]));
                }
                else if (op === 'decrypt') {
                    var decipher = nodeCrypto.createDecipheriv('aes-256-cbc', key, iv);
                    let firstChunk = decipher.update(data);
                    let secondChunk = decipher.final();
                    resolve(Buffer.concat([firstChunk, secondChunk]));
                }
            }
        });
    };
}

var aesCbcEncrypt = getAes("encrypt");
var aesCbcDecrypt = getAes("decrypt");

function hmacSha256Sign(key, msg) {
    return new Promise(function (resolve) {
        var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));
        hmac.update(msg);
        var result = hmac.digest();
        resolve(result);
    });
}

function hmacSha256Verify(key, msg, sig) {
    return new Promise(function (resolve) {
        var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));
        hmac.update(msg);
        var expectedSig = hmac.digest();
        resolve(equalConstTime(expectedSig, sig));
    });
}

/**
  * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source
  * depending on your browser.
  * @return {Buffer} A 32-byte private key.
  * @function
  */
exports.generatePrivate = function () {
    var privateKey = randomBytes(32);
    while (!isValidPrivateKey(privateKey)) {
        privateKey = randomBytes(32);
    }
    return privateKey;
};

var getPublic = exports.getPublic = function (privateKey) {
    // This function has sync API so we throw an error immediately.
    assert(privateKey.length === 32, "Bad private key");
    assert(isValidPrivateKey(privateKey), "Bad private key");
    // XXX(Kagami): `elliptic.utils.encode` returns array for every
    // encoding except `hex`.
    return Buffer.from(ec.keyFromPrivate(privateKey).getPublic("arr"));
};

/**
 * Get compressed version of public key.
 */
var getPublicCompressed = exports.getPublicCompressed = function (privateKey) { // jshint ignore:line
    assert(privateKey.length === 32, "Bad private key");
    assert(isValidPrivateKey(privateKey), "Bad private key");
    // See https://github.com/wanderer/secp256k1-node/issues/46
    let compressed = true;
    return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, "arr"));
};

// NOTE(Kagami): We don't use promise shim in Browser implementation
// because it's supported natively in new browsers (see
// <http://caniuse.com/#feat=promises>) and we can use only new browsers
// because of the WebCryptoAPI (see
// <http://caniuse.com/#feat=cryptography>).
exports.sign = function (privateKey, msg) {
    return new Promise(function (resolve) {
        assert(privateKey.length === 32, "Bad private key");
        assert(isValidPrivateKey(privateKey), "Bad private key");
        assert(msg.length > 0, "Message should not be empty");
        assert(msg.length <= 32, "Message is too long");
        resolve(Buffer.from(ec.sign(msg, privateKey, { canonical: true }).toDER()));
    });
};

exports.verify = function (publicKey, msg, sig) {
    return new Promise(function (resolve, reject) {
        assert(publicKey.length === 65 || publicKey.length === 33, "Bad public key");
        if (publicKey.length === 65) {
            assert(publicKey[0] === 4, "Bad public key");
        }
        if (publicKey.length === 33) {
            assert(publicKey[0] === 2 || publicKey[0] === 3, "Bad public key");
        }
        assert(msg.length > 0, "Message should not be empty");
        assert(msg.length <= 32, "Message is too long");
        if (ec.verify(msg, sig, publicKey)) {
            resolve(null);
        } else {
            reject(new Error("Bad signature"));
        }
    });
};

var derive = exports.derive = function (privateKeyA, publicKeyB) {
    return new Promise(function (resolve) {
        assert(Buffer.isBuffer(privateKeyA), "Bad private key");
        assert(Buffer.isBuffer(publicKeyB), "Bad public key");
        assert(privateKeyA.length === 32, "Bad private key");
        assert(isValidPrivateKey(privateKeyA), "Bad private key");
        assert(publicKeyB.length === 65 || publicKeyB.length === 33, "Bad public key");
        if (publicKeyB.length === 65) {
            assert(publicKeyB[0] === 4, "Bad public key");
        }
        if (publicKeyB.length === 33) {
            assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, "Bad public key");
        }
        var keyA = ec.keyFromPrivate(privateKeyA);
        var keyB = ec.keyFromPublic(publicKeyB);
        var Px = keyA.derive(keyB.getPublic());  // BN instance
        resolve(Buffer.from(Px.toArray()));
    });
};

exports.encrypt = function (publicKeyTo, msg, opts) {
    opts = opts || {};
    // Tmp variables to save context from flat promises;
    var iv, ephemPublicKey, ciphertext, macKey;
    return new Promise(function (resolve) {
        var ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);
        // There is a very unlikely possibility that it is not a valid key
        while (!isValidPrivateKey(ephemPrivateKey)) {
            ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);
        }
        ephemPublicKey = getPublic(ephemPrivateKey);
        resolve(derive(ephemPrivateKey, publicKeyTo));
    }).then(function (Px) {
        return sha512(Px);
    }).then(function (hash) {
        iv = opts.iv || randomBytes(16);
        var encryptionKey = hash.slice(0, 32);
        macKey = hash.slice(32);
        return aesCbcEncrypt(iv, encryptionKey, msg);
    }).then(function (data) {
        ciphertext = data;
        var dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);
        return hmacSha256Sign(macKey, dataToMac);
    }).then(function (mac) {
        return {
            iv: iv,
            ephemPublicKey: ephemPublicKey,
            ciphertext: ciphertext,
            mac: mac,
        };
    });
};

exports.decrypt = function (privateKey, opts) {
    // Tmp variable to save context from flat promises;
    var encryptionKey;
    return derive(privateKey, opts.ephemPublicKey).then(function (Px) {
        return sha512(Px);
    }).then(function (hash) {
        encryptionKey = hash.slice(0, 32);
        var macKey = hash.slice(32);
        var dataToMac = Buffer.concat([
            opts.iv,
            opts.ephemPublicKey,
            opts.ciphertext
        ]);
        return hmacSha256Verify(macKey, dataToMac, opts.mac);
    }).then(function (macGood) {
        assert(macGood, "Bad MAC");
        return aesCbcDecrypt(opts.iv, encryptionKey, opts.ciphertext);
    }).then(function (msg) {
        return Buffer.from(new Uint8Array(msg));
    });
};

/***/ }),

/***/ 4832:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

class ed25519 {
    static async #getLibrary() {
        const _sodium = __nccwpck_require__(5315);
        await _sodium.ready;
        return _sodium;
    }

    static async encrypt(publicKeyBuf, messageBuf) {
        const sodium = await this.#getLibrary();
        const curve25519PublicKey = sodium.crypto_sign_ed25519_pk_to_curve25519(publicKeyBuf.slice(1));
        return Buffer.from(sodium.crypto_box_seal(messageBuf, curve25519PublicKey));
    }

    static async decrypt(privateKeyBuf, encryptedBuf) {
        const sodium = await this.#getLibrary();
        const keyPair = sodium.crypto_sign_seed_keypair(privateKeyBuf.slice(1));
        const curve25519PublicKey_ = sodium.crypto_sign_ed25519_pk_to_curve25519(keyPair.publicKey);
        const curve25519PrivateKey = sodium.crypto_sign_ed25519_sk_to_curve25519(keyPair.privateKey);
        return Buffer.from(sodium.crypto_box_seal_open(encryptedBuf, curve25519PublicKey_, curve25519PrivateKey));
    }
}

class secp256k1 {
    // Offsets of the properties in the encrypted buffer.
    static ivOffset = 65;
    static macOffset = this.ivOffset + 16;
    static ciphertextOffset = this.macOffset + 32;
    
    static #getLibrary() {
        const eccrypto = __nccwpck_require__(4776) // Using local copy of the eccrypto code file.
        return eccrypto;
    }

    static async encrypt(publicKeyBuf, messageBuf, options = {}) {
        const eccrypto = this.#getLibrary();
        // For the encryption library, both keys and data should be buffers.
        const encrypted = await eccrypto.encrypt(publicKeyBuf, messageBuf, options);
        // Concat all the properties of the encrypted object to a single buffer.
        return Buffer.concat([encrypted.ephemPublicKey, encrypted.iv, encrypted.mac, encrypted.ciphertext]);
    }

    static async decrypt(privateKeyBuf, encryptedBuf) {
        const eccrypto = this.#getLibrary();
        // Extract the buffer from the string and prepare encrypt object from buffer offsets for decryption.
        const encryptedObj = {
            ephemPublicKey: encryptedBuf.slice(0, this.ivOffset),
            iv: encryptedBuf.slice(this.ivOffset, this.macOffset),
            mac: encryptedBuf.slice(this.macOffset, this.ciphertextOffset),
            ciphertext: encryptedBuf.slice(this.ciphertextOffset)
        }

        const decrypted = await eccrypto.decrypt(privateKeyBuf.slice(1), encryptedObj)
            .catch(err => console.log(err));

        return decrypted;
    }
}

class EncryptionHelper {
    static contentFormat = 'base64';
    static keyFormat = 'hex';
    static ed25519KeyType = 'ed25519';
    static secp256k1KeyType = 'ecdsa-secp256k1';

    static #getAlgorithmFromKey(key) {
        const bytes = Buffer.from(key, this.keyFormat);
        return bytes.length === 33 && bytes.at(0) === 0xed
            ? this.ed25519KeyType
            : this.secp256k1KeyType;
    }

    static #getEncryptor(key) {
        const format = this.#getAlgorithmFromKey(key);
        return format === this.secp256k1KeyType ? secp256k1 : ed25519;
    }

    static async encrypt(publicKey, message, options = {}) {
        const publicKeyBuf = Buffer.from(publicKey, this.keyFormat);
        const messageBuf = Buffer.from(JSON.stringify(message));
        const encryptor = this.#getEncryptor(publicKey);
        const result = await encryptor.encrypt(publicKeyBuf, messageBuf, options);
        return result ? result.toString(this.contentFormat) : null;
    }

    static async decrypt(privateKey, encrypted) {
        const privateKeyBuf = Buffer.from(privateKey, this.keyFormat);
        const encryptedBuf = Buffer.from(encrypted, this.contentFormat);
        const encryptor = this.#getEncryptor(privateKey);
        const decrypted = await encryptor.decrypt(privateKeyBuf, encryptedBuf);
        return decrypted ? JSON.parse(decrypted.toString()) : null;
    }
}

module.exports = {
    EncryptionHelper
}

/***/ }),

/***/ 6170:
/***/ ((module) => {

class EventEmitter {
    constructor() {
        this.handlers = {};
    }

    on(event, handler) {
        if (!this.handlers[event])
            this.handlers[event] = [];
        this.handlers[event].push({
            once: false,
            func: handler
        });
    }

    once(event, handler) {
        if (!this.handlers[event])
            this.handlers[event] = [];
        this.handlers[event].push({
            once: true,
            func: handler
        });
    }

    off(event, handler = null) {
        if (this.handlers[event]) {
            if (handler)
                this.handlers[event] = this.handlers[event].filter(h => h !== handler);
            else
                delete this.handlers[event];
        }
    }

    emit(event, value, error = null) {
        if (this.handlers[event]) {
            this.handlers[event].forEach(handler => handler.func(value, error));

            // Rmove all handlers marked as 'once'.
            this.handlers[event] = this.handlers[event].filter(h => !h.once);
        }
    }
}

module.exports = {
    EventEmitter
}

/***/ }),

/***/ 9849:
/***/ ((module) => {

const EvernodeConstants = {
    EVR: 'EVR',
    TOKEN_PREFIX_HEX: '657672686F7374', // evrhost
    LEASE_TOKEN_PREFIX_HEX: '6576726C65617365', // evrlease
    LEASE_TOKEN_VERSION_PREFIX_HEX: '4C5456', // LTV (Lease_Token_Version)
    LEASE_TOKEN_VERSION: 1,
    HOOK_NAMESPACE: '01EAF09326B4911554384121FF56FA8FECC215FDDE2EC35D9E59F2C53EC665A0',
    NOW_IN_EVRS: "0.00000001",
    HOOKS: [
        "Governor",
        "Registry",
        "Heartbeat"
    ],
    CandidateVote: {
        Reject: 0,
        Support: 1
    },
    CandidateTypes: {
        NewHook: 1,
        PilotedMode: 2,
        DudHost: 3
    },
    GovernanceModes: {
        Piloted: 1,
        CoPiloted: 2,
        AutoPiloted: 3
    },
    CandidateStatuses: {
        CANDIDATE_REJECTED: 0,
        CANDIDATE_SUPPORTED: 1,
        CANDIDATE_ELECTED: 2,
        CANDIDATE_PURGED: 3,
        CANDIDATE_WITHDRAWN: 4
    }
}

const EventTypes = {
    ACQUIRE_LEASE: 'evnAcquireLease',
    ACQUIRE_SUCCESS: 'evnAcquireSuccess',
    ACQUIRE_ERROR: 'evnAcquireError',
    ACQUIRE_REF: 'evnAcquireRef',
    HOST_REG: 'evnHostReg',
    HOST_DEREG: 'evnHostDereg',
    HOST_UPDATE_INFO: 'evnHostUpdateReg',
    HEARTBEAT: 'evnHeartbeat',
    HOST_TRANSFER: 'evnTransfer',
    EXTEND_LEASE: 'evnExtendLease',
    EXTEND_SUCCESS: 'evnExtendSuccess',
    EXTEND_ERROR: 'evnExtendError',
    EXTEND_REF: 'evnExtendRef',
    INIT: 'evnInitialize',
    REFUND: 'evnRefund',
    REFUND_REF: 'evnRefundRef',
    DEAD_HOST_PRUNE: 'evnDeadHostPrune',
    HOST_REBATE: 'evnHostRebate',
    CANDIDATE_PROPOSE: 'evnCandidatePropose',
    CANDIDATE_PROPOSE_REF: 'evnCandidateProposeRef',
    CANDIDATE_WITHDRAW: 'evnCandidateWithdraw',
    CANDIDATE_VOTE: 'evnCandidateVote',
    CANDIDATE_STATUS_CHANGE: 'evnCandidateStatusChange',
    DUD_HOST_REPORT: 'evnDudHostReport',
    HOOK_UPDATE_RES: 'evnHookUpdateRes',
    GOVERNANCE_MODE_CHANGE: 'evnGovernanceModeChange',
    LINKED_CANDIDATE_REMOVE: 'evnRemoveLinkedCandidate',
    HOST_UPDATE_REPUTATION: 'evnHostUpdateReputation'
}

const MemoFormats = {
    TEXT: 'text/plain',
    JSON: 'text/json',
    BASE64: 'base64',
    HEX: 'hex'
}

const ErrorCodes = {
    ACQUIRE_ERR: 'ACQUIRE_ERR',
    EXTEND_ERR: 'EXTEND_ERR',
    PROPOSE_ERR: 'PROPOSE_ERR',
}

const ErrorReasons = {
    TRANSACTION_FAILURE: 'TRANSACTION_FAILURE',
    NO_OFFER: 'NO_OFFER',
    NO_TOKEN: 'NO_TOKEN',
    INTERNAL_ERR: 'INTERNAL_ERR',
    TIMEOUT: 'TIMEOUT',
    HOST_INVALID: 'HOST_INVALID',
    HOST_INACTIVE: 'HOST_INACTIVE',
    NO_STATE_KEY: 'NO_STATE_KEY'
}

// All keys are prefixed with 'EVR' (0x455652)
// Config keys sub-prefix: 0x01
const HookStateKeys = {
    // Configuration.
    EVR_ISSUER_ADDR: "4556520100000000000000000000000000000000000000000000000000000001",
    FOUNDATION_ADDR: "4556520100000000000000000000000000000000000000000000000000000002",
    MOMENT_SIZE: "4556520100000000000000000000000000000000000000000000000000000003",
    MINT_LIMIT: "4556520100000000000000000000000000000000000000000000000000000004",
    FIXED_REG_FEE: "4556520100000000000000000000000000000000000000000000000000000005",
    HOST_HEARTBEAT_FREQ: "4556520100000000000000000000000000000000000000000000000000000006",
    LEASE_ACQUIRE_WINDOW: "4556520100000000000000000000000000000000000000000000000000000007",
    REWARD_CONFIGURATION: "4556520100000000000000000000000000000000000000000000000000000008",
    MAX_TOLERABLE_DOWNTIME: "4556520100000000000000000000000000000000000000000000000000000009",
    MOMENT_TRANSIT_INFO: "455652010000000000000000000000000000000000000000000000000000000A",
    MAX_TRX_EMISSION_FEE: "455652010000000000000000000000000000000000000000000000000000000B",
    HEARTBEAT_ADDR: "455652010000000000000000000000000000000000000000000000000000000C",
    REGISTRY_ADDR: "455652010000000000000000000000000000000000000000000000000000000D",
    GOVERNANCE_CONFIGURATION: "455652010000000000000000000000000000000000000000000000000000000E",
    NETWORK_CONFIGURATION: "455652010000000000000000000000000000000000000000000000000000000F",

    // Singleton
    HOST_COUNT: "4556523200000000000000000000000000000000000000000000000000000000",
    MOMENT_BASE_INFO: "4556523300000000000000000000000000000000000000000000000000000000",
    HOST_REG_FEE: "4556523400000000000000000000000000000000000000000000000000000000",
    MAX_REG: "4556523500000000000000000000000000000000000000000000000000000000",
    REWARD_INFO: "4556523600000000000000000000000000000000000000000000000000000000",
    GOVERNANCE_INFO: "4556523700000000000000000000000000000000000000000000000000000000",
    TRX_FEE_BASE_INFO: "4556523800000000000000000000000000000000000000000000000000000000",

    // Prefixes
    PREFIX_HOST_TOKENID: "45565202",
    PREFIX_HOST_ADDR: "45565203",
    PREFIX_TRANSFEREE_ADDR: "45565204",
    PREFIX_CANDIDATE_OWNER: "45565205",
    PREFIX_CANDIDATE_ID: "45565206",
}

// All keys are prefixed with 'EVR' (0x455652)
const HookParamKeys = {
    PARAM_STATE_HOOK_KEY: "4556520100000000000000000000000000000000000000000000000000000001",
    PARAM_EVENT_TYPE_KEY: "4556520100000000000000000000000000000000000000000000000000000002",
    PARAM_EVENT_DATA_KEY: "4556520100000000000000000000000000000000000000000000000000000003",
}

const EvernodeEvents = {
    HostRegistered: "HostRegistered",
    HostDeregistered: "HostDeregistered",
    HostTransfer: "HostTransfer",
    AcquireLease: "AcquireLease",
    AcquireSuccess: "AcquireSuccess",
    AcquireError: "AcquireError",
    Heartbeat: "Heartbeat",
    ExtendLease: "ExtendLease",
    ExtendSuccess: "ExtendSuccess",
    ExtendError: "ExtendError",
    HostRegUpdated: "HostRegUpdated",
    HostReRegistered: "HostReRegistered",
    Initialized: "Initialized",
    DeadHostPrune: "DeadHostPrune",
    HostRebate: "HostRebate",
    CandidateProposed: "CandidateProposed",
    CandidateWithdrawn: "CandidateWithdrawn",
    ChildHookUpdated: "ChildHookUpdated",
    GovernanceModeChanged: "GovernanceModeChanged",
    FoundationVoted: "FoundationVoted",
    DudHostReported: "DudHostReported",
    DudHostRemoved: "DudHostRemoved",
    DudHostStatusChanged: "DudHostStatusChanged",
    FallbackToPiloted: "FallbackToPiloted",
    NewHookStatusChanged: "NewHookStatusChanged",
    LinkedDudHostCandidateRemoved: "LinkedDudHostCandidateRemoved",
    HostReputationUpdated: "HostReputationUpdated"
}

const URITokenTypes = {
    LEASE_URI_TOKEN: 1,
    REGISTRATION_URI_TOKEN: 2
}

const RegExp = {
    PublicPrivateKey: /^[0-9A-Fa-f]{66}$/
}

module.exports = {
    EvernodeConstants,
    EventTypes,
    MemoFormats,
    ErrorCodes,
    ErrorReasons,
    HookStateKeys,
    EvernodeEvents,
    URITokenTypes,
    HookParamKeys,
    RegExp
}

/***/ }),

/***/ 2523:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { EvernodeConstants, URITokenTypes } = __nccwpck_require__(9849);
const { TransactionHelper } = __nccwpck_require__(7071);

const NFT_PAGE_LEDGER_ENTRY_TYPE_HEX = '0050';

class EvernodeHelpers {
    static async getLeases(xrplAcc) {
        const hostUriOffers = (await xrplAcc.getURITokens()).filter(uriToken => uriToken.Issuer == xrplAcc.address && this.isValidURI(uriToken.URI, EvernodeConstants.LEASE_TOKEN_PREFIX_HEX) && uriToken.Flags == 1);
        return hostUriOffers;
    }

    static async getLeaseOffers(xrplAcc) {
        const hostUriOffers = (await this.getLeases(xrplAcc)).filter(uriToken => uriToken.Amount);
        return hostUriOffers;
    }

    static async getUnofferedLeases(xrplAcc) {
        const hostUriTokens = (await this.getLeases(xrplAcc)).filter(uriToken => !uriToken.Amount);
        return hostUriTokens
    }

    static async getNFTPageAndLocation(nfTokenId, xrplAcc, xrplApi, buffer = true) {

        const nftPageApprxKeylet = xrplAcc.generateKeylet('nftPage', { nfTokenId: nfTokenId });
        const nftPageMaxKeylet = xrplAcc.generateKeylet('nftPageMax');
        // Index is the last 32 bytes of the Keylet (Last 64 HEX characters).
        let page = await xrplApi.getLedgerEntry(nftPageMaxKeylet.substring(4, 68));
        while (page?.PreviousPageMin) {
            // Compare the low 96 bits. (Last 24 HEX characters).
            if (Number('0x' + page.index.substring(40, 64)) >= Number('0x' + nftPageApprxKeylet.substring(40, 64))) {
                // Check the existence of the NFToken
                let token = page.NFTokens.find(n => n.NFToken.NFTokenID == nfTokenId);
                if (!token) {
                    page = await xrplApi.getLedgerEntry(page.PreviousPageMin);
                }
                else
                    break;
            }
        }

        const nftPageInfo = page.NFTokens.map((n, loc) => { return { NFTPage: NFT_PAGE_LEDGER_ENTRY_TYPE_HEX + page.index, NFTokenID: n.NFToken.NFTokenID, location: loc } }).find(n => n.NFTokenID == nfTokenId);
        if (buffer) {
            let locBuf = Buffer.alloc(2,0);
            locBuf.writeUInt16BE(nftPageInfo.location);
            // <NFT_PAGE_KEYLET(34 bytes)><LOCATION(2 bytes)>
            return Buffer.concat([Buffer.from(nftPageInfo.NFTPage, "hex"), locBuf]);
        }

        return nftPageInfo;
    }

    static getEpochRewardQuota(epoch, firstEpochRewardQuota) {
        const div = (epoch > 1) ? Math.pow(2, epoch - 1) : 1;
        return firstEpochRewardQuota / div;
    }

    static isValidURI(uri, pattern, tokenCategory = URITokenTypes.LEASE_URI_TOKEN) {
        if (tokenCategory === URITokenTypes.LEASE_URI_TOKEN) {
            uri = TransactionHelper.hexToASCII(uri);
            const uriBuf = Buffer.from(uri, 'base64');
            uri = uriBuf.toString('hex').toUpperCase();
        }
        return uri.startsWith(pattern);
    }
}

module.exports = {
    EvernodeHelpers
}

/***/ }),

/***/ 4675:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const crypto = __nccwpck_require__(6113);

const HOOK_DEFINITION_LEDGER_TYPE_PREFIX = 68; // Decimal value of ASCII 'D'

class HookHelpers {
    static getHookDefinitionIndex(hookHash) {
        const typeBuf = Buffer.alloc(2, 0);
        typeBuf.writeInt16BE(HOOK_DEFINITION_LEDGER_TYPE_PREFIX);

        const hookHashBuf = Buffer.from(hookHash, 'hex');

        let hash = crypto.createHash('sha512');

        let data = hash.update(typeBuf);
        data = hash.update(hookHashBuf);

        const digest = data.digest('hex');
        // Get the first 32 bytes of hash.
        return digest.substring(0, 64).toUpperCase();
    }

    static getHookDefinitionKeylet(index) {
        const keyletBuf = Buffer.alloc(34, 0);
        keyletBuf.writeInt16BE(HOOK_DEFINITION_LEDGER_TYPE_PREFIX);
        Buffer.from(index, 'hex').copy(keyletBuf, 2);

        return keyletBuf.toString('hex');
    }
}

module.exports = {
    HookHelpers
}

/***/ }),

/***/ 5053:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { Defaults, HookTypes } = __nccwpck_require__(8262);
const { RegistryClient, RegistryEvents } = __nccwpck_require__(8074);
const { GovernorClient, GovernorEvents } = __nccwpck_require__(335);
const { HeartbeatClient, HeartbeatEvents } = __nccwpck_require__(6510);
const { HookClientFactory } = __nccwpck_require__(2344);
const { TenantClient, TenantEvents } = __nccwpck_require__(6449);
const { HostClient, HostEvents } = __nccwpck_require__(1437);
const { FoundationClient, FoundationEvents } = __nccwpck_require__(2466);
const { XrplApi } = __nccwpck_require__(1850);
const { XrplApiEvents, XrplConstants } = __nccwpck_require__(3307);
const { XrplAccount } = __nccwpck_require__(9329);
const { EvernodeConstants, HookStateKeys, HookParamKeys, EventTypes } = __nccwpck_require__(9849);
const { XflHelpers } = __nccwpck_require__(3243);
const { StateHelpers } = __nccwpck_require__(3860);
const { UtilHelpers } = __nccwpck_require__(6687);
const { TransactionHelper } = __nccwpck_require__(7071);
const { EncryptionHelper } = __nccwpck_require__(4832);
const { EvernodeHelpers } = __nccwpck_require__(2523);


module.exports = {
    RegistryClient,
    RegistryEvents,
    GovernorClient,
    GovernorEvents,
    HeartbeatClient,
    HeartbeatEvents,
    TenantClient,
    TenantEvents,
    HostClient,
    HostEvents,
    FoundationClient,
    FoundationEvents,
    XrplApi,
    XrplApiEvents,
    XrplConstants,
    XrplAccount,
    EvernodeConstants,
    Defaults,
    XflHelpers,
    StateHelpers,
    UtilHelpers,
    TransactionHelper,
    EncryptionHelper,
    HookStateKeys,
    HookParamKeys,
    EventTypes,
    HookTypes,
    HookClientFactory,
    EvernodeHelpers
}

/***/ }),

/***/ 3860:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const codec = __nccwpck_require__(597);
const { Buffer } = __nccwpck_require__(4300);
const { HookStateKeys, EvernodeConstants } = __nccwpck_require__(9849);
const { XflHelpers } = __nccwpck_require__(3243);
const crypto = __nccwpck_require__(6113);
const { sha512Half } = __nccwpck_require__(4010);

const EPOCH_OFFSET = 0;
const SAVED_MOMENT_OFFSET = 1;
const PREV_MOMENT_ACTIVE_HOST_COUNT_OFFSET = 5;
const CUR_MOMENT_ACTIVE_HOST_COUNT_OFFSET = 9;
const EPOCH_POOL_OFFSET = 13;
const HOST_MAX_LEASE_AMOUNT_OFFSET = 21;

const EPOCH_COUNT_OFFSET = 0;
const FIRST_EPOCH_REWARD_QUOTA_OFFSET = 1;
const EPOCH_REWARD_AMOUNT_OFFSET = 5;
const REWARD_START_MOMENT_OFFSET = 9;
const ACCUMULATED_REWARD_FREQUENCY_OFFSET = 13;
const HOST_REPUTATION_THRESHOLD_OFFSET = 15;
const HOST_MIN_INSTANCE_COUNT_OFFSET = 16;

const TRANSIT_IDX_OFFSET = 0;
const TRANSIT_MOMENT_SIZE_OFFSET = 8;
const TRANSIT_MOMENT_TYPE_OFFSET = 10;

const MOMENT_BASE_POINT_OFFSET = 0;
const MOMENT_AT_TRANSITION_OFFSET = 8;
const MOMENT_TYPE_OFFSET = 12;

const ELIGIBILITY_PERIOD_OFFSET = 0;
const CANDIDATE_LIFE_PERIOD_OFFSET = 4;
const CANDIDATE_ELECTION_PERIOD_OFFSET = 8;
const CANDIDATE_SUPPORT_AVERAGE_OFFSET = 12;

const GOVERNANCE_MODE_OFFSET = 0;
const LAST_CANDIDATE_IDX_OFFSET = 1;
const VOTER_BASE_COUNT_OFFSET = 5;
const VOTER_BASE_COUNT_CHANGED_TIMESTAMP_OFFSET = 9;
const FOUNDATION_LAST_VOTED_CANDIDATE_IDX = 17;
const FOUNDATION_LAST_VOTED_TIMESTAMP_OFFSET = 21;
const ELECTED_PROPOSAL_UNIQUE_ID_OFFSET = 29;
const PROPOSAL_ELECTED_TIMESTAMP_OFFSET = 61;
const UPDATED_HOOK_COUNT_OFFSET = 69;

const FEE_BASE_AVG_OFFSET = 0;
const FEE_BASE_AVG_CHANGED_IDX_OFFSET = 4;
const FEE_BASE_AVG_ACCUMULATOR_OFFSET = 12;
const FEE_BASE_COUNTER_OFFSET = 16;

const HOST_TOKEN_ID_OFFSET = 0;
const HOST_COUNTRY_CODE_OFFSET = 32;
const HOST_RESERVED_OFFSET = 34;
const HOST_DESCRIPTION_OFFSET = 42;
const HOST_REG_LEDGER_OFFSET = 68;
const HOST_REG_FEE_OFFSET = 76;
const HOST_TOT_INS_COUNT_OFFSET = 84;
const HOST_ACT_INS_COUNT_OFFSET = 88;
const HOST_HEARTBEAT_TIMESTAMP_OFFSET = 92;
const HOST_VERSION_OFFSET = 100;
const HOST_REG_TIMESTAMP_OFFSET = 103;
const HOST_TRANSFER_FLAG_OFFSET = 111;
const HOST_LAST_VOTE_CANDIDATE_IDX_OFFSET = 112;
const HOST_LAST_VOTE_TIMESTAMP_OFFSET = 116;
const HOST_SUPPORT_VOTE_FLAG_OFFSET = 124;
const HOST_REPUTATION_OFFSET = 125;
const HOST_FLAGS_OFFSET = 126;
const HOST_TRANSFER_TIMESTAMP_OFFSET = 127;
const HOST_LEASE_AMOUNT_OFFSET = 135;

const HOST_ADDRESS_OFFSET = 0;
const HOST_CPU_MODEL_NAME_OFFSET = 20;
const HOST_CPU_COUNT_OFFSET = 60;
const HOST_CPU_SPEED_OFFSET = 62;
const HOST_CPU_MICROSEC_OFFSET = 64;
const HOST_RAM_MB_OFFSET = 68;
const HOST_DISK_MB_OFFSET = 72;
const HOST_EMAIL_ADDRESS_OFFSET = 76;
const HOST_ACCUMULATED_REWARD_OFFSET = 116;

const PREV_HOST_ADDRESS_OFFSET = 0;
const TRANSFER_LEDGER_IDX_OFFSET = 20;
const TRANSFERRED_NFT_ID_OFFSET = 28;

const CANDIDATE_GOVERNOR_HOOK_HASH_OFFSET = 0;
const CANDIDATE_REGISTRY_HOOK_HASH_OFFSET = 32;
const CANDIDATE_HEARTBEAT_HOOK_HASH_OFFSET = 64;

const CANDIDATE_OWNER_ADDRESS_OFFSET = 0;
const CANDIDATE_IDX_OFFSET = 20;
const CANDIDATE_SHORT_NAME_OFFSET = 24;
const CANDIDATE_CREATED_TIMESTAMP_OFFSET = 44;
const CANDIDATE_PROPOSAL_FEE_OFFSET = 52;
const CANDIDATE_POSITIVE_VOTE_COUNT_OFFSET = 60;
const CANDIDATE_LAST_VOTE_TIMESTAMP_OFFSET = 64;
const CANDIDATE_STATUS_OFFSET = 72;
const CANDIDATE_STATUS_CHANGE_TIMESTAMP_OFFSET = 73;
const CANDIDATE_FOUNDATION_VOTE_STATUS_OFFSET = 81;

const NETWORK_BUSYNESS_DETECT_PERIOD_OFFSET = 0;
const NETWORK_BUSYNESS_DETECT_AVERAGE_OFFSET = 4;

const STATE_KEY_TYPES = {
    TOKEN_ID: 2,
    HOST_ADDR: 3,
    TRANSFEREE_ADDR: 4,
    CANDIDATE_OWNER: 5,
    CANDIDATE_ID: 6
}

const MOMENT_TYPES = {
    LEDGER: 0,
    TIMESTAMP: 1
}

const TRANSFER_STATES = {
    NO_TRANSFER: 0,
    HAS_A_TRANSFER: 1
}

const HOST_FLAGS = {
    REPUTED_ON_HEARTBEAT: 1
}

const EVERNODE_PREFIX = 'EVR';
const HOST_ADDR_KEY_ZERO_COUNT = 8;
const TRANSFEREE_ADDR_KEY_ZERO_COUNT = 8;
const CANDIDATE_OWNER_KEY_ZERO_COUNT = 8;
const HOOK_STATE_LEDGER_TYPE_PREFIX = 118; // Decimal value of ASCII 'v'
const PENDING_TRANSFER = 1;
const HOST_EMAIL_ADDRESS_LEN = 40;

class StateHelpers {
    static StateTypes = {
        TOKEN_ID: 'tokenId',
        HOST_ADDR: 'hostAddr',
        SIGLETON: 'singleton',
        CONFIGURATION: 'configuration',
        TRANSFEREE_ADDR: 'transfereeAddr',
        CANDIDATE_OWNER: 'candidateOwner',
        CANDIDATE_ID: 'candidateId'
    }

    static timeLines = {
        SEC: "SEC"
    }

    static getStateData(states, key) {
        const state = states.find(s => key === s.key);
        if (!state)
            return null;

        return state.data;
    }

    static decodeHostAddressState(stateKeyBuf, stateDataBuf) {
        let data = {
            address: codec.encodeAccountID(stateKeyBuf.slice(12)),
            uriTokenId: stateDataBuf.slice(HOST_TOKEN_ID_OFFSET, HOST_COUNTRY_CODE_OFFSET).toString('hex').toUpperCase(),
            countryCode: stateDataBuf.slice(HOST_COUNTRY_CODE_OFFSET, HOST_RESERVED_OFFSET).toString(),
            description: stateDataBuf.slice(HOST_DESCRIPTION_OFFSET, HOST_REG_LEDGER_OFFSET).toString().replace(/\0/g, ''),
            registrationLedger: Number(stateDataBuf.readBigUInt64LE(HOST_REG_LEDGER_OFFSET)),
            registrationFee: Number(stateDataBuf.readBigUInt64LE(HOST_REG_FEE_OFFSET)),
            maxInstances: stateDataBuf.readUInt32LE(HOST_TOT_INS_COUNT_OFFSET),
            activeInstances: stateDataBuf.readUInt32LE(HOST_ACT_INS_COUNT_OFFSET),
            lastHeartbeatIndex: Number(stateDataBuf.readBigUInt64LE(HOST_HEARTBEAT_TIMESTAMP_OFFSET)),
            version: `${stateDataBuf.readUInt8(HOST_VERSION_OFFSET)}.${stateDataBuf.readUInt8(HOST_VERSION_OFFSET + 1)}.${stateDataBuf.readUInt8(HOST_VERSION_OFFSET + 2)}`,
            isATransferer: (stateDataBuf.readUInt8(HOST_TRANSFER_FLAG_OFFSET) === PENDING_TRANSFER) ? TRANSFER_STATES.HAS_A_TRANSFER : TRANSFER_STATES.NO_TRANSFER,
            lastVoteCandidateIdx: stateDataBuf.readUInt32LE(HOST_LAST_VOTE_CANDIDATE_IDX_OFFSET),
            lastVoteTimestamp: Number(stateDataBuf.readBigUInt64LE(HOST_LAST_VOTE_TIMESTAMP_OFFSET)),
            supportVoteSent: stateDataBuf.readUInt8(HOST_SUPPORT_VOTE_FLAG_OFFSET)
        }
        if (stateDataBuf.length > HOST_REG_TIMESTAMP_OFFSET)
            data.registrationTimestamp = Number(stateDataBuf.readBigUInt64LE(HOST_REG_TIMESTAMP_OFFSET));
        if (stateDataBuf.length > HOST_REPUTATION_OFFSET)
            data.hostReputation = stateDataBuf.readUInt8(HOST_REPUTATION_OFFSET);
        if (stateDataBuf.length > HOST_FLAGS_OFFSET) {
            const flags = stateDataBuf.readUInt8(HOST_FLAGS_OFFSET);
            data.reputedOnHeartbeat = !!(flags & HOST_FLAGS.REPUTED_ON_HEARTBEAT);
        }
        if (stateDataBuf.length > HOST_TRANSFER_TIMESTAMP_OFFSET) {
            data.transferTimestamp = Number(stateDataBuf.readBigUInt64LE(HOST_TRANSFER_TIMESTAMP_OFFSET));
        }
        if (stateDataBuf.length > HOST_LEASE_AMOUNT_OFFSET) {
            data.leaseAmount = XflHelpers.toString(stateDataBuf.readBigInt64LE(HOST_LEASE_AMOUNT_OFFSET));

        }
        return data;
    }

    static decodeTokenIdState(stateDataBuf) {
        return {
            address: codec.encodeAccountID(stateDataBuf.slice(HOST_ADDRESS_OFFSET, HOST_CPU_MODEL_NAME_OFFSET)),
            cpuModelName: stateDataBuf.slice(HOST_CPU_MODEL_NAME_OFFSET, HOST_CPU_COUNT_OFFSET).toString().replace(/\x00+$/, ''), // Remove trailing \x00 characters.
            cpuCount: stateDataBuf.readUInt16LE(HOST_CPU_COUNT_OFFSET),
            cpuMHz: stateDataBuf.readUInt16LE(HOST_CPU_SPEED_OFFSET),
            cpuMicrosec: stateDataBuf.readUInt32LE(HOST_CPU_MICROSEC_OFFSET),
            ramMb: stateDataBuf.readUInt32LE(HOST_RAM_MB_OFFSET),
            diskMb: stateDataBuf.readUInt32LE(HOST_DISK_MB_OFFSET),
            email: stateDataBuf.slice(HOST_EMAIL_ADDRESS_OFFSET, HOST_EMAIL_ADDRESS_OFFSET + HOST_EMAIL_ADDRESS_LEN).toString().toString().replace(/\0/g, ''),
            accumulatedRewardAmount: XflHelpers.toString(stateDataBuf.readBigInt64LE(HOST_ACCUMULATED_REWARD_OFFSET))
        }
    }

    static decodeTransfereeAddrState(stateKeyBuf, stateDataBuf) {
        const prevHostClassicAddress = codec.encodeAccountID(stateDataBuf.slice(PREV_HOST_ADDRESS_OFFSET, TRANSFER_LEDGER_IDX_OFFSET));
        return {
            futureOwnerAddress: codec.encodeAccountID(stateKeyBuf.slice(12)),
            prevHostAddressKey: this.generateHostAddrStateKey(prevHostClassicAddress),
            prevHostAddress: prevHostClassicAddress,
            transferLedgerIdx: Number(stateDataBuf.readBigUInt64LE(TRANSFER_LEDGER_IDX_OFFSET)),
            transferredNfTokenId: stateDataBuf.slice(TRANSFERRED_NFT_ID_OFFSET, 60).toString('hex').toUpperCase()
        }
    }

    static decodeCandidateOwnerState(stateKeyBuf, stateDataBuf) {
        let data = {
            ownerAddress: codec.encodeAccountID(stateKeyBuf.slice(12)),
            uniqueId: this.getNewHookCandidateId(stateDataBuf),
            governorHookHash: stateDataBuf.slice(CANDIDATE_GOVERNOR_HOOK_HASH_OFFSET, CANDIDATE_REGISTRY_HOOK_HASH_OFFSET).toString('hex').toUpperCase(),
            registryHookHash: stateDataBuf.slice(CANDIDATE_REGISTRY_HOOK_HASH_OFFSET, CANDIDATE_HEARTBEAT_HOOK_HASH_OFFSET).toString('hex').toUpperCase(),
            heartbeatHookHash: stateDataBuf.slice(CANDIDATE_HEARTBEAT_HOOK_HASH_OFFSET, CANDIDATE_HEARTBEAT_HOOK_HASH_OFFSET + 32).toString('hex').toUpperCase(),
        }
        return data;
    }

    static decodeCandidateIdState(stateDataBuf) {
        let status = '';
        switch (stateDataBuf.readUInt8(CANDIDATE_STATUS_OFFSET)) {
            case EvernodeConstants.CandidateStatuses.CANDIDATE_SUPPORTED:
                status = 'supported';
                break;
            case EvernodeConstants.CandidateStatuses.CANDIDATE_ELECTED:
                status = 'elected';
                break;
            case EvernodeConstants.CandidateStatuses.CANDIDATE_PURGED:
                status = 'purged';
                break;
            case EvernodeConstants.CandidateStatuses.CANDIDATE_WITHDRAWN:
                status = 'withdrawn';
                break;
            default:
                status = 'rejected';
                break;
        }

        return {
            ownerAddress: codec.encodeAccountID(stateDataBuf.slice(CANDIDATE_OWNER_ADDRESS_OFFSET, CANDIDATE_IDX_OFFSET)),
            index: stateDataBuf.readUInt32LE(CANDIDATE_IDX_OFFSET),
            shortName: stateDataBuf.slice(CANDIDATE_SHORT_NAME_OFFSET, CANDIDATE_CREATED_TIMESTAMP_OFFSET).toString().replace(/\x00+$/, ''), // Remove trailing \x00 characters.
            createdTimestamp: Number(stateDataBuf.readBigUInt64LE(CANDIDATE_CREATED_TIMESTAMP_OFFSET)),
            proposalFee: XflHelpers.toString(stateDataBuf.readBigInt64LE(CANDIDATE_PROPOSAL_FEE_OFFSET)),
            positiveVoteCount: stateDataBuf.readUInt32LE(CANDIDATE_POSITIVE_VOTE_COUNT_OFFSET),
            lastVoteTimestamp: Number(stateDataBuf.readBigUInt64LE(CANDIDATE_LAST_VOTE_TIMESTAMP_OFFSET)),
            status: status,
            statusChangeTimestamp: Number(stateDataBuf.readBigUInt64LE(CANDIDATE_STATUS_CHANGE_TIMESTAMP_OFFSET)),
            foundationVoteStatus: stateDataBuf.readUInt8(CANDIDATE_FOUNDATION_VOTE_STATUS_OFFSET) === EvernodeConstants.CandidateStatuses.CANDIDATE_SUPPORTED ? 'supported' : 'rejected'
        }
    }

    static decodeStateData(stateKey, stateData) {
        const hexKey = stateKey.toString('hex').toUpperCase();
        if (Buffer.from(HookStateKeys.PREFIX_HOST_ADDR, 'hex').compare(stateKey, 0, 4) === 0) {
            return {
                type: this.StateTypes.HOST_ADDR,
                key: hexKey,
                ...this.decodeHostAddressState(stateKey, stateData)
            }
        }
        else if (Buffer.from(HookStateKeys.PREFIX_HOST_TOKENID, 'hex').compare(stateKey, 0, 4) === 0) {
            // Generate the address state key.
            const addressKeyBuf = Buffer.alloc(32, 0);
            Buffer.from(HookStateKeys.PREFIX_HOST_ADDR, 'hex').copy(addressKeyBuf);
            stateData.copy(addressKeyBuf, 12, HOST_ADDRESS_OFFSET, HOST_CPU_MODEL_NAME_OFFSET)
            return {
                type: this.StateTypes.TOKEN_ID,
                key: hexKey,
                addressKey: addressKeyBuf.toString('hex').toUpperCase(),
                ...this.decodeTokenIdState(stateData)
            }
        }
        else if (Buffer.from(HookStateKeys.PREFIX_TRANSFEREE_ADDR, 'hex').compare(stateKey, 0, 4) === 0) {
            return {
                type: this.StateTypes.TRANSFEREE_ADDR,
                key: hexKey,
                ...this.decodeTransfereeAddrState(stateKey, stateData)
            }
        }
        else if (Buffer.from(HookStateKeys.PREFIX_CANDIDATE_OWNER, 'hex').compare(stateKey, 0, 4) === 0) {
            const decoded = this.decodeCandidateOwnerState(stateKey, stateData);

            // Generate the address state key.
            const idBuf = Buffer.alloc(32, 0);
            Buffer.from(HookStateKeys.PREFIX_CANDIDATE_ID, 'hex').copy(idBuf);
            Buffer.from(decoded.uniqueId, 'hex').copy(idBuf, 4, 4, 32)

            return {
                type: this.StateTypes.CANDIDATE_OWNER,
                key: hexKey,
                idKey: idBuf.toString('hex').toUpperCase(),
                ...decoded
            }
        }
        else if (Buffer.from(HookStateKeys.PREFIX_CANDIDATE_ID, 'hex').compare(stateKey, 0, 4) === 0) {
            // Generate the owner state key.
            const candidateData = {
                type: this.StateTypes.CANDIDATE_ID,
                key: hexKey
            };

            const uniqueIdBuf = Buffer.alloc(32, 0);
            stateKey.copy(uniqueIdBuf, 4, 4, 32);
            candidateData.uniqueId = uniqueIdBuf.toString('hex').toUpperCase();

            const candidateType = stateKey.readUInt8(4);
            if (EvernodeConstants.CandidateTypes.DudHost === candidateType)
                candidateData.dudHostAddress = codec.encodeAccountID(stateKey.slice(12, 32));

            return {
                ...candidateData,
                ...this.decodeCandidateIdState(stateData)
            }
        }
        else if (Buffer.from(HookStateKeys.HOST_COUNT, 'hex').compare(stateKey) === 0) {
            return {
                type: this.StateTypes.SIGLETON,
                key: hexKey,
                value: stateData.readUInt32LE()
            }
        }
        else if (Buffer.from(HookStateKeys.MOMENT_BASE_INFO, 'hex').compare(stateKey) === 0) {
            return {
                type: this.StateTypes.SIGLETON,
                key: hexKey,
                value: {
                    baseIdx: Number(stateData.readBigUInt64LE(MOMENT_BASE_POINT_OFFSET)),
                    baseTransitionMoment: stateData.length > MOMENT_AT_TRANSITION_OFFSET ? stateData.readUInt32LE(MOMENT_AT_TRANSITION_OFFSET) : 0,
                    momentType: (stateData.length <= MOMENT_TYPE_OFFSET || stateData.readUInt8(MOMENT_TYPE_OFFSET) === MOMENT_TYPES.LEDGER) ? 'ledger' : 'timestamp'
                }
            }
        }
        else if (Buffer.from(HookStateKeys.HOST_REG_FEE, 'hex').compare(stateKey) === 0 || Buffer.from(HookStateKeys.MAX_REG, 'hex').compare(stateKey) === 0) {
            return {
                type: this.StateTypes.SIGLETON,
                key: hexKey,
                value: Number(stateData.readBigUInt64LE())
            }
        }
        else if (Buffer.from(HookStateKeys.REGISTRY_ADDR, 'hex').compare(stateKey) === 0 ||
            Buffer.from(HookStateKeys.HEARTBEAT_ADDR, 'hex').compare(stateKey) === 0 ||
            Buffer.from(HookStateKeys.EVR_ISSUER_ADDR, 'hex').compare(stateKey) === 0 ||
            Buffer.from(HookStateKeys.FOUNDATION_ADDR, 'hex').compare(stateKey) === 0) {
            return {
                type: this.StateTypes.CONFIGURATION,
                key: hexKey,
                value: codec.encodeAccountID(stateData)
            }
        }
        else if (Buffer.from(HookStateKeys.MOMENT_SIZE, 'hex').compare(stateKey) === 0 ||
            Buffer.from(HookStateKeys.HOST_HEARTBEAT_FREQ, 'hex').compare(stateKey) === 0 ||
            Buffer.from(HookStateKeys.LEASE_ACQUIRE_WINDOW, 'hex').compare(stateKey) === 0) {
            return {
                type: this.StateTypes.CONFIGURATION,
                key: hexKey,
                value: stateData.readUInt16LE()
            }
        }
        else if (Buffer.from(HookStateKeys.MINT_LIMIT, 'hex').compare(stateKey) === 0 || Buffer.from(HookStateKeys.FIXED_REG_FEE, 'hex').compare(stateKey) === 0) {
            return {
                type: this.StateTypes.CONFIGURATION,
                key: hexKey,
                value: Number(stateData.readBigUInt64LE())
            }
        }
        else if (Buffer.from(HookStateKeys.REWARD_CONFIGURATION, 'hex').compare(stateKey) === 0) {
            let value = {
                epochCount: stateData.readUInt8(EPOCH_COUNT_OFFSET),
                firstEpochRewardQuota: stateData.readUInt32LE(FIRST_EPOCH_REWARD_QUOTA_OFFSET),
                epochRewardAmount: stateData.readUInt32LE(EPOCH_REWARD_AMOUNT_OFFSET),
                rewardStartMoment: stateData.readUInt32LE(REWARD_START_MOMENT_OFFSET),
                accumulatedRewardFrequency: stateData.readUInt16LE(ACCUMULATED_REWARD_FREQUENCY_OFFSET)
            };
            if (stateData.length > HOST_REPUTATION_THRESHOLD_OFFSET)
                value.hostReputationThreshold = stateData.readUInt8(HOST_REPUTATION_THRESHOLD_OFFSET);
            if (stateData.length > HOST_MIN_INSTANCE_COUNT_OFFSET)
                value.hostMinInstanceCount = stateData.readUInt32LE(HOST_MIN_INSTANCE_COUNT_OFFSET);
            return {
                type: this.StateTypes.CONFIGURATION,
                key: hexKey,
                value: value
            }
        }
        else if (Buffer.from(HookStateKeys.REWARD_INFO, 'hex').compare(stateKey) === 0) {
            let value = {
                epoch: stateData.readUInt8(EPOCH_OFFSET),
                savedMoment: stateData.readUInt32LE(SAVED_MOMENT_OFFSET),
                prevMomentActiveHostCount: stateData.readUInt32LE(PREV_MOMENT_ACTIVE_HOST_COUNT_OFFSET),
                curMomentActiveHostCount: stateData.readUInt32LE(CUR_MOMENT_ACTIVE_HOST_COUNT_OFFSET),
                epochPool: XflHelpers.toString(stateData.readBigInt64LE(EPOCH_POOL_OFFSET)),
            };
            if (stateData.length > HOST_MAX_LEASE_AMOUNT_OFFSET)
                value.hostMaxLeaseAmount = XflHelpers.toString(stateData.readBigInt64LE(HOST_MAX_LEASE_AMOUNT_OFFSET));
            return {
                type: this.StateTypes.SIGLETON,
                key: hexKey,
                value: value
            }
        }
        else if (Buffer.from(HookStateKeys.MAX_TOLERABLE_DOWNTIME, 'hex').compare(stateKey) === 0) {
            return {
                type: this.StateTypes.CONFIGURATION,
                key: hexKey,
                value: stateData.readUInt16LE()
            }
        }
        else if (Buffer.from(HookStateKeys.MOMENT_TRANSIT_INFO, 'hex').compare(stateKey) === 0) {
            Buffer.alloc(1).readUInt8()
            return {
                type: this.StateTypes.CONFIGURATION,
                key: hexKey,
                value: {
                    transitionIndex: Number(stateData.readBigInt64LE(TRANSIT_IDX_OFFSET)),
                    momentSize: stateData.readUInt16LE(TRANSIT_MOMENT_SIZE_OFFSET),
                    momentType: stateData.readUInt8(TRANSIT_MOMENT_TYPE_OFFSET) === MOMENT_TYPES.LEDGER ? 'ledger' : 'timestamp'
                }
            }
        }
        else if (Buffer.from(HookStateKeys.MAX_TRX_EMISSION_FEE, 'hex').compare(stateKey) === 0) {
            return {
                type: this.StateTypes.CONFIGURATION,
                key: hexKey,
                value: Number(stateData.readBigUInt64LE())
            }
        }
        else if (Buffer.from(HookStateKeys.GOVERNANCE_CONFIGURATION, 'hex').compare(stateKey) === 0) {
            return {
                type: this.StateTypes.CONFIGURATION,
                key: hexKey,
                value: {
                    eligibilityPeriod: stateData.readUInt32LE(ELIGIBILITY_PERIOD_OFFSET),
                    candidateLifePeriod: stateData.readUInt32LE(CANDIDATE_LIFE_PERIOD_OFFSET),
                    candidateElectionPeriod: stateData.readUInt32LE(CANDIDATE_ELECTION_PERIOD_OFFSET),
                    candidateSupportAverage: stateData.readUInt16LE(CANDIDATE_SUPPORT_AVERAGE_OFFSET)
                }
            }
        }
        else if (Buffer.from(HookStateKeys.GOVERNANCE_INFO, 'hex').compare(stateKey) === 0) {
            let mode = '';
            switch (stateData.readUInt8(GOVERNANCE_MODE_OFFSET)) {
                case EvernodeConstants.GovernanceModes.Piloted:
                    mode = 'piloted';
                    break;
                case EvernodeConstants.GovernanceModes.CoPiloted:
                    mode = 'co-piloted';
                    break;
                case EvernodeConstants.GovernanceModes.AutoPiloted:
                    mode = 'auto-piloted';
                    break;
                default:
                    mode = 'undefined';
                    break;
            }
            return {
                type: this.StateTypes.SIGLETON,
                key: hexKey,
                value: {
                    governanceMode: mode,
                    lastCandidateIdx: stateData.readUInt32LE(LAST_CANDIDATE_IDX_OFFSET),
                    voteBaseCount: stateData.readUInt32LE(VOTER_BASE_COUNT_OFFSET),
                    voteBaseCountChangedTimestamp: Number(stateData.readBigUInt64LE(VOTER_BASE_COUNT_CHANGED_TIMESTAMP_OFFSET)),
                    foundationLastVotedCandidateIdx: stateData.readUInt32LE(FOUNDATION_LAST_VOTED_CANDIDATE_IDX),
                    foundationLastVotedTimestamp: Number(stateData.readBigUInt64LE(FOUNDATION_LAST_VOTED_TIMESTAMP_OFFSET)),
                    electedProposalUniqueId: stateData.slice(ELECTED_PROPOSAL_UNIQUE_ID_OFFSET, PROPOSAL_ELECTED_TIMESTAMP_OFFSET).toString('hex').toUpperCase(),
                    proposalElectedTimestamp: Number(stateData.readBigUInt64LE(PROPOSAL_ELECTED_TIMESTAMP_OFFSET)),
                    updatedHookCount: stateData.readUInt8(UPDATED_HOOK_COUNT_OFFSET)
                }
            }
        }
        else if (Buffer.from(HookStateKeys.NETWORK_CONFIGURATION, 'hex').compare(stateKey) === 0) {
            return {
                type: this.StateTypes.CONFIGURATION,
                key: hexKey,
                value: {
                    busynessDetectPeriod: stateData.readUInt32LE(NETWORK_BUSYNESS_DETECT_PERIOD_OFFSET),
                    busynessDetectAverage: stateData.readUInt16LE(NETWORK_BUSYNESS_DETECT_AVERAGE_OFFSET)
                }
            }
        }
        else if (Buffer.from(HookStateKeys.TRX_FEE_BASE_INFO, 'hex').compare(stateKey) === 0) {
            return {
                type: this.StateTypes.SIGLETON,
                key: hexKey,
                value: {
                    feeBaseAvg: stateData.readUInt32LE(FEE_BASE_AVG_OFFSET),
                    avgChangedIdx: Number(stateData.readBigUInt64LE(FEE_BASE_AVG_CHANGED_IDX_OFFSET)),
                    avgAccumulator: stateData.readUInt32LE(FEE_BASE_AVG_ACCUMULATOR_OFFSET),
                    counter: stateData.readUInt16LE(FEE_BASE_COUNTER_OFFSET)
                }
            }
        }
        else
            throw { type: 'Validation Error', message: 'Invalid state key.' };
    }

    static decodeStateKey(stateKey) {
        const hexKey = stateKey.toString('hex').toUpperCase();
        if (Buffer.from(HookStateKeys.PREFIX_HOST_ADDR, 'hex').compare(stateKey, 0, 4) === 0) {
            return {
                key: hexKey,
                type: this.StateTypes.HOST_ADDR
            };
        }
        else if (Buffer.from(HookStateKeys.PREFIX_HOST_TOKENID, 'hex').compare(stateKey, 0, 4) === 0) {
            return {
                key: hexKey,
                type: this.StateTypes.TOKEN_ID
            };
        }
        else if (Buffer.from(HookStateKeys.PREFIX_TRANSFEREE_ADDR, 'hex').compare(stateKey, 0, 4) === 0) {
            return {
                key: hexKey,
                type: this.StateTypes.TRANSFEREE_ADDR
            };
        }
        else if (Buffer.from(HookStateKeys.PREFIX_CANDIDATE_ID, 'hex').compare(stateKey, 0, 4) === 0) {
            return {
                key: hexKey,
                type: this.StateTypes.CANDIDATE_ID
            };
        }
        else if (Buffer.from(HookStateKeys.PREFIX_CANDIDATE_OWNER, 'hex').compare(stateKey, 0, 4) === 0) {
            return {
                key: hexKey,
                type: this.StateTypes.CANDIDATE_OWNER
            };
        }
        else if (Buffer.from(HookStateKeys.HOST_COUNT, 'hex').compare(stateKey) === 0 ||
            Buffer.from(HookStateKeys.MOMENT_BASE_INFO, 'hex').compare(stateKey) === 0 ||
            Buffer.from(HookStateKeys.HOST_REG_FEE, 'hex').compare(stateKey) === 0 ||
            Buffer.from(HookStateKeys.MAX_REG, 'hex').compare(stateKey) === 0 ||
            Buffer.from(HookStateKeys.REWARD_INFO, 'hex').compare(stateKey) === 0 ||
            Buffer.from(HookStateKeys.GOVERNANCE_INFO, 'hex').compare(stateKey) === 0 ||
            Buffer.from(HookStateKeys.TRX_FEE_BASE_INFO, 'hex').compare(stateKey) === 0) {
            return {
                key: hexKey,
                type: this.StateTypes.SIGLETON
            };
        }
        else if (Buffer.from(HookStateKeys.EVR_ISSUER_ADDR, 'hex').compare(stateKey) === 0 ||
            Buffer.from(HookStateKeys.FOUNDATION_ADDR, 'hex').compare(stateKey) === 0 ||
            Buffer.from(HookStateKeys.MOMENT_SIZE, 'hex').compare(stateKey) === 0 ||
            Buffer.from(HookStateKeys.HOST_HEARTBEAT_FREQ, 'hex').compare(stateKey) ||
            Buffer.from(HookStateKeys.MINT_LIMIT, 'hex').compare(stateKey) === 0 ||
            Buffer.from(HookStateKeys.FIXED_REG_FEE, 'hex').compare(stateKey) === 0 ||
            Buffer.from(HookStateKeys.LEASE_ACQUIRE_WINDOW, 'hex').compare(stateKey) === 0 ||
            Buffer.from(HookStateKeys.REWARD_CONFIGURATION, 'hex').compare(stateKey) === 0 ||
            Buffer.from(HookStateKeys.MAX_TOLERABLE_DOWNTIME, 'hex').compare(stateKey) === 0 ||
            Buffer.from(HookStateKeys.MOMENT_TRANSIT_INFO, 'hex').compare(stateKey) === 0 ||
            Buffer.from(HookStateKeys.MAX_TRX_EMISSION_FEE, 'hex').compare(stateKey) === 0 ||
            Buffer.from(HookStateKeys.REGISTRY_ADDR, 'hex').compare(stateKey) === 0 ||
            Buffer.from(HookStateKeys.HEARTBEAT_ADDR, 'hex').compare(stateKey) === 0 ||
            Buffer.from(HookStateKeys.GOVERNANCE_CONFIGURATION, 'hex').compare(stateKey) === 0 ||
            Buffer.from(HookStateKeys.NETWORK_CONFIGURATION, 'hex').compare(stateKey) === 0) {
            return {
                key: hexKey,
                type: this.StateTypes.CONFIGURATION
            };
        }
        else
            throw { type: 'Validation Error', message: 'Invalid state key.' };
    }

    static generateTokenIdStateKey(uriToken) {
        // 1 byte - Key Type.
        let buf = Buffer.alloc(1, 0);
        buf.writeUInt8(STATE_KEY_TYPES.TOKEN_ID);

        const uriTokenBuf = Buffer.from(uriToken, "hex");
        const stateKeyBuf = (Buffer.concat([Buffer.from(EVERNODE_PREFIX, "utf-8"), buf, uriTokenBuf.slice(4, 32)]));
        return stateKeyBuf.toString('hex').toUpperCase();
    }

    static generateHostAddrStateKey(address) {
        // 1 byte - Key Type.
        // 8 bytes - Zeros.
        let buf = Buffer.alloc(9, 0);
        buf.writeUInt8(STATE_KEY_TYPES.HOST_ADDR);
        for (let i = 0; i < HOST_ADDR_KEY_ZERO_COUNT; i++) {
            buf.writeUInt8(0, i + 1);
        }

        const addrBuf = Buffer.from(codec.decodeAccountID(address), "hex");
        const stateKeyBuf = Buffer.concat([Buffer.from(EVERNODE_PREFIX, "utf-8"), buf, addrBuf]);
        return stateKeyBuf.toString('hex').toUpperCase();
    }

    static generateTransfereeAddrStateKey(address) {
        // 1 byte - Key Type.
        // 8 bytes - Zeros.
        let buf = Buffer.alloc(9, 0);
        buf.writeUInt8(STATE_KEY_TYPES.TRANSFEREE_ADDR);
        for (let i = 0; i < TRANSFEREE_ADDR_KEY_ZERO_COUNT; i++) {
            buf.writeUInt8(0, i + 1);
        }

        const addrBuf = Buffer.from(codec.decodeAccountID(address), "hex");
        const stateKeyBuf = Buffer.concat([Buffer.from(EVERNODE_PREFIX, "utf-8"), buf, addrBuf]);
        return stateKeyBuf.toString('hex').toUpperCase();
    }

    static generateCandidateIdStateKey(uniqueId) {
        // 1 byte - Key Type.
        let buf = Buffer.alloc(1, 0);
        buf.writeUInt8(STATE_KEY_TYPES.CANDIDATE_ID);

        const idBuf = Buffer.from(uniqueId, "hex");
        const stateKeyBuf = (Buffer.concat([Buffer.from(EVERNODE_PREFIX, "utf-8"), buf, idBuf.slice(4, 32)]));
        return stateKeyBuf.toString('hex').toUpperCase();
    }

    static generateCandidateOwnerStateKey(owner) {
        // 1 byte - Key Type.
        // 8 bytes - Zeros.
        let buf = Buffer.alloc(9, 0);
        buf.writeUInt8(STATE_KEY_TYPES.CANDIDATE_OWNER);
        for (let i = 0; i < CANDIDATE_OWNER_KEY_ZERO_COUNT; i++) {
            buf.writeUInt8(0, i + 1);
        }

        const addrBuf = Buffer.from(codec.decodeAccountID(owner), "hex");
        const stateKeyBuf = Buffer.concat([Buffer.from(EVERNODE_PREFIX, "utf-8"), buf, addrBuf]);
        return stateKeyBuf.toString('hex').toUpperCase();
    }

    static getHookStateIndex(hookAccount, stateKey, hookNamespace = EvernodeConstants.HOOK_NAMESPACE) {
        const typeBuf = Buffer.alloc(2, 0);
        typeBuf.writeInt16BE(HOOK_STATE_LEDGER_TYPE_PREFIX);

        const accIdBuf = codec.decodeAccountID(hookAccount);
        const stateKeyBuf = Buffer.from(stateKey, 'hex');
        const namespaceBuf = Buffer.from(hookNamespace, 'hex');

        let hash = crypto.createHash('sha512');

        let data = hash.update(typeBuf);
        data = hash.update(accIdBuf);
        data = hash.update(stateKeyBuf);
        data = hash.update(namespaceBuf);

        const digest = data.digest('hex');
        // Get the first 32 bytes of hash.
        return digest.substring(0, 64).toUpperCase();
    }

    static getNewHookCandidateId(hashesBuf) {
        const idBuf = Buffer.alloc(32, 0);
        idBuf.writeUInt8(EvernodeConstants.CandidateTypes.NewHook, 4);
        Buffer.from(sha512Half(hashesBuf)).copy(idBuf, 5, 5);
        return idBuf.toString('hex').toUpperCase();
    }

    static getPilotedModeCandidateId() {
        const idBuf = Buffer.alloc(32, 0);
        idBuf.writeUInt8(EvernodeConstants.CandidateTypes.PilotedMode, 4);
        Buffer.from(EvernodeConstants.HOOK_NAMESPACE, 'hex').copy(idBuf, 5, 5);
        return idBuf.toString('hex').toUpperCase();
    }

    static getDudHostCandidateId(hostAddress) {
        const idBuf = Buffer.alloc(32, 0);
        idBuf.writeUInt8(EvernodeConstants.CandidateTypes.DudHost, 4);
        codec.decodeAccountID(hostAddress).copy(idBuf, 12);
        return idBuf.toString('hex').toUpperCase();
    }

    static getCandidateType(candidateId) {
        return Buffer.from(candidateId, 'hex').readUInt8(4);
    }
}

module.exports = {
    StateHelpers
}

/***/ }),

/***/ 7071:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { MemoFormats, HookParamKeys } = __nccwpck_require__(9849);

class TransactionHelper {

    // Convert memos from our object type to xrpl lib object type.
    static formatMemos(memos) {
        return memos ? memos.filter(m => m.type).map(m => {
            const data = (m.format === MemoFormats.HEX) ? m.data :
                TransactionHelper.asciiToHex((typeof m.data === "object") ? JSON.stringify(m.data) : m.data)
            return {
                Memo: {
                    MemoType: TransactionHelper.asciiToHex(m.type),
                    MemoFormat: TransactionHelper.asciiToHex(m.format),
                    MemoData: data
                }
            }
        }) : [];
    }

    // Convert memos from xrpl lib object type to our object type.
    static deserializeMemos(memos) {
        if (!memos)
            return [];

        return memos.filter(m => m.Memo).map(m => {
            const format = m.Memo.MemoFormat ? TransactionHelper.hexToASCII(m.Memo.MemoFormat) : null;
            const data = m.Memo.MemoData ?
                ((format === MemoFormats.HEX) ? m.Memo.MemoData : TransactionHelper.hexToASCII(m.Memo.MemoData)) : null;
            return {
                type: m.Memo.MemoType ? TransactionHelper.hexToASCII(m.Memo.MemoType) : null,
                format: format,
                data: data
            }
        })
    }

    // Convert hook params from our object type to xrpl lib object type.
    static formatHookParams(params) {
        return params ? params.filter(m => m.name).map(m => {
            return {
                HookParameter: {
                    HookParameterName: m.name,
                    HookParameterValue: m.value ?
                        (m.name === HookParamKeys.PARAM_EVENT_TYPE_KEY ? TransactionHelper.asciiToHex(m.value) :
                            m.value.toUpperCase()) : ''
                }
            }
        }) : [];
    }

    // Convert hook params from xrpl lib object type to our object type.
    static deserializeHookParams(params) {
        if (!params)
            return [];

        return params.filter(m => m.HookParameter).map(m => {
            return {
                name: m.HookParameter.HookParameterName,
                value: m.HookParameter.HookParameterValue ?
                    (m.HookParameter.HookParameterName === HookParamKeys.PARAM_EVENT_TYPE_KEY ? TransactionHelper.hexToASCII(m.HookParameter.HookParameterValue) :
                        m.HookParameter.HookParameterValue.toUpperCase()) : '',
            }
        })
    }

    static hexToASCII(hex) {
        if (!hex)
            return "";

        return Buffer.from(hex, 'hex').toString();
    }

    static asciiToHex(str) {
        if (!str)
            return "";

        return Buffer.from(str).toString('hex').toUpperCase();
    }
}

module.exports = {
    TransactionHelper
}

/***/ }),

/***/ 6687:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { Buffer } = __nccwpck_require__(4300);
const { XflHelpers } = __nccwpck_require__(3243);
const { EvernodeConstants } = __nccwpck_require__(9849);
const { TransactionHelper } = __nccwpck_require__(7071);
const { EvernodeHelpers } = __nccwpck_require__(2523);

// Utility helper functions.
class UtilHelpers {

    static decodeLeaseTokenUri(hexUri) {
        // Get the lease index from the token's URI.
        // <prefix><version>lease index 16)><half of tos hash><lease amount (int64)><identifier (uint32)><(ip numeric array)>

        const asciiUri = TransactionHelper.hexToASCII(hexUri);
        const uriBuf = Buffer.from(asciiUri, 'base64');
        // Lengths of sub sections.
        const prefixLen = EvernodeConstants.LEASE_TOKEN_PREFIX_HEX.length / 2;
        const versionPrefixLen = EvernodeConstants.LEASE_TOKEN_VERSION_PREFIX_HEX.length / 2;
        const versionLen = versionPrefixLen + 2;
        const indexLen = 2;
        const halfToSLen = 16;
        const leaseAmountLen = 8;
        const identifierLen = 4;
        const ipDataLen = 17;

        const isVersionedURI = EvernodeHelpers.isValidURI(hexUri, `${EvernodeConstants.LEASE_TOKEN_PREFIX_HEX}${EvernodeConstants.LEASE_TOKEN_VERSION_PREFIX_HEX}`);

        // Offsets of sub sections
        const versionPrefixOffset = prefixLen + versionPrefixLen;
        const halfTosHashOffset = isVersionedURI ? (prefixLen + versionLen + indexLen) : (prefixLen + indexLen);
        const leaseAmountOffset = isVersionedURI ? (prefixLen + versionLen + indexLen + halfToSLen) : (prefixLen + indexLen + halfToSLen);
        const identifierOffset = isVersionedURI ? (prefixLen + versionLen + indexLen + halfToSLen + leaseAmountLen) : (prefixLen + indexLen + halfToSLen + leaseAmountLen);
        const ipDataOffset = isVersionedURI ? (prefixLen + versionLen + indexLen + halfToSLen + leaseAmountLen + identifierLen) : (prefixLen + indexLen + halfToSLen + leaseAmountLen + identifierLen);

        return {
            version: isVersionedURI ? `${uriBuf.slice(prefixLen, versionPrefixOffset).toString()}${uriBuf.readUint16BE(prefixLen + versionPrefixLen)}` : null,
            leaseIndex: isVersionedURI ? uriBuf.readUint16BE(prefixLen + versionLen) : uriBuf.readUint16BE(prefixLen),
            halfTos: uriBuf.slice(halfTosHashOffset, halfTosHashOffset + halfToSLen),
            leaseAmount: parseFloat(XflHelpers.toString(uriBuf.readBigInt64BE(leaseAmountOffset))),
            identifier: uriBuf.length > identifierOffset ? uriBuf.readUInt32BE(identifierOffset) : null,
            outboundIP: (uriBuf.length > ipDataOffset && (uriBuf.readUint8(ipDataOffset) == 6))
                ? { family: 6, address: uriBuf.slice(ipDataOffset + 1, ipDataOffset + 1 + ipDataLen).toString('hex').toUpperCase().replace(/(.{4})(?!$)/g, "$1:") }
                : null
        }
    }

    static getCurrentUnixTime(format = "sec") {
        const time = Date.now();
        switch (format) {
            case "sec":
                return Math.floor(time / 1000);
            default:
                return time;
        }
    }

}

module.exports = {
    UtilHelpers
}

/***/ }),

/***/ 3243:
/***/ ((module) => {

const minMantissa = 1000000000000000n
const maxMantissa = 9999999999999999n
const minExponent = -96
const maxExponent = 80

// Helper class to handle XFL float numbers.
class XflHelpers {

    static getExponent(xfl) {
        if (xfl < 0n)
            throw "Invalid XFL";
        if (xfl == 0n)
            return 0n;
        return ((xfl >> 54n) & 0xFFn) - 97n;
    }

    static getMantissa(xfl) {
        if (xfl < 0n)
            throw "Invalid XFL";
        if (xfl == 0n)
            return 0n;
        return xfl - ((xfl >> 54n) << 54n);
    }

    static isNegative(xfl) {
        if (xfl < 0n)
            throw "Invalid XFL";
        if (xfl == 0n)
            return false;
        return ((xfl >> 62n) & 1n) == 0n;
    }

    static toString(xfl) {
        if (xfl < 0n)
            throw "Invalid XFL";
        if (xfl == 0n)
            return '0';

        const mantissa = this.getMantissa(xfl);
        const exponent = this.getExponent(xfl);
        const mantissaStr = mantissa.toString();
        let finalResult = '';
        if (exponent > 0n) {
            finalResult = mantissaStr.padEnd(mantissaStr.length + Number(exponent), '0');
        } else {
            const newExponent = Number(exponent) + mantissaStr.length;
            const cleanedMantissa = mantissaStr.replace(/0+$/, '');
            if (newExponent == 0) {
                finalResult = '0.' + cleanedMantissa;
            } else if (newExponent < 0) {
                finalResult = '0.' + cleanedMantissa.padStart(newExponent * (-1) + cleanedMantissa.length, '0');
            } else {
                finalResult = mantissaStr.substr(0, newExponent) + '.' + mantissaStr.substr(newExponent).replace(/0+$/, '');
            }
        }
        return (this.isNegative(xfl) ? '-' : '') + finalResult.replace(/\.+$/, '');
    }

    static getXfl(floatStr) {
        let exponent;
        let mantissa;
        floatStr = parseFloat(floatStr).toString();

        if (floatStr === '0') {
            exponent = BigInt(0);
            mantissa = BigInt(0);
        }
        else if (floatStr.includes('.')) {
            const parts = floatStr.split('.');
            exponent = BigInt(-parts[1].length);
            mantissa = BigInt(parseInt(parts.join('')));
        }
        else if (floatStr.endsWith('0')) {
            const mantissaStr = floatStr.replace(/0+$/g, "");
            exponent = BigInt(floatStr.length - mantissaStr.length);
            mantissa = BigInt(parseInt(mantissaStr));
        }
        else {
            exponent = BigInt(0);
            mantissa = BigInt(parseInt(floatStr));
        }

        // Convert types as needed.
        if (typeof (exponent) != 'bigint')
            exponent = BigInt(exponent);

        if (typeof (mantissa) != 'bigint')
            mantissa = BigInt(mantissa);

        // Canonical zero.
        if (mantissa == 0n)
            return 0n;

        // Normalize.
        let is_negative = mantissa < 0;
        if (is_negative)
            mantissa *= -1n;

        while (mantissa > maxMantissa) {
            mantissa /= 10n;
            exponent++;
        }
        while (mantissa < minMantissa) {
            mantissa *= 10n;
            exponent--;
        }

        // Canonical zero on mantissa underflow.
        if (mantissa == 0)
            return 0n;

        // Under and overflows.
        if (exponent > maxExponent || exponent < minExponent)
            return -1; // Note this is an "invalid" XFL used to propagate errors.

        exponent += 97n;

        let xfl = (is_negative ? 0n : 1n);
        xfl <<= 8n;
        xfl |= BigInt(exponent);
        xfl <<= 54n;
        xfl |= BigInt(mantissa);

        return xfl;
    }
}

module.exports = {
    XflHelpers
}

/***/ }),

/***/ 9329:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const xrpl = __nccwpck_require__(4666);
const kp = __nccwpck_require__(8150);
const codec = __nccwpck_require__(597);
const crypto = __nccwpck_require__(6113);
const { XrplConstants, XrplTransactionTypes } = __nccwpck_require__(3307);
const { TransactionHelper } = __nccwpck_require__(7071);
const { EventEmitter } = __nccwpck_require__(6170);
const { Defaults } = __nccwpck_require__(8262);

class XrplAccount {

    #events = new EventEmitter();
    #subscribed = false;
    #txStreamHandler;

    constructor(address = null, secret = null, options = {}) {
        if (!address && !secret)
            throw "Both address and secret cannot be empty";

        this.address = address;
        this.secret = secret;
        this.xrplApi = options.xrplApi || Defaults.values.xrplApi;

        if (!this.xrplApi)
            throw "XrplAccount: xrplApi not specified.";

        if (!this.address && this.secret) {
            this.wallet = xrpl.Wallet.fromSeed(this.secret);
            this.address = this.wallet.classicAddress;
        } else if (this.secret) {
            const keypair = kp.deriveKeypair(this.secret);
            const derivedPubKeyAddress = kp.deriveAddress(keypair.publicKey);
            if (this.address == derivedPubKeyAddress)
                this.wallet = xrpl.Wallet.fromSeed(this.secret);
            else
                this.wallet = xrpl.Wallet.fromSeed(this.secret, { masterAddress: this.address });
        }

        this.#txStreamHandler = (eventName, tx, error) => {
            this.#events.emit(eventName, tx, error);
        };
    }

    on(event, handler) {
        this.#events.on(event, handler);
    }

    once(event, handler) {
        this.#events.once(event, handler);
    }

    off(event, handler = null) {
        this.#events.off(event, handler);
    }

    deriveKeypair() {
        if (!this.secret)
            throw 'Cannot derive key pair: Account secret is empty.';

        return kp.deriveKeypair(this.secret);
    }

    async exists() {
        return await this.xrplApi.isAccountExists(this.address);
    }

    async getInfo() {
        return await this.xrplApi.getAccountInfo(this.address);
    }

    async getSequence() {
        return (await this.getInfo())?.Sequence;
    }

    async getMintedNFTokens() {
        return ((await this.getInfo())?.MintedNFTokens || 0);
    }

    async getBurnedNFTokens() {
        return ((await this.getInfo())?.BurnedNFTokens || 0);
    }

    async getMessageKey() {
        return (await this.getInfo())?.MessageKey;
    }

    async getDomain() {
        const domain = (await this.getInfo())?.Domain;
        return domain ? TransactionHelper.hexToASCII(domain) : null;
    }

    async getTrustLines(currency, issuer) {
        const lines = await this.xrplApi.getTrustlines(this.address, {
            limit: 399,
            peer: issuer
        });
        return currency ? lines.filter(l => l.currency === currency) : lines;
    }

    async getChecks(fromAccount) {
        return await this.xrplApi.getAccountObjects(fromAccount, { type: "check" });
    }

    async getNfts() {
        return await this.xrplApi.getNfts(this.address, {
            limit: 399
        });
    }

    async getOffers() {
        return await this.xrplApi.getOffers(this.address);
    }

    async getNftOffers() {
        return await this.xrplApi.getNftOffers(this.address);
    }

    async getNftByUri(uri, isHexUri = false) {
        const nfts = await this.getNfts();
        const hexUri = isHexUri ? uri : TransactionHelper.asciiToHex(uri).toUpperCase();
        return nfts.find(n => n.URI == hexUri);
    }

    async getAccountObjects(options) {
        return await this.xrplApi.getAccountObjects(this.address, options);
    }

    async getNamespaceEntries(namespaceId, options = {}) {
        return await this.xrplApi.getNamespaceEntries(this.address, namespaceId, options);
    }

    async getFlags() {
        return xrpl.parseAccountRootFlags((await this.getInfo()).Flags);
    }

    async getAccountTrx(minLedgerIndex = -1, maxLedgerIndex = -1, isForward = true) {
        return await this.xrplApi.getAccountTrx(this.address, { ledger_index_min: minLedgerIndex, ledger_index_max: maxLedgerIndex, forward: isForward });
    }

    async hasValidKeyPair() {
        return await this.xrplApi.isValidKeyForAddress(this.wallet.publicKey, this.address);
    }

    async setAccountFields(fields, options = {}) {
        const preparedTxn = await this.prepareSetAccountFields(fields, options);
        return await this.signAndSubmit(preparedTxn, options.submissionRef);
    }

    async prepareSetAccountFields(fields, options = {}) {
        /**
         * Example for fields
         * 
         * fields = {
         *  Domain : "www.mydomain.com",
         *  Flags : { asfDefaultRipple: false, asfDisableMaster: true } 
         * }
         * 
         */

        if (Object.keys(fields).length === 0)
            throw "AccountSet fields cannot be empty.";

        const tx = {
            TransactionType: XrplTransactionTypes.ACCOUNT_SET,
            Account: this.address
        };

        for (const [key, value] of Object.entries(fields)) {

            switch (key) {
                case 'Domain':
                    tx.Domain = TransactionHelper.asciiToHex(value).toUpperCase();
                    break;

                case 'Flags':
                    for (const [flagKey, flagValue] of Object.entries(value)) {
                        tx[(flagValue) ? 'SetFlag' : 'ClearFlag'] |= xrpl.AccountSetAsfFlags[flagKey];
                    }
                    break;

                default:
                    tx[key] = value;
                    break;
            }
        }

        return await this.#prepareSubmissionTransaction(tx, options);
    }

    async setSignerList(signerList = [], options = {}) {

        const preparedTxn = await this.prepareSetSignerList(signerList, options);
        return await this.signAndSubmit(preparedTxn, options.submissionRef);
    }

    /**
     * Set the signer list to the account. Setting signerQuorum = 0 in options, will remove the signerlist from the account.
     * @param {*} signerList (optional) An array of signers. Ex:  [ {account:"ras24cvffvfbvfbbt5or4332", weight: 1}, {}, ...]
     * @param {*} options  Ex:  {signerQuorum: 1, sequence: 6543233}
     * @returns a promise
     */
    async prepareSetSignerList(signerList = [], options = {}) {
        if (options.signerQuorum < 0)
            throw ("Everpocket: quorum can't be less than zero.");

        if (options.signerQuorum > 0 && signerList.length >= 0) {
            let totalWeight = 0;
            for (const signer of signerList) {
                if (!(signer.account && signer.account.length > 0 && signer.weight && signer.weight > 0))
                    throw ("Everpocket: Signer list is invalid");
                totalWeight += signerList.weight;
            }
            if (totalWeight < options.signerQuorum)
                throw ("Everpocket: Total weight is less than the quorum");
        }

        signerList = signerList.sort((a, b) => a.account < b.account ? -1 : 1);

        const signerListTx =
        {
            Flags: 0,
            TransactionType: XrplTransactionTypes.SIGNER_LIST_SET,
            Account: this.address,
            SignerQuorum: options.signerQuorum,
            SignerEntries: [
                ...signerList.map(signer => ({
                    SignerEntry: {
                        Account: signer.account,
                        SignerWeight: signer.weight
                    }
                }))
            ]
        };
        return await this.#prepareSubmissionTransaction(signerListTx, options);
    }

    async makePayment(toAddr, amount, currency = null, issuer = null, memos = null, options = {}) {
        const preparedTxn = await this.prepareMakePayment(toAddr, amount, currency, issuer, memos, options);
        return await this.signAndSubmit(preparedTxn, options.submissionRef);
    }

    async prepareMakePayment(toAddr, amount, currency = null, issuer = null, memos = null, options = {}) {

        const amountObj = makeAmountObject(amount, currency, issuer);

        return await this.#prepareSubmissionTransaction({
            TransactionType: XrplTransactionTypes.PAYMENT,
            Account: this.address,
            Amount: amountObj,
            Destination: toAddr,
            Memos: TransactionHelper.formatMemos(memos),
            HookParameters: TransactionHelper.formatHookParams(options.hookParams)
        }, options);
    }

    async setTrustLine(currency, issuer, limit, allowRippling = false, memos = null, options = {}) {
        const preparedTxn = await this.prepareSetTrustLine(currency, issuer, limit, allowRippling, memos, options);
        return await this.signAndSubmit(preparedTxn, options.submissionRef);
    }

    async prepareSetTrustLine(currency, issuer, limit, allowRippling = false, memos = null, options = {}) {

        if (typeof limit !== 'string')
            throw "Limit must be a string.";

        let tx = {
            TransactionType: XrplTransactionTypes.TRUST_SET,
            Account: this.address,
            LimitAmount: {
                currency: currency,
                issuer: issuer,
                value: limit
            },
            Memos: TransactionHelper.formatMemos(memos),
            HookParameters: TransactionHelper.formatHookParams(options.hookParams)
        };

        if (!allowRippling)
            tx.Flags = 131072; // tfSetNoRipple;

        return await this.#prepareSubmissionTransaction(tx, options);
    }

    async setRegularKey(regularKey, memos = null, options = {}) {
        const preparedTxn = await this.prepareSetRegularKey(regularKey, memos, options);
        return await this.signAndSubmit(preparedTxn, options.submissionRef);
    }

    async prepareSetRegularKey(regularKey, memos = null, options = {}) {

        return await this.#prepareSubmissionTransaction({
            TransactionType: XrplTransactionTypes.SET_REGULAR_KEY,
            Account: this.address,
            RegularKey: regularKey,
            Memos: TransactionHelper.formatMemos(memos),
            HookParameters: TransactionHelper.formatHookParams(options.hookParams)
        }, options);
    }

    async cashCheck(check, options = {}) {
        const preparedTxn = await this.prepareCashCheck(check, options);
        return await this.signAndSubmit(preparedTxn, options.submissionRef);
    }

    async prepareCashCheck(check, options = {}) {
        const checkIDhasher = crypto.createHash('sha512')
        checkIDhasher.update(Buffer.from('0043', 'hex'))
        checkIDhasher.update(Buffer.from(codec.decodeAccountID(check.Account)))
        const seqBuf = Buffer.alloc(4)
        seqBuf.writeUInt32BE(check.Sequence, 0)
        checkIDhasher.update(seqBuf)
        const checkID = checkIDhasher.digest('hex').slice(0, 64).toUpperCase()
        console.log("Calculated checkID:", checkID);

        return await this.#prepareSubmissionTransaction({
            TransactionType: XrplTransactionTypes.CHECK_CASH,
            Account: this.address,
            CheckID: checkID,
            Amount: {
                currency: check.SendMax.currency,
                issuer: check.SendMax.issuer,
                value: check.SendMax.value
            },
        }, options);
    }

    async offerSell(sellAmount, sellCurrency, sellIssuer, forAmount, forCurrency, forIssuer = null, expiration = 4294967295, memos = null, options = {}) {
        const preparedTxn = await this.prepareOfferSell(sellAmount, sellCurrency, sellIssuer, forAmount, forCurrency, forIssuer, expiration, memos, options);
        return await this.signAndSubmit(preparedTxn, options.submissionRef);
    }

    async prepareOfferSell(sellAmount, sellCurrency, sellIssuer, forAmount, forCurrency, forIssuer = null, expiration = 4294967295, memos = null, options = {}) {

        const sellAmountObj = makeAmountObject(sellAmount, sellCurrency, sellIssuer);
        const forAmountObj = makeAmountObject(forAmount, forCurrency, forIssuer);

        return await this.#prepareSubmissionTransaction({
            TransactionType: XrplTransactionTypes.OFFER_CREATE,
            Account: this.address,
            TakerGets: sellAmountObj,
            TakerPays: forAmountObj,
            Expiration: expiration,
            Memos: TransactionHelper.formatMemos(memos),
            HookParameters: TransactionHelper.formatHookParams(options.hookParams)
        }, options);
    }

    async offerBuy(buyAmount, buyCurrency, buyIssuer, forAmount, forCurrency, forIssuer = null, expiration = 4294967295, memos = null, options = {}) {
        const preparedTxn = await this.prepareOfferBuy(buyAmount, buyCurrency, buyIssuer, forAmount, forCurrency, forIssuer, expiration, memos, options);
        return await this.signAndSubmit(preparedTxn, options.submissionRef);
    }

    async prepareOfferBuy(buyAmount, buyCurrency, buyIssuer, forAmount, forCurrency, forIssuer = null, expiration = 4294967295, memos = null, options = {}) {

        const buyAmountObj = makeAmountObject(buyAmount, buyCurrency, buyIssuer);
        const forAmountObj = makeAmountObject(forAmount, forCurrency, forIssuer);

        return await this.#prepareSubmissionTransaction({
            TransactionType: XrplTransactionTypes.OFFER_CREATE,
            Account: this.address,
            TakerGets: forAmountObj,
            TakerPays: buyAmountObj,
            Expiration: expiration,
            Memos: TransactionHelper.formatMemos(memos),
            HookParameters: TransactionHelper.formatHookParams(options.hookParams)
        }, options);
    }

    async cancelOffer(offerSequence, memos = null, options = {}) {
        const preparedTxn = await this.prepareCancelOffer(offerSequence, memos, options);
        return await this.signAndSubmit(preparedTxn, options.submissionRef);
    }

    async prepareCancelOffer(offerSequence, memos = null, options = {}) {
        return await this.#prepareSubmissionTransaction({
            TransactionType: XrplTransactionTypes.OFFER_CANCEL,
            Account: this.address,
            OfferSequence: offerSequence,
            Memos: TransactionHelper.formatMemos(memos),
            HookParameters: TransactionHelper.formatHookParams(options.hookParams)
        }, options);
    }

    async mintNft(uri, taxon, transferFee, flags = {}, memos = null, options = {}) {
        const preparedTxn = await this.prepareMintNft(uri, taxon, transferFee, flags, memos, options);
        return await this.signAndSubmit(preparedTxn, options.submissionRef);
    }

    async prepareMintNft(uri, taxon, transferFee, flags = {}, memos = null, options = {}) {
        return await this.#prepareSubmissionTransaction({
            TransactionType: XrplTransactionTypes.NF_TOKEN_MINT,
            Account: this.address,
            URI: flags.isHexUri ? uri : TransactionHelper.asciiToHex(uri).toUpperCase(),
            NFTokenTaxon: taxon,
            TransferFee: transferFee,
            Flags: (flags.isBurnable ? 1 : 0) | (flags.isOnlyXRP ? 2 : 0) | (flags.isTrustLine ? 4 : 0) | (flags.isTransferable ? 8 : 0),
            Memos: TransactionHelper.formatMemos(memos),
            HookParameters: TransactionHelper.formatHookParams(options.hookParams)
        }, options);
    }

    async offerSellNft(nfTokenId, amount, currency, issuer = null, destination = null, expiration = 4294967295, memos = null, options = {}) {
        const preparedTxn = await this.prepareOfferSellNft(nfTokenId, amount, currency, issuer, destination, expiration, memos, options);
        return await this.signAndSubmit(preparedTxn, options.submissionRef);
    }

    async prepareOfferSellNft(nfTokenId, amount, currency, issuer = null, destination = null, expiration = 4294967295, memos = null, options = {}) {

        const amountObj = makeAmountObject(amount, currency, issuer);
        const tx = {
            TransactionType: XrplTransactionTypes.NF_TOKEN_CREATE_OFFER,
            Account: this.address,
            NFTokenID: nfTokenId,
            Amount: amountObj,
            Expiration: expiration,
            Flags: 1, // tfSellToken
            Memos: TransactionHelper.formatMemos(memos),
            HookParameters: TransactionHelper.formatHookParams(options.hookParams)
        };

        return await this.#prepareSubmissionTransaction(destination ? { ...tx, Destination: destination } : tx, options);
    }

    async offerBuyNft(nfTokenId, owner, amount, currency, issuer = null, expiration = 4294967295, memos = null, options = {}) {
        const preparedTxn = await this.prepareOfferSellNft(nfTokenId, owner, amount, currency, issuer, expiration, memos, options);
        return await this.signAndSubmit(preparedTxn, options.submissionRef);
    }

    async prepareOfferBuyNft(nfTokenId, owner, amount, currency, issuer = null, expiration = 4294967295, memos = null, options = {}) {

        const amountObj = makeAmountObject(amount, currency, issuer);

        return await this.#prepareSubmissionTransaction({
            TransactionType: XrplTransactionTypes.NF_TOKEN_CREATE_OFFER,
            Account: this.address,
            NFTokenID: nfTokenId,
            Owner: owner,
            Amount: amountObj,
            Expiration: expiration,
            Flags: 0, // Buy offer
            Memos: TransactionHelper.formatMemos(memos),
            HookParameters: TransactionHelper.formatHookParams(options.hookParams)
        }, options);
    }


    async sellNft(offerId, memos = null, options = {}) {
        const preparedTxn = await this.prepareSellNft(offerId, memos, options);
        return await this.signAndSubmit(preparedTxn, options.submissionRef);
    }

    async prepareSellNft(offerId, memos = null, options = {}) {

        return await this.#prepareSubmissionTransaction({
            TransactionType: XrplTransactionTypes.NF_TOKEN_ACCEPT_OFFER,
            Account: this.address,
            NFTokenBuyOffer: offerId,
            Memos: TransactionHelper.formatMemos(memos),
            HookParameters: TransactionHelper.formatHookParams(options.hookParams)
        }, options);
    }

    async buyNft(offerId, memos = null, options = {}) {
        const preparedTxn = await this.prepareBuyNft(offerId, memos, options);
        return await this.signAndSubmit(preparedTxn, options.submissionRef);
    }

    async prepareBuyNft(offerId, memos = null, options = {}) {

        return await this.#prepareSubmissionTransaction({
            TransactionType: XrplTransactionTypes.NF_TOKEN_ACCEPT_OFFER,
            Account: this.address,
            NFTokenSellOffer: offerId,
            Memos: TransactionHelper.formatMemos(memos),
            HookParameters: TransactionHelper.formatHookParams(options.hookParams)
        }, options);
    }

    async burnNft(nfTokenId, owner = null, memos = null, options = {}) {
        const preparedTxn = await this.prepareBurnNft(nfTokenId, owner, memos, options);
        return await this.signAndSubmit(preparedTxn, options.submissionRef);
    }

    async prepareBurnNft(nfTokenId, owner = null, memos = null, options = {}) {

        const tx = {
            TransactionType: XrplTransactionTypes.NF_TOKEN_ACCEPT_OFFER,
            Account: this.address,
            NFTokenID: nfTokenId,
            Memos: TransactionHelper.formatMemos(memos),
            HookParameters: TransactionHelper.formatHookParams(options.hookParams)
        };

        return await this.#prepareSubmissionTransaction(owner ? { ...tx, Owner: owner } : tx, options);
    }

    generateKeylet(type, data = {}) {
        switch (type) {
            case 'nftPage': {
                const accIdHex = (codec.decodeAccountID(this.address)).toString('hex').toUpperCase();
                const tokenPortion = data?.nfTokenId.substr(40, 64);
                return '0050' + accIdHex + tokenPortion;
            }

            case 'nftPageMax': {
                const accIdHex = (codec.decodeAccountID(this.address)).toString('hex').toUpperCase();
                return '0050' + accIdHex + 'F'.repeat(24);
            }

            case 'nftPageMin': {
                const accIdHex = (codec.decodeAccountID(this.address)).toString('hex').toUpperCase();
                return '0050' + accIdHex + '0'.repeat(24);
            }

            default:
                return null;
        }
    }

    async subscribe() {
        // Subscribe only once. Otherwise event handlers will be duplicated.
        if (this.#subscribed)
            return;

        await this.xrplApi.subscribeToAddress(this.address, this.#txStreamHandler);

        this.#subscribed = true;
    }

    async unsubscribe() {
        if (!this.#subscribed)
            return;

        await this.xrplApi.unsubscribeFromAddress(this.address, this.#txStreamHandler);
        this.#subscribed = false;
    }

    /**
     * Submit the signed raw transaction.
     * @param txBlob Signed and encoded transacion as a hex string.
     */
    submitTransactionBlob(txBlob) {

        // Returned format.
        // {
        //     id: txHash, (if signing success)
        //     code: final transaction result code.
        //     details: submission and transaction details, (if signing success)
        //     error: Any error that prevents submission.
        // }

        return new Promise(async (resolve, reject) => {
            try {
                const submission = await this.xrplApi.submit(txBlob);
                const r = submission?.result;
                const txResult = {
                    id: r?.hash,
                    code: r?.meta?.TransactionResult,
                    details: r
                };

                console.log("Transaction result: " + txResult.code);
                const hookExecRes = txResult.details?.meta?.HookExecutions?.map(o => {
                    return {
                        result: o.HookExecution?.HookResult,
                        returnCode: parseInt(o.HookExecution?.HookReturnCode, 16),
                        message: TransactionHelper.hexToASCII(o.HookExecution?.HookReturnString).replace(/\x00+$/, '')
                    }
                });
                if (txResult.code === "tesSUCCESS")
                    resolve({ ...txResult, ...(hookExecRes ? { hookExecutionResult: hookExecRes } : {}) });
                else
                    reject({ ...txResult, ...(hookExecRes ? { hookExecutionResult: hookExecRes } : {}) });
            }
            catch (err) {
                console.log("Error submitting transaction:", err);
                reject({ error: err });
            }

        });
    }

    /**
     * Sign the given transaction and returns the signed blob and its hash.
     * @param {object} tx Transaction object.
     * @param {boolean} isMultiSign Whether the transaction is for multisigning. Defaults to false.
     * @returns {hash: string, tx_blob: string}
     */
    sign(tx, isMultiSign = false) {
        return this.xrplApi.xrplHelper.sign(tx, this.secret, isMultiSign)
    }

    // URIToken related methods

    async mintURIToken(uri, digest = null, flags = {}, options = {}) {
        const preparedTxn = await this.prepareMintURIToken(uri, digest, flags, options);
        return await this.signAndSubmit(preparedTxn, options.submissionRef);
    }

    async prepareMintURIToken(uri, digest = null, flags = {}, options = {}) {
        const tx = {
            Account: this.address,
            TransactionType: XrplTransactionTypes.URI_TOKEN_MINT,
            URI: flags.isHexUri ? uri : TransactionHelper.asciiToHex(uri).toUpperCase(),
            Flags: flags.isBurnable ? 1 : 0
        }

        if (digest)
            tx.Digest = digest;

        return await this.#prepareSubmissionTransaction(tx, options);
    }


    async burnURIToken(uriTokenID, options = {}) {
        const preparedTxn = await this.prepareBurnURIToken(uriTokenID, options);
        return await this.signAndSubmit(preparedTxn, options.submissionRef);
    }

    async prepareBurnURIToken(uriTokenID, options = {}) {
        const tx = {
            Account: this.address,
            TransactionType: XrplTransactionTypes.URI_TOKEN_BURN,
            URITokenID: uriTokenID
        }
        return await this.#prepareSubmissionTransaction(tx, options);
    }

    async sellURIToken(uriTokenID, amount, currency, issuer = null, toAddr = null, memos = null, options = {}) {
        const preparedTxn = await this.prepareSellURIToken(uriTokenID, amount, currency, issuer, toAddr, memos, options);
        return await this.signAndSubmit(preparedTxn, options.submissionRef);
    }

    async prepareSellURIToken(uriTokenID, amount, currency, issuer = null, toAddr = null, memos = null, options = {}) {
        const amountObj = makeAmountObject(amount, currency, issuer);
        const tx = {
            Account: this.address,
            TransactionType: XrplTransactionTypes.URI_TOKEN_CREATE_SELL_OFFER,
            Amount: amountObj,
            URITokenID: uriTokenID
        };

        if (toAddr)
            tx.Destination = toAddr;

        if (memos)
            tx.Memos = TransactionHelper.formatMemos(memos);

        if (options.hookParams)
            tx.HookParameters = TransactionHelper.formatHookParams(options.hookParams);

        return await this.#prepareSubmissionTransaction(tx, options);
    }

    async buyURIToken(uriToken, memos = null, options = {}) {
        const preparedTxn = await this.prepareBuyURIToken(uriToken, memos, options);
        return await this.signAndSubmit(preparedTxn, options.submissionRef);
    }

    async prepareBuyURIToken(uriToken, memos = null, options = {}) {
        const tx = {
            Account: this.address,
            TransactionType: XrplTransactionTypes.URI_TOKEN_BUY_OFFER,
            Amount: uriToken.Amount,
            URITokenID: uriToken.index
        }

        if (memos)
            tx.Memos = TransactionHelper.formatMemos(memos);

        if (options.hookParams)
            tx.HookParameters = TransactionHelper.formatHookParams(options.hookParams);

        return await this.#prepareSubmissionTransaction(tx, options);
    }

    async clearURITokenOffer(uriTokenID, options = {}) {
        const preparedTxn = await this.prepareClearURITokenOffer(uriTokenID, options);
        return await this.signAndSubmit(preparedTxn, options.submissionRef);
    }

    async prepareClearURITokenOffer(uriTokenID, options = {}) {
        return await this.#prepareSubmissionTransaction({
            Account: this.address,
            TransactionType: XrplTransactionTypes.URI_TOKEN_CANCEL_SELL_OFFER,
            URITokenID: uriTokenID
        }, options);
    }

    async getURITokens(options) {
        const obj = await this.getAccountObjects(options);
        return obj.filter(t => t.LedgerEntryType == 'URIToken');
    }

    async getURITokenByUri(uri, isHexUri = false) {
        const tokens = await this.getURITokens();
        const hexUri = isHexUri ? uri : TransactionHelper.asciiToHex(uri).toUpperCase();
        return tokens.find(t => t.URI == hexUri);
    }


    generateIssuedURITokenId(uri) {
        if (uri.length < 1 || uri.length > 256)
            throw 'Invalid URI';

        const URITOKEN_LEDGER_TYPE_PREFIX = 85; // Decimal value of ASCII 'U'
        const accIdHex = (codec.decodeAccountID(this.address)).toString('hex').toUpperCase();
        let uriHex = '';
        for (let n in uri) {
            let digit = uri.charCodeAt(n).toString(16).toUpperCase();
            uriHex += (digit.length == 1 ? '0' : '') + digit
        }

        let hash = crypto.createHash('sha512');

        const typeBuf = Buffer.alloc(2, 0);
        typeBuf.writeInt16BE(URITOKEN_LEDGER_TYPE_PREFIX);

        const dataBuf = Buffer.from(`${accIdHex}${uriHex}`, 'hex');

        let output = hash.update(typeBuf);
        output = hash.update(dataBuf);

        const digest = output.digest('hex');

        // Get the first 32 bytes of hash.
        return digest.substring(0, 64).toUpperCase();
    }


    /**
     * Prepare a transaction for submission. (Signing Free)
     * @param {object} tx Partially prepared transaction.
     * @param {*} options Options regarding to the transaction submission.
     * @returns Submission transaction.
     */
    async #prepareSubmissionTransaction(tx, options) {
        // Attach tx options to the transaction.
        const txOptions = {
            LastLedgerSequence: options.maxLedgerIndex || (this.xrplApi.ledgerIndex + XrplConstants.MAX_LEDGER_OFFSET),
            Sequence: options.sequence || await this.getSequence(),
            SigningPubKey: '', // This field is required for fee calculation.
            Fee: '0', // This field is required for fee calculation.
            NetworkID: Defaults.values.networkID
        }

        if (options?.Flags)
            txOptions.Flags = options.Flags;

        Object.assign(tx, txOptions);
        const txnBlob = this.xrplApi.xrplHelper.encode(tx);
        const fees = options.fee || (options.feeUplift ? (`${options.feeUplift + Number(await this.xrplApi.getTransactionFee(txnBlob))}`) : await this.xrplApi.getTransactionFee(txnBlob));
        delete tx['SigningPubKey'];
        tx.Fee = fees + '';
        return tx;
    }

    /**
     * Sign and submit prepared transaction.
     * @param {object} preparedTransaction Prepared transaction.
     * @param {object} submissionRef [Optional] Reference object to take submission references.
     * @returns result of the submitted transaction.
     */
    async signAndSubmit(preparedTransaction, submissionRef = {}) {
        const signedTxn = this.sign(preparedTransaction, false);
        return await this.xrplApi.submitAndWait(preparedTransaction, signedTxn.tx_blob, submissionRef);
    }

    /**
     * Submit a multi-singed transaction.
     * @param {object} tx Signed transaction.
     * @returns Result of the transaction.
     */
    async submitMultisigned(tx) {
        return await this.xrplApi.submitMultisigned(tx)
    }
}

function makeAmountObject(amount, currency = null, issuer = null) {
    if (typeof amount !== 'string')
        throw "Amount must be a string.";

    const amountObj = !issuer ? amount : {
        currency: currency,
        issuer: issuer,
        value: amount
    }
    return amountObj;
}

module.exports = {
    XrplAccount
}


/***/ }),

/***/ 1850:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const xrpl = __nccwpck_require__(4666);
const kp = __nccwpck_require__(8150);
const { EventEmitter } = __nccwpck_require__(6170);
const { Defaults } = __nccwpck_require__(8262);
const { TransactionHelper } = __nccwpck_require__(7071);
const { XrplApiEvents } = __nccwpck_require__(3307);
const { XrplAccount } = __nccwpck_require__(9329);
const { XrplHelpers } = __nccwpck_require__(3189)

const MAX_PAGE_LIMIT = 400;
const API_REQ_TYPE = {
    NAMESPACE_ENTRIES: 'namespace_entries',
    ACCOUNT_OBJECTS: 'account_objects',
    LINES: 'lines',
    ACCOUNT_NFTS: 'account_nfts',
    OFFERS: 'offers',
    TRANSACTIONS: 'transactions'
}

const RESPONSE_WATCH_TIMEOUT = 1000
const NETWORK_MODES = {
    INSUFFICIENT_NETWORK_MODE: 'InsufficientNetworkMode'
}

const FUNCTIONING_SERVER_STATES = ['full', 'validating', 'proposing']
const LEDGER_DESYNC_TIME = 20000

class XrplApi {

    #primaryServer;
    #fallbackServers;
    #client;
    #events = new EventEmitter();
    #addressSubscriptions = [];
    #isPermanentlyDisconnected = false;
    #isConnectionAcquired = false;
    #isClientAcquired = false;
    #isPrimaryServerConnected = false;
    #isFallbackServerConnected = false;
    #xrplClientOptions;
    #autoReconnect;

    constructor(rippledServer = null, options = {}) {
        if (rippledServer == '-') {
            this.#primaryServer = null;
        } else {
            this.#primaryServer = rippledServer || Defaults.values.rippledServer;
        }
        this.#fallbackServers = options.fallbackRippledServers || Defaults.values.fallbackRippledServers || [];

        if (!this.#primaryServer && (!this.#fallbackServers || !this.#fallbackServers.length))
            throw 'Either primaryServer or fallbackServers required.';

        this.#xrplClientOptions = options.xrplClientOptions;
        this.#autoReconnect = options.autoReconnect ?? true;
    }

    async #acquireClient() {
        while (!(this.#isPrimaryServerConnected || this.#isFallbackServerConnected) && this.#isClientAcquired || this.#isConnectionAcquired) {
            await new Promise((resolve) => setTimeout(resolve, 100));
        }
        this.#isClientAcquired = true;
    }

    #releaseClient() {
        this.#isClientAcquired = false;
    }

    async #acquireConnection() {
        while (this.#isClientAcquired) {
            await new Promise((resolve) => setTimeout(resolve, 100));
        }
        this.#isConnectionAcquired = true;
    }

    #releaseConnection() {
        this.#isConnectionAcquired = false;
    }

    async #setXrplClient(client) {
        try {
            if (this.#client) { // Clear all listeners if there's an already created client.
                await this.#client.removeAllListeners();
                await this.#client.disconnect();
            }

            this.#client = client;
        }
        catch (e) {
            console.log("Error occurred in Client initiation:", e)
        }
    }

    async #handleClientConnect(client) {
        await this.#initEventListeners(client);

        if (!client.isConnected())
            await client.connect();

        const resp = await client.request({ command: 'server_state', ledger_index: "current" });
        const serverState = resp?.result?.state?.server_state;

        if (!FUNCTIONING_SERVER_STATES.includes(serverState))
            throw "Client might have functioning issues."

        await this.#setXrplClient(client);
    }

    async #initEventListeners(client) {
        // First remove all the listeners.
        let ledgerTimeout;
        try {
            await client.removeAllListeners();
        }
        catch { }

        client.on('error', (errorCode, errorMessage) => {
            console.log(errorCode + ': ' + errorMessage);
        });

        client.on('disconnected', async (code) => {
            this.#events.emit(XrplApiEvents.DISCONNECTED, code);

            this.#isPrimaryServerConnected = false;
            this.#isFallbackServerConnected = false;

            if (this.#autoReconnect && !this.#isPermanentlyDisconnected) {
                console.log(`Connection failure for ${client.url} (code:${code})`);
                console.log("Re-initializing xrpl client.");
                try {
                    await this.#connectXrplClient(true);
                }
                catch (e) {
                    console.log("Error occurred while re-initializing", e)
                }
            }
            if (ledgerTimeout)
                clearTimeout(ledgerTimeout);
        });


        client.on('ledgerClosed', (ledger) => {
            if (ledgerTimeout) {
                clearTimeout(ledgerTimeout);
            }

            ledgerTimeout = setTimeout(async () => {
                try {
                    let serverState = await this.getServerState();
                    if (!FUNCTIONING_SERVER_STATES.includes(serverState)) {
                        this.#events.emit(XrplApiEvents.SERVER_DESYNCED, { "event_type": "on_alert", "server_state": serverState });
                    }
                } catch (e) {
                    console.log("Error occurred while listening to server de-syncs.", e)
                } finally {
                    clearTimeout(ledgerTimeout);
                }
            }, LEDGER_DESYNC_TIME);

            this.ledgerIndex = ledger.ledger_index;
            this.#events.emit(XrplApiEvents.LEDGER, ledger);
        });

        client.on("transaction", async (data) => {
            try {
                if (data.validated) {
                    // NFTokenAcceptOffer transactions does not contain a Destination. So we check whether the accepted offer is created by which subscribed account
                    if (data.transaction.TransactionType === 'URITokenBuy') {
                        // We take all the offers created by subscribed accounts in previous ledger until we get the respective offer.
                        for (const subscription of this.#addressSubscriptions) {
                            const acc = new XrplAccount(subscription.address, null, { xrplApi: this });
                            // Here we access the offers that were there in this account based on the given ledger index.
                            const offers = await acc.getURITokens({ ledger_index: data.ledger_index - 1 });
                            // Filter out the matching URI token offer for the scenario.
                            const offer = offers.find(o => o.index === data.transaction.URITokenID && o.Amount);
                            // When we find the respective offer. We populate the destination and offer info and then we break the loop.
                            if (offer) {
                                // We populate some sell offer properties to the transaction to be sent with the event.
                                data.transaction.Destination = subscription.address;
                                // Replace the offer with the found offer object.
                                data.transaction.URITokenSellOffer = offer;
                                break;
                            }
                        }
                    }

                    const matches = this.#addressSubscriptions.filter(s => s.address === data.transaction.Destination); // Only incoming transactions.
                    if (matches.length > 0) {
                        const tx = {
                            LedgerHash: data.ledger_hash,
                            LedgerIndex: data.ledger_index,
                            ...data.transaction
                        };

                        if (data.meta?.delivered_amount)
                            tx.DeliveredAmount = data.meta.delivered_amount;

                        // Create an object copy. Otherwise xrpl client will mutate the transaction object,
                        const eventName = tx.TransactionType.toLowerCase();
                        // Emit the event only for successful transactions, Otherwise emit error.
                        if (data.engine_result === "tesSUCCESS") {
                            tx.Memos = TransactionHelper.deserializeMemos(tx.Memos);
                            tx.HookParameters = TransactionHelper.deserializeHookParams(tx.HookParameters);
                            matches.forEach(s => s.handler(eventName, tx));
                        }
                        else {
                            matches.forEach(s => s.handler(eventName, null, data.engine_result_message));
                        }
                    }
                }
            } catch (e) {
                console.log("Error occurred while listening to transactions.", e)
            }
        });
    }

    async #attemptFallbackServerReconnect(maxAttempts = null) {
        if (!this.#fallbackServers || this.#fallbackServers?.length == 0)
            return;

        await this.#acquireClient();

        let errors = {};
        let attempt = 0;
        retryIterator:
        while (!this.#isPermanentlyDisconnected && !this.#isPrimaryServerConnected && !this.#isFallbackServerConnected) { // Keep attempting until consumer calls disconnect() manually or if the primary server is disconnected.
            ++attempt;
            for (const server of this.#fallbackServers) {
                const client = new xrpl.Client(server, this.#xrplClientOptions);
                try {
                    if (!this.#isPrimaryServerConnected) {
                        await this.#handleClientConnect(client);
                        this.#isFallbackServerConnected = true;
                    }
                    break retryIterator;
                }
                catch (e) {
                    this.#releaseClient();
                    console.log(`Error occurred while connecting to fallback server ${server}`);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    if (client.isConnected()) {
                        console.log('Connection closure already handled');
                        await client.disconnect();
                    }

                    if (!this.#isPermanentlyDisconnected) {
                        const delaySec = 2 * attempt; // Retry with backoff delay.
                        if (!maxAttempts || attempt < maxAttempts)
                            console.log(`Fallback server ${server} connection attempt ${attempt} failed. Retrying in ${delaySec}s...`);
                        else {
                            errors[server] = { error: `Fallback server ${server} connection max attempts failed.`, exception: e };
                        }

                        await new Promise(resolve => setTimeout(resolve, delaySec * 1000));
                    }
                }
            }

            if (maxAttempts && attempt >= maxAttempts)
                return { error: Object.values(errors) };
        }

        return {};
    }

    async #attemptPrimaryServerReconnect(maxAttempts = null) {
        await this.#acquireClient();

        let attempt = 0;
        while (!this.#isPermanentlyDisconnected && !this.#isPrimaryServerConnected && !this.#isFallbackServerConnected) { // Keep attempting until consumer calls disconnect() manually.
            ++attempt;
            const client = new xrpl.Client(this.#primaryServer, this.#xrplClientOptions);
            try {
                await this.#handleClientConnect(client);
                this.#isPrimaryServerConnected = true;
                break;
            }
            catch (e) {
                this.#releaseClient();
                console.log("Error occurred while re-connecting to the primary server")
                await new Promise(resolve => setTimeout(resolve, 1000));
                if (client.isConnected()) {
                    console.log('Connection closure already handled');
                    await client.disconnect();
                }

                if (!this.#isPermanentlyDisconnected) {
                    const delaySec = 2 * attempt; // Retry with backoff delay.
                    if (!maxAttempts || attempt < maxAttempts)
                        console.log(`Primary server ${this.#primaryServer} attempt ${attempt} failed. Retrying in ${delaySec}s...`);
                    else
                        return { error: `Primary server ${this.#primaryServer} connection max attempts failed.`, exception: e };
                    await new Promise(resolve => setTimeout(resolve, delaySec * 1000));
                }
            }
        }

        return {};
    }

    async #connectXrplClient(reconnect = false) {
        let res = [];
        if (reconnect) {
            if (this.#primaryServer) {
                res = await Promise.all([this.#attemptPrimaryServerReconnect(), this.#attemptFallbackServerReconnect()]);
            } else {
                res = [await this.#attemptFallbackServerReconnect()];
            }
        }
        else {
            if (this.#primaryServer) {
                res = await Promise.all([this.#attemptPrimaryServerReconnect(1), this.#attemptFallbackServerReconnect(1)]);
            } else {
                res = [await this.#attemptFallbackServerReconnect(1)];
            }
        }

        if (res.filter(r => r && !r.error).length == 0)
            throw res.filter(r => r && r.error).map(r => r.error);

        // After connection established, check again whether maintainConnections has become false.
        // This is in case the consumer has called disconnect() while connection is being established.
        if (!this.#isPermanentlyDisconnected) {
            await this.#waitForConnection();
            this.#releaseClient();

            this.ledgerIndex = await this.#getLedgerIndex();

            this.#subscribeToStream('ledger');

            // Re-subscribe to existing account address subscriptions (in case this is a reconnect)
            if (this.#addressSubscriptions.length > 0)
                await this.#handleClientRequest({ command: 'subscribe', accounts: this.#addressSubscriptions.map(s => s.address) });
        }
        else {
            this.#releaseClient();
            await this.disconnect();
        }
    }

    async #requestWithPaging(requestObj, requestType) {
        let res = [];
        let checked = false;
        let resp;
        let count = requestObj?.limit;

        while ((!count || count > 0) && (!checked || resp?.result?.marker)) {
            checked = true;
            requestObj.limit = count ? Math.min(count, MAX_PAGE_LIMIT) : MAX_PAGE_LIMIT;
            if (resp?.result?.marker)
                requestObj.marker = resp?.result?.marker;
            else
                delete requestObj.marker;
            resp = (await this.#handleClientRequest(requestObj));
            if (resp?.result && resp?.result[requestType])
                res.push(...resp.result[requestType]);
            if (count)
                count -= requestObj.limit;
        }

        return res;
    }

    async #handleClientRequest(request = {}) {
        await this.#acquireConnection();
        try {
            const response = await this.#client.request(request);
            this.#releaseConnection();
            return response;
        }
        catch (e) {
            this.#releaseConnection();
            if (e?.data?.error_message === NETWORK_MODES.INSUFFICIENT_NETWORK_MODE) {
                this.#events.emit(XrplApiEvents.SERVER_DESYNCED, { "event_type": "on_error", "error_code": e.data?.error_code, "error_message": e.data.error_message });
            }
            throw e;
        }
    }

    on(event, handler) {
        this.#events.on(event, handler);
    }

    once(event, handler) {
        this.#events.once(event, handler);
    }

    off(event, handler = null) {
        this.#events.off(event, handler);
    }

    async #waitForConnection() {
        while (!(this.#isPrimaryServerConnected || this.#isFallbackServerConnected)) {
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        return true;
    }

    async connect() {
        this.#isPermanentlyDisconnected = false;

        if (!this.#client || !this.#client.isConnected()) {
            await this.#connectXrplClient();
        }
        const definitions = await this.#handleClientRequest({ command: 'server_definitions' })
        this.xrplHelper = new XrplHelpers(definitions.result);
    }

    async disconnect() {
        await this.#acquireConnection();

        try {
            this.#isPermanentlyDisconnected = true;

            if (this.#client && this.#client.isConnected()) {
                await this.#client.disconnect().catch(console.error);
            }
            this.#releaseConnection();
        }
        catch (e) {
            this.#releaseConnection();
            throw e;
        }
    }

    async #getLedgerIndex() {
        await this.#acquireConnection();

        try {
            const index = await this.#client.getLedgerIndex();
            this.#releaseConnection();
            return index;
        }
        catch (e) {
            this.#releaseConnection();
            throw e;
        }
    }

    async isValidKeyForAddress(publicKey, address) {
        const info = await this.getAccountInfo(address);
        const accountFlags = xrpl.parseAccountRootFlags(info.Flags);
        const regularKey = info.RegularKey;
        const derivedPubKeyAddress = kp.deriveAddress(publicKey);

        // If the master key is disabled the derived pubkey address should be the regular key.
        // Otherwise it could be account address or the regular key
        if (accountFlags.lsfDisableMaster)
            return regularKey && (derivedPubKeyAddress === regularKey);
        else
            return derivedPubKeyAddress === address || (regularKey && derivedPubKeyAddress === regularKey);
    }

    async isAccountExists(address) {
        try {
            await this.#handleClientRequest({ command: 'account_info', account: address });
            return true;
        }
        catch (e) {
            if (e.data.error === 'actNotFound') return false;
            else throw e;
        }
    }

    async getServerState(ledgerIdx = "current") {
        const resp = (await this.#handleClientRequest({ command: 'server_state', ledger_index: ledgerIdx }));
        return resp?.result?.state?.server_state;
    }

    async getAccountInfo(address) {
        const resp = (await this.#handleClientRequest({ command: 'account_info', account: address }));
        return resp?.result?.account_data;
    }

    async getServerDefinition() {
        const resp = (await this.#handleClientRequest({ command: 'server_definitions' }));
        return resp?.result;
    }

    async getServerInfo() {
        const resp = (await this.#handleClientRequest({ command: 'server_info' }));
        return resp?.result;
    }

    async getAccountObjects(address, options) {
        return this.#requestWithPaging({ command: 'account_objects', account: address, ...options }, API_REQ_TYPE.ACCOUNT_OBJECTS);
    }

    async getNamespaceEntries(address, namespaceId, options) {
        return this.#requestWithPaging({ command: 'account_namespace', account: address, namespace_id: namespaceId, ...options }, API_REQ_TYPE.NAMESPACE_ENTRIES);
    }

    async getNftOffers(address, options) {
        const offers = await this.getAccountObjects(address, options);
        // TODO: Pass rippled filter parameter when xrpl.js supports it.
        return offers.filter(o => o.LedgerEntryType == 'NFTokenOffer');
    }

    async getTrustlines(address, options) {
        return this.#requestWithPaging({ command: 'account_lines', account: address, ledger_index: "validated", ...options }, API_REQ_TYPE.LINES);
    }

    async getAccountTrx(address, options) {
        return this.#requestWithPaging({ command: 'account_tx', account: address, ...options }, API_REQ_TYPE.TRANSACTIONS);
    }

    async getNfts(address, options) {
        return this.#requestWithPaging({ command: 'account_nfts', account: address, ledger_index: "validated", ...options }, API_REQ_TYPE.ACCOUNT_NFTS);
    }

    async getOffers(address, options) {
        return this.#requestWithPaging({ command: 'account_offers', account: address, ledger_index: "validated", ...options }, API_REQ_TYPE.OFFERS);
    }

    async getSellOffers(nfTokenId, options = {}) {
        return this.#requestWithPaging({ command: 'nft_sell_offers', nft_id: nfTokenId, ledger_index: "validated", ...options }, API_REQ_TYPE.OFFERS);
    }

    async getBuyOffers(nfTokenId, options = {}) {
        return this.#requestWithPaging({ command: 'nft_buy_offers', nft_id: nfTokenId, ledger_index: "validated", ...options }, API_REQ_TYPE.OFFERS);
    }

    async getLedgerEntry(index, options) {
        try {
            const resp = (await this.#handleClientRequest({ command: 'ledger_entry', index: index, ledger_index: "validated", ...options }));
            return resp?.result?.node;

        } catch (e) {
            if (e?.data?.error === 'entryNotFound')
                return null;
            throw e;
        }
    }

    async getTxnInfo(txnHash, options) {
        const resp = (await this.#handleClientRequest({ command: 'tx', transaction: txnHash, binary: false, ...options }));
        return resp?.result;
    }

    async subscribeToAddress(address, handler) {
        this.#addressSubscriptions.push({ address: address, handler: handler });
        await this.#handleClientRequest({ command: 'subscribe', accounts: [address] });
    }

    async unsubscribeFromAddress(address, handler) {
        for (let i = this.#addressSubscriptions.length - 1; i >= 0; i--) {
            const sub = this.#addressSubscriptions[i];
            if (sub.address === address && sub.handler === handler)
                this.#addressSubscriptions.splice(i, 1);
        }
        await this.#handleClientRequest({ command: 'unsubscribe', accounts: [address] });
    }

    async getTransactionFee(txBlob) {
        const fees = await this.#handleClientRequest({ command: 'fee', tx_blob: txBlob });
        return fees?.result?.drops?.base_fee;
    }

    async #subscribeToStream(streamName) {
        await this.#handleClientRequest({ command: 'subscribe', streams: [streamName] });
    }

    /**
     * Get the transaction results if validated.
     * @param {string} txHash Hash of the transaction to check.
     * @returns Validated results of the transaction.
     */
    async getTransactionValidatedResults(txHash) {
        const txResponse = await this.getTxnInfo(txHash)
            .catch((e) => {
                return null;
            });

        if (txResponse?.validated) {
            return {
                id: txResponse?.hash,
                code: txResponse?.meta?.TransactionResult,
                details: txResponse
            };
        }

        return null;
    }

    /**
     * Watching to acquire the transaction submission. (Waits until txn. is applied to the ledger.)
     * @param {string} txHash Transaction Hash
     * @param {number} lastLedger Last ledger sequence of the transaction.
     * @param {object} submissionResult Result of the submission.
     * @returns Returns the applied transaction object.
     */
    async #waitForFinalTransactionOutcome(txHash, lastLedger, submissionResult) {
        if (lastLedger == null)
            throw 'Transaction must contain a LastLedgerSequence value for reliable submission.';

        await new Promise(r => setTimeout(r, RESPONSE_WATCH_TIMEOUT));

        const latestLedger = await this.#getLedgerIndex();

        if (lastLedger < latestLedger) {
            throw {
                status: 'TOOK_LONG',
                error: `The latest ledger sequence ${latestLedger} is greater than the transaction's LastLedgerSequence (${lastLedger})`,
                ...submissionResult
            };
        }

        const txResponse = await this.getTxnInfo(txHash)
            .catch(async (error) => {
                const message = error?.data?.error;
                if (message === 'txnNotFound') {
                    return await this.#waitForFinalTransactionOutcome(
                        txHash,
                        lastLedger,
                        submissionResult
                    );
                }
                throw `${message} \n Preliminary result: ${JSON.stringify(submissionResult, null, 2)}.\nFull error details: ${JSON.stringify(error, null, 2)}`;
            });

        if (txResponse.validated)
            return txResponse;

        return await this.#waitForFinalTransactionOutcome(txHash, lastLedger, submissionResult);
    }

    /**
     * Arrange the transaction result to a standard format.
     * @param {object} tx Submitted Transaction
     * @param {object} submissionResult Response related to that transaction.
     * @returns prepared response of the transaction result.
     */
    async #prepareResponse(tx, submissionResult) {
        const result = await this.#waitForFinalTransactionOutcome(submissionResult.result.tx_json.hash, tx.LastLedgerSequence, submissionResult);
        const txResult = {
            id: result?.hash,
            code: result?.meta?.TransactionResult,
            details: result
        };

        console.log("Transaction result: " + txResult.code);
        const hookExecRes = txResult.details?.meta?.HookExecutions?.map(o => {
            return {
                result: o.HookExecution?.HookResult,
                returnCode: parseInt(o.HookExecution?.HookReturnCode, 16),
                message: TransactionHelper.hexToASCII(o.HookExecution?.HookReturnString).replace(/\x00+$/, '')
            }
        });
        if (txResult.code === "tesSUCCESS")
            return { ...txResult, ...(hookExecRes ? { hookExecutionResult: hookExecRes } : {}) };
        else
            throw { ...txResult, ...(hookExecRes ? { hookExecutionResult: hookExecRes } : {}) };
    }

    /**
     * Submit a multi-signature transaction and wait for validation.
     * @param {object} tx Multi-signed transaction object.
     * @param {object} submissionRef [Optional] Reference object to take submission references.
     * @returns response object of the validated transaction.
     */
    async submitMultisignedAndWait(tx, submissionRef = {}) {
        tx.SigningPubKey = "";
        submissionRef.submissionResult = await this.#handleClientRequest({ command: 'submit_multisigned', tx_json: tx });
        return await this.#prepareResponse(tx, submissionRef.submissionResult);
    }

    /**
     * Only submit a multi-signature transaction.
     * @param {object} tx Multi-signed transaction object.
     * @returns response object of the submitted transaction.
     */
    async submitMultisigned(tx) {
        tx.SigningPubKey = "";
        return await this.#handleClientRequest({ command: 'submit_multisigned', tx_json: tx });
    }

    /**
     * Submit a single-signature transaction.
     * @param {string} tx_blob Signed transaction object.
     * @param {object} submissionRef [Optional] Reference object to take submission references.
     * @returns response object of the validated transaction.
     */
    async submitAndWait(tx, tx_blob, submissionRef = {}) {
        submissionRef.submissionResult = await this.#handleClientRequest({ command: 'submit', tx_blob: tx_blob });
        return await this.#prepareResponse(tx, submissionRef.submissionResult);
    }

    /**
     * Only submit a single-signature transaction.
     * @param {string} tx_blob Signed transaction object.
     * @returns response object of the submitted transaction.
     */
    async submit(tx_blob) {
        return await this.#handleClientRequest({ command: 'submit', tx_blob: tx_blob });
    }

    /**
     * Join the given the array of signed transactions into one multi-signed transaction.
     * For more details: https://js.xrpl.org/functions/multisign.html 
     * 
     * @param {(string | Transaction)[]} transactions An array of signed Transactions (in object or blob form) to combine into a single signed Transaction.
     * @returns A single signed Transaction string which has all Signers from transactions within it.
     */
    multiSign(transactions) {
        if (transactions.length > 0) {
            return xrpl.multisign(transactions);
        } else
            throw ("Transaction list is empty for multi-signing.");
    }
}

module.exports = {
    XrplApi
}

/***/ }),

/***/ 3307:
/***/ ((module) => {

const XrplApiEvents = {
    LEDGER: 'ledger',
    DISCONNECTED: 'disconnected',
    PAYMENT: 'payment',
    NFT_OFFER_CREATE: 'nftokencreateoffer',
    NFT_OFFER_ACCEPT: 'nftokenacceptoffer',
    URI_TOKEN_CREATE_SELL_OFFER: 'uritokencreateselloffer', // For Transfers
    URI_TOKEN_BUY: 'uritokenbuy', // For Acquires
    SERVER_DESYNCED: 'desynced'
}

const XrplConstants = {
    MAX_LEDGER_OFFSET: 10,
    XRP: 'XRP',
    XAH: 'XAH',
    MIN_XRP_AMOUNT: '1', // drops - deprecated
    MIN_DROPS: '1'
}

const XrplTransactionTypes = {
    PAYMENT: 'Payment',
    SIGNER_LIST_SET: 'SignerListSet',
    TRUST_SET: 'TrustSet',
    CHECK_CASH: 'CheckCash',
    ACCOUNT_SET: 'AccountSet',
    SET_REGULAR_KEY: 'SetRegularKey',
    OFFER_CREATE: 'OfferCreate',
    OFFER_CANCEL: 'OfferCancel',
    URI_TOKEN_MINT: 'URITokenMint',
    URI_TOKEN_BURN: 'URITokenBurn',
    URI_TOKEN_CREATE_SELL_OFFER: 'URITokenCreateSellOffer',
    URI_TOKEN_BUY_OFFER: 'URITokenBuy',
    URI_TOKEN_CANCEL_SELL_OFFER: 'URITokenCancelSellOffer',
    NF_TOKEN_MINT: 'NFTokenMint',
    NF_TOKEN_CREATE_OFFER: 'NFTokenCreateOffer',
    NF_TOKEN_ACCEPT_OFFER: 'NFTokenAcceptOffer',
    NF_TOKEN_BURN: 'NFTokenBurn'
}

module.exports = {
    XrplApiEvents,
    XrplConstants,
    XrplTransactionTypes
}

/***/ }),

/***/ 3189:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { sign, derive, XrplDefinitions, binary } = __nccwpck_require__(2335)
class XrplHelpers {
    definitions;
    constructor(definition) {
        this.definitions = new XrplDefinitions(definition);
    }
    encode(transacion) {
        return binary.encode(transacion, this.definitions);
    }
    decode(transacion) {
        return binary.decode(transacion, this.definitions)
    }

    sign(tx, secret, isMultiSign = false) {
        const account = derive.familySeed(secret);
        const signed = sign(tx, (isMultiSign ? [account.signAs(account.address)] : account), this.definitions);
        return {
            hash: signed.id,
            tx_blob: signed.signedTransaction
        }
    }
}

module.exports = {
    XrplHelpers
}

/***/ }),

/***/ 9491:
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ 4300:
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ 6113:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 1517:
/***/ ((module) => {

"use strict";
module.exports = require("elliptic");

/***/ }),

/***/ 2361:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 7147:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 3685:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 5687:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 1808:
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 6005:
/***/ ((module) => {

"use strict";
module.exports = require("node:crypto");

/***/ }),

/***/ 2037:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 1017:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 597:
/***/ ((module) => {

"use strict";
module.exports = require("ripple-address-codec");

/***/ }),

/***/ 8150:
/***/ ((module) => {

"use strict";
module.exports = require("ripple-keypairs");

/***/ }),

/***/ 2781:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 4404:
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ 6224:
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ 7310:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 3837:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 4666:
/***/ ((module) => {

"use strict";
module.exports = require("xrpl");

/***/ }),

/***/ 9796:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ 6996:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('["的","一","是","在","不","了","有","和","人","这","中","大","为","上","个","国","我","以","要","他","时","来","用","们","生","到","作","地","于","出","就","分","对","成","会","可","主","发","年","动","同","工","也","能","下","过","子","说","产","种","面","而","方","后","多","定","行","学","法","所","民","得","经","十","三","之","进","着","等","部","度","家","电","力","里","如","水","化","高","自","二","理","起","小","物","现","实","加","量","都","两","体","制","机","当","使","点","从","业","本","去","把","性","好","应","开","它","合","还","因","由","其","些","然","前","外","天","政","四","日","那","社","义","事","平","形","相","全","表","间","样","与","关","各","重","新","线","内","数","正","心","反","你","明","看","原","又","么","利","比","或","但","质","气","第","向","道","命","此","变","条","只","没","结","解","问","意","建","月","公","无","系","军","很","情","者","最","立","代","想","已","通","并","提","直","题","党","程","展","五","果","料","象","员","革","位","入","常","文","总","次","品","式","活","设","及","管","特","件","长","求","老","头","基","资","边","流","路","级","少","图","山","统","接","知","较","将","组","见","计","别","她","手","角","期","根","论","运","农","指","几","九","区","强","放","决","西","被","干","做","必","战","先","回","则","任","取","据","处","队","南","给","色","光","门","即","保","治","北","造","百","规","热","领","七","海","口","东","导","器","压","志","世","金","增","争","济","阶","油","思","术","极","交","受","联","什","认","六","共","权","收","证","改","清","美","再","采","转","更","单","风","切","打","白","教","速","花","带","安","场","身","车","例","真","务","具","万","每","目","至","达","走","积","示","议","声","报","斗","完","类","八","离","华","名","确","才","科","张","信","马","节","话","米","整","空","元","况","今","集","温","传","土","许","步","群","广","石","记","需","段","研","界","拉","林","律","叫","且","究","观","越","织","装","影","算","低","持","音","众","书","布","复","容","儿","须","际","商","非","验","连","断","深","难","近","矿","千","周","委","素","技","备","半","办","青","省","列","习","响","约","支","般","史","感","劳","便","团","往","酸","历","市","克","何","除","消","构","府","称","太","准","精","值","号","率","族","维","划","选","标","写","存","候","毛","亲","快","效","斯","院","查","江","型","眼","王","按","格","养","易","置","派","层","片","始","却","专","状","育","厂","京","识","适","属","圆","包","火","住","调","满","县","局","照","参","红","细","引","听","该","铁","价","严","首","底","液","官","德","随","病","苏","失","尔","死","讲","配","女","黄","推","显","谈","罪","神","艺","呢","席","含","企","望","密","批","营","项","防","举","球","英","氧","势","告","李","台","落","木","帮","轮","破","亚","师","围","注","远","字","材","排","供","河","态","封","另","施","减","树","溶","怎","止","案","言","士","均","武","固","叶","鱼","波","视","仅","费","紧","爱","左","章","早","朝","害","续","轻","服","试","食","充","兵","源","判","护","司","足","某","练","差","致","板","田","降","黑","犯","负","击","范","继","兴","似","余","坚","曲","输","修","故","城","夫","够","送","笔","船","占","右","财","吃","富","春","职","觉","汉","画","功","巴","跟","虽","杂","飞","检","吸","助","升","阳","互","初","创","抗","考","投","坏","策","古","径","换","未","跑","留","钢","曾","端","责","站","简","述","钱","副","尽","帝","射","草","冲","承","独","令","限","阿","宣","环","双","请","超","微","让","控","州","良","轴","找","否","纪","益","依","优","顶","础","载","倒","房","突","坐","粉","敌","略","客","袁","冷","胜","绝","析","块","剂","测","丝","协","诉","念","陈","仍","罗","盐","友","洋","错","苦","夜","刑","移","频","逐","靠","混","母","短","皮","终","聚","汽","村","云","哪","既","距","卫","停","烈","央","察","烧","迅","境","若","印","洲","刻","括","激","孔","搞","甚","室","待","核","校","散","侵","吧","甲","游","久","菜","味","旧","模","湖","货","损","预","阻","毫","普","稳","乙","妈","植","息","扩","银","语","挥","酒","守","拿","序","纸","医","缺","雨","吗","针","刘","啊","急","唱","误","训","愿","审","附","获","茶","鲜","粮","斤","孩","脱","硫","肥","善","龙","演","父","渐","血","欢","械","掌","歌","沙","刚","攻","谓","盾","讨","晚","粒","乱","燃","矛","乎","杀","药","宁","鲁","贵","钟","煤","读","班","伯","香","介","迫","句","丰","培","握","兰","担","弦","蛋","沉","假","穿","执","答","乐","谁","顺","烟","缩","征","脸","喜","松","脚","困","异","免","背","星","福","买","染","井","概","慢","怕","磁","倍","祖","皇","促","静","补","评","翻","肉","践","尼","衣","宽","扬","棉","希","伤","操","垂","秋","宜","氢","套","督","振","架","亮","末","宪","庆","编","牛","触","映","雷","销","诗","座","居","抓","裂","胞","呼","娘","景","威","绿","晶","厚","盟","衡","鸡","孙","延","危","胶","屋","乡","临","陆","顾","掉","呀","灯","岁","措","束","耐","剧","玉","赵","跳","哥","季","课","凯","胡","额","款","绍","卷","齐","伟","蒸","殖","永","宗","苗","川","炉","岩","弱","零","杨","奏","沿","露","杆","探","滑","镇","饭","浓","航","怀","赶","库","夺","伊","灵","税","途","灭","赛","归","召","鼓","播","盘","裁","险","康","唯","录","菌","纯","借","糖","盖","横","符","私","努","堂","域","枪","润","幅","哈","竟","熟","虫","泽","脑","壤","碳","欧","遍","侧","寨","敢","彻","虑","斜","薄","庭","纳","弹","饲","伸","折","麦","湿","暗","荷","瓦","塞","床","筑","恶","户","访","塔","奇","透","梁","刀","旋","迹","卡","氯","遇","份","毒","泥","退","洗","摆","灰","彩","卖","耗","夏","择","忙","铜","献","硬","予","繁","圈","雪","函","亦","抽","篇","阵","阴","丁","尺","追","堆","雄","迎","泛","爸","楼","避","谋","吨","野","猪","旗","累","偏","典","馆","索","秦","脂","潮","爷","豆","忽","托","惊","塑","遗","愈","朱","替","纤","粗","倾","尚","痛","楚","谢","奋","购","磨","君","池","旁","碎","骨","监","捕","弟","暴","割","贯","殊","释","词","亡","壁","顿","宝","午","尘","闻","揭","炮","残","冬","桥","妇","警","综","招","吴","付","浮","遭","徐","您","摇","谷","赞","箱","隔","订","男","吹","园","纷","唐","败","宋","玻","巨","耕","坦","荣","闭","湾","键","凡","驻","锅","救","恩","剥","凝","碱","齿","截","炼","麻","纺","禁","废","盛","版","缓","净","睛","昌","婚","涉","筒","嘴","插","岸","朗","庄","街","藏","姑","贸","腐","奴","啦","惯","乘","伙","恢","匀","纱","扎","辩","耳","彪","臣","亿","璃","抵","脉","秀","萨","俄","网","舞","店","喷","纵","寸","汗","挂","洪","贺","闪","柬","爆","烯","津","稻","墙","软","勇","像","滚","厘","蒙","芳","肯","坡","柱","荡","腿","仪","旅","尾","轧","冰","贡","登","黎","削","钻","勒","逃","障","氨","郭","峰","币","港","伏","轨","亩","毕","擦","莫","刺","浪","秘","援","株","健","售","股","岛","甘","泡","睡","童","铸","汤","阀","休","汇","舍","牧","绕","炸","哲","磷","绩","朋","淡","尖","启","陷","柴","呈","徒","颜","泪","稍","忘","泵","蓝","拖","洞","授","镜","辛","壮","锋","贫","虚","弯","摩","泰","幼","廷","尊","窗","纲","弄","隶","疑","氏","宫","姐","震","瑞","怪","尤","琴","循","描","膜","违","夹","腰","缘","珠","穷","森","枝","竹","沟","催","绳","忆","邦","剩","幸","浆","栏","拥","牙","贮","礼","滤","钠","纹","罢","拍","咱","喊","袖","埃","勤","罚","焦","潜","伍","墨","欲","缝","姓","刊","饱","仿","奖","铝","鬼","丽","跨","默","挖","链","扫","喝","袋","炭","污","幕","诸","弧","励","梅","奶","洁","灾","舟","鉴","苯","讼","抱","毁","懂","寒","智","埔","寄","届","跃","渡","挑","丹","艰","贝","碰","拔","爹","戴","码","梦","芽","熔","赤","渔","哭","敬","颗","奔","铅","仲","虎","稀","妹","乏","珍","申","桌","遵","允","隆","螺","仓","魏","锐","晓","氮","兼","隐","碍","赫","拨","忠","肃","缸","牵","抢","博","巧","壳","兄","杜","讯","诚","碧","祥","柯","页","巡","矩","悲","灌","龄","伦","票","寻","桂","铺","圣","恐","恰","郑","趣","抬","荒","腾","贴","柔","滴","猛","阔","辆","妻","填","撤","储","签","闹","扰","紫","砂","递","戏","吊","陶","伐","喂","疗","瓶","婆","抚","臂","摸","忍","虾","蜡","邻","胸","巩","挤","偶","弃","槽","劲","乳","邓","吉","仁","烂","砖","租","乌","舰","伴","瓜","浅","丙","暂","燥","橡","柳","迷","暖","牌","秧","胆","详","簧","踏","瓷","谱","呆","宾","糊","洛","辉","愤","竞","隙","怒","粘","乃","绪","肩","籍","敏","涂","熙","皆","侦","悬","掘","享","纠","醒","狂","锁","淀","恨","牲","霸","爬","赏","逆","玩","陵","祝","秒","浙","貌","役","彼","悉","鸭","趋","凤","晨","畜","辈","秩","卵","署","梯","炎","滩","棋","驱","筛","峡","冒","啥","寿","译","浸","泉","帽","迟","硅","疆","贷","漏","稿","冠","嫩","胁","芯","牢","叛","蚀","奥","鸣","岭","羊","凭","串","塘","绘","酵","融","盆","锡","庙","筹","冻","辅","摄","袭","筋","拒","僚","旱","钾","鸟","漆","沈","眉","疏","添","棒","穗","硝","韩","逼","扭","侨","凉","挺","碗","栽","炒","杯","患","馏","劝","豪","辽","勃","鸿","旦","吏","拜","狗","埋","辊","掩","饮","搬","骂","辞","勾","扣","估","蒋","绒","雾","丈","朵","姆","拟","宇","辑","陕","雕","偿","蓄","崇","剪","倡","厅","咬","驶","薯","刷","斥","番","赋","奉","佛","浇","漫","曼","扇","钙","桃","扶","仔","返","俗","亏","腔","鞋","棱","覆","框","悄","叔","撞","骗","勘","旺","沸","孤","吐","孟","渠","屈","疾","妙","惜","仰","狠","胀","谐","抛","霉","桑","岗","嘛","衰","盗","渗","脏","赖","涌","甜","曹","阅","肌","哩","厉","烃","纬","毅","昨","伪","症","煮","叹","钉","搭","茎","笼","酷","偷","弓","锥","恒","杰","坑","鼻","翼","纶","叙","狱","逮","罐","络","棚","抑","膨","蔬","寺","骤","穆","冶","枯","册","尸","凸","绅","坯","牺","焰","轰","欣","晋","瘦","御","锭","锦","丧","旬","锻","垄","搜","扑","邀","亭","酯","迈","舒","脆","酶","闲","忧","酚","顽","羽","涨","卸","仗","陪","辟","惩","杭","姚","肚","捉","飘","漂","昆","欺","吾","郎","烷","汁","呵","饰","萧","雅","邮","迁","燕","撒","姻","赴","宴","烦","债","帐","斑","铃","旨","醇","董","饼","雏","姿","拌","傅","腹","妥","揉","贤","拆","歪","葡","胺","丢","浩","徽","昂","垫","挡","览","贪","慰","缴","汪","慌","冯","诺","姜","谊","凶","劣","诬","耀","昏","躺","盈","骑","乔","溪","丛","卢","抹","闷","咨","刮","驾","缆","悟","摘","铒","掷","颇","幻","柄","惠","惨","佳","仇","腊","窝","涤","剑","瞧","堡","泼","葱","罩","霍","捞","胎","苍","滨","俩","捅","湘","砍","霞","邵","萄","疯","淮","遂","熊","粪","烘","宿","档","戈","驳","嫂","裕","徙","箭","捐","肠","撑","晒","辨","殿","莲","摊","搅","酱","屏","疫","哀","蔡","堵","沫","皱","畅","叠","阁","莱","敲","辖","钩","痕","坝","巷","饿","祸","丘","玄","溜","曰","逻","彭","尝","卿","妨","艇","吞","韦","怨","矮","歇"]');

/***/ }),

/***/ 4262:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('["的","一","是","在","不","了","有","和","人","這","中","大","為","上","個","國","我","以","要","他","時","來","用","們","生","到","作","地","於","出","就","分","對","成","會","可","主","發","年","動","同","工","也","能","下","過","子","說","產","種","面","而","方","後","多","定","行","學","法","所","民","得","經","十","三","之","進","著","等","部","度","家","電","力","裡","如","水","化","高","自","二","理","起","小","物","現","實","加","量","都","兩","體","制","機","當","使","點","從","業","本","去","把","性","好","應","開","它","合","還","因","由","其","些","然","前","外","天","政","四","日","那","社","義","事","平","形","相","全","表","間","樣","與","關","各","重","新","線","內","數","正","心","反","你","明","看","原","又","麼","利","比","或","但","質","氣","第","向","道","命","此","變","條","只","沒","結","解","問","意","建","月","公","無","系","軍","很","情","者","最","立","代","想","已","通","並","提","直","題","黨","程","展","五","果","料","象","員","革","位","入","常","文","總","次","品","式","活","設","及","管","特","件","長","求","老","頭","基","資","邊","流","路","級","少","圖","山","統","接","知","較","將","組","見","計","別","她","手","角","期","根","論","運","農","指","幾","九","區","強","放","決","西","被","幹","做","必","戰","先","回","則","任","取","據","處","隊","南","給","色","光","門","即","保","治","北","造","百","規","熱","領","七","海","口","東","導","器","壓","志","世","金","增","爭","濟","階","油","思","術","極","交","受","聯","什","認","六","共","權","收","證","改","清","美","再","採","轉","更","單","風","切","打","白","教","速","花","帶","安","場","身","車","例","真","務","具","萬","每","目","至","達","走","積","示","議","聲","報","鬥","完","類","八","離","華","名","確","才","科","張","信","馬","節","話","米","整","空","元","況","今","集","溫","傳","土","許","步","群","廣","石","記","需","段","研","界","拉","林","律","叫","且","究","觀","越","織","裝","影","算","低","持","音","眾","書","布","复","容","兒","須","際","商","非","驗","連","斷","深","難","近","礦","千","週","委","素","技","備","半","辦","青","省","列","習","響","約","支","般","史","感","勞","便","團","往","酸","歷","市","克","何","除","消","構","府","稱","太","準","精","值","號","率","族","維","劃","選","標","寫","存","候","毛","親","快","效","斯","院","查","江","型","眼","王","按","格","養","易","置","派","層","片","始","卻","專","狀","育","廠","京","識","適","屬","圓","包","火","住","調","滿","縣","局","照","參","紅","細","引","聽","該","鐵","價","嚴","首","底","液","官","德","隨","病","蘇","失","爾","死","講","配","女","黃","推","顯","談","罪","神","藝","呢","席","含","企","望","密","批","營","項","防","舉","球","英","氧","勢","告","李","台","落","木","幫","輪","破","亞","師","圍","注","遠","字","材","排","供","河","態","封","另","施","減","樹","溶","怎","止","案","言","士","均","武","固","葉","魚","波","視","僅","費","緊","愛","左","章","早","朝","害","續","輕","服","試","食","充","兵","源","判","護","司","足","某","練","差","致","板","田","降","黑","犯","負","擊","范","繼","興","似","餘","堅","曲","輸","修","故","城","夫","夠","送","筆","船","佔","右","財","吃","富","春","職","覺","漢","畫","功","巴","跟","雖","雜","飛","檢","吸","助","昇","陽","互","初","創","抗","考","投","壞","策","古","徑","換","未","跑","留","鋼","曾","端","責","站","簡","述","錢","副","盡","帝","射","草","衝","承","獨","令","限","阿","宣","環","雙","請","超","微","讓","控","州","良","軸","找","否","紀","益","依","優","頂","礎","載","倒","房","突","坐","粉","敵","略","客","袁","冷","勝","絕","析","塊","劑","測","絲","協","訴","念","陳","仍","羅","鹽","友","洋","錯","苦","夜","刑","移","頻","逐","靠","混","母","短","皮","終","聚","汽","村","雲","哪","既","距","衛","停","烈","央","察","燒","迅","境","若","印","洲","刻","括","激","孔","搞","甚","室","待","核","校","散","侵","吧","甲","遊","久","菜","味","舊","模","湖","貨","損","預","阻","毫","普","穩","乙","媽","植","息","擴","銀","語","揮","酒","守","拿","序","紙","醫","缺","雨","嗎","針","劉","啊","急","唱","誤","訓","願","審","附","獲","茶","鮮","糧","斤","孩","脫","硫","肥","善","龍","演","父","漸","血","歡","械","掌","歌","沙","剛","攻","謂","盾","討","晚","粒","亂","燃","矛","乎","殺","藥","寧","魯","貴","鐘","煤","讀","班","伯","香","介","迫","句","豐","培","握","蘭","擔","弦","蛋","沉","假","穿","執","答","樂","誰","順","煙","縮","徵","臉","喜","松","腳","困","異","免","背","星","福","買","染","井","概","慢","怕","磁","倍","祖","皇","促","靜","補","評","翻","肉","踐","尼","衣","寬","揚","棉","希","傷","操","垂","秋","宜","氫","套","督","振","架","亮","末","憲","慶","編","牛","觸","映","雷","銷","詩","座","居","抓","裂","胞","呼","娘","景","威","綠","晶","厚","盟","衡","雞","孫","延","危","膠","屋","鄉","臨","陸","顧","掉","呀","燈","歲","措","束","耐","劇","玉","趙","跳","哥","季","課","凱","胡","額","款","紹","卷","齊","偉","蒸","殖","永","宗","苗","川","爐","岩","弱","零","楊","奏","沿","露","桿","探","滑","鎮","飯","濃","航","懷","趕","庫","奪","伊","靈","稅","途","滅","賽","歸","召","鼓","播","盤","裁","險","康","唯","錄","菌","純","借","糖","蓋","橫","符","私","努","堂","域","槍","潤","幅","哈","竟","熟","蟲","澤","腦","壤","碳","歐","遍","側","寨","敢","徹","慮","斜","薄","庭","納","彈","飼","伸","折","麥","濕","暗","荷","瓦","塞","床","築","惡","戶","訪","塔","奇","透","梁","刀","旋","跡","卡","氯","遇","份","毒","泥","退","洗","擺","灰","彩","賣","耗","夏","擇","忙","銅","獻","硬","予","繁","圈","雪","函","亦","抽","篇","陣","陰","丁","尺","追","堆","雄","迎","泛","爸","樓","避","謀","噸","野","豬","旗","累","偏","典","館","索","秦","脂","潮","爺","豆","忽","托","驚","塑","遺","愈","朱","替","纖","粗","傾","尚","痛","楚","謝","奮","購","磨","君","池","旁","碎","骨","監","捕","弟","暴","割","貫","殊","釋","詞","亡","壁","頓","寶","午","塵","聞","揭","炮","殘","冬","橋","婦","警","綜","招","吳","付","浮","遭","徐","您","搖","谷","贊","箱","隔","訂","男","吹","園","紛","唐","敗","宋","玻","巨","耕","坦","榮","閉","灣","鍵","凡","駐","鍋","救","恩","剝","凝","鹼","齒","截","煉","麻","紡","禁","廢","盛","版","緩","淨","睛","昌","婚","涉","筒","嘴","插","岸","朗","莊","街","藏","姑","貿","腐","奴","啦","慣","乘","夥","恢","勻","紗","扎","辯","耳","彪","臣","億","璃","抵","脈","秀","薩","俄","網","舞","店","噴","縱","寸","汗","掛","洪","賀","閃","柬","爆","烯","津","稻","牆","軟","勇","像","滾","厘","蒙","芳","肯","坡","柱","盪","腿","儀","旅","尾","軋","冰","貢","登","黎","削","鑽","勒","逃","障","氨","郭","峰","幣","港","伏","軌","畝","畢","擦","莫","刺","浪","秘","援","株","健","售","股","島","甘","泡","睡","童","鑄","湯","閥","休","匯","舍","牧","繞","炸","哲","磷","績","朋","淡","尖","啟","陷","柴","呈","徒","顏","淚","稍","忘","泵","藍","拖","洞","授","鏡","辛","壯","鋒","貧","虛","彎","摩","泰","幼","廷","尊","窗","綱","弄","隸","疑","氏","宮","姐","震","瑞","怪","尤","琴","循","描","膜","違","夾","腰","緣","珠","窮","森","枝","竹","溝","催","繩","憶","邦","剩","幸","漿","欄","擁","牙","貯","禮","濾","鈉","紋","罷","拍","咱","喊","袖","埃","勤","罰","焦","潛","伍","墨","欲","縫","姓","刊","飽","仿","獎","鋁","鬼","麗","跨","默","挖","鏈","掃","喝","袋","炭","污","幕","諸","弧","勵","梅","奶","潔","災","舟","鑑","苯","訟","抱","毀","懂","寒","智","埔","寄","屆","躍","渡","挑","丹","艱","貝","碰","拔","爹","戴","碼","夢","芽","熔","赤","漁","哭","敬","顆","奔","鉛","仲","虎","稀","妹","乏","珍","申","桌","遵","允","隆","螺","倉","魏","銳","曉","氮","兼","隱","礙","赫","撥","忠","肅","缸","牽","搶","博","巧","殼","兄","杜","訊","誠","碧","祥","柯","頁","巡","矩","悲","灌","齡","倫","票","尋","桂","鋪","聖","恐","恰","鄭","趣","抬","荒","騰","貼","柔","滴","猛","闊","輛","妻","填","撤","儲","簽","鬧","擾","紫","砂","遞","戲","吊","陶","伐","餵","療","瓶","婆","撫","臂","摸","忍","蝦","蠟","鄰","胸","鞏","擠","偶","棄","槽","勁","乳","鄧","吉","仁","爛","磚","租","烏","艦","伴","瓜","淺","丙","暫","燥","橡","柳","迷","暖","牌","秧","膽","詳","簧","踏","瓷","譜","呆","賓","糊","洛","輝","憤","競","隙","怒","粘","乃","緒","肩","籍","敏","塗","熙","皆","偵","懸","掘","享","糾","醒","狂","鎖","淀","恨","牲","霸","爬","賞","逆","玩","陵","祝","秒","浙","貌","役","彼","悉","鴨","趨","鳳","晨","畜","輩","秩","卵","署","梯","炎","灘","棋","驅","篩","峽","冒","啥","壽","譯","浸","泉","帽","遲","矽","疆","貸","漏","稿","冠","嫩","脅","芯","牢","叛","蝕","奧","鳴","嶺","羊","憑","串","塘","繪","酵","融","盆","錫","廟","籌","凍","輔","攝","襲","筋","拒","僚","旱","鉀","鳥","漆","沈","眉","疏","添","棒","穗","硝","韓","逼","扭","僑","涼","挺","碗","栽","炒","杯","患","餾","勸","豪","遼","勃","鴻","旦","吏","拜","狗","埋","輥","掩","飲","搬","罵","辭","勾","扣","估","蔣","絨","霧","丈","朵","姆","擬","宇","輯","陝","雕","償","蓄","崇","剪","倡","廳","咬","駛","薯","刷","斥","番","賦","奉","佛","澆","漫","曼","扇","鈣","桃","扶","仔","返","俗","虧","腔","鞋","棱","覆","框","悄","叔","撞","騙","勘","旺","沸","孤","吐","孟","渠","屈","疾","妙","惜","仰","狠","脹","諧","拋","黴","桑","崗","嘛","衰","盜","滲","臟","賴","湧","甜","曹","閱","肌","哩","厲","烴","緯","毅","昨","偽","症","煮","嘆","釘","搭","莖","籠","酷","偷","弓","錐","恆","傑","坑","鼻","翼","綸","敘","獄","逮","罐","絡","棚","抑","膨","蔬","寺","驟","穆","冶","枯","冊","屍","凸","紳","坯","犧","焰","轟","欣","晉","瘦","禦","錠","錦","喪","旬","鍛","壟","搜","撲","邀","亭","酯","邁","舒","脆","酶","閒","憂","酚","頑","羽","漲","卸","仗","陪","闢","懲","杭","姚","肚","捉","飄","漂","昆","欺","吾","郎","烷","汁","呵","飾","蕭","雅","郵","遷","燕","撒","姻","赴","宴","煩","債","帳","斑","鈴","旨","醇","董","餅","雛","姿","拌","傅","腹","妥","揉","賢","拆","歪","葡","胺","丟","浩","徽","昂","墊","擋","覽","貪","慰","繳","汪","慌","馮","諾","姜","誼","兇","劣","誣","耀","昏","躺","盈","騎","喬","溪","叢","盧","抹","悶","諮","刮","駕","纜","悟","摘","鉺","擲","頗","幻","柄","惠","慘","佳","仇","臘","窩","滌","劍","瞧","堡","潑","蔥","罩","霍","撈","胎","蒼","濱","倆","捅","湘","砍","霞","邵","萄","瘋","淮","遂","熊","糞","烘","宿","檔","戈","駁","嫂","裕","徙","箭","捐","腸","撐","曬","辨","殿","蓮","攤","攪","醬","屏","疫","哀","蔡","堵","沫","皺","暢","疊","閣","萊","敲","轄","鉤","痕","壩","巷","餓","禍","丘","玄","溜","曰","邏","彭","嘗","卿","妨","艇","吞","韋","怨","矮","歇"]');

/***/ }),

/***/ 32:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('["abdikace","abeceda","adresa","agrese","akce","aktovka","alej","alkohol","amputace","ananas","andulka","anekdota","anketa","antika","anulovat","archa","arogance","asfalt","asistent","aspirace","astma","astronom","atlas","atletika","atol","autobus","azyl","babka","bachor","bacil","baculka","badatel","bageta","bagr","bahno","bakterie","balada","baletka","balkon","balonek","balvan","balza","bambus","bankomat","barbar","baret","barman","baroko","barva","baterka","batoh","bavlna","bazalka","bazilika","bazuka","bedna","beran","beseda","bestie","beton","bezinka","bezmoc","beztak","bicykl","bidlo","biftek","bikiny","bilance","biograf","biolog","bitva","bizon","blahobyt","blatouch","blecha","bledule","blesk","blikat","blizna","blokovat","bloudit","blud","bobek","bobr","bodlina","bodnout","bohatost","bojkot","bojovat","bokorys","bolest","borec","borovice","bota","boubel","bouchat","bouda","boule","bourat","boxer","bradavka","brambora","branka","bratr","brepta","briketa","brko","brloh","bronz","broskev","brunetka","brusinka","brzda","brzy","bublina","bubnovat","buchta","buditel","budka","budova","bufet","bujarost","bukvice","buldok","bulva","bunda","bunkr","burza","butik","buvol","buzola","bydlet","bylina","bytovka","bzukot","capart","carevna","cedr","cedule","cejch","cejn","cela","celer","celkem","celnice","cenina","cennost","cenovka","centrum","cenzor","cestopis","cetka","chalupa","chapadlo","charita","chata","chechtat","chemie","chichot","chirurg","chlad","chleba","chlubit","chmel","chmura","chobot","chochol","chodba","cholera","chomout","chopit","choroba","chov","chrapot","chrlit","chrt","chrup","chtivost","chudina","chutnat","chvat","chvilka","chvost","chyba","chystat","chytit","cibule","cigareta","cihelna","cihla","cinkot","cirkus","cisterna","citace","citrus","cizinec","cizost","clona","cokoliv","couvat","ctitel","ctnost","cudnost","cuketa","cukr","cupot","cvaknout","cval","cvik","cvrkot","cyklista","daleko","dareba","datel","datum","dcera","debata","dechovka","decibel","deficit","deflace","dekl","dekret","demokrat","deprese","derby","deska","detektiv","dikobraz","diktovat","dioda","diplom","disk","displej","divadlo","divoch","dlaha","dlouho","dluhopis","dnes","dobro","dobytek","docent","dochutit","dodnes","dohled","dohoda","dohra","dojem","dojnice","doklad","dokola","doktor","dokument","dolar","doleva","dolina","doma","dominant","domluvit","domov","donutit","dopad","dopis","doplnit","doposud","doprovod","dopustit","dorazit","dorost","dort","dosah","doslov","dostatek","dosud","dosyta","dotaz","dotek","dotknout","doufat","doutnat","dovozce","dozadu","doznat","dozorce","drahota","drak","dramatik","dravec","draze","drdol","drobnost","drogerie","drozd","drsnost","drtit","drzost","duben","duchovno","dudek","duha","duhovka","dusit","dusno","dutost","dvojice","dvorec","dynamit","ekolog","ekonomie","elektron","elipsa","email","emise","emoce","empatie","epizoda","epocha","epopej","epos","esej","esence","eskorta","eskymo","etiketa","euforie","evoluce","exekuce","exkurze","expedice","exploze","export","extrakt","facka","fajfka","fakulta","fanatik","fantazie","farmacie","favorit","fazole","federace","fejeton","fenka","fialka","figurant","filozof","filtr","finance","finta","fixace","fjord","flanel","flirt","flotila","fond","fosfor","fotbal","fotka","foton","frakce","freska","fronta","fukar","funkce","fyzika","galeje","garant","genetika","geolog","gilotina","glazura","glejt","golem","golfista","gotika","graf","gramofon","granule","grep","gril","grog","groteska","guma","hadice","hadr","hala","halenka","hanba","hanopis","harfa","harpuna","havran","hebkost","hejkal","hejno","hejtman","hektar","helma","hematom","herec","herna","heslo","hezky","historik","hladovka","hlasivky","hlava","hledat","hlen","hlodavec","hloh","hloupost","hltat","hlubina","hluchota","hmat","hmota","hmyz","hnis","hnojivo","hnout","hoblina","hoboj","hoch","hodiny","hodlat","hodnota","hodovat","hojnost","hokej","holinka","holka","holub","homole","honitba","honorace","horal","horda","horizont","horko","horlivec","hormon","hornina","horoskop","horstvo","hospoda","hostina","hotovost","houba","houf","houpat","houska","hovor","hradba","hranice","hravost","hrazda","hrbolek","hrdina","hrdlo","hrdost","hrnek","hrobka","hromada","hrot","hrouda","hrozen","hrstka","hrubost","hryzat","hubenost","hubnout","hudba","hukot","humr","husita","hustota","hvozd","hybnost","hydrant","hygiena","hymna","hysterik","idylka","ihned","ikona","iluze","imunita","infekce","inflace","inkaso","inovace","inspekce","internet","invalida","investor","inzerce","ironie","jablko","jachta","jahoda","jakmile","jakost","jalovec","jantar","jarmark","jaro","jasan","jasno","jatka","javor","jazyk","jedinec","jedle","jednatel","jehlan","jekot","jelen","jelito","jemnost","jenom","jepice","jeseter","jevit","jezdec","jezero","jinak","jindy","jinoch","jiskra","jistota","jitrnice","jizva","jmenovat","jogurt","jurta","kabaret","kabel","kabinet","kachna","kadet","kadidlo","kahan","kajak","kajuta","kakao","kaktus","kalamita","kalhoty","kalibr","kalnost","kamera","kamkoliv","kamna","kanibal","kanoe","kantor","kapalina","kapela","kapitola","kapka","kaple","kapota","kapr","kapusta","kapybara","karamel","karotka","karton","kasa","katalog","katedra","kauce","kauza","kavalec","kazajka","kazeta","kazivost","kdekoliv","kdesi","kedluben","kemp","keramika","kino","klacek","kladivo","klam","klapot","klasika","klaun","klec","klenba","klepat","klesnout","klid","klima","klisna","klobouk","klokan","klopa","kloub","klubovna","klusat","kluzkost","kmen","kmitat","kmotr","kniha","knot","koalice","koberec","kobka","kobliha","kobyla","kocour","kohout","kojenec","kokos","koktejl","kolaps","koleda","kolize","kolo","komando","kometa","komik","komnata","komora","kompas","komunita","konat","koncept","kondice","konec","konfese","kongres","konina","konkurs","kontakt","konzerva","kopanec","kopie","kopnout","koprovka","korbel","korektor","kormidlo","koroptev","korpus","koruna","koryto","korzet","kosatec","kostka","kotel","kotleta","kotoul","koukat","koupelna","kousek","kouzlo","kovboj","koza","kozoroh","krabice","krach","krajina","kralovat","krasopis","kravata","kredit","krejcar","kresba","kreveta","kriket","kritik","krize","krkavec","krmelec","krmivo","krocan","krok","kronika","kropit","kroupa","krovka","krtek","kruhadlo","krupice","krutost","krvinka","krychle","krypta","krystal","kryt","kudlanka","kufr","kujnost","kukla","kulajda","kulich","kulka","kulomet","kultura","kuna","kupodivu","kurt","kurzor","kutil","kvalita","kvasinka","kvestor","kynolog","kyselina","kytara","kytice","kytka","kytovec","kyvadlo","labrador","lachtan","ladnost","laik","lakomec","lamela","lampa","lanovka","lasice","laso","lastura","latinka","lavina","lebka","leckdy","leden","lednice","ledovka","ledvina","legenda","legie","legrace","lehce","lehkost","lehnout","lektvar","lenochod","lentilka","lepenka","lepidlo","letadlo","letec","letmo","letokruh","levhart","levitace","levobok","libra","lichotka","lidojed","lidskost","lihovina","lijavec","lilek","limetka","linie","linka","linoleum","listopad","litina","litovat","lobista","lodivod","logika","logoped","lokalita","loket","lomcovat","lopata","lopuch","lord","losos","lotr","loudal","louh","louka","louskat","lovec","lstivost","lucerna","lucifer","lump","lusk","lustrace","lvice","lyra","lyrika","lysina","madam","madlo","magistr","mahagon","majetek","majitel","majorita","makak","makovice","makrela","malba","malina","malovat","malvice","maminka","mandle","manko","marnost","masakr","maskot","masopust","matice","matrika","maturita","mazanec","mazivo","mazlit","mazurka","mdloba","mechanik","meditace","medovina","melasa","meloun","mentolka","metla","metoda","metr","mezera","migrace","mihnout","mihule","mikina","mikrofon","milenec","milimetr","milost","mimika","mincovna","minibar","minomet","minulost","miska","mistr","mixovat","mladost","mlha","mlhovina","mlok","mlsat","mluvit","mnich","mnohem","mobil","mocnost","modelka","modlitba","mohyla","mokro","molekula","momentka","monarcha","monokl","monstrum","montovat","monzun","mosaz","moskyt","most","motivace","motorka","motyka","moucha","moudrost","mozaika","mozek","mozol","mramor","mravenec","mrkev","mrtvola","mrzet","mrzutost","mstitel","mudrc","muflon","mulat","mumie","munice","muset","mutace","muzeum","muzikant","myslivec","mzda","nabourat","nachytat","nadace","nadbytek","nadhoz","nadobro","nadpis","nahlas","nahnat","nahodile","nahradit","naivita","najednou","najisto","najmout","naklonit","nakonec","nakrmit","nalevo","namazat","namluvit","nanometr","naoko","naopak","naostro","napadat","napevno","naplnit","napnout","naposled","naprosto","narodit","naruby","narychlo","nasadit","nasekat","naslepo","nastat","natolik","navenek","navrch","navzdory","nazvat","nebe","nechat","necky","nedaleko","nedbat","neduh","negace","nehet","nehoda","nejen","nejprve","neklid","nelibost","nemilost","nemoc","neochota","neonka","nepokoj","nerost","nerv","nesmysl","nesoulad","netvor","neuron","nevina","nezvykle","nicota","nijak","nikam","nikdy","nikl","nikterak","nitro","nocleh","nohavice","nominace","nora","norek","nositel","nosnost","nouze","noviny","novota","nozdra","nuda","nudle","nuget","nutit","nutnost","nutrie","nymfa","obal","obarvit","obava","obdiv","obec","obehnat","obejmout","obezita","obhajoba","obilnice","objasnit","objekt","obklopit","oblast","oblek","obliba","obloha","obluda","obnos","obohatit","obojek","obout","obrazec","obrna","obruba","obrys","obsah","obsluha","obstarat","obuv","obvaz","obvinit","obvod","obvykle","obyvatel","obzor","ocas","ocel","ocenit","ochladit","ochota","ochrana","ocitnout","odboj","odbyt","odchod","odcizit","odebrat","odeslat","odevzdat","odezva","odhadce","odhodit","odjet","odjinud","odkaz","odkoupit","odliv","odluka","odmlka","odolnost","odpad","odpis","odplout","odpor","odpustit","odpykat","odrazka","odsoudit","odstup","odsun","odtok","odtud","odvaha","odveta","odvolat","odvracet","odznak","ofina","ofsajd","ohlas","ohnisko","ohrada","ohrozit","ohryzek","okap","okenice","oklika","okno","okouzlit","okovy","okrasa","okres","okrsek","okruh","okupant","okurka","okusit","olejnina","olizovat","omak","omeleta","omezit","omladina","omlouvat","omluva","omyl","onehdy","opakovat","opasek","operace","opice","opilost","opisovat","opora","opozice","opravdu","oproti","orbital","orchestr","orgie","orlice","orloj","ortel","osada","oschnout","osika","osivo","oslava","oslepit","oslnit","oslovit","osnova","osoba","osolit","ospalec","osten","ostraha","ostuda","ostych","osvojit","oteplit","otisk","otop","otrhat","otrlost","otrok","otruby","otvor","ovanout","ovar","oves","ovlivnit","ovoce","oxid","ozdoba","pachatel","pacient","padouch","pahorek","pakt","palanda","palec","palivo","paluba","pamflet","pamlsek","panenka","panika","panna","panovat","panstvo","pantofle","paprika","parketa","parodie","parta","paruka","paryba","paseka","pasivita","pastelka","patent","patrona","pavouk","pazneht","pazourek","pecka","pedagog","pejsek","peklo","peloton","penalta","pendrek","penze","periskop","pero","pestrost","petarda","petice","petrolej","pevnina","pexeso","pianista","piha","pijavice","pikle","piknik","pilina","pilnost","pilulka","pinzeta","pipeta","pisatel","pistole","pitevna","pivnice","pivovar","placenta","plakat","plamen","planeta","plastika","platit","plavidlo","plaz","plech","plemeno","plenta","ples","pletivo","plevel","plivat","plnit","plno","plocha","plodina","plomba","plout","pluk","plyn","pobavit","pobyt","pochod","pocit","poctivec","podat","podcenit","podepsat","podhled","podivit","podklad","podmanit","podnik","podoba","podpora","podraz","podstata","podvod","podzim","poezie","pohanka","pohnutka","pohovor","pohroma","pohyb","pointa","pojistka","pojmout","pokazit","pokles","pokoj","pokrok","pokuta","pokyn","poledne","polibek","polknout","poloha","polynom","pomalu","pominout","pomlka","pomoc","pomsta","pomyslet","ponechat","ponorka","ponurost","popadat","popel","popisek","poplach","poprosit","popsat","popud","poradce","porce","porod","porucha","poryv","posadit","posed","posila","poskok","poslanec","posoudit","pospolu","postava","posudek","posyp","potah","potkan","potlesk","potomek","potrava","potupa","potvora","poukaz","pouto","pouzdro","povaha","povidla","povlak","povoz","povrch","povstat","povyk","povzdech","pozdrav","pozemek","poznatek","pozor","pozvat","pracovat","prahory","praktika","prales","praotec","praporek","prase","pravda","princip","prkno","probudit","procento","prodej","profese","prohra","projekt","prolomit","promile","pronikat","propad","prorok","prosba","proton","proutek","provaz","prskavka","prsten","prudkost","prut","prvek","prvohory","psanec","psovod","pstruh","ptactvo","puberta","puch","pudl","pukavec","puklina","pukrle","pult","pumpa","punc","pupen","pusa","pusinka","pustina","putovat","putyka","pyramida","pysk","pytel","racek","rachot","radiace","radnice","radon","raft","ragby","raketa","rakovina","rameno","rampouch","rande","rarach","rarita","rasovna","rastr","ratolest","razance","razidlo","reagovat","reakce","recept","redaktor","referent","reflex","rejnok","reklama","rekord","rekrut","rektor","reputace","revize","revma","revolver","rezerva","riskovat","riziko","robotika","rodokmen","rohovka","rokle","rokoko","romaneto","ropovod","ropucha","rorejs","rosol","rostlina","rotmistr","rotoped","rotunda","roubenka","roucho","roup","roura","rovina","rovnice","rozbor","rozchod","rozdat","rozeznat","rozhodce","rozinka","rozjezd","rozkaz","rozloha","rozmar","rozpad","rozruch","rozsah","roztok","rozum","rozvod","rubrika","ruchadlo","rukavice","rukopis","ryba","rybolov","rychlost","rydlo","rypadlo","rytina","ryzost","sadista","sahat","sako","samec","samizdat","samota","sanitka","sardinka","sasanka","satelit","sazba","sazenice","sbor","schovat","sebranka","secese","sedadlo","sediment","sedlo","sehnat","sejmout","sekera","sekta","sekunda","sekvoje","semeno","seno","servis","sesadit","seshora","seskok","seslat","sestra","sesuv","sesypat","setba","setina","setkat","setnout","setrvat","sever","seznam","shoda","shrnout","sifon","silnice","sirka","sirotek","sirup","situace","skafandr","skalisko","skanzen","skaut","skeptik","skica","skladba","sklenice","sklo","skluz","skoba","skokan","skoro","skripta","skrz","skupina","skvost","skvrna","slabika","sladidlo","slanina","slast","slavnost","sledovat","slepec","sleva","slezina","slib","slina","sliznice","slon","sloupek","slovo","sluch","sluha","slunce","slupka","slza","smaragd","smetana","smilstvo","smlouva","smog","smrad","smrk","smrtka","smutek","smysl","snad","snaha","snob","sobota","socha","sodovka","sokol","sopka","sotva","souboj","soucit","soudce","souhlas","soulad","soumrak","souprava","soused","soutok","souviset","spalovna","spasitel","spis","splav","spodek","spojenec","spolu","sponzor","spornost","spousta","sprcha","spustit","sranda","sraz","srdce","srna","srnec","srovnat","srpen","srst","srub","stanice","starosta","statika","stavba","stehno","stezka","stodola","stolek","stopa","storno","stoupat","strach","stres","strhnout","strom","struna","studna","stupnice","stvol","styk","subjekt","subtropy","suchar","sudost","sukno","sundat","sunout","surikata","surovina","svah","svalstvo","svetr","svatba","svazek","svisle","svitek","svoboda","svodidlo","svorka","svrab","sykavka","sykot","synek","synovec","sypat","sypkost","syrovost","sysel","sytost","tabletka","tabule","tahoun","tajemno","tajfun","tajga","tajit","tajnost","taktika","tamhle","tampon","tancovat","tanec","tanker","tapeta","tavenina","tazatel","technika","tehdy","tekutina","telefon","temnota","tendence","tenista","tenor","teplota","tepna","teprve","terapie","termoska","textil","ticho","tiskopis","titulek","tkadlec","tkanina","tlapka","tleskat","tlukot","tlupa","tmel","toaleta","topinka","topol","torzo","touha","toulec","tradice","traktor","tramp","trasa","traverza","trefit","trest","trezor","trhavina","trhlina","trochu","trojice","troska","trouba","trpce","trpitel","trpkost","trubec","truchlit","truhlice","trus","trvat","tudy","tuhnout","tuhost","tundra","turista","turnaj","tuzemsko","tvaroh","tvorba","tvrdost","tvrz","tygr","tykev","ubohost","uboze","ubrat","ubrousek","ubrus","ubytovna","ucho","uctivost","udivit","uhradit","ujednat","ujistit","ujmout","ukazatel","uklidnit","uklonit","ukotvit","ukrojit","ulice","ulita","ulovit","umyvadlo","unavit","uniforma","uniknout","upadnout","uplatnit","uplynout","upoutat","upravit","uran","urazit","usednout","usilovat","usmrtit","usnadnit","usnout","usoudit","ustlat","ustrnout","utahovat","utkat","utlumit","utonout","utopenec","utrousit","uvalit","uvolnit","uvozovka","uzdravit","uzel","uzenina","uzlina","uznat","vagon","valcha","valoun","vana","vandal","vanilka","varan","varhany","varovat","vcelku","vchod","vdova","vedro","vegetace","vejce","velbloud","veletrh","velitel","velmoc","velryba","venkov","veranda","verze","veselka","veskrze","vesnice","vespodu","vesta","veterina","veverka","vibrace","vichr","videohra","vidina","vidle","vila","vinice","viset","vitalita","vize","vizitka","vjezd","vklad","vkus","vlajka","vlak","vlasec","vlevo","vlhkost","vliv","vlnovka","vloupat","vnucovat","vnuk","voda","vodivost","vodoznak","vodstvo","vojensky","vojna","vojsko","volant","volba","volit","volno","voskovka","vozidlo","vozovna","vpravo","vrabec","vracet","vrah","vrata","vrba","vrcholek","vrhat","vrstva","vrtule","vsadit","vstoupit","vstup","vtip","vybavit","vybrat","vychovat","vydat","vydra","vyfotit","vyhledat","vyhnout","vyhodit","vyhradit","vyhubit","vyjasnit","vyjet","vyjmout","vyklopit","vykonat","vylekat","vymazat","vymezit","vymizet","vymyslet","vynechat","vynikat","vynutit","vypadat","vyplatit","vypravit","vypustit","vyrazit","vyrovnat","vyrvat","vyslovit","vysoko","vystavit","vysunout","vysypat","vytasit","vytesat","vytratit","vyvinout","vyvolat","vyvrhel","vyzdobit","vyznat","vzadu","vzbudit","vzchopit","vzdor","vzduch","vzdychat","vzestup","vzhledem","vzkaz","vzlykat","vznik","vzorek","vzpoura","vztah","vztek","xylofon","zabrat","zabydlet","zachovat","zadarmo","zadusit","zafoukat","zahltit","zahodit","zahrada","zahynout","zajatec","zajet","zajistit","zaklepat","zakoupit","zalepit","zamezit","zamotat","zamyslet","zanechat","zanikat","zaplatit","zapojit","zapsat","zarazit","zastavit","zasunout","zatajit","zatemnit","zatknout","zaujmout","zavalit","zavelet","zavinit","zavolat","zavrtat","zazvonit","zbavit","zbrusu","zbudovat","zbytek","zdaleka","zdarma","zdatnost","zdivo","zdobit","zdroj","zdvih","zdymadlo","zelenina","zeman","zemina","zeptat","zezadu","zezdola","zhatit","zhltnout","zhluboka","zhotovit","zhruba","zima","zimnice","zjemnit","zklamat","zkoumat","zkratka","zkumavka","zlato","zlehka","zloba","zlom","zlost","zlozvyk","zmapovat","zmar","zmatek","zmije","zmizet","zmocnit","zmodrat","zmrzlina","zmutovat","znak","znalost","znamenat","znovu","zobrazit","zotavit","zoubek","zoufale","zplodit","zpomalit","zprava","zprostit","zprudka","zprvu","zrada","zranit","zrcadlo","zrnitost","zrno","zrovna","zrychlit","zrzavost","zticha","ztratit","zubovina","zubr","zvednout","zvenku","zvesela","zvon","zvrat","zvukovod","zvyk"]');

/***/ }),

/***/ 4573:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('["abandon","ability","able","about","above","absent","absorb","abstract","absurd","abuse","access","accident","account","accuse","achieve","acid","acoustic","acquire","across","act","action","actor","actress","actual","adapt","add","addict","address","adjust","admit","adult","advance","advice","aerobic","affair","afford","afraid","again","age","agent","agree","ahead","aim","air","airport","aisle","alarm","album","alcohol","alert","alien","all","alley","allow","almost","alone","alpha","already","also","alter","always","amateur","amazing","among","amount","amused","analyst","anchor","ancient","anger","angle","angry","animal","ankle","announce","annual","another","answer","antenna","antique","anxiety","any","apart","apology","appear","apple","approve","april","arch","arctic","area","arena","argue","arm","armed","armor","army","around","arrange","arrest","arrive","arrow","art","artefact","artist","artwork","ask","aspect","assault","asset","assist","assume","asthma","athlete","atom","attack","attend","attitude","attract","auction","audit","august","aunt","author","auto","autumn","average","avocado","avoid","awake","aware","away","awesome","awful","awkward","axis","baby","bachelor","bacon","badge","bag","balance","balcony","ball","bamboo","banana","banner","bar","barely","bargain","barrel","base","basic","basket","battle","beach","bean","beauty","because","become","beef","before","begin","behave","behind","believe","below","belt","bench","benefit","best","betray","better","between","beyond","bicycle","bid","bike","bind","biology","bird","birth","bitter","black","blade","blame","blanket","blast","bleak","bless","blind","blood","blossom","blouse","blue","blur","blush","board","boat","body","boil","bomb","bone","bonus","book","boost","border","boring","borrow","boss","bottom","bounce","box","boy","bracket","brain","brand","brass","brave","bread","breeze","brick","bridge","brief","bright","bring","brisk","broccoli","broken","bronze","broom","brother","brown","brush","bubble","buddy","budget","buffalo","build","bulb","bulk","bullet","bundle","bunker","burden","burger","burst","bus","business","busy","butter","buyer","buzz","cabbage","cabin","cable","cactus","cage","cake","call","calm","camera","camp","can","canal","cancel","candy","cannon","canoe","canvas","canyon","capable","capital","captain","car","carbon","card","cargo","carpet","carry","cart","case","cash","casino","castle","casual","cat","catalog","catch","category","cattle","caught","cause","caution","cave","ceiling","celery","cement","census","century","cereal","certain","chair","chalk","champion","change","chaos","chapter","charge","chase","chat","cheap","check","cheese","chef","cherry","chest","chicken","chief","child","chimney","choice","choose","chronic","chuckle","chunk","churn","cigar","cinnamon","circle","citizen","city","civil","claim","clap","clarify","claw","clay","clean","clerk","clever","click","client","cliff","climb","clinic","clip","clock","clog","close","cloth","cloud","clown","club","clump","cluster","clutch","coach","coast","coconut","code","coffee","coil","coin","collect","color","column","combine","come","comfort","comic","common","company","concert","conduct","confirm","congress","connect","consider","control","convince","cook","cool","copper","copy","coral","core","corn","correct","cost","cotton","couch","country","couple","course","cousin","cover","coyote","crack","cradle","craft","cram","crane","crash","crater","crawl","crazy","cream","credit","creek","crew","cricket","crime","crisp","critic","crop","cross","crouch","crowd","crucial","cruel","cruise","crumble","crunch","crush","cry","crystal","cube","culture","cup","cupboard","curious","current","curtain","curve","cushion","custom","cute","cycle","dad","damage","damp","dance","danger","daring","dash","daughter","dawn","day","deal","debate","debris","decade","december","decide","decline","decorate","decrease","deer","defense","define","defy","degree","delay","deliver","demand","demise","denial","dentist","deny","depart","depend","deposit","depth","deputy","derive","describe","desert","design","desk","despair","destroy","detail","detect","develop","device","devote","diagram","dial","diamond","diary","dice","diesel","diet","differ","digital","dignity","dilemma","dinner","dinosaur","direct","dirt","disagree","discover","disease","dish","dismiss","disorder","display","distance","divert","divide","divorce","dizzy","doctor","document","dog","doll","dolphin","domain","donate","donkey","donor","door","dose","double","dove","draft","dragon","drama","drastic","draw","dream","dress","drift","drill","drink","drip","drive","drop","drum","dry","duck","dumb","dune","during","dust","dutch","duty","dwarf","dynamic","eager","eagle","early","earn","earth","easily","east","easy","echo","ecology","economy","edge","edit","educate","effort","egg","eight","either","elbow","elder","electric","elegant","element","elephant","elevator","elite","else","embark","embody","embrace","emerge","emotion","employ","empower","empty","enable","enact","end","endless","endorse","enemy","energy","enforce","engage","engine","enhance","enjoy","enlist","enough","enrich","enroll","ensure","enter","entire","entry","envelope","episode","equal","equip","era","erase","erode","erosion","error","erupt","escape","essay","essence","estate","eternal","ethics","evidence","evil","evoke","evolve","exact","example","excess","exchange","excite","exclude","excuse","execute","exercise","exhaust","exhibit","exile","exist","exit","exotic","expand","expect","expire","explain","expose","express","extend","extra","eye","eyebrow","fabric","face","faculty","fade","faint","faith","fall","false","fame","family","famous","fan","fancy","fantasy","farm","fashion","fat","fatal","father","fatigue","fault","favorite","feature","february","federal","fee","feed","feel","female","fence","festival","fetch","fever","few","fiber","fiction","field","figure","file","film","filter","final","find","fine","finger","finish","fire","firm","first","fiscal","fish","fit","fitness","fix","flag","flame","flash","flat","flavor","flee","flight","flip","float","flock","floor","flower","fluid","flush","fly","foam","focus","fog","foil","fold","follow","food","foot","force","forest","forget","fork","fortune","forum","forward","fossil","foster","found","fox","fragile","frame","frequent","fresh","friend","fringe","frog","front","frost","frown","frozen","fruit","fuel","fun","funny","furnace","fury","future","gadget","gain","galaxy","gallery","game","gap","garage","garbage","garden","garlic","garment","gas","gasp","gate","gather","gauge","gaze","general","genius","genre","gentle","genuine","gesture","ghost","giant","gift","giggle","ginger","giraffe","girl","give","glad","glance","glare","glass","glide","glimpse","globe","gloom","glory","glove","glow","glue","goat","goddess","gold","good","goose","gorilla","gospel","gossip","govern","gown","grab","grace","grain","grant","grape","grass","gravity","great","green","grid","grief","grit","grocery","group","grow","grunt","guard","guess","guide","guilt","guitar","gun","gym","habit","hair","half","hammer","hamster","hand","happy","harbor","hard","harsh","harvest","hat","have","hawk","hazard","head","health","heart","heavy","hedgehog","height","hello","helmet","help","hen","hero","hidden","high","hill","hint","hip","hire","history","hobby","hockey","hold","hole","holiday","hollow","home","honey","hood","hope","horn","horror","horse","hospital","host","hotel","hour","hover","hub","huge","human","humble","humor","hundred","hungry","hunt","hurdle","hurry","hurt","husband","hybrid","ice","icon","idea","identify","idle","ignore","ill","illegal","illness","image","imitate","immense","immune","impact","impose","improve","impulse","inch","include","income","increase","index","indicate","indoor","industry","infant","inflict","inform","inhale","inherit","initial","inject","injury","inmate","inner","innocent","input","inquiry","insane","insect","inside","inspire","install","intact","interest","into","invest","invite","involve","iron","island","isolate","issue","item","ivory","jacket","jaguar","jar","jazz","jealous","jeans","jelly","jewel","job","join","joke","journey","joy","judge","juice","jump","jungle","junior","junk","just","kangaroo","keen","keep","ketchup","key","kick","kid","kidney","kind","kingdom","kiss","kit","kitchen","kite","kitten","kiwi","knee","knife","knock","know","lab","label","labor","ladder","lady","lake","lamp","language","laptop","large","later","latin","laugh","laundry","lava","law","lawn","lawsuit","layer","lazy","leader","leaf","learn","leave","lecture","left","leg","legal","legend","leisure","lemon","lend","length","lens","leopard","lesson","letter","level","liar","liberty","library","license","life","lift","light","like","limb","limit","link","lion","liquid","list","little","live","lizard","load","loan","lobster","local","lock","logic","lonely","long","loop","lottery","loud","lounge","love","loyal","lucky","luggage","lumber","lunar","lunch","luxury","lyrics","machine","mad","magic","magnet","maid","mail","main","major","make","mammal","man","manage","mandate","mango","mansion","manual","maple","marble","march","margin","marine","market","marriage","mask","mass","master","match","material","math","matrix","matter","maximum","maze","meadow","mean","measure","meat","mechanic","medal","media","melody","melt","member","memory","mention","menu","mercy","merge","merit","merry","mesh","message","metal","method","middle","midnight","milk","million","mimic","mind","minimum","minor","minute","miracle","mirror","misery","miss","mistake","mix","mixed","mixture","mobile","model","modify","mom","moment","monitor","monkey","monster","month","moon","moral","more","morning","mosquito","mother","motion","motor","mountain","mouse","move","movie","much","muffin","mule","multiply","muscle","museum","mushroom","music","must","mutual","myself","mystery","myth","naive","name","napkin","narrow","nasty","nation","nature","near","neck","need","negative","neglect","neither","nephew","nerve","nest","net","network","neutral","never","news","next","nice","night","noble","noise","nominee","noodle","normal","north","nose","notable","note","nothing","notice","novel","now","nuclear","number","nurse","nut","oak","obey","object","oblige","obscure","observe","obtain","obvious","occur","ocean","october","odor","off","offer","office","often","oil","okay","old","olive","olympic","omit","once","one","onion","online","only","open","opera","opinion","oppose","option","orange","orbit","orchard","order","ordinary","organ","orient","original","orphan","ostrich","other","outdoor","outer","output","outside","oval","oven","over","own","owner","oxygen","oyster","ozone","pact","paddle","page","pair","palace","palm","panda","panel","panic","panther","paper","parade","parent","park","parrot","party","pass","patch","path","patient","patrol","pattern","pause","pave","payment","peace","peanut","pear","peasant","pelican","pen","penalty","pencil","people","pepper","perfect","permit","person","pet","phone","photo","phrase","physical","piano","picnic","picture","piece","pig","pigeon","pill","pilot","pink","pioneer","pipe","pistol","pitch","pizza","place","planet","plastic","plate","play","please","pledge","pluck","plug","plunge","poem","poet","point","polar","pole","police","pond","pony","pool","popular","portion","position","possible","post","potato","pottery","poverty","powder","power","practice","praise","predict","prefer","prepare","present","pretty","prevent","price","pride","primary","print","priority","prison","private","prize","problem","process","produce","profit","program","project","promote","proof","property","prosper","protect","proud","provide","public","pudding","pull","pulp","pulse","pumpkin","punch","pupil","puppy","purchase","purity","purpose","purse","push","put","puzzle","pyramid","quality","quantum","quarter","question","quick","quit","quiz","quote","rabbit","raccoon","race","rack","radar","radio","rail","rain","raise","rally","ramp","ranch","random","range","rapid","rare","rate","rather","raven","raw","razor","ready","real","reason","rebel","rebuild","recall","receive","recipe","record","recycle","reduce","reflect","reform","refuse","region","regret","regular","reject","relax","release","relief","rely","remain","remember","remind","remove","render","renew","rent","reopen","repair","repeat","replace","report","require","rescue","resemble","resist","resource","response","result","retire","retreat","return","reunion","reveal","review","reward","rhythm","rib","ribbon","rice","rich","ride","ridge","rifle","right","rigid","ring","riot","ripple","risk","ritual","rival","river","road","roast","robot","robust","rocket","romance","roof","rookie","room","rose","rotate","rough","round","route","royal","rubber","rude","rug","rule","run","runway","rural","sad","saddle","sadness","safe","sail","salad","salmon","salon","salt","salute","same","sample","sand","satisfy","satoshi","sauce","sausage","save","say","scale","scan","scare","scatter","scene","scheme","school","science","scissors","scorpion","scout","scrap","screen","script","scrub","sea","search","season","seat","second","secret","section","security","seed","seek","segment","select","sell","seminar","senior","sense","sentence","series","service","session","settle","setup","seven","shadow","shaft","shallow","share","shed","shell","sheriff","shield","shift","shine","ship","shiver","shock","shoe","shoot","shop","short","shoulder","shove","shrimp","shrug","shuffle","shy","sibling","sick","side","siege","sight","sign","silent","silk","silly","silver","similar","simple","since","sing","siren","sister","situate","six","size","skate","sketch","ski","skill","skin","skirt","skull","slab","slam","sleep","slender","slice","slide","slight","slim","slogan","slot","slow","slush","small","smart","smile","smoke","smooth","snack","snake","snap","sniff","snow","soap","soccer","social","sock","soda","soft","solar","soldier","solid","solution","solve","someone","song","soon","sorry","sort","soul","sound","soup","source","south","space","spare","spatial","spawn","speak","special","speed","spell","spend","sphere","spice","spider","spike","spin","spirit","split","spoil","sponsor","spoon","sport","spot","spray","spread","spring","spy","square","squeeze","squirrel","stable","stadium","staff","stage","stairs","stamp","stand","start","state","stay","steak","steel","stem","step","stereo","stick","still","sting","stock","stomach","stone","stool","story","stove","strategy","street","strike","strong","struggle","student","stuff","stumble","style","subject","submit","subway","success","such","sudden","suffer","sugar","suggest","suit","summer","sun","sunny","sunset","super","supply","supreme","sure","surface","surge","surprise","surround","survey","suspect","sustain","swallow","swamp","swap","swarm","swear","sweet","swift","swim","swing","switch","sword","symbol","symptom","syrup","system","table","tackle","tag","tail","talent","talk","tank","tape","target","task","taste","tattoo","taxi","teach","team","tell","ten","tenant","tennis","tent","term","test","text","thank","that","theme","then","theory","there","they","thing","this","thought","three","thrive","throw","thumb","thunder","ticket","tide","tiger","tilt","timber","time","tiny","tip","tired","tissue","title","toast","tobacco","today","toddler","toe","together","toilet","token","tomato","tomorrow","tone","tongue","tonight","tool","tooth","top","topic","topple","torch","tornado","tortoise","toss","total","tourist","toward","tower","town","toy","track","trade","traffic","tragic","train","transfer","trap","trash","travel","tray","treat","tree","trend","trial","tribe","trick","trigger","trim","trip","trophy","trouble","truck","true","truly","trumpet","trust","truth","try","tube","tuition","tumble","tuna","tunnel","turkey","turn","turtle","twelve","twenty","twice","twin","twist","two","type","typical","ugly","umbrella","unable","unaware","uncle","uncover","under","undo","unfair","unfold","unhappy","uniform","unique","unit","universe","unknown","unlock","until","unusual","unveil","update","upgrade","uphold","upon","upper","upset","urban","urge","usage","use","used","useful","useless","usual","utility","vacant","vacuum","vague","valid","valley","valve","van","vanish","vapor","various","vast","vault","vehicle","velvet","vendor","venture","venue","verb","verify","version","very","vessel","veteran","viable","vibrant","vicious","victory","video","view","village","vintage","violin","virtual","virus","visa","visit","visual","vital","vivid","vocal","voice","void","volcano","volume","vote","voyage","wage","wagon","wait","walk","wall","walnut","want","warfare","warm","warrior","wash","wasp","waste","water","wave","way","wealth","weapon","wear","weasel","weather","web","wedding","weekend","weird","welcome","west","wet","whale","what","wheat","wheel","when","where","whip","whisper","wide","width","wife","wild","will","win","window","wine","wing","wink","winner","winter","wire","wisdom","wise","wish","witness","wolf","woman","wonder","wood","wool","word","work","world","worry","worth","wrap","wreck","wrestle","wrist","write","wrong","yard","year","yellow","you","young","youth","zebra","zero","zone","zoo"]');

/***/ }),

/***/ 1848:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('["abaisser","abandon","abdiquer","abeille","abolir","aborder","aboutir","aboyer","abrasif","abreuver","abriter","abroger","abrupt","absence","absolu","absurde","abusif","abyssal","académie","acajou","acarien","accabler","accepter","acclamer","accolade","accroche","accuser","acerbe","achat","acheter","aciduler","acier","acompte","acquérir","acronyme","acteur","actif","actuel","adepte","adéquat","adhésif","adjectif","adjuger","admettre","admirer","adopter","adorer","adoucir","adresse","adroit","adulte","adverbe","aérer","aéronef","affaire","affecter","affiche","affreux","affubler","agacer","agencer","agile","agiter","agrafer","agréable","agrume","aider","aiguille","ailier","aimable","aisance","ajouter","ajuster","alarmer","alchimie","alerte","algèbre","algue","aliéner","aliment","alléger","alliage","allouer","allumer","alourdir","alpaga","altesse","alvéole","amateur","ambigu","ambre","aménager","amertume","amidon","amiral","amorcer","amour","amovible","amphibie","ampleur","amusant","analyse","anaphore","anarchie","anatomie","ancien","anéantir","angle","angoisse","anguleux","animal","annexer","annonce","annuel","anodin","anomalie","anonyme","anormal","antenne","antidote","anxieux","apaiser","apéritif","aplanir","apologie","appareil","appeler","apporter","appuyer","aquarium","aqueduc","arbitre","arbuste","ardeur","ardoise","argent","arlequin","armature","armement","armoire","armure","arpenter","arracher","arriver","arroser","arsenic","artériel","article","aspect","asphalte","aspirer","assaut","asservir","assiette","associer","assurer","asticot","astre","astuce","atelier","atome","atrium","atroce","attaque","attentif","attirer","attraper","aubaine","auberge","audace","audible","augurer","aurore","automne","autruche","avaler","avancer","avarice","avenir","averse","aveugle","aviateur","avide","avion","aviser","avoine","avouer","avril","axial","axiome","badge","bafouer","bagage","baguette","baignade","balancer","balcon","baleine","balisage","bambin","bancaire","bandage","banlieue","bannière","banquier","barbier","baril","baron","barque","barrage","bassin","bastion","bataille","bateau","batterie","baudrier","bavarder","belette","bélier","belote","bénéfice","berceau","berger","berline","bermuda","besace","besogne","bétail","beurre","biberon","bicycle","bidule","bijou","bilan","bilingue","billard","binaire","biologie","biopsie","biotype","biscuit","bison","bistouri","bitume","bizarre","blafard","blague","blanchir","blessant","blinder","blond","bloquer","blouson","bobard","bobine","boire","boiser","bolide","bonbon","bondir","bonheur","bonifier","bonus","bordure","borne","botte","boucle","boueux","bougie","boulon","bouquin","bourse","boussole","boutique","boxeur","branche","brasier","brave","brebis","brèche","breuvage","bricoler","brigade","brillant","brioche","brique","brochure","broder","bronzer","brousse","broyeur","brume","brusque","brutal","bruyant","buffle","buisson","bulletin","bureau","burin","bustier","butiner","butoir","buvable","buvette","cabanon","cabine","cachette","cadeau","cadre","caféine","caillou","caisson","calculer","calepin","calibre","calmer","calomnie","calvaire","camarade","caméra","camion","campagne","canal","caneton","canon","cantine","canular","capable","caporal","caprice","capsule","capter","capuche","carabine","carbone","caresser","caribou","carnage","carotte","carreau","carton","cascade","casier","casque","cassure","causer","caution","cavalier","caverne","caviar","cédille","ceinture","céleste","cellule","cendrier","censurer","central","cercle","cérébral","cerise","cerner","cerveau","cesser","chagrin","chaise","chaleur","chambre","chance","chapitre","charbon","chasseur","chaton","chausson","chavirer","chemise","chenille","chéquier","chercher","cheval","chien","chiffre","chignon","chimère","chiot","chlorure","chocolat","choisir","chose","chouette","chrome","chute","cigare","cigogne","cimenter","cinéma","cintrer","circuler","cirer","cirque","citerne","citoyen","citron","civil","clairon","clameur","claquer","classe","clavier","client","cligner","climat","clivage","cloche","clonage","cloporte","cobalt","cobra","cocasse","cocotier","coder","codifier","coffre","cogner","cohésion","coiffer","coincer","colère","colibri","colline","colmater","colonel","combat","comédie","commande","compact","concert","conduire","confier","congeler","connoter","consonne","contact","convexe","copain","copie","corail","corbeau","cordage","corniche","corpus","correct","cortège","cosmique","costume","coton","coude","coupure","courage","couteau","couvrir","coyote","crabe","crainte","cravate","crayon","créature","créditer","crémeux","creuser","crevette","cribler","crier","cristal","critère","croire","croquer","crotale","crucial","cruel","crypter","cubique","cueillir","cuillère","cuisine","cuivre","culminer","cultiver","cumuler","cupide","curatif","curseur","cyanure","cycle","cylindre","cynique","daigner","damier","danger","danseur","dauphin","débattre","débiter","déborder","débrider","débutant","décaler","décembre","déchirer","décider","déclarer","décorer","décrire","décupler","dédale","déductif","déesse","défensif","défiler","défrayer","dégager","dégivrer","déglutir","dégrafer","déjeuner","délice","déloger","demander","demeurer","démolir","dénicher","dénouer","dentelle","dénuder","départ","dépenser","déphaser","déplacer","déposer","déranger","dérober","désastre","descente","désert","désigner","désobéir","dessiner","destrier","détacher","détester","détourer","détresse","devancer","devenir","deviner","devoir","diable","dialogue","diamant","dicter","différer","digérer","digital","digne","diluer","dimanche","diminuer","dioxyde","directif","diriger","discuter","disposer","dissiper","distance","divertir","diviser","docile","docteur","dogme","doigt","domaine","domicile","dompter","donateur","donjon","donner","dopamine","dortoir","dorure","dosage","doseur","dossier","dotation","douanier","double","douceur","douter","doyen","dragon","draper","dresser","dribbler","droiture","duperie","duplexe","durable","durcir","dynastie","éblouir","écarter","écharpe","échelle","éclairer","éclipse","éclore","écluse","école","économie","écorce","écouter","écraser","écrémer","écrivain","écrou","écume","écureuil","édifier","éduquer","effacer","effectif","effigie","effort","effrayer","effusion","égaliser","égarer","éjecter","élaborer","élargir","électron","élégant","éléphant","élève","éligible","élitisme","éloge","élucider","éluder","emballer","embellir","embryon","émeraude","émission","emmener","émotion","émouvoir","empereur","employer","emporter","emprise","émulsion","encadrer","enchère","enclave","encoche","endiguer","endosser","endroit","enduire","énergie","enfance","enfermer","enfouir","engager","engin","englober","énigme","enjamber","enjeu","enlever","ennemi","ennuyeux","enrichir","enrobage","enseigne","entasser","entendre","entier","entourer","entraver","énumérer","envahir","enviable","envoyer","enzyme","éolien","épaissir","épargne","épatant","épaule","épicerie","épidémie","épier","épilogue","épine","épisode","épitaphe","époque","épreuve","éprouver","épuisant","équerre","équipe","ériger","érosion","erreur","éruption","escalier","espadon","espèce","espiègle","espoir","esprit","esquiver","essayer","essence","essieu","essorer","estime","estomac","estrade","étagère","étaler","étanche","étatique","éteindre","étendoir","éternel","éthanol","éthique","ethnie","étirer","étoffer","étoile","étonnant","étourdir","étrange","étroit","étude","euphorie","évaluer","évasion","éventail","évidence","éviter","évolutif","évoquer","exact","exagérer","exaucer","exceller","excitant","exclusif","excuse","exécuter","exemple","exercer","exhaler","exhorter","exigence","exiler","exister","exotique","expédier","explorer","exposer","exprimer","exquis","extensif","extraire","exulter","fable","fabuleux","facette","facile","facture","faiblir","falaise","fameux","famille","farceur","farfelu","farine","farouche","fasciner","fatal","fatigue","faucon","fautif","faveur","favori","fébrile","féconder","fédérer","félin","femme","fémur","fendoir","féodal","fermer","féroce","ferveur","festival","feuille","feutre","février","fiasco","ficeler","fictif","fidèle","figure","filature","filetage","filière","filleul","filmer","filou","filtrer","financer","finir","fiole","firme","fissure","fixer","flairer","flamme","flasque","flatteur","fléau","flèche","fleur","flexion","flocon","flore","fluctuer","fluide","fluvial","folie","fonderie","fongible","fontaine","forcer","forgeron","formuler","fortune","fossile","foudre","fougère","fouiller","foulure","fourmi","fragile","fraise","franchir","frapper","frayeur","frégate","freiner","frelon","frémir","frénésie","frère","friable","friction","frisson","frivole","froid","fromage","frontal","frotter","fruit","fugitif","fuite","fureur","furieux","furtif","fusion","futur","gagner","galaxie","galerie","gambader","garantir","gardien","garnir","garrigue","gazelle","gazon","géant","gélatine","gélule","gendarme","général","génie","genou","gentil","géologie","géomètre","géranium","germe","gestuel","geyser","gibier","gicler","girafe","givre","glace","glaive","glisser","globe","gloire","glorieux","golfeur","gomme","gonfler","gorge","gorille","goudron","gouffre","goulot","goupille","gourmand","goutte","graduel","graffiti","graine","grand","grappin","gratuit","gravir","grenat","griffure","griller","grimper","grogner","gronder","grotte","groupe","gruger","grutier","gruyère","guépard","guerrier","guide","guimauve","guitare","gustatif","gymnaste","gyrostat","habitude","hachoir","halte","hameau","hangar","hanneton","haricot","harmonie","harpon","hasard","hélium","hématome","herbe","hérisson","hermine","héron","hésiter","heureux","hiberner","hibou","hilarant","histoire","hiver","homard","hommage","homogène","honneur","honorer","honteux","horde","horizon","horloge","hormone","horrible","houleux","housse","hublot","huileux","humain","humble","humide","humour","hurler","hydromel","hygiène","hymne","hypnose","idylle","ignorer","iguane","illicite","illusion","image","imbiber","imiter","immense","immobile","immuable","impact","impérial","implorer","imposer","imprimer","imputer","incarner","incendie","incident","incliner","incolore","indexer","indice","inductif","inédit","ineptie","inexact","infini","infliger","informer","infusion","ingérer","inhaler","inhiber","injecter","injure","innocent","inoculer","inonder","inscrire","insecte","insigne","insolite","inspirer","instinct","insulter","intact","intense","intime","intrigue","intuitif","inutile","invasion","inventer","inviter","invoquer","ironique","irradier","irréel","irriter","isoler","ivoire","ivresse","jaguar","jaillir","jambe","janvier","jardin","jauger","jaune","javelot","jetable","jeton","jeudi","jeunesse","joindre","joncher","jongler","joueur","jouissif","journal","jovial","joyau","joyeux","jubiler","jugement","junior","jupon","juriste","justice","juteux","juvénile","kayak","kimono","kiosque","label","labial","labourer","lacérer","lactose","lagune","laine","laisser","laitier","lambeau","lamelle","lampe","lanceur","langage","lanterne","lapin","largeur","larme","laurier","lavabo","lavoir","lecture","légal","léger","légume","lessive","lettre","levier","lexique","lézard","liasse","libérer","libre","licence","licorne","liège","lièvre","ligature","ligoter","ligue","limer","limite","limonade","limpide","linéaire","lingot","lionceau","liquide","lisière","lister","lithium","litige","littoral","livreur","logique","lointain","loisir","lombric","loterie","louer","lourd","loutre","louve","loyal","lubie","lucide","lucratif","lueur","lugubre","luisant","lumière","lunaire","lundi","luron","lutter","luxueux","machine","magasin","magenta","magique","maigre","maillon","maintien","mairie","maison","majorer","malaxer","maléfice","malheur","malice","mallette","mammouth","mandater","maniable","manquant","manteau","manuel","marathon","marbre","marchand","mardi","maritime","marqueur","marron","marteler","mascotte","massif","matériel","matière","matraque","maudire","maussade","mauve","maximal","méchant","méconnu","médaille","médecin","méditer","méduse","meilleur","mélange","mélodie","membre","mémoire","menacer","mener","menhir","mensonge","mentor","mercredi","mérite","merle","messager","mesure","métal","météore","méthode","métier","meuble","miauler","microbe","miette","mignon","migrer","milieu","million","mimique","mince","minéral","minimal","minorer","minute","miracle","miroiter","missile","mixte","mobile","moderne","moelleux","mondial","moniteur","monnaie","monotone","monstre","montagne","monument","moqueur","morceau","morsure","mortier","moteur","motif","mouche","moufle","moulin","mousson","mouton","mouvant","multiple","munition","muraille","murène","murmure","muscle","muséum","musicien","mutation","muter","mutuel","myriade","myrtille","mystère","mythique","nageur","nappe","narquois","narrer","natation","nation","nature","naufrage","nautique","navire","nébuleux","nectar","néfaste","négation","négliger","négocier","neige","nerveux","nettoyer","neurone","neutron","neveu","niche","nickel","nitrate","niveau","noble","nocif","nocturne","noirceur","noisette","nomade","nombreux","nommer","normatif","notable","notifier","notoire","nourrir","nouveau","novateur","novembre","novice","nuage","nuancer","nuire","nuisible","numéro","nuptial","nuque","nutritif","obéir","objectif","obliger","obscur","observer","obstacle","obtenir","obturer","occasion","occuper","océan","octobre","octroyer","octupler","oculaire","odeur","odorant","offenser","officier","offrir","ogive","oiseau","oisillon","olfactif","olivier","ombrage","omettre","onctueux","onduler","onéreux","onirique","opale","opaque","opérer","opinion","opportun","opprimer","opter","optique","orageux","orange","orbite","ordonner","oreille","organe","orgueil","orifice","ornement","orque","ortie","osciller","osmose","ossature","otarie","ouragan","ourson","outil","outrager","ouvrage","ovation","oxyde","oxygène","ozone","paisible","palace","palmarès","palourde","palper","panache","panda","pangolin","paniquer","panneau","panorama","pantalon","papaye","papier","papoter","papyrus","paradoxe","parcelle","paresse","parfumer","parler","parole","parrain","parsemer","partager","parure","parvenir","passion","pastèque","paternel","patience","patron","pavillon","pavoiser","payer","paysage","peigne","peintre","pelage","pélican","pelle","pelouse","peluche","pendule","pénétrer","pénible","pensif","pénurie","pépite","péplum","perdrix","perforer","période","permuter","perplexe","persil","perte","peser","pétale","petit","pétrir","peuple","pharaon","phobie","phoque","photon","phrase","physique","piano","pictural","pièce","pierre","pieuvre","pilote","pinceau","pipette","piquer","pirogue","piscine","piston","pivoter","pixel","pizza","placard","plafond","plaisir","planer","plaque","plastron","plateau","pleurer","plexus","pliage","plomb","plonger","pluie","plumage","pochette","poésie","poète","pointe","poirier","poisson","poivre","polaire","policier","pollen","polygone","pommade","pompier","ponctuel","pondérer","poney","portique","position","posséder","posture","potager","poteau","potion","pouce","poulain","poumon","pourpre","poussin","pouvoir","prairie","pratique","précieux","prédire","préfixe","prélude","prénom","présence","prétexte","prévoir","primitif","prince","prison","priver","problème","procéder","prodige","profond","progrès","proie","projeter","prologue","promener","propre","prospère","protéger","prouesse","proverbe","prudence","pruneau","psychose","public","puceron","puiser","pulpe","pulsar","punaise","punitif","pupitre","purifier","puzzle","pyramide","quasar","querelle","question","quiétude","quitter","quotient","racine","raconter","radieux","ragondin","raideur","raisin","ralentir","rallonge","ramasser","rapide","rasage","ratisser","ravager","ravin","rayonner","réactif","réagir","réaliser","réanimer","recevoir","réciter","réclamer","récolter","recruter","reculer","recycler","rédiger","redouter","refaire","réflexe","réformer","refrain","refuge","régalien","région","réglage","régulier","réitérer","rejeter","rejouer","relatif","relever","relief","remarque","remède","remise","remonter","remplir","remuer","renard","renfort","renifler","renoncer","rentrer","renvoi","replier","reporter","reprise","reptile","requin","réserve","résineux","résoudre","respect","rester","résultat","rétablir","retenir","réticule","retomber","retracer","réunion","réussir","revanche","revivre","révolte","révulsif","richesse","rideau","rieur","rigide","rigoler","rincer","riposter","risible","risque","rituel","rival","rivière","rocheux","romance","rompre","ronce","rondin","roseau","rosier","rotatif","rotor","rotule","rouge","rouille","rouleau","routine","royaume","ruban","rubis","ruche","ruelle","rugueux","ruiner","ruisseau","ruser","rustique","rythme","sabler","saboter","sabre","sacoche","safari","sagesse","saisir","salade","salive","salon","saluer","samedi","sanction","sanglier","sarcasme","sardine","saturer","saugrenu","saumon","sauter","sauvage","savant","savonner","scalpel","scandale","scélérat","scénario","sceptre","schéma","science","scinder","score","scrutin","sculpter","séance","sécable","sécher","secouer","sécréter","sédatif","séduire","seigneur","séjour","sélectif","semaine","sembler","semence","séminal","sénateur","sensible","sentence","séparer","séquence","serein","sergent","sérieux","serrure","sérum","service","sésame","sévir","sevrage","sextuple","sidéral","siècle","siéger","siffler","sigle","signal","silence","silicium","simple","sincère","sinistre","siphon","sirop","sismique","situer","skier","social","socle","sodium","soigneux","soldat","soleil","solitude","soluble","sombre","sommeil","somnoler","sonde","songeur","sonnette","sonore","sorcier","sortir","sosie","sottise","soucieux","soudure","souffle","soulever","soupape","source","soutirer","souvenir","spacieux","spatial","spécial","sphère","spiral","stable","station","sternum","stimulus","stipuler","strict","studieux","stupeur","styliste","sublime","substrat","subtil","subvenir","succès","sucre","suffixe","suggérer","suiveur","sulfate","superbe","supplier","surface","suricate","surmener","surprise","sursaut","survie","suspect","syllabe","symbole","symétrie","synapse","syntaxe","système","tabac","tablier","tactile","tailler","talent","talisman","talonner","tambour","tamiser","tangible","tapis","taquiner","tarder","tarif","tartine","tasse","tatami","tatouage","taupe","taureau","taxer","témoin","temporel","tenaille","tendre","teneur","tenir","tension","terminer","terne","terrible","tétine","texte","thème","théorie","thérapie","thorax","tibia","tiède","timide","tirelire","tiroir","tissu","titane","titre","tituber","toboggan","tolérant","tomate","tonique","tonneau","toponyme","torche","tordre","tornade","torpille","torrent","torse","tortue","totem","toucher","tournage","tousser","toxine","traction","trafic","tragique","trahir","train","trancher","travail","trèfle","tremper","trésor","treuil","triage","tribunal","tricoter","trilogie","triomphe","tripler","triturer","trivial","trombone","tronc","tropical","troupeau","tuile","tulipe","tumulte","tunnel","turbine","tuteur","tutoyer","tuyau","tympan","typhon","typique","tyran","ubuesque","ultime","ultrason","unanime","unifier","union","unique","unitaire","univers","uranium","urbain","urticant","usage","usine","usuel","usure","utile","utopie","vacarme","vaccin","vagabond","vague","vaillant","vaincre","vaisseau","valable","valise","vallon","valve","vampire","vanille","vapeur","varier","vaseux","vassal","vaste","vecteur","vedette","végétal","véhicule","veinard","véloce","vendredi","vénérer","venger","venimeux","ventouse","verdure","vérin","vernir","verrou","verser","vertu","veston","vétéran","vétuste","vexant","vexer","viaduc","viande","victoire","vidange","vidéo","vignette","vigueur","vilain","village","vinaigre","violon","vipère","virement","virtuose","virus","visage","viseur","vision","visqueux","visuel","vital","vitesse","viticole","vitrine","vivace","vivipare","vocation","voguer","voile","voisin","voiture","volaille","volcan","voltiger","volume","vorace","vortex","voter","vouloir","voyage","voyelle","wagon","xénon","yacht","zèbre","zénith","zeste","zoologie"]');

/***/ }),

/***/ 2841:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('["abaco","abbaglio","abbinato","abete","abisso","abolire","abrasivo","abrogato","accadere","accenno","accusato","acetone","achille","acido","acqua","acre","acrilico","acrobata","acuto","adagio","addebito","addome","adeguato","aderire","adipe","adottare","adulare","affabile","affetto","affisso","affranto","aforisma","afoso","africano","agave","agente","agevole","aggancio","agire","agitare","agonismo","agricolo","agrumeto","aguzzo","alabarda","alato","albatro","alberato","albo","albume","alce","alcolico","alettone","alfa","algebra","aliante","alibi","alimento","allagato","allegro","allievo","allodola","allusivo","almeno","alogeno","alpaca","alpestre","altalena","alterno","alticcio","altrove","alunno","alveolo","alzare","amalgama","amanita","amarena","ambito","ambrato","ameba","america","ametista","amico","ammasso","ammenda","ammirare","ammonito","amore","ampio","ampliare","amuleto","anacardo","anagrafe","analista","anarchia","anatra","anca","ancella","ancora","andare","andrea","anello","angelo","angolare","angusto","anima","annegare","annidato","anno","annuncio","anonimo","anticipo","anzi","apatico","apertura","apode","apparire","appetito","appoggio","approdo","appunto","aprile","arabica","arachide","aragosta","araldica","arancio","aratura","arazzo","arbitro","archivio","ardito","arenile","argento","argine","arguto","aria","armonia","arnese","arredato","arringa","arrosto","arsenico","arso","artefice","arzillo","asciutto","ascolto","asepsi","asettico","asfalto","asino","asola","aspirato","aspro","assaggio","asse","assoluto","assurdo","asta","astenuto","astice","astratto","atavico","ateismo","atomico","atono","attesa","attivare","attorno","attrito","attuale","ausilio","austria","autista","autonomo","autunno","avanzato","avere","avvenire","avviso","avvolgere","azione","azoto","azzimo","azzurro","babele","baccano","bacino","baco","badessa","badilata","bagnato","baita","balcone","baldo","balena","ballata","balzano","bambino","bandire","baraonda","barbaro","barca","baritono","barlume","barocco","basilico","basso","batosta","battuto","baule","bava","bavosa","becco","beffa","belgio","belva","benda","benevole","benigno","benzina","bere","berlina","beta","bibita","bici","bidone","bifido","biga","bilancia","bimbo","binocolo","biologo","bipede","bipolare","birbante","birra","biscotto","bisesto","bisnonno","bisonte","bisturi","bizzarro","blando","blatta","bollito","bonifico","bordo","bosco","botanico","bottino","bozzolo","braccio","bradipo","brama","branca","bravura","bretella","brevetto","brezza","briglia","brillante","brindare","broccolo","brodo","bronzina","brullo","bruno","bubbone","buca","budino","buffone","buio","bulbo","buono","burlone","burrasca","bussola","busta","cadetto","caduco","calamaro","calcolo","calesse","calibro","calmo","caloria","cambusa","camerata","camicia","cammino","camola","campale","canapa","candela","cane","canino","canotto","cantina","capace","capello","capitolo","capogiro","cappero","capra","capsula","carapace","carcassa","cardo","carisma","carovana","carretto","cartolina","casaccio","cascata","caserma","caso","cassone","castello","casuale","catasta","catena","catrame","cauto","cavillo","cedibile","cedrata","cefalo","celebre","cellulare","cena","cenone","centesimo","ceramica","cercare","certo","cerume","cervello","cesoia","cespo","ceto","chela","chiaro","chicca","chiedere","chimera","china","chirurgo","chitarra","ciao","ciclismo","cifrare","cigno","cilindro","ciottolo","circa","cirrosi","citrico","cittadino","ciuffo","civetta","civile","classico","clinica","cloro","cocco","codardo","codice","coerente","cognome","collare","colmato","colore","colposo","coltivato","colza","coma","cometa","commando","comodo","computer","comune","conciso","condurre","conferma","congelare","coniuge","connesso","conoscere","consumo","continuo","convegno","coperto","copione","coppia","copricapo","corazza","cordata","coricato","cornice","corolla","corpo","corredo","corsia","cortese","cosmico","costante","cottura","covato","cratere","cravatta","creato","credere","cremoso","crescita","creta","criceto","crinale","crisi","critico","croce","cronaca","crostata","cruciale","crusca","cucire","cuculo","cugino","cullato","cupola","curatore","cursore","curvo","cuscino","custode","dado","daino","dalmata","damerino","daniela","dannoso","danzare","datato","davanti","davvero","debutto","decennio","deciso","declino","decollo","decreto","dedicato","definito","deforme","degno","delegare","delfino","delirio","delta","demenza","denotato","dentro","deposito","derapata","derivare","deroga","descritto","deserto","desiderio","desumere","detersivo","devoto","diametro","dicembre","diedro","difeso","diffuso","digerire","digitale","diluvio","dinamico","dinnanzi","dipinto","diploma","dipolo","diradare","dire","dirotto","dirupo","disagio","discreto","disfare","disgelo","disposto","distanza","disumano","dito","divano","divelto","dividere","divorato","doblone","docente","doganale","dogma","dolce","domato","domenica","dominare","dondolo","dono","dormire","dote","dottore","dovuto","dozzina","drago","druido","dubbio","dubitare","ducale","duna","duomo","duplice","duraturo","ebano","eccesso","ecco","eclissi","economia","edera","edicola","edile","editoria","educare","egemonia","egli","egoismo","egregio","elaborato","elargire","elegante","elencato","eletto","elevare","elfico","elica","elmo","elsa","eluso","emanato","emblema","emesso","emiro","emotivo","emozione","empirico","emulo","endemico","enduro","energia","enfasi","enoteca","entrare","enzima","epatite","epilogo","episodio","epocale","eppure","equatore","erario","erba","erboso","erede","eremita","erigere","ermetico","eroe","erosivo","errante","esagono","esame","esanime","esaudire","esca","esempio","esercito","esibito","esigente","esistere","esito","esofago","esortato","esoso","espanso","espresso","essenza","esso","esteso","estimare","estonia","estroso","esultare","etilico","etnico","etrusco","etto","euclideo","europa","evaso","evidenza","evitato","evoluto","evviva","fabbrica","faccenda","fachiro","falco","famiglia","fanale","fanfara","fango","fantasma","fare","farfalla","farinoso","farmaco","fascia","fastoso","fasullo","faticare","fato","favoloso","febbre","fecola","fede","fegato","felpa","feltro","femmina","fendere","fenomeno","fermento","ferro","fertile","fessura","festivo","fetta","feudo","fiaba","fiducia","fifa","figurato","filo","finanza","finestra","finire","fiore","fiscale","fisico","fiume","flacone","flamenco","flebo","flemma","florido","fluente","fluoro","fobico","focaccia","focoso","foderato","foglio","folata","folclore","folgore","fondente","fonetico","fonia","fontana","forbito","forchetta","foresta","formica","fornaio","foro","fortezza","forzare","fosfato","fosso","fracasso","frana","frassino","fratello","freccetta","frenata","fresco","frigo","frollino","fronde","frugale","frutta","fucilata","fucsia","fuggente","fulmine","fulvo","fumante","fumetto","fumoso","fune","funzione","fuoco","furbo","furgone","furore","fuso","futile","gabbiano","gaffe","galateo","gallina","galoppo","gambero","gamma","garanzia","garbo","garofano","garzone","gasdotto","gasolio","gastrico","gatto","gaudio","gazebo","gazzella","geco","gelatina","gelso","gemello","gemmato","gene","genitore","gennaio","genotipo","gergo","ghepardo","ghiaccio","ghisa","giallo","gilda","ginepro","giocare","gioiello","giorno","giove","girato","girone","gittata","giudizio","giurato","giusto","globulo","glutine","gnomo","gobba","golf","gomito","gommone","gonfio","gonna","governo","gracile","grado","grafico","grammo","grande","grattare","gravoso","grazia","greca","gregge","grifone","grigio","grinza","grotta","gruppo","guadagno","guaio","guanto","guardare","gufo","guidare","ibernato","icona","identico","idillio","idolo","idra","idrico","idrogeno","igiene","ignaro","ignorato","ilare","illeso","illogico","illudere","imballo","imbevuto","imbocco","imbuto","immane","immerso","immolato","impacco","impeto","impiego","importo","impronta","inalare","inarcare","inattivo","incanto","incendio","inchino","incisivo","incluso","incontro","incrocio","incubo","indagine","india","indole","inedito","infatti","infilare","inflitto","ingaggio","ingegno","inglese","ingordo","ingrosso","innesco","inodore","inoltrare","inondato","insano","insetto","insieme","insonnia","insulina","intasato","intero","intonaco","intuito","inumidire","invalido","invece","invito","iperbole","ipnotico","ipotesi","ippica","iride","irlanda","ironico","irrigato","irrorare","isolato","isotopo","isterico","istituto","istrice","italia","iterare","labbro","labirinto","lacca","lacerato","lacrima","lacuna","laddove","lago","lampo","lancetta","lanterna","lardoso","larga","laringe","lastra","latenza","latino","lattuga","lavagna","lavoro","legale","leggero","lembo","lentezza","lenza","leone","lepre","lesivo","lessato","lesto","letterale","leva","levigato","libero","lido","lievito","lilla","limatura","limitare","limpido","lineare","lingua","liquido","lira","lirica","lisca","lite","litigio","livrea","locanda","lode","logica","lombare","londra","longevo","loquace","lorenzo","loto","lotteria","luce","lucidato","lumaca","luminoso","lungo","lupo","luppolo","lusinga","lusso","lutto","macabro","macchina","macero","macinato","madama","magico","maglia","magnete","magro","maiolica","malafede","malgrado","malinteso","malsano","malto","malumore","mana","mancia","mandorla","mangiare","manifesto","mannaro","manovra","mansarda","mantide","manubrio","mappa","maratona","marcire","maretta","marmo","marsupio","maschera","massaia","mastino","materasso","matricola","mattone","maturo","mazurca","meandro","meccanico","mecenate","medesimo","meditare","mega","melassa","melis","melodia","meninge","meno","mensola","mercurio","merenda","merlo","meschino","mese","messere","mestolo","metallo","metodo","mettere","miagolare","mica","micelio","michele","microbo","midollo","miele","migliore","milano","milite","mimosa","minerale","mini","minore","mirino","mirtillo","miscela","missiva","misto","misurare","mitezza","mitigare","mitra","mittente","mnemonico","modello","modifica","modulo","mogano","mogio","mole","molosso","monastero","monco","mondina","monetario","monile","monotono","monsone","montato","monviso","mora","mordere","morsicato","mostro","motivato","motosega","motto","movenza","movimento","mozzo","mucca","mucosa","muffa","mughetto","mugnaio","mulatto","mulinello","multiplo","mummia","munto","muovere","murale","musa","muscolo","musica","mutevole","muto","nababbo","nafta","nanometro","narciso","narice","narrato","nascere","nastrare","naturale","nautica","naviglio","nebulosa","necrosi","negativo","negozio","nemmeno","neofita","neretto","nervo","nessuno","nettuno","neutrale","neve","nevrotico","nicchia","ninfa","nitido","nobile","nocivo","nodo","nome","nomina","nordico","normale","norvegese","nostrano","notare","notizia","notturno","novella","nucleo","nulla","numero","nuovo","nutrire","nuvola","nuziale","oasi","obbedire","obbligo","obelisco","oblio","obolo","obsoleto","occasione","occhio","occidente","occorrere","occultare","ocra","oculato","odierno","odorare","offerta","offrire","offuscato","oggetto","oggi","ognuno","olandese","olfatto","oliato","oliva","ologramma","oltre","omaggio","ombelico","ombra","omega","omissione","ondoso","onere","onice","onnivoro","onorevole","onta","operato","opinione","opposto","oracolo","orafo","ordine","orecchino","orefice","orfano","organico","origine","orizzonte","orma","ormeggio","ornativo","orologio","orrendo","orribile","ortensia","ortica","orzata","orzo","osare","oscurare","osmosi","ospedale","ospite","ossa","ossidare","ostacolo","oste","otite","otre","ottagono","ottimo","ottobre","ovale","ovest","ovino","oviparo","ovocito","ovunque","ovviare","ozio","pacchetto","pace","pacifico","padella","padrone","paese","paga","pagina","palazzina","palesare","pallido","palo","palude","pandoro","pannello","paolo","paonazzo","paprica","parabola","parcella","parere","pargolo","pari","parlato","parola","partire","parvenza","parziale","passivo","pasticca","patacca","patologia","pattume","pavone","peccato","pedalare","pedonale","peggio","peloso","penare","pendice","penisola","pennuto","penombra","pensare","pentola","pepe","pepita","perbene","percorso","perdonato","perforare","pergamena","periodo","permesso","perno","perplesso","persuaso","pertugio","pervaso","pesatore","pesista","peso","pestifero","petalo","pettine","petulante","pezzo","piacere","pianta","piattino","piccino","picozza","piega","pietra","piffero","pigiama","pigolio","pigro","pila","pilifero","pillola","pilota","pimpante","pineta","pinna","pinolo","pioggia","piombo","piramide","piretico","pirite","pirolisi","pitone","pizzico","placebo","planare","plasma","platano","plenario","pochezza","poderoso","podismo","poesia","poggiare","polenta","poligono","pollice","polmonite","polpetta","polso","poltrona","polvere","pomice","pomodoro","ponte","popoloso","porfido","poroso","porpora","porre","portata","posa","positivo","possesso","postulato","potassio","potere","pranzo","prassi","pratica","precluso","predica","prefisso","pregiato","prelievo","premere","prenotare","preparato","presenza","pretesto","prevalso","prima","principe","privato","problema","procura","produrre","profumo","progetto","prolunga","promessa","pronome","proposta","proroga","proteso","prova","prudente","prugna","prurito","psiche","pubblico","pudica","pugilato","pugno","pulce","pulito","pulsante","puntare","pupazzo","pupilla","puro","quadro","qualcosa","quasi","querela","quota","raccolto","raddoppio","radicale","radunato","raffica","ragazzo","ragione","ragno","ramarro","ramingo","ramo","randagio","rantolare","rapato","rapina","rappreso","rasatura","raschiato","rasente","rassegna","rastrello","rata","ravveduto","reale","recepire","recinto","recluta","recondito","recupero","reddito","redimere","regalato","registro","regola","regresso","relazione","remare","remoto","renna","replica","reprimere","reputare","resa","residente","responso","restauro","rete","retina","retorica","rettifica","revocato","riassunto","ribadire","ribelle","ribrezzo","ricarica","ricco","ricevere","riciclato","ricordo","ricreduto","ridicolo","ridurre","rifasare","riflesso","riforma","rifugio","rigare","rigettato","righello","rilassato","rilevato","rimanere","rimbalzo","rimedio","rimorchio","rinascita","rincaro","rinforzo","rinnovo","rinomato","rinsavito","rintocco","rinuncia","rinvenire","riparato","ripetuto","ripieno","riportare","ripresa","ripulire","risata","rischio","riserva","risibile","riso","rispetto","ristoro","risultato","risvolto","ritardo","ritegno","ritmico","ritrovo","riunione","riva","riverso","rivincita","rivolto","rizoma","roba","robotico","robusto","roccia","roco","rodaggio","rodere","roditore","rogito","rollio","romantico","rompere","ronzio","rosolare","rospo","rotante","rotondo","rotula","rovescio","rubizzo","rubrica","ruga","rullino","rumine","rumoroso","ruolo","rupe","russare","rustico","sabato","sabbiare","sabotato","sagoma","salasso","saldatura","salgemma","salivare","salmone","salone","saltare","saluto","salvo","sapere","sapido","saporito","saraceno","sarcasmo","sarto","sassoso","satellite","satira","satollo","saturno","savana","savio","saziato","sbadiglio","sbalzo","sbancato","sbarra","sbattere","sbavare","sbendare","sbirciare","sbloccato","sbocciato","sbrinare","sbruffone","sbuffare","scabroso","scadenza","scala","scambiare","scandalo","scapola","scarso","scatenare","scavato","scelto","scenico","scettro","scheda","schiena","sciarpa","scienza","scindere","scippo","sciroppo","scivolo","sclerare","scodella","scolpito","scomparto","sconforto","scoprire","scorta","scossone","scozzese","scriba","scrollare","scrutinio","scuderia","scultore","scuola","scuro","scusare","sdebitare","sdoganare","seccatura","secondo","sedano","seggiola","segnalato","segregato","seguito","selciato","selettivo","sella","selvaggio","semaforo","sembrare","seme","seminato","sempre","senso","sentire","sepolto","sequenza","serata","serbato","sereno","serio","serpente","serraglio","servire","sestina","setola","settimana","sfacelo","sfaldare","sfamato","sfarzoso","sfaticato","sfera","sfida","sfilato","sfinge","sfocato","sfoderare","sfogo","sfoltire","sforzato","sfratto","sfruttato","sfuggito","sfumare","sfuso","sgabello","sgarbato","sgonfiare","sgorbio","sgrassato","sguardo","sibilo","siccome","sierra","sigla","signore","silenzio","sillaba","simbolo","simpatico","simulato","sinfonia","singolo","sinistro","sino","sintesi","sinusoide","sipario","sisma","sistole","situato","slitta","slogatura","sloveno","smarrito","smemorato","smentito","smeraldo","smilzo","smontare","smottato","smussato","snellire","snervato","snodo","sobbalzo","sobrio","soccorso","sociale","sodale","soffitto","sogno","soldato","solenne","solido","sollazzo","solo","solubile","solvente","somatico","somma","sonda","sonetto","sonnifero","sopire","soppeso","sopra","sorgere","sorpasso","sorriso","sorso","sorteggio","sorvolato","sospiro","sosta","sottile","spada","spalla","spargere","spatola","spavento","spazzola","specie","spedire","spegnere","spelatura","speranza","spessore","spettrale","spezzato","spia","spigoloso","spillato","spinoso","spirale","splendido","sportivo","sposo","spranga","sprecare","spronato","spruzzo","spuntino","squillo","sradicare","srotolato","stabile","stacco","staffa","stagnare","stampato","stantio","starnuto","stasera","statuto","stelo","steppa","sterzo","stiletto","stima","stirpe","stivale","stizzoso","stonato","storico","strappo","stregato","stridulo","strozzare","strutto","stuccare","stufo","stupendo","subentro","succoso","sudore","suggerito","sugo","sultano","suonare","superbo","supporto","surgelato","surrogato","sussurro","sutura","svagare","svedese","sveglio","svelare","svenuto","svezia","sviluppo","svista","svizzera","svolta","svuotare","tabacco","tabulato","tacciare","taciturno","tale","talismano","tampone","tannino","tara","tardivo","targato","tariffa","tarpare","tartaruga","tasto","tattico","taverna","tavolata","tazza","teca","tecnico","telefono","temerario","tempo","temuto","tendone","tenero","tensione","tentacolo","teorema","terme","terrazzo","terzetto","tesi","tesserato","testato","tetro","tettoia","tifare","tigella","timbro","tinto","tipico","tipografo","tiraggio","tiro","titanio","titolo","titubante","tizio","tizzone","toccare","tollerare","tolto","tombola","tomo","tonfo","tonsilla","topazio","topologia","toppa","torba","tornare","torrone","tortora","toscano","tossire","tostatura","totano","trabocco","trachea","trafila","tragedia","tralcio","tramonto","transito","trapano","trarre","trasloco","trattato","trave","treccia","tremolio","trespolo","tributo","tricheco","trifoglio","trillo","trincea","trio","tristezza","triturato","trivella","tromba","trono","troppo","trottola","trovare","truccato","tubatura","tuffato","tulipano","tumulto","tunisia","turbare","turchino","tuta","tutela","ubicato","uccello","uccisore","udire","uditivo","uffa","ufficio","uguale","ulisse","ultimato","umano","umile","umorismo","uncinetto","ungere","ungherese","unicorno","unificato","unisono","unitario","unte","uovo","upupa","uragano","urgenza","urlo","usanza","usato","uscito","usignolo","usuraio","utensile","utilizzo","utopia","vacante","vaccinato","vagabondo","vagliato","valanga","valgo","valico","valletta","valoroso","valutare","valvola","vampata","vangare","vanitoso","vano","vantaggio","vanvera","vapore","varano","varcato","variante","vasca","vedetta","vedova","veduto","vegetale","veicolo","velcro","velina","velluto","veloce","venato","vendemmia","vento","verace","verbale","vergogna","verifica","vero","verruca","verticale","vescica","vessillo","vestale","veterano","vetrina","vetusto","viandante","vibrante","vicenda","vichingo","vicinanza","vidimare","vigilia","vigneto","vigore","vile","villano","vimini","vincitore","viola","vipera","virgola","virologo","virulento","viscoso","visione","vispo","vissuto","visura","vita","vitello","vittima","vivanda","vivido","viziare","voce","voga","volatile","volere","volpe","voragine","vulcano","zampogna","zanna","zappato","zattera","zavorra","zefiro","zelante","zelo","zenzero","zerbino","zibetto","zinco","zircone","zitto","zolla","zotico","zucchero","zufolo","zulu","zuppa"]');

/***/ }),

/***/ 4472:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('["あいこくしん","あいさつ","あいだ","あおぞら","あかちゃん","あきる","あけがた","あける","あこがれる","あさい","あさひ","あしあと","あじわう","あずかる","あずき","あそぶ","あたえる","あたためる","あたりまえ","あたる","あつい","あつかう","あっしゅく","あつまり","あつめる","あてな","あてはまる","あひる","あぶら","あぶる","あふれる","あまい","あまど","あまやかす","あまり","あみもの","あめりか","あやまる","あゆむ","あらいぐま","あらし","あらすじ","あらためる","あらゆる","あらわす","ありがとう","あわせる","あわてる","あんい","あんがい","あんこ","あんぜん","あんてい","あんない","あんまり","いいだす","いおん","いがい","いがく","いきおい","いきなり","いきもの","いきる","いくじ","いくぶん","いけばな","いけん","いこう","いこく","いこつ","いさましい","いさん","いしき","いじゅう","いじょう","いじわる","いずみ","いずれ","いせい","いせえび","いせかい","いせき","いぜん","いそうろう","いそがしい","いだい","いだく","いたずら","いたみ","いたりあ","いちおう","いちじ","いちど","いちば","いちぶ","いちりゅう","いつか","いっしゅん","いっせい","いっそう","いったん","いっち","いってい","いっぽう","いてざ","いてん","いどう","いとこ","いない","いなか","いねむり","いのち","いのる","いはつ","いばる","いはん","いびき","いひん","いふく","いへん","いほう","いみん","いもうと","いもたれ","いもり","いやがる","いやす","いよかん","いよく","いらい","いらすと","いりぐち","いりょう","いれい","いれもの","いれる","いろえんぴつ","いわい","いわう","いわかん","いわば","いわゆる","いんげんまめ","いんさつ","いんしょう","いんよう","うえき","うえる","うおざ","うがい","うかぶ","うかべる","うきわ","うくらいな","うくれれ","うけたまわる","うけつけ","うけとる","うけもつ","うける","うごかす","うごく","うこん","うさぎ","うしなう","うしろがみ","うすい","うすぎ","うすぐらい","うすめる","うせつ","うちあわせ","うちがわ","うちき","うちゅう","うっかり","うつくしい","うったえる","うつる","うどん","うなぎ","うなじ","うなずく","うなる","うねる","うのう","うぶげ","うぶごえ","うまれる","うめる","うもう","うやまう","うよく","うらがえす","うらぐち","うらない","うりあげ","うりきれ","うるさい","うれしい","うれゆき","うれる","うろこ","うわき","うわさ","うんこう","うんちん","うんてん","うんどう","えいえん","えいが","えいきょう","えいご","えいせい","えいぶん","えいよう","えいわ","えおり","えがお","えがく","えきたい","えくせる","えしゃく","えすて","えつらん","えのぐ","えほうまき","えほん","えまき","えもじ","えもの","えらい","えらぶ","えりあ","えんえん","えんかい","えんぎ","えんげき","えんしゅう","えんぜつ","えんそく","えんちょう","えんとつ","おいかける","おいこす","おいしい","おいつく","おうえん","おうさま","おうじ","おうせつ","おうたい","おうふく","おうべい","おうよう","おえる","おおい","おおう","おおどおり","おおや","おおよそ","おかえり","おかず","おがむ","おかわり","おぎなう","おきる","おくさま","おくじょう","おくりがな","おくる","おくれる","おこす","おこなう","おこる","おさえる","おさない","おさめる","おしいれ","おしえる","おじぎ","おじさん","おしゃれ","おそらく","おそわる","おたがい","おたく","おだやか","おちつく","おっと","おつり","おでかけ","おとしもの","おとなしい","おどり","おどろかす","おばさん","おまいり","おめでとう","おもいで","おもう","おもたい","おもちゃ","おやつ","おやゆび","およぼす","おらんだ","おろす","おんがく","おんけい","おんしゃ","おんせん","おんだん","おんちゅう","おんどけい","かあつ","かいが","がいき","がいけん","がいこう","かいさつ","かいしゃ","かいすいよく","かいぜん","かいぞうど","かいつう","かいてん","かいとう","かいふく","がいへき","かいほう","かいよう","がいらい","かいわ","かえる","かおり","かかえる","かがく","かがし","かがみ","かくご","かくとく","かざる","がぞう","かたい","かたち","がちょう","がっきゅう","がっこう","がっさん","がっしょう","かなざわし","かのう","がはく","かぶか","かほう","かほご","かまう","かまぼこ","かめれおん","かゆい","かようび","からい","かるい","かろう","かわく","かわら","がんか","かんけい","かんこう","かんしゃ","かんそう","かんたん","かんち","がんばる","きあい","きあつ","きいろ","ぎいん","きうい","きうん","きえる","きおう","きおく","きおち","きおん","きかい","きかく","きかんしゃ","ききて","きくばり","きくらげ","きけんせい","きこう","きこえる","きこく","きさい","きさく","きさま","きさらぎ","ぎじかがく","ぎしき","ぎじたいけん","ぎじにってい","ぎじゅつしゃ","きすう","きせい","きせき","きせつ","きそう","きぞく","きぞん","きたえる","きちょう","きつえん","ぎっちり","きつつき","きつね","きてい","きどう","きどく","きない","きなが","きなこ","きぬごし","きねん","きのう","きのした","きはく","きびしい","きひん","きふく","きぶん","きぼう","きほん","きまる","きみつ","きむずかしい","きめる","きもだめし","きもち","きもの","きゃく","きやく","ぎゅうにく","きよう","きょうりゅう","きらい","きらく","きりん","きれい","きれつ","きろく","ぎろん","きわめる","ぎんいろ","きんかくじ","きんじょ","きんようび","ぐあい","くいず","くうかん","くうき","くうぐん","くうこう","ぐうせい","くうそう","ぐうたら","くうふく","くうぼ","くかん","くきょう","くげん","ぐこう","くさい","くさき","くさばな","くさる","くしゃみ","くしょう","くすのき","くすりゆび","くせげ","くせん","ぐたいてき","くださる","くたびれる","くちこみ","くちさき","くつした","ぐっすり","くつろぐ","くとうてん","くどく","くなん","くねくね","くのう","くふう","くみあわせ","くみたてる","くめる","くやくしょ","くらす","くらべる","くるま","くれる","くろう","くわしい","ぐんかん","ぐんしょく","ぐんたい","ぐんて","けあな","けいかく","けいけん","けいこ","けいさつ","げいじゅつ","けいたい","げいのうじん","けいれき","けいろ","けおとす","けおりもの","げきか","げきげん","げきだん","げきちん","げきとつ","げきは","げきやく","げこう","げこくじょう","げざい","けさき","げざん","けしき","けしごむ","けしょう","げすと","けたば","けちゃっぷ","けちらす","けつあつ","けつい","けつえき","けっこん","けつじょ","けっせき","けってい","けつまつ","げつようび","げつれい","けつろん","げどく","けとばす","けとる","けなげ","けなす","けなみ","けぬき","げねつ","けねん","けはい","げひん","けぶかい","げぼく","けまり","けみかる","けむし","けむり","けもの","けらい","けろけろ","けわしい","けんい","けんえつ","けんお","けんか","げんき","けんげん","けんこう","けんさく","けんしゅう","けんすう","げんそう","けんちく","けんてい","けんとう","けんない","けんにん","げんぶつ","けんま","けんみん","けんめい","けんらん","けんり","こあくま","こいぬ","こいびと","ごうい","こうえん","こうおん","こうかん","ごうきゅう","ごうけい","こうこう","こうさい","こうじ","こうすい","ごうせい","こうそく","こうたい","こうちゃ","こうつう","こうてい","こうどう","こうない","こうはい","ごうほう","ごうまん","こうもく","こうりつ","こえる","こおり","ごかい","ごがつ","ごかん","こくご","こくさい","こくとう","こくない","こくはく","こぐま","こけい","こける","ここのか","こころ","こさめ","こしつ","こすう","こせい","こせき","こぜん","こそだて","こたい","こたえる","こたつ","こちょう","こっか","こつこつ","こつばん","こつぶ","こてい","こてん","ことがら","ことし","ことば","ことり","こなごな","こねこね","このまま","このみ","このよ","ごはん","こひつじ","こふう","こふん","こぼれる","ごまあぶら","こまかい","ごますり","こまつな","こまる","こむぎこ","こもじ","こもち","こもの","こもん","こやく","こやま","こゆう","こゆび","こよい","こよう","こりる","これくしょん","ころっけ","こわもて","こわれる","こんいん","こんかい","こんき","こんしゅう","こんすい","こんだて","こんとん","こんなん","こんびに","こんぽん","こんまけ","こんや","こんれい","こんわく","ざいえき","さいかい","さいきん","ざいげん","ざいこ","さいしょ","さいせい","ざいたく","ざいちゅう","さいてき","ざいりょう","さうな","さかいし","さがす","さかな","さかみち","さがる","さぎょう","さくし","さくひん","さくら","さこく","さこつ","さずかる","ざせき","さたん","さつえい","ざつおん","ざっか","ざつがく","さっきょく","ざっし","さつじん","ざっそう","さつたば","さつまいも","さてい","さといも","さとう","さとおや","さとし","さとる","さのう","さばく","さびしい","さべつ","さほう","さほど","さます","さみしい","さみだれ","さむけ","さめる","さやえんどう","さゆう","さよう","さよく","さらだ","ざるそば","さわやか","さわる","さんいん","さんか","さんきゃく","さんこう","さんさい","ざんしょ","さんすう","さんせい","さんそ","さんち","さんま","さんみ","さんらん","しあい","しあげ","しあさって","しあわせ","しいく","しいん","しうち","しえい","しおけ","しかい","しかく","じかん","しごと","しすう","じだい","したうけ","したぎ","したて","したみ","しちょう","しちりん","しっかり","しつじ","しつもん","してい","してき","してつ","じてん","じどう","しなぎれ","しなもの","しなん","しねま","しねん","しのぐ","しのぶ","しはい","しばかり","しはつ","しはらい","しはん","しひょう","しふく","じぶん","しへい","しほう","しほん","しまう","しまる","しみん","しむける","じむしょ","しめい","しめる","しもん","しゃいん","しゃうん","しゃおん","じゃがいも","しやくしょ","しゃくほう","しゃけん","しゃこ","しゃざい","しゃしん","しゃせん","しゃそう","しゃたい","しゃちょう","しゃっきん","じゃま","しゃりん","しゃれい","じゆう","じゅうしょ","しゅくはく","じゅしん","しゅっせき","しゅみ","しゅらば","じゅんばん","しょうかい","しょくたく","しょっけん","しょどう","しょもつ","しらせる","しらべる","しんか","しんこう","じんじゃ","しんせいじ","しんちく","しんりん","すあげ","すあし","すあな","ずあん","すいえい","すいか","すいとう","ずいぶん","すいようび","すうがく","すうじつ","すうせん","すおどり","すきま","すくう","すくない","すける","すごい","すこし","ずさん","すずしい","すすむ","すすめる","すっかり","ずっしり","ずっと","すてき","すてる","すねる","すのこ","すはだ","すばらしい","ずひょう","ずぶぬれ","すぶり","すふれ","すべて","すべる","ずほう","すぼん","すまい","すめし","すもう","すやき","すらすら","するめ","すれちがう","すろっと","すわる","すんぜん","すんぽう","せあぶら","せいかつ","せいげん","せいじ","せいよう","せおう","せかいかん","せきにん","せきむ","せきゆ","せきらんうん","せけん","せこう","せすじ","せたい","せたけ","せっかく","せっきゃく","ぜっく","せっけん","せっこつ","せっさたくま","せつぞく","せつだん","せつでん","せっぱん","せつび","せつぶん","せつめい","せつりつ","せなか","せのび","せはば","せびろ","せぼね","せまい","せまる","せめる","せもたれ","せりふ","ぜんあく","せんい","せんえい","せんか","せんきょ","せんく","せんげん","ぜんご","せんさい","せんしゅ","せんすい","せんせい","せんぞ","せんたく","せんちょう","せんてい","せんとう","せんぬき","せんねん","せんぱい","ぜんぶ","ぜんぽう","せんむ","せんめんじょ","せんもん","せんやく","せんゆう","せんよう","ぜんら","ぜんりゃく","せんれい","せんろ","そあく","そいとげる","そいね","そうがんきょう","そうき","そうご","そうしん","そうだん","そうなん","そうび","そうめん","そうり","そえもの","そえん","そがい","そげき","そこう","そこそこ","そざい","そしな","そせい","そせん","そそぐ","そだてる","そつう","そつえん","そっかん","そつぎょう","そっけつ","そっこう","そっせん","そっと","そとがわ","そとづら","そなえる","そなた","そふぼ","そぼく","そぼろ","そまつ","そまる","そむく","そむりえ","そめる","そもそも","そよかぜ","そらまめ","そろう","そんかい","そんけい","そんざい","そんしつ","そんぞく","そんちょう","ぞんび","ぞんぶん","そんみん","たあい","たいいん","たいうん","たいえき","たいおう","だいがく","たいき","たいぐう","たいけん","たいこ","たいざい","だいじょうぶ","だいすき","たいせつ","たいそう","だいたい","たいちょう","たいてい","だいどころ","たいない","たいねつ","たいのう","たいはん","だいひょう","たいふう","たいへん","たいほ","たいまつばな","たいみんぐ","たいむ","たいめん","たいやき","たいよう","たいら","たいりょく","たいる","たいわん","たうえ","たえる","たおす","たおる","たおれる","たかい","たかね","たきび","たくさん","たこく","たこやき","たさい","たしざん","だじゃれ","たすける","たずさわる","たそがれ","たたかう","たたく","ただしい","たたみ","たちばな","だっかい","だっきゃく","だっこ","だっしゅつ","だったい","たてる","たとえる","たなばた","たにん","たぬき","たのしみ","たはつ","たぶん","たべる","たぼう","たまご","たまる","だむる","ためいき","ためす","ためる","たもつ","たやすい","たよる","たらす","たりきほんがん","たりょう","たりる","たると","たれる","たれんと","たろっと","たわむれる","だんあつ","たんい","たんおん","たんか","たんき","たんけん","たんご","たんさん","たんじょうび","だんせい","たんそく","たんたい","だんち","たんてい","たんとう","だんな","たんにん","だんねつ","たんのう","たんぴん","だんぼう","たんまつ","たんめい","だんれつ","だんろ","だんわ","ちあい","ちあん","ちいき","ちいさい","ちえん","ちかい","ちから","ちきゅう","ちきん","ちけいず","ちけん","ちこく","ちさい","ちしき","ちしりょう","ちせい","ちそう","ちたい","ちたん","ちちおや","ちつじょ","ちてき","ちてん","ちぬき","ちぬり","ちのう","ちひょう","ちへいせん","ちほう","ちまた","ちみつ","ちみどろ","ちめいど","ちゃんこなべ","ちゅうい","ちゆりょく","ちょうし","ちょさくけん","ちらし","ちらみ","ちりがみ","ちりょう","ちるど","ちわわ","ちんたい","ちんもく","ついか","ついたち","つうか","つうじょう","つうはん","つうわ","つかう","つかれる","つくね","つくる","つけね","つける","つごう","つたえる","つづく","つつじ","つつむ","つとめる","つながる","つなみ","つねづね","つのる","つぶす","つまらない","つまる","つみき","つめたい","つもり","つもる","つよい","つるぼ","つるみく","つわもの","つわり","てあし","てあて","てあみ","ていおん","ていか","ていき","ていけい","ていこく","ていさつ","ていし","ていせい","ていたい","ていど","ていねい","ていひょう","ていへん","ていぼう","てうち","ておくれ","てきとう","てくび","でこぼこ","てさぎょう","てさげ","てすり","てそう","てちがい","てちょう","てつがく","てつづき","でっぱ","てつぼう","てつや","でぬかえ","てぬき","てぬぐい","てのひら","てはい","てぶくろ","てふだ","てほどき","てほん","てまえ","てまきずし","てみじか","てみやげ","てらす","てれび","てわけ","てわたし","でんあつ","てんいん","てんかい","てんき","てんぐ","てんけん","てんごく","てんさい","てんし","てんすう","でんち","てんてき","てんとう","てんない","てんぷら","てんぼうだい","てんめつ","てんらんかい","でんりょく","でんわ","どあい","といれ","どうかん","とうきゅう","どうぐ","とうし","とうむぎ","とおい","とおか","とおく","とおす","とおる","とかい","とかす","ときおり","ときどき","とくい","とくしゅう","とくてん","とくに","とくべつ","とけい","とける","とこや","とさか","としょかん","とそう","とたん","とちゅう","とっきゅう","とっくん","とつぜん","とつにゅう","とどける","ととのえる","とない","となえる","となり","とのさま","とばす","どぶがわ","とほう","とまる","とめる","ともだち","ともる","どようび","とらえる","とんかつ","どんぶり","ないかく","ないこう","ないしょ","ないす","ないせん","ないそう","なおす","ながい","なくす","なげる","なこうど","なさけ","なたでここ","なっとう","なつやすみ","ななおし","なにごと","なにもの","なにわ","なのか","なふだ","なまいき","なまえ","なまみ","なみだ","なめらか","なめる","なやむ","ならう","ならび","ならぶ","なれる","なわとび","なわばり","にあう","にいがた","にうけ","におい","にかい","にがて","にきび","にくしみ","にくまん","にげる","にさんかたんそ","にしき","にせもの","にちじょう","にちようび","にっか","にっき","にっけい","にっこう","にっさん","にっしょく","にっすう","にっせき","にってい","になう","にほん","にまめ","にもつ","にやり","にゅういん","にりんしゃ","にわとり","にんい","にんか","にんき","にんげん","にんしき","にんずう","にんそう","にんたい","にんち","にんてい","にんにく","にんぷ","にんまり","にんむ","にんめい","にんよう","ぬいくぎ","ぬかす","ぬぐいとる","ぬぐう","ぬくもり","ぬすむ","ぬまえび","ぬめり","ぬらす","ぬんちゃく","ねあげ","ねいき","ねいる","ねいろ","ねぐせ","ねくたい","ねくら","ねこぜ","ねこむ","ねさげ","ねすごす","ねそべる","ねだん","ねつい","ねっしん","ねつぞう","ねったいぎょ","ねぶそく","ねふだ","ねぼう","ねほりはほり","ねまき","ねまわし","ねみみ","ねむい","ねむたい","ねもと","ねらう","ねわざ","ねんいり","ねんおし","ねんかん","ねんきん","ねんぐ","ねんざ","ねんし","ねんちゃく","ねんど","ねんぴ","ねんぶつ","ねんまつ","ねんりょう","ねんれい","のいず","のおづま","のがす","のきなみ","のこぎり","のこす","のこる","のせる","のぞく","のぞむ","のたまう","のちほど","のっく","のばす","のはら","のべる","のぼる","のみもの","のやま","のらいぬ","のらねこ","のりもの","のりゆき","のれん","のんき","ばあい","はあく","ばあさん","ばいか","ばいく","はいけん","はいご","はいしん","はいすい","はいせん","はいそう","はいち","ばいばい","はいれつ","はえる","はおる","はかい","ばかり","はかる","はくしゅ","はけん","はこぶ","はさみ","はさん","はしご","ばしょ","はしる","はせる","ぱそこん","はそん","はたん","はちみつ","はつおん","はっかく","はづき","はっきり","はっくつ","はっけん","はっこう","はっさん","はっしん","はったつ","はっちゅう","はってん","はっぴょう","はっぽう","はなす","はなび","はにかむ","はぶらし","はみがき","はむかう","はめつ","はやい","はやし","はらう","はろうぃん","はわい","はんい","はんえい","はんおん","はんかく","はんきょう","ばんぐみ","はんこ","はんしゃ","はんすう","はんだん","ぱんち","ぱんつ","はんてい","はんとし","はんのう","はんぱ","はんぶん","はんぺん","はんぼうき","はんめい","はんらん","はんろん","ひいき","ひうん","ひえる","ひかく","ひかり","ひかる","ひかん","ひくい","ひけつ","ひこうき","ひこく","ひさい","ひさしぶり","ひさん","びじゅつかん","ひしょ","ひそか","ひそむ","ひたむき","ひだり","ひたる","ひつぎ","ひっこし","ひっし","ひつじゅひん","ひっす","ひつぜん","ぴったり","ぴっちり","ひつよう","ひてい","ひとごみ","ひなまつり","ひなん","ひねる","ひはん","ひびく","ひひょう","ひほう","ひまわり","ひまん","ひみつ","ひめい","ひめじし","ひやけ","ひやす","ひよう","びょうき","ひらがな","ひらく","ひりつ","ひりょう","ひるま","ひるやすみ","ひれい","ひろい","ひろう","ひろき","ひろゆき","ひんかく","ひんけつ","ひんこん","ひんしゅ","ひんそう","ぴんち","ひんぱん","びんぼう","ふあん","ふいうち","ふうけい","ふうせん","ぷうたろう","ふうとう","ふうふ","ふえる","ふおん","ふかい","ふきん","ふくざつ","ふくぶくろ","ふこう","ふさい","ふしぎ","ふじみ","ふすま","ふせい","ふせぐ","ふそく","ぶたにく","ふたん","ふちょう","ふつう","ふつか","ふっかつ","ふっき","ふっこく","ぶどう","ふとる","ふとん","ふのう","ふはい","ふひょう","ふへん","ふまん","ふみん","ふめつ","ふめん","ふよう","ふりこ","ふりる","ふるい","ふんいき","ぶんがく","ぶんぐ","ふんしつ","ぶんせき","ふんそう","ぶんぽう","へいあん","へいおん","へいがい","へいき","へいげん","へいこう","へいさ","へいしゃ","へいせつ","へいそ","へいたく","へいてん","へいねつ","へいわ","へきが","へこむ","べにいろ","べにしょうが","へらす","へんかん","べんきょう","べんごし","へんさい","へんたい","べんり","ほあん","ほいく","ぼうぎょ","ほうこく","ほうそう","ほうほう","ほうもん","ほうりつ","ほえる","ほおん","ほかん","ほきょう","ぼきん","ほくろ","ほけつ","ほけん","ほこう","ほこる","ほしい","ほしつ","ほしゅ","ほしょう","ほせい","ほそい","ほそく","ほたて","ほたる","ぽちぶくろ","ほっきょく","ほっさ","ほったん","ほとんど","ほめる","ほんい","ほんき","ほんけ","ほんしつ","ほんやく","まいにち","まかい","まかせる","まがる","まける","まこと","まさつ","まじめ","ますく","まぜる","まつり","まとめ","まなぶ","まぬけ","まねく","まほう","まもる","まゆげ","まよう","まろやか","まわす","まわり","まわる","まんが","まんきつ","まんぞく","まんなか","みいら","みうち","みえる","みがく","みかた","みかん","みけん","みこん","みじかい","みすい","みすえる","みせる","みっか","みつかる","みつける","みてい","みとめる","みなと","みなみかさい","みねらる","みのう","みのがす","みほん","みもと","みやげ","みらい","みりょく","みわく","みんか","みんぞく","むいか","むえき","むえん","むかい","むかう","むかえ","むかし","むぎちゃ","むける","むげん","むさぼる","むしあつい","むしば","むじゅん","むしろ","むすう","むすこ","むすぶ","むすめ","むせる","むせん","むちゅう","むなしい","むのう","むやみ","むよう","むらさき","むりょう","むろん","めいあん","めいうん","めいえん","めいかく","めいきょく","めいさい","めいし","めいそう","めいぶつ","めいれい","めいわく","めぐまれる","めざす","めした","めずらしい","めだつ","めまい","めやす","めんきょ","めんせき","めんどう","もうしあげる","もうどうけん","もえる","もくし","もくてき","もくようび","もちろん","もどる","もらう","もんく","もんだい","やおや","やける","やさい","やさしい","やすい","やすたろう","やすみ","やせる","やそう","やたい","やちん","やっと","やっぱり","やぶる","やめる","ややこしい","やよい","やわらかい","ゆうき","ゆうびんきょく","ゆうべ","ゆうめい","ゆけつ","ゆしゅつ","ゆせん","ゆそう","ゆたか","ゆちゃく","ゆでる","ゆにゅう","ゆびわ","ゆらい","ゆれる","ようい","ようか","ようきゅう","ようじ","ようす","ようちえん","よかぜ","よかん","よきん","よくせい","よくぼう","よけい","よごれる","よさん","よしゅう","よそう","よそく","よっか","よてい","よどがわく","よねつ","よやく","よゆう","よろこぶ","よろしい","らいう","らくがき","らくご","らくさつ","らくだ","らしんばん","らせん","らぞく","らたい","らっか","られつ","りえき","りかい","りきさく","りきせつ","りくぐん","りくつ","りけん","りこう","りせい","りそう","りそく","りてん","りねん","りゆう","りゅうがく","りよう","りょうり","りょかん","りょくちゃ","りょこう","りりく","りれき","りろん","りんご","るいけい","るいさい","るいじ","るいせき","るすばん","るりがわら","れいかん","れいぎ","れいせい","れいぞうこ","れいとう","れいぼう","れきし","れきだい","れんあい","れんけい","れんこん","れんさい","れんしゅう","れんぞく","れんらく","ろうか","ろうご","ろうじん","ろうそく","ろくが","ろこつ","ろじうら","ろしゅつ","ろせん","ろてん","ろめん","ろれつ","ろんぎ","ろんぱ","ろんぶん","ろんり","わかす","わかめ","わかやま","わかれる","わしつ","わじまし","わすれもの","わらう","われる"]');

/***/ }),

/***/ 8013:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('["가격","가끔","가난","가능","가득","가르침","가뭄","가방","가상","가슴","가운데","가을","가이드","가입","가장","가정","가족","가죽","각오","각자","간격","간부","간섭","간장","간접","간판","갈등","갈비","갈색","갈증","감각","감기","감소","감수성","감자","감정","갑자기","강남","강당","강도","강력히","강변","강북","강사","강수량","강아지","강원도","강의","강제","강조","같이","개구리","개나리","개방","개별","개선","개성","개인","객관적","거실","거액","거울","거짓","거품","걱정","건강","건물","건설","건조","건축","걸음","검사","검토","게시판","게임","겨울","견해","결과","결국","결론","결석","결승","결심","결정","결혼","경계","경고","경기","경력","경복궁","경비","경상도","경영","경우","경쟁","경제","경주","경찰","경치","경향","경험","계곡","계단","계란","계산","계속","계약","계절","계층","계획","고객","고구려","고궁","고급","고등학생","고무신","고민","고양이","고장","고전","고집","고춧가루","고통","고향","곡식","골목","골짜기","골프","공간","공개","공격","공군","공급","공기","공동","공무원","공부","공사","공식","공업","공연","공원","공장","공짜","공책","공통","공포","공항","공휴일","과목","과일","과장","과정","과학","관객","관계","관광","관념","관람","관련","관리","관습","관심","관점","관찰","광경","광고","광장","광주","괴로움","굉장히","교과서","교문","교복","교실","교양","교육","교장","교직","교통","교환","교훈","구경","구름","구멍","구별","구분","구석","구성","구속","구역","구입","구청","구체적","국가","국기","국내","국립","국물","국민","국수","국어","국왕","국적","국제","국회","군대","군사","군인","궁극적","권리","권위","권투","귀국","귀신","규정","규칙","균형","그날","그냥","그늘","그러나","그룹","그릇","그림","그제서야","그토록","극복","극히","근거","근교","근래","근로","근무","근본","근원","근육","근처","글씨","글자","금강산","금고","금년","금메달","금액","금연","금요일","금지","긍정적","기간","기관","기념","기능","기독교","기둥","기록","기름","기법","기본","기분","기쁨","기숙사","기술","기억","기업","기온","기운","기원","기적","기준","기침","기혼","기획","긴급","긴장","길이","김밥","김치","김포공항","깍두기","깜빡","깨달음","깨소금","껍질","꼭대기","꽃잎","나들이","나란히","나머지","나물","나침반","나흘","낙엽","난방","날개","날씨","날짜","남녀","남대문","남매","남산","남자","남편","남학생","낭비","낱말","내년","내용","내일","냄비","냄새","냇물","냉동","냉면","냉방","냉장고","넥타이","넷째","노동","노란색","노력","노인","녹음","녹차","녹화","논리","논문","논쟁","놀이","농구","농담","농민","농부","농업","농장","농촌","높이","눈동자","눈물","눈썹","뉴욕","느낌","늑대","능동적","능력","다방","다양성","다음","다이어트","다행","단계","단골","단독","단맛","단순","단어","단위","단점","단체","단추","단편","단풍","달걀","달러","달력","달리","닭고기","담당","담배","담요","담임","답변","답장","당근","당분간","당연히","당장","대규모","대낮","대단히","대답","대도시","대략","대량","대륙","대문","대부분","대신","대응","대장","대전","대접","대중","대책","대출","대충","대통령","대학","대한민국","대합실","대형","덩어리","데이트","도대체","도덕","도둑","도망","도서관","도심","도움","도입","도자기","도저히","도전","도중","도착","독감","독립","독서","독일","독창적","동화책","뒷모습","뒷산","딸아이","마누라","마늘","마당","마라톤","마련","마무리","마사지","마약","마요네즈","마을","마음","마이크","마중","마지막","마찬가지","마찰","마흔","막걸리","막내","막상","만남","만두","만세","만약","만일","만점","만족","만화","많이","말기","말씀","말투","맘대로","망원경","매년","매달","매력","매번","매스컴","매일","매장","맥주","먹이","먼저","먼지","멀리","메일","며느리","며칠","면담","멸치","명단","명령","명예","명의","명절","명칭","명함","모금","모니터","모델","모든","모범","모습","모양","모임","모조리","모집","모퉁이","목걸이","목록","목사","목소리","목숨","목적","목표","몰래","몸매","몸무게","몸살","몸속","몸짓","몸통","몹시","무관심","무궁화","무더위","무덤","무릎","무슨","무엇","무역","무용","무조건","무지개","무척","문구","문득","문법","문서","문제","문학","문화","물가","물건","물결","물고기","물론","물리학","물음","물질","물체","미국","미디어","미사일","미술","미역","미용실","미움","미인","미팅","미혼","민간","민족","민주","믿음","밀가루","밀리미터","밑바닥","바가지","바구니","바나나","바늘","바닥","바닷가","바람","바이러스","바탕","박물관","박사","박수","반대","반드시","반말","반발","반성","반응","반장","반죽","반지","반찬","받침","발가락","발걸음","발견","발달","발레","발목","발바닥","발생","발음","발자국","발전","발톱","발표","밤하늘","밥그릇","밥맛","밥상","밥솥","방금","방면","방문","방바닥","방법","방송","방식","방안","방울","방지","방학","방해","방향","배경","배꼽","배달","배드민턴","백두산","백색","백성","백인","백제","백화점","버릇","버섯","버튼","번개","번역","번지","번호","벌금","벌레","벌써","범위","범인","범죄","법률","법원","법적","법칙","베이징","벨트","변경","변동","변명","변신","변호사","변화","별도","별명","별일","병실","병아리","병원","보관","보너스","보라색","보람","보름","보상","보안","보자기","보장","보전","보존","보통","보편적","보험","복도","복사","복숭아","복습","볶음","본격적","본래","본부","본사","본성","본인","본질","볼펜","봉사","봉지","봉투","부근","부끄러움","부담","부동산","부문","부분","부산","부상","부엌","부인","부작용","부장","부정","부족","부지런히","부친","부탁","부품","부회장","북부","북한","분노","분량","분리","분명","분석","분야","분위기","분필","분홍색","불고기","불과","불교","불꽃","불만","불법","불빛","불안","불이익","불행","브랜드","비극","비난","비닐","비둘기","비디오","비로소","비만","비명","비밀","비바람","비빔밥","비상","비용","비율","비중","비타민","비판","빌딩","빗물","빗방울","빗줄기","빛깔","빨간색","빨래","빨리","사건","사계절","사나이","사냥","사람","사랑","사립","사모님","사물","사방","사상","사생활","사설","사슴","사실","사업","사용","사월","사장","사전","사진","사촌","사춘기","사탕","사투리","사흘","산길","산부인과","산업","산책","살림","살인","살짝","삼계탕","삼국","삼십","삼월","삼촌","상관","상금","상대","상류","상반기","상상","상식","상업","상인","상자","상점","상처","상추","상태","상표","상품","상황","새벽","색깔","색연필","생각","생명","생물","생방송","생산","생선","생신","생일","생활","서랍","서른","서명","서민","서비스","서양","서울","서적","서점","서쪽","서클","석사","석유","선거","선물","선배","선생","선수","선원","선장","선전","선택","선풍기","설거지","설날","설렁탕","설명","설문","설사","설악산","설치","설탕","섭씨","성공","성당","성명","성별","성인","성장","성적","성질","성함","세금","세미나","세상","세월","세종대왕","세탁","센터","센티미터","셋째","소규모","소극적","소금","소나기","소년","소득","소망","소문","소설","소속","소아과","소용","소원","소음","소중히","소지품","소질","소풍","소형","속담","속도","속옷","손가락","손길","손녀","손님","손등","손목","손뼉","손실","손질","손톱","손해","솔직히","솜씨","송아지","송이","송편","쇠고기","쇼핑","수건","수년","수단","수돗물","수동적","수면","수명","수박","수상","수석","수술","수시로","수업","수염","수영","수입","수준","수집","수출","수컷","수필","수학","수험생","수화기","숙녀","숙소","숙제","순간","순서","순수","순식간","순위","숟가락","술병","술집","숫자","스님","스물","스스로","스승","스웨터","스위치","스케이트","스튜디오","스트레스","스포츠","슬쩍","슬픔","습관","습기","승객","승리","승부","승용차","승진","시각","시간","시골","시금치","시나리오","시댁","시리즈","시멘트","시민","시부모","시선","시설","시스템","시아버지","시어머니","시월","시인","시일","시작","시장","시절","시점","시중","시즌","시집","시청","시합","시험","식구","식기","식당","식량","식료품","식물","식빵","식사","식생활","식초","식탁","식품","신고","신규","신념","신문","신발","신비","신사","신세","신용","신제품","신청","신체","신화","실감","실내","실력","실례","실망","실수","실습","실시","실장","실정","실질적","실천","실체","실컷","실태","실패","실험","실현","심리","심부름","심사","심장","심정","심판","쌍둥이","씨름","씨앗","아가씨","아나운서","아드님","아들","아쉬움","아스팔트","아시아","아울러","아저씨","아줌마","아직","아침","아파트","아프리카","아픔","아홉","아흔","악기","악몽","악수","안개","안경","안과","안내","안녕","안동","안방","안부","안주","알루미늄","알코올","암시","암컷","압력","앞날","앞문","애인","애정","액수","앨범","야간","야단","야옹","약간","약국","약속","약수","약점","약품","약혼녀","양념","양력","양말","양배추","양주","양파","어둠","어려움","어른","어젯밤","어쨌든","어쩌다가","어쩐지","언니","언덕","언론","언어","얼굴","얼른","얼음","얼핏","엄마","업무","업종","업체","엉덩이","엉망","엉터리","엊그제","에너지","에어컨","엔진","여건","여고생","여관","여군","여권","여대생","여덟","여동생","여든","여론","여름","여섯","여성","여왕","여인","여전히","여직원","여학생","여행","역사","역시","역할","연결","연구","연극","연기","연락","연설","연세","연속","연습","연애","연예인","연인","연장","연주","연출","연필","연합","연휴","열기","열매","열쇠","열심히","열정","열차","열흘","염려","엽서","영국","영남","영상","영양","영역","영웅","영원히","영하","영향","영혼","영화","옆구리","옆방","옆집","예감","예금","예방","예산","예상","예선","예술","예습","예식장","예약","예전","예절","예정","예컨대","옛날","오늘","오락","오랫동안","오렌지","오로지","오른발","오븐","오십","오염","오월","오전","오직","오징어","오페라","오피스텔","오히려","옥상","옥수수","온갖","온라인","온몸","온종일","온통","올가을","올림픽","올해","옷차림","와이셔츠","와인","완성","완전","왕비","왕자","왜냐하면","왠지","외갓집","외국","외로움","외삼촌","외출","외침","외할머니","왼발","왼손","왼쪽","요금","요일","요즘","요청","용기","용서","용어","우산","우선","우승","우연히","우정","우체국","우편","운동","운명","운반","운전","운행","울산","울음","움직임","웃어른","웃음","워낙","원고","원래","원서","원숭이","원인","원장","원피스","월급","월드컵","월세","월요일","웨이터","위반","위법","위성","위원","위험","위협","윗사람","유난히","유럽","유명","유물","유산","유적","유치원","유학","유행","유형","육군","육상","육십","육체","은행","음력","음료","음반","음성","음식","음악","음주","의견","의논","의문","의복","의식","의심","의외로","의욕","의원","의학","이것","이곳","이념","이놈","이달","이대로","이동","이렇게","이력서","이론적","이름","이민","이발소","이별","이불","이빨","이상","이성","이슬","이야기","이용","이웃","이월","이윽고","이익","이전","이중","이튿날","이틀","이혼","인간","인격","인공","인구","인근","인기","인도","인류","인물","인생","인쇄","인연","인원","인재","인종","인천","인체","인터넷","인하","인형","일곱","일기","일단","일대","일등","일반","일본","일부","일상","일생","일손","일요일","일월","일정","일종","일주일","일찍","일체","일치","일행","일회용","임금","임무","입대","입력","입맛","입사","입술","입시","입원","입장","입학","자가용","자격","자극","자동","자랑","자부심","자식","자신","자연","자원","자율","자전거","자정","자존심","자판","작가","작년","작성","작업","작용","작은딸","작품","잔디","잔뜩","잔치","잘못","잠깐","잠수함","잠시","잠옷","잠자리","잡지","장관","장군","장기간","장래","장례","장르","장마","장면","장모","장미","장비","장사","장소","장식","장애인","장인","장점","장차","장학금","재능","재빨리","재산","재생","재작년","재정","재채기","재판","재학","재활용","저것","저고리","저곳","저녁","저런","저렇게","저번","저울","저절로","저축","적극","적당히","적성","적용","적응","전개","전공","전기","전달","전라도","전망","전문","전반","전부","전세","전시","전용","전자","전쟁","전주","전철","전체","전통","전혀","전후","절대","절망","절반","절약","절차","점검","점수","점심","점원","점점","점차","접근","접시","접촉","젓가락","정거장","정도","정류장","정리","정말","정면","정문","정반대","정보","정부","정비","정상","정성","정오","정원","정장","정지","정치","정확히","제공","제과점","제대로","제목","제발","제법","제삿날","제안","제일","제작","제주도","제출","제품","제한","조각","조건","조금","조깅","조명","조미료","조상","조선","조용히","조절","조정","조직","존댓말","존재","졸업","졸음","종교","종로","종류","종소리","종업원","종종","종합","좌석","죄인","주관적","주름","주말","주머니","주먹","주문","주민","주방","주변","주식","주인","주일","주장","주전자","주택","준비","줄거리","줄기","줄무늬","중간","중계방송","중국","중년","중단","중독","중반","중부","중세","중소기업","중순","중앙","중요","중학교","즉석","즉시","즐거움","증가","증거","증권","증상","증세","지각","지갑","지경","지극히","지금","지급","지능","지름길","지리산","지방","지붕","지식","지역","지우개","지원","지적","지점","지진","지출","직선","직업","직원","직장","진급","진동","진로","진료","진리","진짜","진찰","진출","진통","진행","질문","질병","질서","짐작","집단","집안","집중","짜증","찌꺼기","차남","차라리","차량","차림","차별","차선","차츰","착각","찬물","찬성","참가","참기름","참새","참석","참여","참외","참조","찻잔","창가","창고","창구","창문","창밖","창작","창조","채널","채점","책가방","책방","책상","책임","챔피언","처벌","처음","천국","천둥","천장","천재","천천히","철도","철저히","철학","첫날","첫째","청년","청바지","청소","청춘","체계","체력","체온","체육","체중","체험","초등학생","초반","초밥","초상화","초순","초여름","초원","초저녁","초점","초청","초콜릿","촛불","총각","총리","총장","촬영","최근","최상","최선","최신","최악","최종","추석","추억","추진","추천","추측","축구","축소","축제","축하","출근","출발","출산","출신","출연","출입","출장","출판","충격","충고","충돌","충분히","충청도","취업","취직","취향","치약","친구","친척","칠십","칠월","칠판","침대","침묵","침실","칫솔","칭찬","카메라","카운터","칼국수","캐릭터","캠퍼스","캠페인","커튼","컨디션","컬러","컴퓨터","코끼리","코미디","콘서트","콜라","콤플렉스","콩나물","쾌감","쿠데타","크림","큰길","큰딸","큰소리","큰아들","큰어머니","큰일","큰절","클래식","클럽","킬로","타입","타자기","탁구","탁자","탄생","태권도","태양","태풍","택시","탤런트","터널","터미널","테니스","테스트","테이블","텔레비전","토론","토마토","토요일","통계","통과","통로","통신","통역","통일","통장","통제","통증","통합","통화","퇴근","퇴원","퇴직금","튀김","트럭","특급","특별","특성","특수","특징","특히","튼튼히","티셔츠","파란색","파일","파출소","판결","판단","판매","판사","팔십","팔월","팝송","패션","팩스","팩시밀리","팬티","퍼센트","페인트","편견","편의","편지","편히","평가","평균","평생","평소","평양","평일","평화","포스터","포인트","포장","포함","표면","표정","표준","표현","품목","품질","풍경","풍속","풍습","프랑스","프린터","플라스틱","피곤","피망","피아노","필름","필수","필요","필자","필통","핑계","하느님","하늘","하드웨어","하룻밤","하반기","하숙집","하순","하여튼","하지만","하천","하품","하필","학과","학교","학급","학기","학년","학력","학번","학부모","학비","학생","학술","학습","학용품","학원","학위","학자","학점","한계","한글","한꺼번에","한낮","한눈","한동안","한때","한라산","한마디","한문","한번","한복","한식","한여름","한쪽","할머니","할아버지","할인","함께","함부로","합격","합리적","항공","항구","항상","항의","해결","해군","해답","해당","해물","해석","해설","해수욕장","해안","핵심","핸드백","햄버거","햇볕","햇살","행동","행복","행사","행운","행위","향기","향상","향수","허락","허용","헬기","현관","현금","현대","현상","현실","현장","현재","현지","혈액","협력","형부","형사","형수","형식","형제","형태","형편","혜택","호기심","호남","호랑이","호박","호텔","호흡","혹시","홀로","홈페이지","홍보","홍수","홍차","화면","화분","화살","화요일","화장","화학","확보","확인","확장","확정","환갑","환경","환영","환율","환자","활기","활동","활발히","활용","활짝","회견","회관","회복","회색","회원","회장","회전","횟수","횡단보도","효율적","후반","후춧가루","훈련","훨씬","휴식","휴일","흉내","흐름","흑백","흑인","흔적","흔히","흥미","흥분","희곡","희망","희생","흰색","힘껏"]');

/***/ }),

/***/ 1945:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('["abacate","abaixo","abalar","abater","abduzir","abelha","aberto","abismo","abotoar","abranger","abreviar","abrigar","abrupto","absinto","absoluto","absurdo","abutre","acabado","acalmar","acampar","acanhar","acaso","aceitar","acelerar","acenar","acervo","acessar","acetona","achatar","acidez","acima","acionado","acirrar","aclamar","aclive","acolhida","acomodar","acoplar","acordar","acumular","acusador","adaptar","adega","adentro","adepto","adequar","aderente","adesivo","adeus","adiante","aditivo","adjetivo","adjunto","admirar","adorar","adquirir","adubo","adverso","advogado","aeronave","afastar","aferir","afetivo","afinador","afivelar","aflito","afluente","afrontar","agachar","agarrar","agasalho","agenciar","agilizar","agiota","agitado","agora","agradar","agreste","agrupar","aguardar","agulha","ajoelhar","ajudar","ajustar","alameda","alarme","alastrar","alavanca","albergue","albino","alcatra","aldeia","alecrim","alegria","alertar","alface","alfinete","algum","alheio","aliar","alicate","alienar","alinhar","aliviar","almofada","alocar","alpiste","alterar","altitude","alucinar","alugar","aluno","alusivo","alvo","amaciar","amador","amarelo","amassar","ambas","ambiente","ameixa","amenizar","amido","amistoso","amizade","amolador","amontoar","amoroso","amostra","amparar","ampliar","ampola","anagrama","analisar","anarquia","anatomia","andaime","anel","anexo","angular","animar","anjo","anomalia","anotado","ansioso","anterior","anuidade","anunciar","anzol","apagador","apalpar","apanhado","apego","apelido","apertada","apesar","apetite","apito","aplauso","aplicada","apoio","apontar","aposta","aprendiz","aprovar","aquecer","arame","aranha","arara","arcada","ardente","areia","arejar","arenito","aresta","argiloso","argola","arma","arquivo","arraial","arrebate","arriscar","arroba","arrumar","arsenal","arterial","artigo","arvoredo","asfaltar","asilado","aspirar","assador","assinar","assoalho","assunto","astral","atacado","atadura","atalho","atarefar","atear","atender","aterro","ateu","atingir","atirador","ativo","atoleiro","atracar","atrevido","atriz","atual","atum","auditor","aumentar","aura","aurora","autismo","autoria","autuar","avaliar","avante","avaria","avental","avesso","aviador","avisar","avulso","axila","azarar","azedo","azeite","azulejo","babar","babosa","bacalhau","bacharel","bacia","bagagem","baiano","bailar","baioneta","bairro","baixista","bajular","baleia","baliza","balsa","banal","bandeira","banho","banir","banquete","barato","barbado","baronesa","barraca","barulho","baseado","bastante","batata","batedor","batida","batom","batucar","baunilha","beber","beijo","beirada","beisebol","beldade","beleza","belga","beliscar","bendito","bengala","benzer","berimbau","berlinda","berro","besouro","bexiga","bezerro","bico","bicudo","bienal","bifocal","bifurcar","bigorna","bilhete","bimestre","bimotor","biologia","biombo","biosfera","bipolar","birrento","biscoito","bisneto","bispo","bissexto","bitola","bizarro","blindado","bloco","bloquear","boato","bobagem","bocado","bocejo","bochecha","boicotar","bolada","boletim","bolha","bolo","bombeiro","bonde","boneco","bonita","borbulha","borda","boreal","borracha","bovino","boxeador","branco","brasa","braveza","breu","briga","brilho","brincar","broa","brochura","bronzear","broto","bruxo","bucha","budismo","bufar","bule","buraco","busca","busto","buzina","cabana","cabelo","cabide","cabo","cabrito","cacau","cacetada","cachorro","cacique","cadastro","cadeado","cafezal","caiaque","caipira","caixote","cajado","caju","calafrio","calcular","caldeira","calibrar","calmante","calota","camada","cambista","camisa","camomila","campanha","camuflar","canavial","cancelar","caneta","canguru","canhoto","canivete","canoa","cansado","cantar","canudo","capacho","capela","capinar","capotar","capricho","captador","capuz","caracol","carbono","cardeal","careca","carimbar","carneiro","carpete","carreira","cartaz","carvalho","casaco","casca","casebre","castelo","casulo","catarata","cativar","caule","causador","cautelar","cavalo","caverna","cebola","cedilha","cegonha","celebrar","celular","cenoura","censo","centeio","cercar","cerrado","certeiro","cerveja","cetim","cevada","chacota","chaleira","chamado","chapada","charme","chatice","chave","chefe","chegada","cheiro","cheque","chicote","chifre","chinelo","chocalho","chover","chumbo","chutar","chuva","cicatriz","ciclone","cidade","cidreira","ciente","cigana","cimento","cinto","cinza","ciranda","circuito","cirurgia","citar","clareza","clero","clicar","clone","clube","coado","coagir","cobaia","cobertor","cobrar","cocada","coelho","coentro","coeso","cogumelo","coibir","coifa","coiote","colar","coleira","colher","colidir","colmeia","colono","coluna","comando","combinar","comentar","comitiva","comover","complexo","comum","concha","condor","conectar","confuso","congelar","conhecer","conjugar","consumir","contrato","convite","cooperar","copeiro","copiador","copo","coquetel","coragem","cordial","corneta","coronha","corporal","correio","cortejo","coruja","corvo","cosseno","costela","cotonete","couro","couve","covil","cozinha","cratera","cravo","creche","credor","creme","crer","crespo","criada","criminal","crioulo","crise","criticar","crosta","crua","cruzeiro","cubano","cueca","cuidado","cujo","culatra","culminar","culpar","cultura","cumprir","cunhado","cupido","curativo","curral","cursar","curto","cuspir","custear","cutelo","damasco","datar","debater","debitar","deboche","debulhar","decalque","decimal","declive","decote","decretar","dedal","dedicado","deduzir","defesa","defumar","degelo","degrau","degustar","deitado","deixar","delator","delegado","delinear","delonga","demanda","demitir","demolido","dentista","depenado","depilar","depois","depressa","depurar","deriva","derramar","desafio","desbotar","descanso","desenho","desfiado","desgaste","desigual","deslize","desmamar","desova","despesa","destaque","desviar","detalhar","detentor","detonar","detrito","deusa","dever","devido","devotado","dezena","diagrama","dialeto","didata","difuso","digitar","dilatado","diluente","diminuir","dinastia","dinheiro","diocese","direto","discreta","disfarce","disparo","disquete","dissipar","distante","ditador","diurno","diverso","divisor","divulgar","dizer","dobrador","dolorido","domador","dominado","donativo","donzela","dormente","dorsal","dosagem","dourado","doutor","drenagem","drible","drogaria","duelar","duende","dueto","duplo","duquesa","durante","duvidoso","eclodir","ecoar","ecologia","edificar","edital","educado","efeito","efetivar","ejetar","elaborar","eleger","eleitor","elenco","elevador","eliminar","elogiar","embargo","embolado","embrulho","embutido","emenda","emergir","emissor","empatia","empenho","empinado","empolgar","emprego","empurrar","emulador","encaixe","encenado","enchente","encontro","endeusar","endossar","enfaixar","enfeite","enfim","engajado","engenho","englobar","engomado","engraxar","enguia","enjoar","enlatar","enquanto","enraizar","enrolado","enrugar","ensaio","enseada","ensino","ensopado","entanto","enteado","entidade","entortar","entrada","entulho","envergar","enviado","envolver","enxame","enxerto","enxofre","enxuto","epiderme","equipar","ereto","erguido","errata","erva","ervilha","esbanjar","esbelto","escama","escola","escrita","escuta","esfinge","esfolar","esfregar","esfumado","esgrima","esmalte","espanto","espelho","espiga","esponja","espreita","espumar","esquerda","estaca","esteira","esticar","estofado","estrela","estudo","esvaziar","etanol","etiqueta","euforia","europeu","evacuar","evaporar","evasivo","eventual","evidente","evoluir","exagero","exalar","examinar","exato","exausto","excesso","excitar","exclamar","executar","exemplo","exibir","exigente","exonerar","expandir","expelir","expirar","explanar","exposto","expresso","expulsar","externo","extinto","extrato","fabricar","fabuloso","faceta","facial","fada","fadiga","faixa","falar","falta","familiar","fandango","fanfarra","fantoche","fardado","farelo","farinha","farofa","farpa","fartura","fatia","fator","favorita","faxina","fazenda","fechado","feijoada","feirante","felino","feminino","fenda","feno","fera","feriado","ferrugem","ferver","festejar","fetal","feudal","fiapo","fibrose","ficar","ficheiro","figurado","fileira","filho","filme","filtrar","firmeza","fisgada","fissura","fita","fivela","fixador","fixo","flacidez","flamingo","flanela","flechada","flora","flutuar","fluxo","focal","focinho","fofocar","fogo","foguete","foice","folgado","folheto","forjar","formiga","forno","forte","fosco","fossa","fragata","fralda","frango","frasco","fraterno","freira","frente","fretar","frieza","friso","fritura","fronha","frustrar","fruteira","fugir","fulano","fuligem","fundar","fungo","funil","furador","furioso","futebol","gabarito","gabinete","gado","gaiato","gaiola","gaivota","galega","galho","galinha","galocha","ganhar","garagem","garfo","gargalo","garimpo","garoupa","garrafa","gasoduto","gasto","gata","gatilho","gaveta","gazela","gelado","geleia","gelo","gemada","gemer","gemido","generoso","gengiva","genial","genoma","genro","geologia","gerador","germinar","gesso","gestor","ginasta","gincana","gingado","girafa","girino","glacial","glicose","global","glorioso","goela","goiaba","golfe","golpear","gordura","gorjeta","gorro","gostoso","goteira","governar","gracejo","gradual","grafite","gralha","grampo","granada","gratuito","graveto","graxa","grego","grelhar","greve","grilo","grisalho","gritaria","grosso","grotesco","grudado","grunhido","gruta","guache","guarani","guaxinim","guerrear","guiar","guincho","guisado","gula","guloso","guru","habitar","harmonia","haste","haver","hectare","herdar","heresia","hesitar","hiato","hibernar","hidratar","hiena","hino","hipismo","hipnose","hipoteca","hoje","holofote","homem","honesto","honrado","hormonal","hospedar","humorado","iate","ideia","idoso","ignorado","igreja","iguana","ileso","ilha","iludido","iluminar","ilustrar","imagem","imediato","imenso","imersivo","iminente","imitador","imortal","impacto","impedir","implante","impor","imprensa","impune","imunizar","inalador","inapto","inativo","incenso","inchar","incidir","incluir","incolor","indeciso","indireto","indutor","ineficaz","inerente","infantil","infestar","infinito","inflamar","informal","infrator","ingerir","inibido","inicial","inimigo","injetar","inocente","inodoro","inovador","inox","inquieto","inscrito","inseto","insistir","inspetor","instalar","insulto","intacto","integral","intimar","intocado","intriga","invasor","inverno","invicto","invocar","iogurte","iraniano","ironizar","irreal","irritado","isca","isento","isolado","isqueiro","italiano","janeiro","jangada","janta","jararaca","jardim","jarro","jasmim","jato","javali","jazida","jejum","joaninha","joelhada","jogador","joia","jornal","jorrar","jovem","juba","judeu","judoca","juiz","julgador","julho","jurado","jurista","juro","justa","labareda","laboral","lacre","lactante","ladrilho","lagarta","lagoa","laje","lamber","lamentar","laminar","lampejo","lanche","lapidar","lapso","laranja","lareira","largura","lasanha","lastro","lateral","latido","lavanda","lavoura","lavrador","laxante","lazer","lealdade","lebre","legado","legendar","legista","leigo","leiloar","leitura","lembrete","leme","lenhador","lentilha","leoa","lesma","leste","letivo","letreiro","levar","leveza","levitar","liberal","libido","liderar","ligar","ligeiro","limitar","limoeiro","limpador","linda","linear","linhagem","liquidez","listagem","lisura","litoral","livro","lixa","lixeira","locador","locutor","lojista","lombo","lona","longe","lontra","lorde","lotado","loteria","loucura","lousa","louvar","luar","lucidez","lucro","luneta","lustre","lutador","luva","macaco","macete","machado","macio","madeira","madrinha","magnata","magreza","maior","mais","malandro","malha","malote","maluco","mamilo","mamoeiro","mamute","manada","mancha","mandato","manequim","manhoso","manivela","manobrar","mansa","manter","manusear","mapeado","maquinar","marcador","maresia","marfim","margem","marinho","marmita","maroto","marquise","marreco","martelo","marujo","mascote","masmorra","massagem","mastigar","matagal","materno","matinal","matutar","maxilar","medalha","medida","medusa","megafone","meiga","melancia","melhor","membro","memorial","menino","menos","mensagem","mental","merecer","mergulho","mesada","mesclar","mesmo","mesquita","mestre","metade","meteoro","metragem","mexer","mexicano","micro","migalha","migrar","milagre","milenar","milhar","mimado","minerar","minhoca","ministro","minoria","miolo","mirante","mirtilo","misturar","mocidade","moderno","modular","moeda","moer","moinho","moita","moldura","moleza","molho","molinete","molusco","montanha","moqueca","morango","morcego","mordomo","morena","mosaico","mosquete","mostarda","motel","motim","moto","motriz","muda","muito","mulata","mulher","multar","mundial","munido","muralha","murcho","muscular","museu","musical","nacional","nadador","naja","namoro","narina","narrado","nascer","nativa","natureza","navalha","navegar","navio","neblina","nebuloso","negativa","negociar","negrito","nervoso","neta","neural","nevasca","nevoeiro","ninar","ninho","nitidez","nivelar","nobreza","noite","noiva","nomear","nominal","nordeste","nortear","notar","noticiar","noturno","novelo","novilho","novo","nublado","nudez","numeral","nupcial","nutrir","nuvem","obcecado","obedecer","objetivo","obrigado","obscuro","obstetra","obter","obturar","ocidente","ocioso","ocorrer","oculista","ocupado","ofegante","ofensiva","oferenda","oficina","ofuscado","ogiva","olaria","oleoso","olhar","oliveira","ombro","omelete","omisso","omitir","ondulado","oneroso","ontem","opcional","operador","oponente","oportuno","oposto","orar","orbitar","ordem","ordinal","orfanato","orgasmo","orgulho","oriental","origem","oriundo","orla","ortodoxo","orvalho","oscilar","ossada","osso","ostentar","otimismo","ousadia","outono","outubro","ouvido","ovelha","ovular","oxidar","oxigenar","pacato","paciente","pacote","pactuar","padaria","padrinho","pagar","pagode","painel","pairar","paisagem","palavra","palestra","palheta","palito","palmada","palpitar","pancada","panela","panfleto","panqueca","pantanal","papagaio","papelada","papiro","parafina","parcial","pardal","parede","partida","pasmo","passado","pastel","patamar","patente","patinar","patrono","paulada","pausar","peculiar","pedalar","pedestre","pediatra","pedra","pegada","peitoral","peixe","pele","pelicano","penca","pendurar","peneira","penhasco","pensador","pente","perceber","perfeito","pergunta","perito","permitir","perna","perplexo","persiana","pertence","peruca","pescado","pesquisa","pessoa","petiscar","piada","picado","piedade","pigmento","pilastra","pilhado","pilotar","pimenta","pincel","pinguim","pinha","pinote","pintar","pioneiro","pipoca","piquete","piranha","pires","pirueta","piscar","pistola","pitanga","pivete","planta","plaqueta","platina","plebeu","plumagem","pluvial","pneu","poda","poeira","poetisa","polegada","policiar","poluente","polvilho","pomar","pomba","ponderar","pontaria","populoso","porta","possuir","postal","pote","poupar","pouso","povoar","praia","prancha","prato","praxe","prece","predador","prefeito","premiar","prensar","preparar","presilha","pretexto","prevenir","prezar","primata","princesa","prisma","privado","processo","produto","profeta","proibido","projeto","prometer","propagar","prosa","protetor","provador","publicar","pudim","pular","pulmonar","pulseira","punhal","punir","pupilo","pureza","puxador","quadra","quantia","quarto","quase","quebrar","queda","queijo","quente","querido","quimono","quina","quiosque","rabanada","rabisco","rachar","racionar","radial","raiar","rainha","raio","raiva","rajada","ralado","ramal","ranger","ranhura","rapadura","rapel","rapidez","raposa","raquete","raridade","rasante","rascunho","rasgar","raspador","rasteira","rasurar","ratazana","ratoeira","realeza","reanimar","reaver","rebaixar","rebelde","rebolar","recado","recente","recheio","recibo","recordar","recrutar","recuar","rede","redimir","redonda","reduzida","reenvio","refinar","refletir","refogar","refresco","refugiar","regalia","regime","regra","reinado","reitor","rejeitar","relativo","remador","remendo","remorso","renovado","reparo","repelir","repleto","repolho","represa","repudiar","requerer","resenha","resfriar","resgatar","residir","resolver","respeito","ressaca","restante","resumir","retalho","reter","retirar","retomada","retratar","revelar","revisor","revolta","riacho","rica","rigidez","rigoroso","rimar","ringue","risada","risco","risonho","robalo","rochedo","rodada","rodeio","rodovia","roedor","roleta","romano","roncar","rosado","roseira","rosto","rota","roteiro","rotina","rotular","rouco","roupa","roxo","rubro","rugido","rugoso","ruivo","rumo","rupestre","russo","sabor","saciar","sacola","sacudir","sadio","safira","saga","sagrada","saibro","salada","saleiro","salgado","saliva","salpicar","salsicha","saltar","salvador","sambar","samurai","sanar","sanfona","sangue","sanidade","sapato","sarda","sargento","sarjeta","saturar","saudade","saxofone","sazonal","secar","secular","seda","sedento","sediado","sedoso","sedutor","segmento","segredo","segundo","seiva","seleto","selvagem","semanal","semente","senador","senhor","sensual","sentado","separado","sereia","seringa","serra","servo","setembro","setor","sigilo","silhueta","silicone","simetria","simpatia","simular","sinal","sincero","singular","sinopse","sintonia","sirene","siri","situado","soberano","sobra","socorro","sogro","soja","solda","soletrar","solteiro","sombrio","sonata","sondar","sonegar","sonhador","sono","soprano","soquete","sorrir","sorteio","sossego","sotaque","soterrar","sovado","sozinho","suavizar","subida","submerso","subsolo","subtrair","sucata","sucesso","suco","sudeste","sufixo","sugador","sugerir","sujeito","sulfato","sumir","suor","superior","suplicar","suposto","suprimir","surdina","surfista","surpresa","surreal","surtir","suspiro","sustento","tabela","tablete","tabuada","tacho","tagarela","talher","talo","talvez","tamanho","tamborim","tampa","tangente","tanto","tapar","tapioca","tardio","tarefa","tarja","tarraxa","tatuagem","taurino","taxativo","taxista","teatral","tecer","tecido","teclado","tedioso","teia","teimar","telefone","telhado","tempero","tenente","tensor","tentar","termal","terno","terreno","tese","tesoura","testado","teto","textura","texugo","tiara","tigela","tijolo","timbrar","timidez","tingido","tinteiro","tiragem","titular","toalha","tocha","tolerar","tolice","tomada","tomilho","tonel","tontura","topete","tora","torcido","torneio","torque","torrada","torto","tostar","touca","toupeira","toxina","trabalho","tracejar","tradutor","trafegar","trajeto","trama","trancar","trapo","traseiro","tratador","travar","treino","tremer","trepidar","trevo","triagem","tribo","triciclo","tridente","trilogia","trindade","triplo","triturar","triunfal","trocar","trombeta","trova","trunfo","truque","tubular","tucano","tudo","tulipa","tupi","turbo","turma","turquesa","tutelar","tutorial","uivar","umbigo","unha","unidade","uniforme","urologia","urso","urtiga","urubu","usado","usina","usufruir","vacina","vadiar","vagaroso","vaidoso","vala","valente","validade","valores","vantagem","vaqueiro","varanda","vareta","varrer","vascular","vasilha","vassoura","vazar","vazio","veado","vedar","vegetar","veicular","veleiro","velhice","veludo","vencedor","vendaval","venerar","ventre","verbal","verdade","vereador","vergonha","vermelho","verniz","versar","vertente","vespa","vestido","vetorial","viaduto","viagem","viajar","viatura","vibrador","videira","vidraria","viela","viga","vigente","vigiar","vigorar","vilarejo","vinco","vinheta","vinil","violeta","virada","virtude","visitar","visto","vitral","viveiro","vizinho","voador","voar","vogal","volante","voleibol","voltagem","volumoso","vontade","vulto","vuvuzela","xadrez","xarope","xeque","xeretar","xerife","xingar","zangado","zarpar","zebu","zelador","zombar","zoologia","zumbido"]');

/***/ }),

/***/ 659:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('["ábaco","abdomen","abeja","abierto","abogado","abono","aborto","abrazo","abrir","abuelo","abuso","acabar","academia","acceso","acción","aceite","acelga","acento","aceptar","ácido","aclarar","acné","acoger","acoso","activo","acto","actriz","actuar","acudir","acuerdo","acusar","adicto","admitir","adoptar","adorno","aduana","adulto","aéreo","afectar","afición","afinar","afirmar","ágil","agitar","agonía","agosto","agotar","agregar","agrio","agua","agudo","águila","aguja","ahogo","ahorro","aire","aislar","ajedrez","ajeno","ajuste","alacrán","alambre","alarma","alba","álbum","alcalde","aldea","alegre","alejar","alerta","aleta","alfiler","alga","algodón","aliado","aliento","alivio","alma","almeja","almíbar","altar","alteza","altivo","alto","altura","alumno","alzar","amable","amante","amapola","amargo","amasar","ámbar","ámbito","ameno","amigo","amistad","amor","amparo","amplio","ancho","anciano","ancla","andar","andén","anemia","ángulo","anillo","ánimo","anís","anotar","antena","antiguo","antojo","anual","anular","anuncio","añadir","añejo","año","apagar","aparato","apetito","apio","aplicar","apodo","aporte","apoyo","aprender","aprobar","apuesta","apuro","arado","araña","arar","árbitro","árbol","arbusto","archivo","arco","arder","ardilla","arduo","área","árido","aries","armonía","arnés","aroma","arpa","arpón","arreglo","arroz","arruga","arte","artista","asa","asado","asalto","ascenso","asegurar","aseo","asesor","asiento","asilo","asistir","asno","asombro","áspero","astilla","astro","astuto","asumir","asunto","atajo","ataque","atar","atento","ateo","ático","atleta","átomo","atraer","atroz","atún","audaz","audio","auge","aula","aumento","ausente","autor","aval","avance","avaro","ave","avellana","avena","avestruz","avión","aviso","ayer","ayuda","ayuno","azafrán","azar","azote","azúcar","azufre","azul","baba","babor","bache","bahía","baile","bajar","balanza","balcón","balde","bambú","banco","banda","baño","barba","barco","barniz","barro","báscula","bastón","basura","batalla","batería","batir","batuta","baúl","bazar","bebé","bebida","bello","besar","beso","bestia","bicho","bien","bingo","blanco","bloque","blusa","boa","bobina","bobo","boca","bocina","boda","bodega","boina","bola","bolero","bolsa","bomba","bondad","bonito","bono","bonsái","borde","borrar","bosque","bote","botín","bóveda","bozal","bravo","brazo","brecha","breve","brillo","brinco","brisa","broca","broma","bronce","brote","bruja","brusco","bruto","buceo","bucle","bueno","buey","bufanda","bufón","búho","buitre","bulto","burbuja","burla","burro","buscar","butaca","buzón","caballo","cabeza","cabina","cabra","cacao","cadáver","cadena","caer","café","caída","caimán","caja","cajón","cal","calamar","calcio","caldo","calidad","calle","calma","calor","calvo","cama","cambio","camello","camino","campo","cáncer","candil","canela","canguro","canica","canto","caña","cañón","caoba","caos","capaz","capitán","capote","captar","capucha","cara","carbón","cárcel","careta","carga","cariño","carne","carpeta","carro","carta","casa","casco","casero","caspa","castor","catorce","catre","caudal","causa","cazo","cebolla","ceder","cedro","celda","célebre","celoso","célula","cemento","ceniza","centro","cerca","cerdo","cereza","cero","cerrar","certeza","césped","cetro","chacal","chaleco","champú","chancla","chapa","charla","chico","chiste","chivo","choque","choza","chuleta","chupar","ciclón","ciego","cielo","cien","cierto","cifra","cigarro","cima","cinco","cine","cinta","ciprés","circo","ciruela","cisne","cita","ciudad","clamor","clan","claro","clase","clave","cliente","clima","clínica","cobre","cocción","cochino","cocina","coco","código","codo","cofre","coger","cohete","cojín","cojo","cola","colcha","colegio","colgar","colina","collar","colmo","columna","combate","comer","comida","cómodo","compra","conde","conejo","conga","conocer","consejo","contar","copa","copia","corazón","corbata","corcho","cordón","corona","correr","coser","cosmos","costa","cráneo","cráter","crear","crecer","creído","crema","cría","crimen","cripta","crisis","cromo","crónica","croqueta","crudo","cruz","cuadro","cuarto","cuatro","cubo","cubrir","cuchara","cuello","cuento","cuerda","cuesta","cueva","cuidar","culebra","culpa","culto","cumbre","cumplir","cuna","cuneta","cuota","cupón","cúpula","curar","curioso","curso","curva","cutis","dama","danza","dar","dardo","dátil","deber","débil","década","decir","dedo","defensa","definir","dejar","delfín","delgado","delito","demora","denso","dental","deporte","derecho","derrota","desayuno","deseo","desfile","desnudo","destino","desvío","detalle","detener","deuda","día","diablo","diadema","diamante","diana","diario","dibujo","dictar","diente","dieta","diez","difícil","digno","dilema","diluir","dinero","directo","dirigir","disco","diseño","disfraz","diva","divino","doble","doce","dolor","domingo","don","donar","dorado","dormir","dorso","dos","dosis","dragón","droga","ducha","duda","duelo","dueño","dulce","dúo","duque","durar","dureza","duro","ébano","ebrio","echar","eco","ecuador","edad","edición","edificio","editor","educar","efecto","eficaz","eje","ejemplo","elefante","elegir","elemento","elevar","elipse","élite","elixir","elogio","eludir","embudo","emitir","emoción","empate","empeño","empleo","empresa","enano","encargo","enchufe","encía","enemigo","enero","enfado","enfermo","engaño","enigma","enlace","enorme","enredo","ensayo","enseñar","entero","entrar","envase","envío","época","equipo","erizo","escala","escena","escolar","escribir","escudo","esencia","esfera","esfuerzo","espada","espejo","espía","esposa","espuma","esquí","estar","este","estilo","estufa","etapa","eterno","ética","etnia","evadir","evaluar","evento","evitar","exacto","examen","exceso","excusa","exento","exigir","exilio","existir","éxito","experto","explicar","exponer","extremo","fábrica","fábula","fachada","fácil","factor","faena","faja","falda","fallo","falso","faltar","fama","familia","famoso","faraón","farmacia","farol","farsa","fase","fatiga","fauna","favor","fax","febrero","fecha","feliz","feo","feria","feroz","fértil","fervor","festín","fiable","fianza","fiar","fibra","ficción","ficha","fideo","fiebre","fiel","fiera","fiesta","figura","fijar","fijo","fila","filete","filial","filtro","fin","finca","fingir","finito","firma","flaco","flauta","flecha","flor","flota","fluir","flujo","flúor","fobia","foca","fogata","fogón","folio","folleto","fondo","forma","forro","fortuna","forzar","fosa","foto","fracaso","frágil","franja","frase","fraude","freír","freno","fresa","frío","frito","fruta","fuego","fuente","fuerza","fuga","fumar","función","funda","furgón","furia","fusil","fútbol","futuro","gacela","gafas","gaita","gajo","gala","galería","gallo","gamba","ganar","gancho","ganga","ganso","garaje","garza","gasolina","gastar","gato","gavilán","gemelo","gemir","gen","género","genio","gente","geranio","gerente","germen","gesto","gigante","gimnasio","girar","giro","glaciar","globo","gloria","gol","golfo","goloso","golpe","goma","gordo","gorila","gorra","gota","goteo","gozar","grada","gráfico","grano","grasa","gratis","grave","grieta","grillo","gripe","gris","grito","grosor","grúa","grueso","grumo","grupo","guante","guapo","guardia","guerra","guía","guiño","guion","guiso","guitarra","gusano","gustar","haber","hábil","hablar","hacer","hacha","hada","hallar","hamaca","harina","haz","hazaña","hebilla","hebra","hecho","helado","helio","hembra","herir","hermano","héroe","hervir","hielo","hierro","hígado","higiene","hijo","himno","historia","hocico","hogar","hoguera","hoja","hombre","hongo","honor","honra","hora","hormiga","horno","hostil","hoyo","hueco","huelga","huerta","hueso","huevo","huida","huir","humano","húmedo","humilde","humo","hundir","huracán","hurto","icono","ideal","idioma","ídolo","iglesia","iglú","igual","ilegal","ilusión","imagen","imán","imitar","impar","imperio","imponer","impulso","incapaz","índice","inerte","infiel","informe","ingenio","inicio","inmenso","inmune","innato","insecto","instante","interés","íntimo","intuir","inútil","invierno","ira","iris","ironía","isla","islote","jabalí","jabón","jamón","jarabe","jardín","jarra","jaula","jazmín","jefe","jeringa","jinete","jornada","joroba","joven","joya","juerga","jueves","juez","jugador","jugo","juguete","juicio","junco","jungla","junio","juntar","júpiter","jurar","justo","juvenil","juzgar","kilo","koala","labio","lacio","lacra","lado","ladrón","lagarto","lágrima","laguna","laico","lamer","lámina","lámpara","lana","lancha","langosta","lanza","lápiz","largo","larva","lástima","lata","látex","latir","laurel","lavar","lazo","leal","lección","leche","lector","leer","legión","legumbre","lejano","lengua","lento","leña","león","leopardo","lesión","letal","letra","leve","leyenda","libertad","libro","licor","líder","lidiar","lienzo","liga","ligero","lima","límite","limón","limpio","lince","lindo","línea","lingote","lino","linterna","líquido","liso","lista","litera","litio","litro","llaga","llama","llanto","llave","llegar","llenar","llevar","llorar","llover","lluvia","lobo","loción","loco","locura","lógica","logro","lombriz","lomo","lonja","lote","lucha","lucir","lugar","lujo","luna","lunes","lupa","lustro","luto","luz","maceta","macho","madera","madre","maduro","maestro","mafia","magia","mago","maíz","maldad","maleta","malla","malo","mamá","mambo","mamut","manco","mando","manejar","manga","maniquí","manjar","mano","manso","manta","mañana","mapa","máquina","mar","marco","marea","marfil","margen","marido","mármol","marrón","martes","marzo","masa","máscara","masivo","matar","materia","matiz","matriz","máximo","mayor","mazorca","mecha","medalla","medio","médula","mejilla","mejor","melena","melón","memoria","menor","mensaje","mente","menú","mercado","merengue","mérito","mes","mesón","meta","meter","método","metro","mezcla","miedo","miel","miembro","miga","mil","milagro","militar","millón","mimo","mina","minero","mínimo","minuto","miope","mirar","misa","miseria","misil","mismo","mitad","mito","mochila","moción","moda","modelo","moho","mojar","molde","moler","molino","momento","momia","monarca","moneda","monja","monto","moño","morada","morder","moreno","morir","morro","morsa","mortal","mosca","mostrar","motivo","mover","móvil","mozo","mucho","mudar","mueble","muela","muerte","muestra","mugre","mujer","mula","muleta","multa","mundo","muñeca","mural","muro","músculo","museo","musgo","música","muslo","nácar","nación","nadar","naipe","naranja","nariz","narrar","nasal","natal","nativo","natural","náusea","naval","nave","navidad","necio","néctar","negar","negocio","negro","neón","nervio","neto","neutro","nevar","nevera","nicho","nido","niebla","nieto","niñez","niño","nítido","nivel","nobleza","noche","nómina","noria","norma","norte","nota","noticia","novato","novela","novio","nube","nuca","núcleo","nudillo","nudo","nuera","nueve","nuez","nulo","número","nutria","oasis","obeso","obispo","objeto","obra","obrero","observar","obtener","obvio","oca","ocaso","océano","ochenta","ocho","ocio","ocre","octavo","octubre","oculto","ocupar","ocurrir","odiar","odio","odisea","oeste","ofensa","oferta","oficio","ofrecer","ogro","oído","oír","ojo","ola","oleada","olfato","olivo","olla","olmo","olor","olvido","ombligo","onda","onza","opaco","opción","ópera","opinar","oponer","optar","óptica","opuesto","oración","orador","oral","órbita","orca","orden","oreja","órgano","orgía","orgullo","oriente","origen","orilla","oro","orquesta","oruga","osadía","oscuro","osezno","oso","ostra","otoño","otro","oveja","óvulo","óxido","oxígeno","oyente","ozono","pacto","padre","paella","página","pago","país","pájaro","palabra","palco","paleta","pálido","palma","paloma","palpar","pan","panal","pánico","pantera","pañuelo","papá","papel","papilla","paquete","parar","parcela","pared","parir","paro","párpado","parque","párrafo","parte","pasar","paseo","pasión","paso","pasta","pata","patio","patria","pausa","pauta","pavo","payaso","peatón","pecado","pecera","pecho","pedal","pedir","pegar","peine","pelar","peldaño","pelea","peligro","pellejo","pelo","peluca","pena","pensar","peñón","peón","peor","pepino","pequeño","pera","percha","perder","pereza","perfil","perico","perla","permiso","perro","persona","pesa","pesca","pésimo","pestaña","pétalo","petróleo","pez","pezuña","picar","pichón","pie","piedra","pierna","pieza","pijama","pilar","piloto","pimienta","pino","pintor","pinza","piña","piojo","pipa","pirata","pisar","piscina","piso","pista","pitón","pizca","placa","plan","plata","playa","plaza","pleito","pleno","plomo","pluma","plural","pobre","poco","poder","podio","poema","poesía","poeta","polen","policía","pollo","polvo","pomada","pomelo","pomo","pompa","poner","porción","portal","posada","poseer","posible","poste","potencia","potro","pozo","prado","precoz","pregunta","premio","prensa","preso","previo","primo","príncipe","prisión","privar","proa","probar","proceso","producto","proeza","profesor","programa","prole","promesa","pronto","propio","próximo","prueba","público","puchero","pudor","pueblo","puerta","puesto","pulga","pulir","pulmón","pulpo","pulso","puma","punto","puñal","puño","pupa","pupila","puré","quedar","queja","quemar","querer","queso","quieto","química","quince","quitar","rábano","rabia","rabo","ración","radical","raíz","rama","rampa","rancho","rango","rapaz","rápido","rapto","rasgo","raspa","rato","rayo","raza","razón","reacción","realidad","rebaño","rebote","recaer","receta","rechazo","recoger","recreo","recto","recurso","red","redondo","reducir","reflejo","reforma","refrán","refugio","regalo","regir","regla","regreso","rehén","reino","reír","reja","relato","relevo","relieve","relleno","reloj","remar","remedio","remo","rencor","rendir","renta","reparto","repetir","reposo","reptil","res","rescate","resina","respeto","resto","resumen","retiro","retorno","retrato","reunir","revés","revista","rey","rezar","rico","riego","rienda","riesgo","rifa","rígido","rigor","rincón","riñón","río","riqueza","risa","ritmo","rito","rizo","roble","roce","rociar","rodar","rodeo","rodilla","roer","rojizo","rojo","romero","romper","ron","ronco","ronda","ropa","ropero","rosa","rosca","rostro","rotar","rubí","rubor","rudo","rueda","rugir","ruido","ruina","ruleta","rulo","rumbo","rumor","ruptura","ruta","rutina","sábado","saber","sabio","sable","sacar","sagaz","sagrado","sala","saldo","salero","salir","salmón","salón","salsa","salto","salud","salvar","samba","sanción","sandía","sanear","sangre","sanidad","sano","santo","sapo","saque","sardina","sartén","sastre","satán","sauna","saxofón","sección","seco","secreto","secta","sed","seguir","seis","sello","selva","semana","semilla","senda","sensor","señal","señor","separar","sepia","sequía","ser","serie","sermón","servir","sesenta","sesión","seta","setenta","severo","sexo","sexto","sidra","siesta","siete","siglo","signo","sílaba","silbar","silencio","silla","símbolo","simio","sirena","sistema","sitio","situar","sobre","socio","sodio","sol","solapa","soldado","soledad","sólido","soltar","solución","sombra","sondeo","sonido","sonoro","sonrisa","sopa","soplar","soporte","sordo","sorpresa","sorteo","sostén","sótano","suave","subir","suceso","sudor","suegra","suelo","sueño","suerte","sufrir","sujeto","sultán","sumar","superar","suplir","suponer","supremo","sur","surco","sureño","surgir","susto","sutil","tabaco","tabique","tabla","tabú","taco","tacto","tajo","talar","talco","talento","talla","talón","tamaño","tambor","tango","tanque","tapa","tapete","tapia","tapón","taquilla","tarde","tarea","tarifa","tarjeta","tarot","tarro","tarta","tatuaje","tauro","taza","tazón","teatro","techo","tecla","técnica","tejado","tejer","tejido","tela","teléfono","tema","temor","templo","tenaz","tender","tener","tenis","tenso","teoría","terapia","terco","término","ternura","terror","tesis","tesoro","testigo","tetera","texto","tez","tibio","tiburón","tiempo","tienda","tierra","tieso","tigre","tijera","tilde","timbre","tímido","timo","tinta","tío","típico","tipo","tira","tirón","titán","títere","título","tiza","toalla","tobillo","tocar","tocino","todo","toga","toldo","tomar","tono","tonto","topar","tope","toque","tórax","torero","tormenta","torneo","toro","torpedo","torre","torso","tortuga","tos","tosco","toser","tóxico","trabajo","tractor","traer","tráfico","trago","traje","tramo","trance","trato","trauma","trazar","trébol","tregua","treinta","tren","trepar","tres","tribu","trigo","tripa","triste","triunfo","trofeo","trompa","tronco","tropa","trote","trozo","truco","trueno","trufa","tubería","tubo","tuerto","tumba","tumor","túnel","túnica","turbina","turismo","turno","tutor","ubicar","úlcera","umbral","unidad","unir","universo","uno","untar","uña","urbano","urbe","urgente","urna","usar","usuario","útil","utopía","uva","vaca","vacío","vacuna","vagar","vago","vaina","vajilla","vale","válido","valle","valor","válvula","vampiro","vara","variar","varón","vaso","vecino","vector","vehículo","veinte","vejez","vela","velero","veloz","vena","vencer","venda","veneno","vengar","venir","venta","venus","ver","verano","verbo","verde","vereda","verja","verso","verter","vía","viaje","vibrar","vicio","víctima","vida","vídeo","vidrio","viejo","viernes","vigor","vil","villa","vinagre","vino","viñedo","violín","viral","virgo","virtud","visor","víspera","vista","vitamina","viudo","vivaz","vivero","vivir","vivo","volcán","volumen","volver","voraz","votar","voto","voz","vuelo","vulgar","yacer","yate","yegua","yema","yerno","yeso","yodo","yoga","yogur","zafiro","zanja","zapato","zarza","zona","zorro","zumo","zurdo"]');

/***/ }),

/***/ 9794:
/***/ ((module) => {

"use strict";
module.exports = {"version":"1.0.34"};

/***/ }),

/***/ 1698:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"TYPES":{"Done":-1,"Unknown":-2,"NotPresent":0,"UInt16":1,"UInt32":2,"UInt64":3,"Hash128":4,"Hash256":5,"Amount":6,"Blob":7,"AccountID":8,"STObject":14,"STArray":15,"UInt8":16,"Hash160":17,"PathSet":18,"Vector256":19,"UInt96":20,"UInt192":21,"UInt384":22,"UInt512":23,"Issue":24,"XChainBridge":25,"Transaction":10001,"LedgerEntry":10002,"Validation":10003,"Metadata":10004},"LEDGER_ENTRY_TYPES":{"Invalid":-1,"AccountRoot":97,"DirectoryNode":100,"RippleState":114,"Ticket":84,"SignerList":83,"Offer":111,"Bridge":105,"LedgerHashes":104,"Amendments":102,"XChainOwnedClaimID":113,"XChainOwnedCreateAccountClaimID":116,"FeeSettings":115,"Escrow":117,"PayChannel":120,"Check":67,"DepositPreauth":112,"NegativeUNL":78,"NFTokenPage":80,"NFTokenOffer":55,"AMM":121,"DID":73,"Any":-3,"Child":-2,"Nickname":110,"Contract":99,"GeneratorMap":103},"FIELDS":[["Generic",{"nth":0,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Unknown"}],["Invalid",{"nth":-1,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Unknown"}],["ObjectEndMarker",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["ArrayEndMarker",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["hash",{"nth":257,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Hash256"}],["index",{"nth":258,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Hash256"}],["taker_gets_funded",{"nth":258,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Amount"}],["taker_pays_funded",{"nth":259,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Amount"}],["LedgerEntry",{"nth":257,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"LedgerEntry"}],["Transaction",{"nth":257,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Transaction"}],["Validation",{"nth":257,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Validation"}],["Metadata",{"nth":257,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Metadata"}],["CloseResolution",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt8"}],["Method",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt8"}],["TransactionResult",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt8"}],["TickSize",{"nth":16,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt8"}],["UNLModifyDisabling",{"nth":17,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt8"}],["HookResult",{"nth":18,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt8"}],["WasLockingChainSend",{"nth":19,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt8"}],["LedgerEntryType",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["TransactionType",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["SignerWeight",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["TransferFee",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["TradingFee",{"nth":5,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["DiscountedFee",{"nth":6,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["Version",{"nth":16,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["HookStateChangeCount",{"nth":17,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["HookEmitCount",{"nth":18,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["HookExecutionIndex",{"nth":19,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["HookApiVersion",{"nth":20,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["NetworkID",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["Flags",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["SourceTag",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["Sequence",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["PreviousTxnLgrSeq",{"nth":5,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["LedgerSequence",{"nth":6,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["CloseTime",{"nth":7,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["ParentCloseTime",{"nth":8,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["SigningTime",{"nth":9,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["Expiration",{"nth":10,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["TransferRate",{"nth":11,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["WalletSize",{"nth":12,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["OwnerCount",{"nth":13,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["DestinationTag",{"nth":14,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["HighQualityIn",{"nth":16,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["HighQualityOut",{"nth":17,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["LowQualityIn",{"nth":18,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["LowQualityOut",{"nth":19,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["QualityIn",{"nth":20,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["QualityOut",{"nth":21,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["StampEscrow",{"nth":22,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["BondAmount",{"nth":23,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["LoadFee",{"nth":24,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["OfferSequence",{"nth":25,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["FirstLedgerSequence",{"nth":26,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["LastLedgerSequence",{"nth":27,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["TransactionIndex",{"nth":28,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["OperationLimit",{"nth":29,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["ReferenceFeeUnits",{"nth":30,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["ReserveBase",{"nth":31,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["ReserveIncrement",{"nth":32,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["SetFlag",{"nth":33,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["ClearFlag",{"nth":34,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["SignerQuorum",{"nth":35,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["CancelAfter",{"nth":36,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["FinishAfter",{"nth":37,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["SignerListID",{"nth":38,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["SettleDelay",{"nth":39,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["TicketCount",{"nth":40,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["TicketSequence",{"nth":41,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["NFTokenTaxon",{"nth":42,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["MintedNFTokens",{"nth":43,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["BurnedNFTokens",{"nth":44,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["HookStateCount",{"nth":45,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["EmitGeneration",{"nth":46,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["VoteWeight",{"nth":48,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["FirstNFTokenSequence",{"nth":50,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["IndexNext",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["IndexPrevious",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["BookNode",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["OwnerNode",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["BaseFee",{"nth":5,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["ExchangeRate",{"nth":6,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["LowNode",{"nth":7,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["HighNode",{"nth":8,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["DestinationNode",{"nth":9,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["Cookie",{"nth":10,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["ServerVersion",{"nth":11,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["NFTokenOfferNode",{"nth":12,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["EmitBurden",{"nth":13,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["HookOn",{"nth":16,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["HookInstructionCount",{"nth":17,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["HookReturnCode",{"nth":18,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["ReferenceCount",{"nth":19,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["XChainClaimID",{"nth":20,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["XChainAccountCreateCount",{"nth":21,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["XChainAccountClaimCount",{"nth":22,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["EmailHash",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash128"}],["TakerPaysCurrency",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash160"}],["TakerPaysIssuer",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash160"}],["TakerGetsCurrency",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash160"}],["TakerGetsIssuer",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash160"}],["LedgerHash",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["ParentHash",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["TransactionHash",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["AccountHash",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["PreviousTxnID",{"nth":5,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["LedgerIndex",{"nth":6,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["WalletLocator",{"nth":7,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["RootIndex",{"nth":8,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["AccountTxnID",{"nth":9,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["NFTokenID",{"nth":10,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["EmitParentTxnID",{"nth":11,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["EmitNonce",{"nth":12,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["EmitHookHash",{"nth":13,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["AMMID",{"nth":14,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["BookDirectory",{"nth":16,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["InvoiceID",{"nth":17,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["Nickname",{"nth":18,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["Amendment",{"nth":19,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["Digest",{"nth":21,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["Channel",{"nth":22,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["ConsensusHash",{"nth":23,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["CheckID",{"nth":24,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["ValidatedHash",{"nth":25,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["PreviousPageMin",{"nth":26,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["NextPageMin",{"nth":27,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["NFTokenBuyOffer",{"nth":28,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["NFTokenSellOffer",{"nth":29,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["HookStateKey",{"nth":30,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["HookHash",{"nth":31,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["HookNamespace",{"nth":32,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["HookSetTxnID",{"nth":33,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["Amount",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["Balance",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["LimitAmount",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["TakerPays",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["TakerGets",{"nth":5,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["LowLimit",{"nth":6,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["HighLimit",{"nth":7,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["Fee",{"nth":8,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["SendMax",{"nth":9,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["DeliverMin",{"nth":10,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["Amount2",{"nth":11,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["BidMin",{"nth":12,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["BidMax",{"nth":13,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["MinimumOffer",{"nth":16,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["RippleEscrow",{"nth":17,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["DeliveredAmount",{"nth":18,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["NFTokenBrokerFee",{"nth":19,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["BaseFeeDrops",{"nth":22,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["ReserveBaseDrops",{"nth":23,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["ReserveIncrementDrops",{"nth":24,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["LPTokenOut",{"nth":25,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["LPTokenIn",{"nth":26,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["EPrice",{"nth":27,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["Price",{"nth":28,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["SignatureReward",{"nth":29,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["MinAccountCreateAmount",{"nth":30,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["LPTokenBalance",{"nth":31,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["PublicKey",{"nth":1,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["MessageKey",{"nth":2,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["SigningPubKey",{"nth":3,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["TxnSignature",{"nth":4,"isVLEncoded":true,"isSerialized":true,"isSigningField":false,"type":"Blob"}],["URI",{"nth":5,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["Signature",{"nth":6,"isVLEncoded":true,"isSerialized":true,"isSigningField":false,"type":"Blob"}],["Domain",{"nth":7,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["FundCode",{"nth":8,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["RemoveCode",{"nth":9,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["ExpireCode",{"nth":10,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["CreateCode",{"nth":11,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["MemoType",{"nth":12,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["MemoData",{"nth":13,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["MemoFormat",{"nth":14,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["Fulfillment",{"nth":16,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["Condition",{"nth":17,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["MasterSignature",{"nth":18,"isVLEncoded":true,"isSerialized":true,"isSigningField":false,"type":"Blob"}],["UNLModifyValidator",{"nth":19,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["ValidatorToDisable",{"nth":20,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["ValidatorToReEnable",{"nth":21,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["HookStateData",{"nth":22,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["HookReturnString",{"nth":23,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["HookParameterName",{"nth":24,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["HookParameterValue",{"nth":25,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["DIDDocument",{"nth":26,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["Data",{"nth":27,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["Account",{"nth":1,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["Owner",{"nth":2,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["Destination",{"nth":3,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["Issuer",{"nth":4,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["Authorize",{"nth":5,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["Unauthorize",{"nth":6,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["RegularKey",{"nth":8,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["NFTokenMinter",{"nth":9,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["EmitCallback",{"nth":10,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["HookAccount",{"nth":16,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["OtherChainSource",{"nth":18,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["OtherChainDestination",{"nth":19,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["AttestationSignerAccount",{"nth":20,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["AttestationRewardAccount",{"nth":21,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["LockingChainDoor",{"nth":22,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["IssuingChainDoor",{"nth":23,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["Indexes",{"nth":1,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Vector256"}],["Hashes",{"nth":2,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Vector256"}],["Amendments",{"nth":3,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Vector256"}],["NFTokenOffers",{"nth":4,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Vector256"}],["Paths",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"PathSet"}],["LockingChainIssue",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Issue"}],["IssuingChainIssue",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Issue"}],["Asset",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Issue"}],["Asset2",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Issue"}],["XChainBridge",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"XChainBridge"}],["TransactionMetaData",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["CreatedNode",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["DeletedNode",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["ModifiedNode",{"nth":5,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["PreviousFields",{"nth":6,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["FinalFields",{"nth":7,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["NewFields",{"nth":8,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["TemplateEntry",{"nth":9,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["Memo",{"nth":10,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["SignerEntry",{"nth":11,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["NFToken",{"nth":12,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["EmitDetails",{"nth":13,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["Hook",{"nth":14,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["Signer",{"nth":16,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["Majority",{"nth":18,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["DisabledValidator",{"nth":19,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["EmittedTxn",{"nth":20,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["HookExecution",{"nth":21,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["HookDefinition",{"nth":22,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["HookParameter",{"nth":23,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["HookGrant",{"nth":24,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["VoteEntry",{"nth":25,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["AuctionSlot",{"nth":26,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["AuthAccount",{"nth":27,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["XChainClaimProofSig",{"nth":28,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["XChainCreateAccountProofSig",{"nth":29,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["XChainClaimAttestationCollectionElement",{"nth":30,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["XChainCreateAccountAttestationCollectionElement",{"nth":31,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["Signers",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":false,"type":"STArray"}],["SignerEntries",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["Template",{"nth":5,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["Necessary",{"nth":6,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["Sufficient",{"nth":7,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["AffectedNodes",{"nth":8,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["Memos",{"nth":9,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["NFTokens",{"nth":10,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["Hooks",{"nth":11,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["VoteSlots",{"nth":12,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["Majorities",{"nth":16,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["DisabledValidators",{"nth":17,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["HookExecutions",{"nth":18,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["HookParameters",{"nth":19,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["HookGrants",{"nth":20,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["XChainClaimAttestations",{"nth":21,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["XChainCreateAccountAttestations",{"nth":22,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["AuthAccounts",{"nth":25,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}]],"TRANSACTION_RESULTS":{"telLOCAL_ERROR":-399,"telBAD_DOMAIN":-398,"telBAD_PATH_COUNT":-397,"telBAD_PUBLIC_KEY":-396,"telFAILED_PROCESSING":-395,"telINSUF_FEE_P":-394,"telNO_DST_PARTIAL":-393,"telCAN_NOT_QUEUE":-392,"telCAN_NOT_QUEUE_BALANCE":-391,"telCAN_NOT_QUEUE_BLOCKS":-390,"telCAN_NOT_QUEUE_BLOCKED":-389,"telCAN_NOT_QUEUE_FEE":-388,"telCAN_NOT_QUEUE_FULL":-387,"telWRONG_NETWORK":-386,"telREQUIRES_NETWORK_ID":-385,"telNETWORK_ID_MAKES_TX_NON_CANONICAL":-384,"temMALFORMED":-299,"temBAD_AMOUNT":-298,"temBAD_CURRENCY":-297,"temBAD_EXPIRATION":-296,"temBAD_FEE":-295,"temBAD_ISSUER":-294,"temBAD_LIMIT":-293,"temBAD_OFFER":-292,"temBAD_PATH":-291,"temBAD_PATH_LOOP":-290,"temBAD_REGKEY":-289,"temBAD_SEND_XRP_LIMIT":-288,"temBAD_SEND_XRP_MAX":-287,"temBAD_SEND_XRP_NO_DIRECT":-286,"temBAD_SEND_XRP_PARTIAL":-285,"temBAD_SEND_XRP_PATHS":-284,"temBAD_SEQUENCE":-283,"temBAD_SIGNATURE":-282,"temBAD_SRC_ACCOUNT":-281,"temBAD_TRANSFER_RATE":-280,"temDST_IS_SRC":-279,"temDST_NEEDED":-278,"temINVALID":-277,"temINVALID_FLAG":-276,"temREDUNDANT":-275,"temRIPPLE_EMPTY":-274,"temDISABLED":-273,"temBAD_SIGNER":-272,"temBAD_QUORUM":-271,"temBAD_WEIGHT":-270,"temBAD_TICK_SIZE":-269,"temINVALID_ACCOUNT_ID":-268,"temCANNOT_PREAUTH_SELF":-267,"temINVALID_COUNT":-266,"temUNCERTAIN":-265,"temUNKNOWN":-264,"temSEQ_AND_TICKET":-263,"temBAD_NFTOKEN_TRANSFER_FEE":-262,"temBAD_AMM_TOKENS":-261,"temXCHAIN_EQUAL_DOOR_ACCOUNTS":-260,"temXCHAIN_BAD_PROOF":-259,"temXCHAIN_BRIDGE_BAD_ISSUES":-258,"temXCHAIN_BRIDGE_NONDOOR_OWNER":-257,"temXCHAIN_BRIDGE_BAD_MIN_ACCOUNT_CREATE_AMOUNT":-256,"temXCHAIN_BRIDGE_BAD_REWARD_AMOUNT":-255,"temEMPTY_DID":-254,"tefFAILURE":-199,"tefALREADY":-198,"tefBAD_ADD_AUTH":-197,"tefBAD_AUTH":-196,"tefBAD_LEDGER":-195,"tefCREATED":-194,"tefEXCEPTION":-193,"tefINTERNAL":-192,"tefNO_AUTH_REQUIRED":-191,"tefPAST_SEQ":-190,"tefWRONG_PRIOR":-189,"tefMASTER_DISABLED":-188,"tefMAX_LEDGER":-187,"tefBAD_SIGNATURE":-186,"tefBAD_QUORUM":-185,"tefNOT_MULTI_SIGNING":-184,"tefBAD_AUTH_MASTER":-183,"tefINVARIANT_FAILED":-182,"tefTOO_BIG":-181,"tefNO_TICKET":-180,"tefNFTOKEN_IS_NOT_TRANSFERABLE":-179,"terRETRY":-99,"terFUNDS_SPENT":-98,"terINSUF_FEE_B":-97,"terNO_ACCOUNT":-96,"terNO_AUTH":-95,"terNO_LINE":-94,"terOWNERS":-93,"terPRE_SEQ":-92,"terLAST":-91,"terNO_RIPPLE":-90,"terQUEUED":-89,"terPRE_TICKET":-88,"terNO_AMM":-87,"terSUBMITTED":-86,"tesSUCCESS":0,"tecCLAIM":100,"tecPATH_PARTIAL":101,"tecUNFUNDED_ADD":102,"tecUNFUNDED_OFFER":103,"tecUNFUNDED_PAYMENT":104,"tecFAILED_PROCESSING":105,"tecDIR_FULL":121,"tecINSUF_RESERVE_LINE":122,"tecINSUF_RESERVE_OFFER":123,"tecNO_DST":124,"tecNO_DST_INSUF_XRP":125,"tecNO_LINE_INSUF_RESERVE":126,"tecNO_LINE_REDUNDANT":127,"tecPATH_DRY":128,"tecUNFUNDED":129,"tecNO_ALTERNATIVE_KEY":130,"tecNO_REGULAR_KEY":131,"tecOWNERS":132,"tecNO_ISSUER":133,"tecNO_AUTH":134,"tecNO_LINE":135,"tecINSUFF_FEE":136,"tecFROZEN":137,"tecNO_TARGET":138,"tecNO_PERMISSION":139,"tecNO_ENTRY":140,"tecINSUFFICIENT_RESERVE":141,"tecNEED_MASTER_KEY":142,"tecDST_TAG_NEEDED":143,"tecINTERNAL":144,"tecOVERSIZE":145,"tecCRYPTOCONDITION_ERROR":146,"tecINVARIANT_FAILED":147,"tecEXPIRED":148,"tecDUPLICATE":149,"tecKILLED":150,"tecHAS_OBLIGATIONS":151,"tecTOO_SOON":152,"tecHOOK_REJECTED":153,"tecMAX_SEQUENCE_REACHED":154,"tecNO_SUITABLE_NFTOKEN_PAGE":155,"tecNFTOKEN_BUY_SELL_MISMATCH":156,"tecNFTOKEN_OFFER_TYPE_MISMATCH":157,"tecCANT_ACCEPT_OWN_NFTOKEN_OFFER":158,"tecINSUFFICIENT_FUNDS":159,"tecOBJECT_NOT_FOUND":160,"tecINSUFFICIENT_PAYMENT":161,"tecUNFUNDED_AMM":162,"tecAMM_BALANCE":163,"tecAMM_FAILED":164,"tecAMM_INVALID_TOKENS":165,"tecAMM_EMPTY":166,"tecAMM_NOT_EMPTY":167,"tecAMM_ACCOUNT":168,"tecINCOMPLETE":169,"tecXCHAIN_BAD_TRANSFER_ISSUE":170,"tecXCHAIN_NO_CLAIM_ID":171,"tecXCHAIN_BAD_CLAIM_ID":172,"tecXCHAIN_CLAIM_NO_QUORUM":173,"tecXCHAIN_PROOF_UNKNOWN_KEY":174,"tecXCHAIN_CREATE_ACCOUNT_NONXRP_ISSUE":175,"tecXCHAIN_WRONG_CHAIN":176,"tecXCHAIN_REWARD_MISMATCH":177,"tecXCHAIN_NO_SIGNERS_LIST":178,"tecXCHAIN_SENDING_ACCOUNT_MISMATCH":179,"tecXCHAIN_INSUFF_CREATE_AMOUNT":180,"tecXCHAIN_ACCOUNT_CREATE_PAST":181,"tecXCHAIN_ACCOUNT_CREATE_TOO_MANY":182,"tecXCHAIN_PAYMENT_FAILED":183,"tecXCHAIN_SELF_COMMIT":184,"tecXCHAIN_BAD_PUBLIC_KEY_ACCOUNT_PAIR":185,"tecXCHAIN_CREATE_ACCOUNT_DISABLED":186,"tecEMPTY_DID":187},"TRANSACTION_TYPES":{"Invalid":-1,"Payment":0,"EscrowCreate":1,"EscrowFinish":2,"AccountSet":3,"EscrowCancel":4,"SetRegularKey":5,"NickNameSet":6,"OfferCreate":7,"OfferCancel":8,"Contract":9,"TicketCreate":10,"TicketCancel":11,"SignerListSet":12,"PaymentChannelCreate":13,"PaymentChannelFund":14,"PaymentChannelClaim":15,"CheckCreate":16,"CheckCash":17,"CheckCancel":18,"DepositPreauth":19,"TrustSet":20,"AccountDelete":21,"SetHook":22,"NFTokenMint":25,"NFTokenBurn":26,"NFTokenCreateOffer":27,"NFTokenCancelOffer":28,"NFTokenAcceptOffer":29,"Clawback":30,"AMMCreate":35,"AMMDeposit":36,"AMMWithdraw":37,"AMMVote":38,"AMMBid":39,"AMMDelete":40,"XChainCreateClaimID":41,"XChainCommit":42,"XChainClaim":43,"XChainAccountCreateCommit":44,"XChainAddClaimAttestation":45,"XChainAddAccountCreateAttestation":46,"XChainModifyBridge":47,"XChainCreateBridge":48,"DIDSet":49,"DIDDelete":50,"EnableAmendment":100,"SetFee":101,"UNLModify":102}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__nccwpck_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = __dirname + "/";
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __nccwpck_require__(5053);
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;