"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.completeMultiSigned = exports.complete = exports.prepare = exports.accountAddress = void 0;
var Utils = __importStar(require("../utils"));
var sign_1 = require("../sign");
var assert_1 = __importDefault(require("assert"));
var xrpl_binary_codec_prerelease_1 = require("xrpl-binary-codec-prerelease");
var assertValidPubkey = function (pubkey) {
    (0, assert_1.default)(typeof pubkey === "string", "Uncompressed PubKey: string expected");
    if (pubkey.length === 64) {
        // ED Uncompressed
        (0, assert_1.default)(Utils.getAlgorithmFromKey("ED" + pubkey) === "ed25519", "Key length ed25519, algo not ed25519");
    }
    else if (pubkey.length === 66) {
        // Compressed (?)
        (0, assert_1.default)(Utils.deriveAddress("A" + pubkey.slice(1)), "Compressed PubKey length, invalid address derivation");
    }
    else {
        // Secp256k1 Uncompressed
        (0, assert_1.default)(pubkey.length === 130, "Uncompressed PubKey: incorrect length");
        (0, assert_1.default)(pubkey.slice(0, 2) === "04", 'Uncompressed PubKey: should start with "04"');
    }
};
/**
 * Prepare a transaction for a Raw card: get Hash to sign
 */
var prepare = function (txJson, pubkey, multiSign, definitions) {
    if (multiSign === void 0) { multiSign = false; }
    assertValidPubkey(pubkey);
    var signingPubKey = Utils.compressPubKey(pubkey);
    var transaction = Object.assign({}, __assign({}, txJson));
    (0, sign_1.setNativeAsset)(transaction);
    (0, assert_1.default)(typeof transaction === "object" && transaction !== null, "Transaction: Object expected");
    if (typeof transaction.signingPubKey === "undefined") {
        Object.assign(transaction, { SigningPubKey: signingPubKey });
    }
    if (multiSign) {
        Object.assign(transaction, { SigningPubKey: "" });
    }
    // Payment Channel Authorization
    if (String((transaction === null || transaction === void 0 ? void 0 : transaction.TransactionType) || "").toLowerCase() ===
        "paymentchannelauthorize" ||
        String((transaction === null || transaction === void 0 ? void 0 : transaction.command) || "").toLowerCase() === "channel_authorize" ||
        (!(transaction === null || transaction === void 0 ? void 0 : transaction.TransactionType) &&
            !(transaction === null || transaction === void 0 ? void 0 : transaction.command) &&
            (((transaction === null || transaction === void 0 ? void 0 : transaction.channel) && (transaction === null || transaction === void 0 ? void 0 : transaction.amount)) ||
                ((transaction === null || transaction === void 0 ? void 0 : transaction.Channel) && (transaction === null || transaction === void 0 ? void 0 : transaction.Amount))))) {
        Object.assign(transaction, {
            TransactionType: undefined,
            command: undefined,
            channel: (transaction === null || transaction === void 0 ? void 0 : transaction.channel) || (transaction === null || transaction === void 0 ? void 0 : transaction.Channel),
            amount: (transaction === null || transaction === void 0 ? void 0 : transaction.amount) || (transaction === null || transaction === void 0 ? void 0 : transaction.Amount),
        });
    }
    var message = Utils.encodeTransaction(transaction, multiSign ? Utils.deriveAddress(signingPubKey) : undefined, definitions);
    var hashToSign = Utils.getAlgorithmFromKey(signingPubKey) === "ed25519"
        ? message
        : Utils.bytesToHex(Utils.hash(message));
    return {
        pubkey: pubkey,
        signingPubKey: signingPubKey,
        multiSign: multiSign,
        transaction: transaction,
        message: message,
        hashToSign: hashToSign,
    };
};
exports.prepare = prepare;
var complete = function (Prepared, signature, definitions) {
    assertValidPubkey(Prepared.pubkey);
    (0, assert_1.default)(typeof signature === "string", "signature: string expected");
    (0, assert_1.default)(signature.length === 128, "signature: incorrect length");
    var txnSignature = Utils.getAlgorithmFromKey(Prepared.signingPubKey) === "ed25519"
        ? signature
        : Utils.secp256k1_p1363ToFullyCanonicalDerSignature(signature);
    var signatureVerifies = Utils.verifySignature(Prepared.message, txnSignature, Prepared.signingPubKey);
    var isPayChanAuth = false;
    var txJson = {};
    var signedTransaction = "";
    var id = "";
    Object.assign(txJson, Prepared.transaction);
    (0, sign_1.setNativeAsset)(txJson);
    if (signatureVerifies) {
        Object.assign(txJson, { TxnSignature: txnSignature });
        signedTransaction = Utils.encodeTransaction(txJson, undefined, definitions);
        id = Utils.computeBinaryTransactionHash(signedTransaction);
    }
    // Payment channel auth
    if (!(txJson === null || txJson === void 0 ? void 0 : txJson.TransactionType) &&
        !(txJson === null || txJson === void 0 ? void 0 : txJson.command) &&
        (txJson === null || txJson === void 0 ? void 0 : txJson.channel) &&
        (txJson === null || txJson === void 0 ? void 0 : txJson.amount)) {
        isPayChanAuth = true;
        id = "";
        signedTransaction = String(txJson.TxnSignature || "");
        txJson = {
            channel: txJson.channel,
            amount: txJson.amount,
        };
    }
    return {
        type: isPayChanAuth ? "SignedPayChanAuth" : "SignedTx",
        txnSignature: txnSignature,
        signatureVerifies: signatureVerifies,
        txJson: txJson,
        signedTransaction: signedTransaction,
        id: id,
    };
};
exports.complete = complete;
var completeMultiSigned = function (txJson, SignersAndSignatures, definitions) {
    (0, assert_1.default)(Array.isArray(SignersAndSignatures), "SignersAndSignatures not array");
    (0, assert_1.default)(SignersAndSignatures.length > 0, "SignersAndSignatures empty");
    var transaction = Object.assign({}, txJson);
    (0, sign_1.setNativeAsset)(txJson);
    Object.assign(transaction, { SigningPubKey: "" });
    // const hashToSign = Utils.bytesToHex(Utils.hash(message))
    var toCombine = SignersAndSignatures.map(function (SignerAndSignature) {
        var pubKey = SignerAndSignature.pubKey.length === 130
            ? Utils.compressPubKey(SignerAndSignature.pubKey)
            : SignerAndSignature.pubKey.length === 64
                ? "ED" + SignerAndSignature.pubKey
                : SignerAndSignature.pubKey;
        var signerAddress = Utils.deriveAddress(pubKey);
        var txnSignature = Utils.getAlgorithmFromKey(pubKey) === "ed25519"
            ? SignerAndSignature.signature
            : Utils.secp256k1_p1363ToFullyCanonicalDerSignature(SignerAndSignature.signature);
        var message = Utils.encodeTransaction(transaction, signerAddress, definitions);
        // console.log({message, txnSignature, pubKey})
        var signatureVerifies = Utils.verifySignature(message, txnSignature, pubKey);
        (0, assert_1.default)(signatureVerifies, "Invalid signature by/for " + signerAddress);
        Object.assign(transaction, {
            Signers: [
                {
                    Signer: {
                        Account: signerAddress,
                        SigningPubKey: pubKey,
                        TxnSignature: txnSignature,
                    },
                },
            ],
        });
        var MultiSignature = {
            signerAddress: signerAddress,
            signature: SignerAndSignature.signature,
            verifies: signatureVerifies,
            transaction: transaction,
            signedTransaction: Utils.encodeTransaction(transaction, undefined, definitions),
        };
        return MultiSignature;
    });
    // console.dir(toCombine, {depth: null})
    var combined = Utils.combine(toCombine.map(function (c) { return c.signedTransaction; }));
    var signedTransaction = String(combined.signedTransaction || "");
    return {
        type: "MultiSignedTx",
        txnSignature: "",
        signatureVerifies: toCombine.every(function (s) { return s.verifies; }),
        txJson: (0, xrpl_binary_codec_prerelease_1.decode)(signedTransaction, definitions),
        signedTransaction: signedTransaction,
        id: String(combined.id || ""),
    };
};
exports.completeMultiSigned = completeMultiSigned;
var accountAddress = function (pubkey) {
    assertValidPubkey(pubkey);
    var signingPubKey = Utils.compressPubKey(pubkey);
    return Utils.deriveAddress(signingPubKey);
};
exports.accountAddress = accountAddress;
