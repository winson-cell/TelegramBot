"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountTypes = void 0;
var ripple_keypairs_1 = require("ripple-keypairs");
var AddressCodec = __importStar(require("ripple-address-codec"));
var Elliptic = __importStar(require("elliptic"));
var Utils = __importStar(require("../utils"));
var Ed25519 = new Elliptic.eddsa("ed25519");
var Secp256k1 = new Elliptic.ec("secp256k1");
/* Types ==================================================================== */
var AccountTypes;
(function (AccountTypes) {
    AccountTypes["Passphrase"] = "passphrase";
    AccountTypes["FamilySeed"] = "familySeed";
    AccountTypes["Mnemonic"] = "mnemonic";
    AccountTypes["Hex"] = "hex";
    AccountTypes["SecretNumbers"] = "secretNumbers";
})(AccountTypes = exports.AccountTypes || (exports.AccountTypes = {}));
/* Class ==================================================================== */
var XRPL_Account = /** @class */ (function () {
    function XRPL_Account(options) {
        if (options === void 0) { options = {}; }
        /**
         * Define object struct
         */
        this.accountType = null;
        this.address = null;
        this.secret = {
            familySeed: null,
            mnemonic: null,
            passphrase: null,
            path: null,
            secretNumbers: null,
        };
        this.keypair = {
            algorithm: null,
            publicKey: null,
            privateKey: null,
        };
        /**
         * Check & apply address
         */
        if (options.address) {
            if (AddressCodec.isValidClassicAddress(options.address)) {
                this.address = options.address;
            }
        }
        /**
         * Check & apply account type [familySeed / mnemonic / passphrase]
         */
        if (options.passphrase) {
            this.accountType = AccountTypes.Passphrase;
            this.secret.passphrase = options.passphrase;
        }
        if (options.familySeed) {
            this.accountType = AccountTypes.FamilySeed;
            this.secret.familySeed = options.familySeed;
            if (options.secretNumbers) {
                this.secret.secretNumbers = options.secretNumbers;
                this.accountType = AccountTypes.SecretNumbers;
            }
        }
        else if (options.mnemonic) {
            this.accountType = AccountTypes.Mnemonic;
            this.secret.mnemonic = options.mnemonic;
            if (options.path) {
                this.secret.path = options.path;
            }
        }
        /**
         * Check & apply keypair, derive publicKey if only privateKey is known
         */
        if (options.keypair && options.keypair instanceof Object) {
            if (options.keypair.privateKey) {
                var prefix = "";
                if (options.keypair.privateKey.length === 64) {
                    prefix = "00";
                }
                this.keypair.privateKey = prefix + options.keypair.privateKey;
                if (this.accountType === null) {
                    this.accountType = AccountTypes.Hex;
                }
            }
            if (options.keypair.publicKey) {
                this.keypair.publicKey = options.keypair.publicKey;
            }
            else if (this.keypair.privateKey) {
                if (
                // @ts-ignore
                options.keypair.privateKey.slice(0, 2) === "ED" ||
                    (options.algorithm && options.algorithm === "ed25519")) {
                    var priv = this.keypair.privateKey.slice(2);
                    // @ts-ignore
                    var keyBytes = Ed25519.keyFromSecret(priv).pubBytes();
                    this.keypair.publicKey = "ED" + Utils.bytesToHex(keyBytes);
                }
                else {
                    var priv = this.keypair.privateKey.slice(2);
                    var keyBytes = Secp256k1.keyFromPrivate(priv)
                        .getPublic()
                        .encodeCompressed("array");
                    // @ts-ignore
                    this.keypair.publicKey = Utils.bytesToHex(keyBytes);
                }
            }
        }
        /**
         * Check & apply algorithm, or retrieve from private key
         */
        if (options.algorithm) {
            this.keypair.algorithm = options.algorithm;
        }
        else {
            if (this.keypair.privateKey) {
                this.keypair.algorithm = Utils.getAlgorithmFromKey(this.keypair.privateKey);
            }
        }
        /**
         * Derive address from publicKey if address unknown
         */
        if (this.address === null && this.keypair.publicKey) {
            this.address = (0, ripple_keypairs_1.deriveAddress)(this.keypair.publicKey);
        }
    }
    XRPL_Account.prototype.signAs = function (address) {
        if (AddressCodec.isValidClassicAddress(address)) {
            this._signAs = address;
        }
        else {
            throw new Error("Invalid signAs address (should contain account address, rXXX...)");
        }
        return this;
    };
    XRPL_Account.prototype.toString = function () {
        return "XPRL Account" + (this.address ? ": " + this.address : "");
    };
    return XRPL_Account;
}());
exports.default = XRPL_Account;
